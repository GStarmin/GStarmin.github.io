<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最大流最小割</title>
    <link href="/2022/12/03/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <url>/2022/12/03/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p>在图论中，去掉其中所有边能使一张网络流图不再连通（即分成两个子图）的边集称为图的割。一个$st-cut$即去掉的边把源点s和汇点t划分在两个不同的部分。</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E4%B9%89.png" alt="pic1"></p><p>一般来说，一张图中有多个不同的$st-cut$，如下图便为其中一个$st-cut$。</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/%E4%B8%80%E4%B8%AA%E5%89%B2%E4%BE%8B%E5%AD%90.png" alt="pic1"></p><p>但是在实际应用中，我们去掉每条边往往都是有代价的，以边的容量作为权值，一个割中去掉的边的权值之和为这个割的值，那么最小割就是这张图上最小的割。</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>为了求解最小割，需要引入最大流的概念。用边的权值表示边的最大流量，一个$st-flow$是从源点s到汇点t的流量。通俗的讲，最大流就是从源点s到汇点t的最大流量。</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/%E6%9C%80%E5%A4%A7%E6%B5%81.png" alt="pic1"></p><h2 id="求解最大流"><a href="#求解最大流" class="headerlink" title="求解最大流"></a>求解最大流</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li>开始时对每条边e令$f(e)&#x3D;0$</li><li>找到一条从源点s到汇点t的路径$s \rightarrow t$使路径上的每条边e满足$f(e)&lt;c(e)$,其中$c(e)$为边e的权值</li><li>$flow &#x3D; flow + 路径上的流量$</li><li>重复上述步骤直至找不到新的路径</li></ul><h3 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h3><h4 id="残留图-Residual-Graph"><a href="#残留图-Residual-Graph" class="headerlink" title="残留图(Residual Graph)"></a>残留图(Residual Graph)</h4><p>在另一个图中，额外构造一个反向边，权值是实际流过该边的流量$f(e)$。</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/%E6%AE%8B%E4%BD%99%E5%9B%BE.png" alt="pic1"></p><p>剩余图有以下性质：</p><ul><li><strong>增广路径(Augmenting Path)</strong>:一个增广路径P是从残余图中的一条简单路径$s \rightarrow t$</li><li>增广路径的容量是该条路径所有边中的最小权值</li></ul><h4 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h4><ul><li>每次找到一条从s到t的增广路径，并调整flow和残留图，不断调整直到没有增广路径</li><li>当残留图中不存在从s到t的增广路径时，该图已经达到最大流</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>初始时没有反向边,此时残留图等于原图</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%901.png" alt="pic1"></p><p>从中选取一条增广路径,并更新残留图和原图</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%902.png" alt="pic1"></p><p>重复上面的步骤,注意<strong>增广路径一定要从残留图中找</strong>,且可以使用残留图中的反向边.</p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%903.png" alt="pic1"></p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%904.png" alt="pic1"></p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%905.png" alt="pic1"></p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%906.png" alt="pic1"></p><p><img src="/../img/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/Ford-Fulkerson%E4%BE%8B%E5%AD%907.png" alt="pic1"></p><p>此时,没有新的增广路径,则最大流的值等于流出源点s的流量减去流进s的流量,即$flow &#x3D; s_{out} - s_{in}$</p><h2 id="最大流与最小割的关系"><a href="#最大流与最小割的关系" class="headerlink" title="最大流与最小割的关系"></a>最大流与最小割的关系</h2><p>最大流最小割定理：最大流&#x3D;最小割。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/12/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/12/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>本文大部分转载自知乎<a href="https://www.zhihu.com/people/ruan-xing-zhi">@阮行止</a>，后添加了自己的一些思考。</p><h2 id="1-从一个生活问题谈起"><a href="#1-从一个生活问题谈起" class="headerlink" title="1. 从一个生活问题谈起"></a>1. 从一个生活问题谈起</h2><p>先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，<strong>需要用到尽量少的钞票</strong>。</p><p>依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666&#x3D;6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。</p><p>这种策略称为“<strong>贪心</strong>”：假设我们面对的局面是“需要凑出w”，贪心策略会<strong>尽快</strong>让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。</p><p>但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：<br>　　15&#x3D;1×11+4×1 （贪心策略使用了5张钞票）<br>　　15&#x3D;3×5 （正确的策略，只用3张钞票）<br>　　为什么会这样呢？贪心策略错在了哪里？  </p><p><strong>鼠目寸光</strong>。</p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w&#x3D;15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。 </p><p>在这里我们发现，贪心是一种<strong>只考虑眼前情况</strong>的策略。</p><p>那么，现在我们怎样才能避免鼠目寸光呢？</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。</p><p>重新分析刚刚的例子。w&#x3D;15时，我们如果取11，接下来就面对w&#x3D;4的情况；如果取5，则接下来面对w&#x3D;10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。</p><p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？  </p><p>明显<strong>cost&#x3D;f(4)+1&#x3D;4+1&#x3D;5</strong> ，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。  </p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1&#x3D;2+1&#x3D;3</strong> 。</p><p>那么，现在w&#x3D;15的时候，我们该取那种钞票呢？<strong>当然是各种方案中，cost值最低的那一个！</strong></p><ul><li>取11：cost&#x3D;f(4)+1&#x3D;4+1&#x3D;5</li><li>取5:cost&#x3D;f(10)+1&#x3D;2+1&#x3D;3</li><li>取1:cost&#x3D;f(14)+1&#x3D;4+1&#x3D;5</li></ul><p>显而易见，cost值最低的是取5的方案。<strong>我们通过上面三个式子，做出了正确的决策！</strong></p><p>这给了我们一个<strong>至关重要</strong>的启示—— f(n)只与f(n-1),f(n-5),f(n-11) 相关；更确切地说：</p><blockquote><p>f(n)&#x3D;min{f(n-1),f(n-5),f(n-11)}+1</p></blockquote><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><p><img src="/../img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpg" alt="pic1"></p><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：</p><ul><li>f(n)只与f(n-1),f(n-5),f(n-11)的值有关。</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。<strong>其他信息并不需要</strong>。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。<strong>我们将求解f(c)称作求解f(n)的“子问题”</strong>。</p><p><strong>这就是DP（动态规划，dynamic programming）</strong>.</p><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</strong></p><h2 id="2-几个简单的概念"><a href="#2-几个简单的概念" class="headerlink" title="2. 几个简单的概念"></a>2. 几个简单的概念</h2><ul><li><strong>无后效性</strong><br>  一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</li></ul><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p><p>“<strong>未来与过去无关</strong>”，这就是<strong>无后效性</strong>。</p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><ul><li>最优子结构</li></ul><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).</p><p>f(n)的定义就已经蕴含了“最优”。利用w&#x3D;14,10,4的最优解，我们即可算出w&#x3D;15的最优解。</p><p>大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“最优子结构性质”。</p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="3-DP的典型应用：DAG最短路"><a href="#3-DP的典型应用：DAG最短路" class="headerlink" title="3. DP的典型应用：DAG最短路"></a>3. DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><p><img src="/img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.png" alt="最短路径"></p><p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).</p><p>想要到T，要么经过C，要么经过D。从而$f(T)&#x3D;min{f(C)+20,f(D)+10}$.</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是$S \rightarrow P\rightarrow Q \rightarrow T$,那肯定S走到Q的最优路径是$S \rightarrow P\rightarrow Q$。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><blockquote><p>f(P)&#x3D;min{f(R)+W<sub>$R \rightarrow P$</sub>}</p></blockquote><p>其中R为有路通到P的所有的点， [公式] 为R到P的过路费。</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="4-对DP原理的一点讨论"><a href="#4-对DP原理的一点讨论" class="headerlink" title="4. 对DP原理的一点讨论"></a>4. 对DP原理的一点讨论</h2><ul><li>DP的核心思想</li></ul><p>DP为什么会快？</p><p>无论是DP还是暴力，我们的算法都是在<strong>可能解空间</strong>内，寻找<strong>最优解</strong>。</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。</p><p>DP是枚举<strong>有希望成为答案的解</strong>。这个空间比暴力的小得多。</p><p>也就是说：<strong>DP自带剪枝</strong>。</p><p>DP舍弃了一大堆不可能成为最优解的答案。譬如：<br>　　15 &#x3D; 5+5+5 被考虑了。<br>　　15 &#x3D; 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。</p><p>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><ul><li>DP的操作过程</li></ul><p>一言以蔽之：<strong>大事化小，小事化了</strong>。</p><p>将一个大问题转化成几个小问题；<br>　　求解小问题；<br>　　推出大问题的解。</p><ul><li>如何设计DP算法</li></ul><p>下面介绍比较通用的设计DP算法的步骤。</p><p>首先，把我们面对的局面表示为x。这一步称为设计状态。</p><p>对于状态x，记我们要求出的答案(e.g. 最小费用)为f(x).我们的目标是求出f(T).<br><strong>找出f(x)与哪些局面有关（记为p）</strong>，写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><ul><li>DP三连</li></ul><p>设计DP算法，往往可以遵循DP三连：</p><p>我是谁？ ——设计状态，表示局面</p><p>我从哪里来？</p><p>我要到哪里去？ ——设计转移</p><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，<strong>更新能从x走到的一些解</strong>。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><blockquote><p>思考题：如何把钞票问题的代码改写成“我到哪里去”的形式？<br>提示：求出f(x)之后，更新f(x+1),f(x+5),f(x+11).</p></blockquote><h2 id="5-例题：最长上升子序列"><a href="#5-例题：最长上升子序列" class="headerlink" title="5. 例题：最长上升子序列"></a>5. 例题：最长上升子序列</h2><p>扯了这么多形而上的内容，还是做一道例题吧。</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。<br>　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p><p>如何设计状态（我是谁）？</p><p>我们记$f(x)$为以a<sub>x</sub>结尾的LIS长度，那么答案就是 $max{f(x)}$</p><p>状态x从哪里推过来（我从哪里来）？</p><p>考虑比x小的每一个p：如果 a<sub>x</sub> &gt; a<sub>p</sub>，那么$f(x)$可以取$f(p)+1$.</p><p>解释：我们把 a<sub>x</sub> 接在 a<sub>p</sub> 的后面，肯定能构造一个以 a<sub>x</sub> 结尾的上升子序列，长度比以 a<sub>p</sub> 结尾的LIS大1.那么，我们可以写出状态转移方程了：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.svg" alt="状态转移方程"></p><p>至此解决问题。两层for循环，复杂度O(n<sup>2</sup>) 。</p><p><img src="/img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%BB%A3%E7%A0%81.jpg" alt="最长上升子序列代码"></p><p>从这三个例题中可以看出，DP是一种思想，一种“大事化小，小事化了”的思想。带着这种思想，DP将会成为我们解决问题的利器。</p><h2 id="6-习题"><a href="#6-习题" class="headerlink" title="6. 习题"></a>6. 习题</h2><p>如果读者有兴趣，可以试着完成下面几个习题：</p><ol><li>请采取一些优化手段，以 O(n log<sub>2</sub> n) 的复杂度解决LIS问题。</li></ol><p>提示：可以参考这篇博客 <a href="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">Junior Dynamic Programming–动态规划初步·各种子序列问题</a></p><ol start="2"><li>“按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成<a href="https://www.luogu.com.cn/problem/P1541">P1541 乌龟棋 - 洛谷</a> 。</li><li>01背包问题是一种常见的DP模型。请完成<a href="https://www.luogu.com.cn/problem/P1048">P1048 采药 - 洛谷</a>。</li></ol><h2 id="7-读后思考：动态规划和分治法的区别与共同点？"><a href="#7-读后思考：动态规划和分治法的区别与共同点？" class="headerlink" title="7. 读后思考：动态规划和分治法的区别与共同点？"></a>7. 读后思考：动态规划和分治法的区别与共同点？</h2><h3 id="1-分治法"><a href="#1-分治法" class="headerlink" title="1. 分治法"></a>1. 分治法</h3><p>分治法(Divide-and-Conquer) : 将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治模式在每一层递归上都有三个步骤：</p><ul><li>分解(Divide)：将原问题分解成一系列子问题；</li><li>解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。</li><li>合并(Combine)：将子问题的结果合并成原问题的解。</li></ul><p>合并排序(Merge Sort)是一个典型分治法的例子。其对应的直观的操作如下:</p><p>分解： 将n个元素分成各含n&#x2F;2个元素的子序列；</p><p>解决：用合并排序法对两个子序列递归地排序；</p><p>合并：合并两个已排序的子序列以得到排序结果。</p><h3 id="2-动态规划法"><a href="#2-动态规划法" class="headerlink" title="2. 动态规划法"></a>2. 动态规划法</h3><p>动态规划算法的设计可以分为如下4个步骤：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><p><strong>分治法是指将问题划分成一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。</strong></p><p>适合采用动态规划方法的最优化问题中的两个要素：<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p><p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p><p>In a word, <strong>分治法 —— 各子问题独立；动态规划 —— 各子问题重叠</strong>。</p><p>算法导论： <strong>动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胜者树与败者树</title>
    <link href="/2022/12/02/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    <url>/2022/12/02/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>胜者树与败者树是完全二叉树。就像是参加比赛一样，每个选手有不同的实力，两个选手PK,实力决定胜负，晋级下一轮，经过几轮之后，就能得到冠军。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。 胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。在k路归并排序中经常用到。</p><h2 id="胜者树"><a href="#胜者树" class="headerlink" title="胜者树"></a>胜者树</h2><p>胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p><p><img src="/img/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/fig1.jpg" alt="fig1"></p><p>上图是一个胜者树的示例。规定数值小者胜。</p><ol><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为3；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为3。</li></ol><p>取出胜者b3之后，叶子结点b3的值变为11时，重构的胜者树如下:</p><p><img src="/img/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/fig2.jpg" alt="fig2"></p><ol><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。</li></ol><p>用胜者树对n个节点实现排序操作，构建胜者树和构建堆比较相似，区别在于胜者树只有叶子节点存放了数据，中间节点记录的是叶子节点间的关系。</p><p>胜者树在每次重构时只需与其兄弟结点比较，一直到根节点选出胜者为止。</p><h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><p>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p><p><img src="/img/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/fig3.jpg" alt="fig3"></p><p>上图是一棵败者树。规定数大者败。</p><ol><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；</li></ol><p>败者树重构过程如下：</p><ul><li>将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。</li><li>比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。</li></ul><p><img src="/img/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/fig4.jpg" alt="fig4"></p><h2 id="胜者树、败者树、堆比较"><a href="#胜者树、败者树、堆比较" class="headerlink" title="胜者树、败者树、堆比较"></a>胜者树、败者树、堆比较</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>这三者空间和时间复杂度都是一样的。调整一次的时间复杂度都是O(logN)的。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，<strong>调整堆的时候，每次都要选出父结点的两个孩子节点的最小值，然后再用孩子结点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了胜者树。这样<strong>每次比较只用跟自己的兄弟结点进行比较就好</strong>，所以用胜者树可以比堆少一半的比较次数。</p><p>而<strong>胜者树想要比较兄弟结点首先要获得其父结点，也就是说需要访存两次</strong>，这时人们又想能否再次减少比较次数，于是就有了败者树。败者树每个新元素上升时，<strong>只需要获得父节点并比较即可</strong>。</p><p>总的来说，败者树与胜者树相比减少了访存时间。<strong>现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html#:~:text=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91%E9%83%BD%E6%98%AF%E5%AE%8C%E5%85%A8,%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BE%E5%88%B0%E6%9C%80%E5%80%BC%E3%80%82">胜者树和败者树</a></li><li><a href="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/12/02/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/12/02/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 </p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><ol><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</li></ol><p>由性质5我们可以推出：<br>    性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</p><h2 id="红黑树和AVL的区别"><a href="#红黑树和AVL的区别" class="headerlink" title="红黑树和AVL的区别"></a>红黑树和AVL的区别</h2><ol><li><p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p></li><li><p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p></li><li><p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/12/02/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/12/02/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Git撤销commit命令"><a href="#Git撤销commit命令" class="headerlink" title="Git撤销commit命令"></a>Git撤销commit命令</h2><p>当要撤销的提交不是最开始的提交时</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD~<br></code></pre></td></tr></table></figure><p>当要撤销的提交时最开始的提交时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">update</span> <span class="hljs-operator">-</span><span class="hljs-keyword">ref</span> <span class="hljs-operator">-</span>d HEAD<br></code></pre></td></tr></table></figure><h2 id="Git连接远程仓库"><a href="#Git连接远程仓库" class="headerlink" title="Git连接远程仓库"></a>Git连接远程仓库</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>url<br></code></pre></td></tr></table></figure><p>注：url为github仓库链接</p><h2 id="Git删除已经add的文件"><a href="#Git删除已经add的文件" class="headerlink" title="Git删除已经add的文件"></a>Git删除已经add的文件</h2><p>1.要删除的文件少时<br>    一种是 <code>git rm --cached</code> “文件路径”，不删除物理文件，仅将该文件从缓存中删除；<br>    一种是 <code>git rm --f</code>  “文件路径”，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。</p><p>2.要删除的文件多时<br>    <code>git rm -r --cached</code> .  清空缓存区<br>    然后将本地文件删除，再次<code>add</code></p><h2 id="Git创建远程新分支"><a href="#Git创建远程新分支" class="headerlink" title="Git创建远程新分支"></a>Git创建远程新分支</h2><p>git无法直接通过命令方式创建远程新分支，需要间接来创建,这里我创建的远程新分支名叫 vedio</p><p>首先 </p><p><code>git checkout --orphan 分支名</code><br><img src="https://img-blog.csdnimg.cn/20210403164118752.png"><br><strong>git rm -rf .</strong> （这一步很关键）<br>然后创建一个文件readme.md（其实任何文件都可以），add并commit，然后</p><p><code>git push origin 分支名</code> </p><p>就可以啦~如下图红框圈注的命令<br><img src="https://img-blog.csdnimg.cn/20210403164816128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTQyMQ==,size_16,color_FFFFFF,t_70"></p><h2 id="git强制提交本地分支覆盖远程分支"><a href="#git强制提交本地分支覆盖远程分支" class="headerlink" title="git强制提交本地分支覆盖远程分支"></a>git强制提交本地分支覆盖远程分支</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> localBranchName:remoteBranchName --force<br></code></pre></td></tr></table></figure><h2 id="Git从远程仓库拉取"><a href="#Git从远程仓库拉取" class="headerlink" title="Git从远程仓库拉取"></a>Git从远程仓库拉取</h2><p><code>git pull origin main</code></p><h2 id="Git创建与切换分支"><a href="#Git创建与切换分支" class="headerlink" title="Git创建与切换分支"></a>Git创建与切换分支</h2><p>创建分支 <code>git branch branch_name</code><br>切换分支 <code>git checkout branch_name</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
