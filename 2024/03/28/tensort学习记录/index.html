

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Starmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="tensorRT学习记录 基础概念 目标检测的mAP AP &amp; mAP  AP：PR 曲线下面积 mAP：mean Average Precision, 即各类别 AP 的平均值  TP、FP、FN、TN  True Positive (TP) False Positive (FP) False Negative (FN) True Negative (TN)  查准率、查全率  查准率（">
<meta property="og:type" content="article">
<meta property="og:title" content="tensort学习记录">
<meta property="og:url" content="https://gstarmin.github.io/2024/03/28/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">
<meta property="og:site_name" content="私人杂货铺">
<meta property="og:description" content="tensorRT学习记录 基础概念 目标检测的mAP AP &amp; mAP  AP：PR 曲线下面积 mAP：mean Average Precision, 即各类别 AP 的平均值  TP、FP、FN、TN  True Positive (TP) False Positive (FP) False Negative (FN) True Negative (TN)  查准率、查全率  查准率（">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-28T14:02:40.000Z">
<meta property="article:modified_time" content="2024-03-28T14:02:40.000Z">
<meta property="article:author" content="Starmin">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>tensort学习记录 - 私人杂货铺</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gstarmin.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Starmin</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="tensort学习记录"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-28 22:02" pubdate>
          2024年3月28日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          189 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">tensort学习记录</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="tensorrt学习记录">tensorRT学习记录</h1>
<h2 id="基础概念">基础概念</h2>
<h3 id="目标检测的map">目标检测的mAP</h3>
<h4 id="ap-map"><strong>AP &amp; mAP</strong></h4>
<ul>
<li>AP：PR 曲线下面积</li>
<li>mAP：mean Average Precision, 即各类别 AP 的平均值</li>
</ul>
<h4 id="tpfpfntn"><strong>TP、FP、FN、TN</strong></h4>
<ul>
<li>True Positive (TP)</li>
<li>False Positive (FP)</li>
<li>False Negative (FN)</li>
<li>True Negative (TN)</li>
</ul>
<h4 id="查准率查全率">查准率、查全率</h4>
<ul>
<li>查准率（Precision）: TP/(TP + FP)</li>
<li>查全率（Recall）: TP/(TP + FN)</li>
</ul>
<p>二者绘制的曲线称为 P-R 曲线</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-0c6661db35cd43e4d18c08dce2512ce1_720w-171231796802316.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="交并比---intersection-over-union-iou"><strong>交并比 -
Intersection Over Union (IOU)</strong></h4>
<p>交并比（IOU）是度量两个检测框（对于目标检测来说）的交叠程度，公式如下：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195312928.png" srcset="/img/loading.gif" lazyload
alt="image-20240405195312928" />
<figcaption aria-hidden="true">image-20240405195312928</figcaption>
</figure>
<p><span class="math inline">\(B_{gt}\)</span>
代表的是目标实际的边框（Ground Truth，GT），<span
class="math inline">\(B_p\)</span> 代表的是预测的边框，通过计算这两者的
IOU，可以判断预测的检测框是否符合条件，IOU 用图片展示如下：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195350834.png" srcset="/img/loading.gif" lazyload
alt="image-20240405195350834" />
<figcaption aria-hidden="true">image-20240405195350834</figcaption>
</figure>
<h4 id="评价指标-map"><strong>评价指标 mAP</strong></h4>
<p>先规定两个公式，一个是 Precision，一个是
Recall，这两个公式同上面的一样，我们把它们扩展开来，用另外一种形式进行展示，其中
<code>all detctions</code> 代表所有预测框的数量，
<code>all ground truths</code> 代表所有 GT 的数量。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195530696.png" srcset="/img/loading.gif" lazyload
alt="image-20240405195530696" />
<figcaption aria-hidden="true">image-20240405195530696</figcaption>
</figure>
<p><strong>AP 是计算某一类 P-R 曲线下的面积，mAP 则是计算所有类别 P-R
曲线下面积的平均值。</strong></p>
<h3 id="object-detection算法">Object Detection算法</h3>
<h4 id="rcnn">RCNN</h4>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405162152948.png" srcset="/img/loading.gif" lazyload
alt="image-20240405162152948" />
<figcaption aria-hidden="true">image-20240405162152948</figcaption>
</figure>
<ul>
<li>使用启发式搜索算法选择锚框</li>
<li>使用预训练模型对每个锚框抽取特征</li>
<li>训练一个SVM来对类别分类</li>
<li>训练一个线性回归模型来预测边缘框偏移</li>
</ul>
<p>选择了不同的锚框大小是不一样的，那么怎么让这些锚框最后变成一个batch呢？</p>
<p>这里使用了ROI pooling：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405162432057.png" srcset="/img/loading.gif" lazyload
alt="image-20240405162432057" />
<figcaption aria-hidden="true">image-20240405162432057</figcaption>
</figure>
<ul>
<li>给定一个锚框，均匀分割成n × m块，输出每块里的最大值</li>
<li>不管锚框多大，总是输出n × m个值</li>
</ul>
<p>尽管 R-CNN
模型通过预训练的卷积神经网络有效地抽取了图像特征，但是<strong>速度非常慢</strong>（如果从一张图片中选取了上千个提议区域，就需要上千次的卷积神经网络的前向传播来执行目标检测，<strong>计算量非常大</strong>）</p>
<h4 id="fast-rcnn">Fast RCNN</h4>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405162743100.png" srcset="/img/loading.gif" lazyload
alt="image-20240405162743100" />
<figcaption aria-hidden="true">image-20240405162743100</figcaption>
</figure>
<ul>
<li>使用CNN对图片抽取特征</li>
<li>在原图片上使用启发式搜索算法选择锚框，并将其映射到提取特征后的feature上</li>
<li>使用RoI池化层对每个锚框生成固定长度特征</li>
<li>使用全连接层分类</li>
</ul>
<p>和RCNN相比，Fast
RCNN不用使用CNN对每个锚框提取特征了，它是对整个图片进行特征抽取，选出来的有重叠的锚框不需要多次计算。</p>
<h4 id="faster-rcnn">Faster RCNN</h4>
<ul>
<li>使用一个区域提议网络来代替启发式搜索来获得更好的锚框。</li>
</ul>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405163938102.png" srcset="/img/loading.gif" lazyload
alt="image-20240405163938102" />
<figcaption aria-hidden="true">image-20240405163938102</figcaption>
</figure>
<p>Faster RCNN和Fast
RCNN不同的是之前的区域选择算法更换成了一个RPN（Region proposal
network）。这个RPN可以理解为一个比较粗糙的目标检测网络，在下面这部分做了一个二分类，判断生成的锚框是否是高质量的锚框,这样一些低质量的锚框就会被过滤掉,然后在剩余的高质量锚框中,使用NMS(非极大值抑制)来渡桥模型预测后的多余框.</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405164342532.png" srcset="/img/loading.gif" lazyload
alt="image-20240405164342532" />
<figcaption aria-hidden="true">image-20240405164342532</figcaption>
</figure>
<p><strong>区域提议网络的计算步骤</strong>：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/c8e2ae2fdafa952b03e4f43973cb1f86ad102ebf.png@1610w_!web-note.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>区域提议网络作为Faster R-CNN
模型的一部分，是和整个模型一起训练得到的（Faster R-CNN
的目标函数不仅包括目标检测中的类别和边界框预测，还包括区域提议网络中锚框的二元类别和边界框预测）</li>
<li>作为端到端训练的结果，区域提议网络能够学习到如何生成高质量的提议区域，从而在减少了从数据中学习的提议区域的数量的情况下，仍然保持了目标检测的精度</li>
</ul>
<p><strong>NMS的思路如下</strong>:</p>
<ol type="1">
<li>选取这类box中scores最大的那一个，记为box_best，并保留它</li>
<li>计算box_best与其余的box的IOU</li>
<li>如果其IOU&gt;0.5了，那么就舍弃这个box（由于可能这两个box表示同一目标，所以保留分数高的哪一个）</li>
<li>从最后剩余的boxes中，再找出最大scores的哪一个，如此循环往复</li>
</ol>
<p>经过NMS之后留下的锚框才会经过RoI Pooling以及后续阶段.</p>
<h4 id="mask-r-cnn">Mask R-CNN</h4>
<p>如果在训练集中还标注了每个目标在图像上的<strong>像素级位置</strong>，Mask
R-CNN 能够有效地利用这些相近地标注信息进一步提升目标检测地精度.</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/a80b045c48d1eda6f340ba23870cc60447629176.png@1610w_!web-note.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Mask R-CNN 是基于 Faster R-CNN 修改而来的，改进在于</p>
<ol type="1">
<li>假设有每个像素的标号的话，就可以对每个像素做预测（<strong>FCN</strong>）</li>
<li>将兴趣区域汇聚层替换成了<strong>兴趣区域对齐层</strong>（RoI pooling
-&gt; RoI align），使用<strong>双线性插值</strong>（bilinear
interpolation）保留特征图上的空间信息，进而更适于像素级预测：对于pooling来说，假如有一个3
* 3的区域，需要对它进行2 * 2的RoI
pooling操作，那么会进行取整从而切割成为不均匀的四个部分，然后进行
pooling
操作，这样切割成为不均匀的四部分的做法对于目标检测来说没有太大的问题，因为目标检测不是像素级别的，偏移几个像素对结果没有太大的影响。但是<strong>对于像素级别的标号来说，会产生极大的误差</strong>；RoI
align
不管能不能整除，如果不能整除的话，会直接将像素切开，切开后的每一部分是原像素的加权（它的值是原像素的一部分）</li>
<li>兴趣区域对齐层的输出包含了所有与兴趣区域的形状相同的特征图，它们不仅被用于<strong>预测每个兴趣区域的类别和边界框</strong>，还通过额外的全卷积网络<strong>预测目标的像素级位置</strong></li>
</ol>
<p><strong>RoI
Align</strong>:引入了一个插值过程，先通过双线性插值到14<em>14，再
pooling到7</em>7，很大程度上解决了仅通过 Pooling 直接采样带来的
Misalignment 对齐问题。虽然 Misalignment 在分类问题上影响并不大，但在
Pixel 级别的 Mask 上会存在较大误差。</p>
<h4 id="模型精度比较">模型精度比较</h4>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405172221743.png" srcset="/img/loading.gif" lazyload
alt="image-20240405172221743" />
<figcaption aria-hidden="true">image-20240405172221743</figcaption>
</figure>
<ul>
<li>x
轴表示<strong>模型的运行速度</strong>，越往右表示模型的速度越快，越往左越慢</li>
<li>y 轴表示
<strong>mAP</strong>（可以简单认为是边界框的预测精度），越往上表示精度越高</li>
<li>图中圆圈的大小表示<strong>内存的使用</strong></li>
<li>Faster RCNN
相对来说精度比较高，但是它在精度提升的同时，样本的处理速度也在变慢（所以只有在对精度</li>
</ul>
<h4 id="小结">小结</h4>
<p>RCNN系列都是两阶段(Two-Stage)的算法,它们的思想都是先做一个粗糙一点的预测,然后做一个更精准的预测.不同的是Fast
RCNN通过先对图片提取特征来减少重复计算,而Faster
RCNN又在这个基础之上通过一个RPN来获得更好的锚框.</p>
<ul>
<li>R-CNN 是最早、也是最有名的一类基于锚框和 CNN 的目标检测算法（R-CNN
可以认为是使用神经网络来做目标检测工作的奠基工作之一），它对图像选取若干提议区域，使用卷积神经网络对每个提议区域执行前向传播以抽取其特征，然后再用这些特征来预测提议区域的类别和边框</li>
<li>Fast/Faster R-CNN持续提升性能：Fast R-CNN
<strong>只对整个图像做卷积神经网络的前向传播</strong>，还引入了<strong>兴趣区域汇聚层</strong>（RoI
pooling），从而为具有不同形状的兴趣区域抽取相同形状的特征；Faster R-CNN
将 Fast R-CNN
中使用的选择性搜索替换为<strong>参与训练的区域提议网络</strong>，这样可以在减少提议区域数量的情况下仍然保持目标检测的精度；Mask
R-CNN 在 Faster R-CNN
的基础上引入了一个<strong>全卷积网络</strong>，从而借助目标的<strong>像素级位置</strong>进一步提升目标检测的精度</li>
<li>Faster R-CNN 和 Mask R-CNN 是在追求高精度场景下的常用算法（Mask
R-CNN
需要有像素级别的标号，所以相对来讲局限性会大一点，在无人车领域使用的比较多）</li>
</ul>
<h4 id="单发多框检测ssd">单发多框检测(SSD)</h4>
<p>R-CNN系列都是要两阶段(如先过一遍RPN然后再做预测),而下面的一类算法只需要过一遍就可以完成检测.</p>
<p><strong>对每个像素生成多个以它为中心的多个锚框</strong>:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/393fb24dc90f86d8a2ea5c254ab623e7acbbf8b0.png@984w_!web-note.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/924c747e8134ee2b55e5752dfba9724a2573aede.png@1356w_!web-note.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/f5c0c5a8e98db98da7ed57bc85e242197090d469.png@1376w_!web-note.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>输入图像之后，首先进入一个基础网络来抽取特征，抽取完特征之后对每个像素生成大量的锚框（每个锚框就是一个样本，然后预测锚框的类别以及到真实边界框的偏移）</li>
<li>SSD
在给定锚框之后<strong>直接对锚框进行预测</strong>，而不需要做两阶段（为什么
Faster RCNN 需要做两次，而 SSD 只需要做一次？SSD
通过做不同分辨率下的预测来提升最终的效果，越到底层的 feature
map，就越大，越往上，feature map
越少，因此<strong>底层更加有利于小物体的检测，而上层更有利于大物体的检测</strong>）</li>
<li>SSD 不再使用 RPN
网络，而是<strong>直接在生成的大量样本（锚框）上做预测</strong>，看是否包含目标物体；如果包含目标物体，再预测该样本到真实边缘框的偏移</li>
</ul>
<p><strong>模型精度</strong>:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405172827789.png" srcset="/img/loading.gif" lazyload
alt="image-20240405172827789" />
<figcaption aria-hidden="true">image-20240405172827789</figcaption>
</figure>
<ul>
<li>上图中绿色的点表示 SSD</li>
<li>从图中可以看出，SSD 相对于Faster RCNN
来讲<strong>速度快很多，但是精度不是太好</strong></li>
<li>SSD 的实现相对来讲比较简单，R-CNN 系列代码的实现非常困难</li>
</ul>
<h4 id="小结-1">小结</h4>
<ul>
<li>SSD通过<strong>单神经网络</strong>来检测模型</li>
<li><strong>以每个像素为中心</strong>产生多个锚框</li>
<li>在<strong>多个段</strong>的输出上进行<strong>多尺度</strong>的检测（底层检测小物体，上层检测大物体）</li>
</ul>
<h4 id="yolo">YOLO</h4>
<ul>
<li>yolo 也是一个 single-stage
的算法，只有一个<strong>单神经网络</strong>来做预测</li>
<li>yolo 也需要锚框，这点和 SSD 相同，但是 SSD
是对每个像素点生成多个锚框，所以在绝大部分情况下两个相邻像素的所生成的锚框的<strong>重叠率</strong>是相当高的，这样就会导致很大的重复计算量。</li>
<li>yolo 的想法是<strong>尽量让锚框不重叠</strong>：首先将图片均匀地分成
S * S 块，每一块就是一个锚框，每一个锚框预测 B
个边缘框（考虑到一个锚框中可能包含多个物体），所以最终就会产生 S ^ 2 * B
个样本，因此速度会远远快于 SSD</li>
<li>yolo
在后续的版本（V2,V3,V4...）中有持续的改进，但是核心思想没有变，真实的边缘框不会随机的出现，真实的边缘框的比例、大小在每个数据集上的出现是有一定的规律的，在知道有一定的规律的时候就可以使用<strong>聚类算法</strong>将这个规律找出来（给定一个数据集，<strong>先分析数据集中的统计信息，然后找出边缘框出现的规律</strong>，这样之后在生成锚框的时候就会有先验知识，从而进一步做出优化）</li>
</ul>
<h4 id="模型精度">模型精度</h4>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/faed4a83cbfa24f5b4062b5b7f35678faa5ee2df.png@1610w_!web-note.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>上图中表示 yolo v3
的直线底端表示论文中的<strong>原始精度</strong>，顶端表示通过改进之后所能达到的<strong>最大精度</strong></li>
</ul>
<h4 id="center-net">center net</h4>
<ul>
<li>基于<strong>非锚框</strong>的目标检测</li>
<li>center net 的优点在于简单</li>
<li>center net 会对<strong>每个像素</strong>做预测，用 FCN
对每个像素做预测（类似于图像分割中用 FCN
对每个像素标号），<strong>预测该像素点是不是真实边缘框的中心点</strong>（将目标检测的边缘框换算成基于每个像素的标号，然后对每个像素做预测，就免去了一些锚框相关的操作）</li>
</ul>
<h3 id="yolo详解">YOLO详解</h3>
<h4 id="yolov1">YOLOv1</h4>
<p><strong>step1</strong>:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194511282.png" srcset="/img/loading.gif" lazyload
alt="image-20240405194511282" />
<figcaption aria-hidden="true">image-20240405194511282</figcaption>
</figure>
<p><strong>step2</strong>:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194528416.png" srcset="/img/loading.gif" lazyload
alt="image-20240405194528416" />
<figcaption aria-hidden="true">image-20240405194528416</figcaption>
</figure>
<p>每一个grid需要预测2个bounding box。每个bounding
box有5个值，分别是4个位置(x,y,w,h)，和一个yolo系列独有的置信度confidence。confidence简单理解为<code>预测边界框与标注边界框的IOU * 是否有目标</code>，即预测边界框与标注边界框的重合程度。</p>
<p>以VOC数据集为例,20个类别,每个grid
cell需要预测一个长度为30的tensor(2组x,y,w,h,confidence和20个类别分数).</p>
<p>每个类别分数如下图:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194440217.png" srcset="/img/loading.gif" lazyload
alt="image-20240405194440217" />
<figcaption aria-hidden="true">image-20240405194440217</figcaption>
</figure>
<ul>
<li>最终预测目标概率为：目标类别分数*confidece</li>
</ul>
<h5 id="网络结构">网络结构</h5>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194359822.png" srcset="/img/loading.gif" lazyload
alt="image-20240405194359822" />
<figcaption aria-hidden="true">image-20240405194359822</figcaption>
</figure>
<ul>
<li>网络输入：448×448×3的彩色图片。</li>
<li>中间层：由若干卷积层和最大池化层组成，用于提取图片的抽象特征。</li>
<li>全连接层：由两个全连接层组成，用来预测目标的位置和类别概率值。</li>
<li>网络输出：7×7×30的预测结果。</li>
</ul>
<h5 id="损失函数">损失函数</h5>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194643807.png" srcset="/img/loading.gif" lazyload
alt="image-20240405194643807" />
<figcaption aria-hidden="true">image-20240405194643807</figcaption>
</figure>
<h5 id="不足之处">不足之处</h5>
<ul>
<li>对于群体型的小目标，检测能力很差。</li>
<li>对于未训练过的新尺寸目标，检测能力很差。</li>
<li>主要错误原因来自于定位不准确。</li>
</ul>
<h4 id="yolov2">YOLOv2</h4>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195027207.png" srcset="/img/loading.gif" lazyload
alt="image-20240405195027207" />
<figcaption aria-hidden="true">image-20240405195027207</figcaption>
</figure>
<h5 id="batch-normalization">Batch Normalization</h5>
<ul>
<li><strong>BN的本质原理</strong>：在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理（归一化至：均值0、方差为1），它是一个可学习、有参数（γ、β）的网络层。</li>
<li><strong>作用：</strong>解决在训练过程中，中间层数据分布发生改变的问题，以防止梯度消失或爆炸、加快训练速度，加快算法收敛速度。</li>
</ul>
<p>检测系列的网络结构中，BN逐渐变成了标配。在Yolo的每个卷积层中加入BN之后，mAP提升了2%，并且去除了Dropout。</p>
<p>BN大体可以分为四步：</p>
<ol type="1">
<li>计算出均值</li>
<li>计算出方差</li>
<li>归一化处理到均值为0，方差为1</li>
<li>变化重构，恢复出这一层网络所要学到的分布</li>
</ol>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405205207083.png" srcset="/img/loading.gif" lazyload
alt="image-20240405205207083" />
<figcaption aria-hidden="true">image-20240405205207083</figcaption>
</figure>
<h5 id="high-resolution-classifier分类网络高分辨率预训练">High
Resolution Classifier（分类网络高分辨率预训练）</h5>
<ul>
<li>这里引入迁移学习(Transfer
learning)的概念：把已训练好的模型（预训练模型）参数迁移到新的模型帮助新模型训练。</li>
</ul>
<blockquote>
<p>迁移学习有三种方式 <strong>Transfer
Learning</strong>：冻结预训练模型的全部卷积层，只训练自己定制的全连接层。
<strong>Extract Feature
Vector</strong>：先计算出预训练模型的卷积层对所有训练和测试数据的特征向量，然后抛开预训练模型，只训练自己定制的简配版全连接网络。
<strong>Fine-tuning</strong>：冻结预训练模型的部分卷积层（通常是靠近输入的多数卷积层，因为这些层保留了大量底层信息）甚至不冻结任何网络层，训练剩下的卷积层（通常是靠近输出的部分卷积层）和全连接层。</p>
</blockquote>
<ul>
<li>Fine-tuning原理：利用已知网络结构和已知网络的参数，修改output层为我们自己的层，微调最后一层前的若干层的训练参数，这样就有效利用了深度神经网络强大的泛化能力，又免去了设计复杂的模型以及耗时良久的训练。</li>
<li>YOLOv1在采用 224×224 分类模型预训练后将分辨率增加到 448×448
，并使用这个高分辨率在检测数据集上finetune。但是直接切换分辨率，检测模型可能难以快速适应高分辨率。所以YOLOv2增加了<strong>在ImageNet数据集上使用</strong>448×448<strong>输入来finetune分类网络</strong>这一中间过程（10
epochs）.<strong>YOLOv2将预训练分成两步：先用</strong>224×224<strong>的输入从头开始训练网络，大概160个epoch（表示将所有训练数据循环跑160次），然后再将输入调整到</strong>448×448<strong>，再训练10个epoch</strong>，这可以使得模型在检测数据集上finetune之前已经适应高分辨率输入。使用高分辨率分类器后，YOLOv2的mAP提升了约4%。</li>
</ul>
<h5 id="convolutional-with-anchor-boxes使用先验框">Convolutional With
Anchor Boxes（使用先验框）</h5>
<p>YOLOv1每个格点预测两个矩形框，在计算loss时，只让与ground
truth最接近的框产生loss数值，而另一个框不做修正。这样规定之后，作者发现两个框在物体的大小、长宽比、类别上逐渐有了分工。在v2中，神经网络不对预测矩形框的宽高的绝对值进行预测，而是预测与Anchor框的偏差（offset），每个格点指定n个Anchor框。在训练时，最接近ground
truth的框产生loss，其余框不产生loss。在引入Anchor
Box操作后，mAP由69.5下降至69.2，原因在于，每个格点预测的物体变多之后，<strong>召回率大幅上升，准确率略微有所下降</strong>，总体mAP略有下降。</p>
<p>v2中移除了v1最后的两层全连接层，全连接层计算量大，耗时久。文中没有详细描述全连接层的替换方案，这里猜测是利用1*1的卷积层代替.</p>
<h5 id="dimension-clustersanchor-box的宽高由聚类产生">Dimension
Clusters（Anchor Box的宽高由聚类产生）</h5>
<p>这里算是作者的一个创新点。Faster R-CNN中的九个Anchor
Box的宽高是事先设定好的比例大小，一共设定三个面积大小的矩形框，每个矩形框有三个宽高比：1:1，2:1，1:2，总共九个框。而在v2中，Anchor
Box的宽高不经过人为获得，而是将训练数据集中的矩形框全部拿出来，用kmeans聚类得到先验框的宽和高。例如使用5个Anchor
Box，那么kmeans聚类的类别中心个数设置为5。加入了聚类操作之后，引入Anchor
Box之后，mAP上升。</p>
<p>需要强调的是，聚类必须要定义聚类点（矩形框 (<span
class="math inline">\(w\)</span>,ℎ)）之间的距离函数，文中使用如下函数：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-418f012af6cc4f94db0486cdca8968aa_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>下图是在VOC和COCO数据集上的聚类分析结果，随着聚类中心数目的增加，平均IOU值（各个边界框与聚类中心的IOU的平均值）是增加的，但是综合考虑模型复杂度和召回率，作者最终选取5个聚类中心作为先验框，其相对于图片的大小如右边图所示。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-d1d8b71299bdeddb13243bc537a34f9a_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h5 id="direct-location-prediction">Direct location prediction</h5>
<p>引入anchor
box的时候遇到的第二个问题：模型不稳定，尤其是在训练刚开始的时候。其位置预测公式为如下图所示：
其中 (x,y) 为边界框的实际中心位置，需要预测的坐标偏移值为 (<span
class="math inline">\(t_x,t_y\)</span>) ,先验框的尺寸为 (<span
class="math inline">\(w_a,h_a\)</span>) 以及中心坐标 (<span
class="math inline">\(x_a,y_a\)</span>) (特征图每个位置的中心点)。由于
(<span class="math inline">\(t_x,t_y\)</span>)
取值没有任何约束，因此预测边框的中心可能出现在任何位置，训练早期不容易稳定。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405211349987.png" srcset="/img/loading.gif" lazyload
alt="image-20240405211349987" />
<figcaption aria-hidden="true">image-20240405211349987</figcaption>
</figure>
<p>所以，YOLOv2弃用了这种预测方式，而是沿用YOLOv1的方法，就是<strong>预测边界框中心点相对于对应cell左上角位置的相对偏移值</strong>，为了将边界框中心点约束在当前cell中，使用sigmoid函数处理偏移值，这样预测的偏移值在(0,1)范围内（每个cell的尺度看做1）。总结来看，根据边界框预测的4个offsets<span
class="math inline">\(t_x,t_y,t_w,t_h\)</span>
,可以按如下公式计算出边界框实际位置和大小：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405211424051.png" srcset="/img/loading.gif" lazyload
alt="image-20240405211424051" />
<figcaption aria-hidden="true">image-20240405211424051</figcaption>
</figure>
<p>其中 (<span class="math inline">\(c_x, c_y\)</span>)
为cell的左上角坐标，在计算时每个cell的尺度为1，所以当前cell的左上角坐标为(1,1)，由于sigmoid（<span
class="math inline">\(\sigma(x)=\frac{1}{1 +
e^{-x}}\)</span>）函数的处理，边界框的中心约束会在cell内部，防止偏移过多。
(<span class="math inline">\(p_w,p_h\)</span>)
是先验框的宽度和长度，其值是相对于特征图大小的。在特征图中每个cell的长和宽均为1。这里记特征图的大小为
(W,H)
，（在文中是(13,13)），这样我们就可以将边界框相对于整张图片的位置和大小计算出来（4个值均在0和1之间）：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405213543725.png" srcset="/img/loading.gif" lazyload
alt="image-20240405213543725" />
<figcaption aria-hidden="true">image-20240405213543725</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-5709a4695997d975d0e8bf0bafd714d8_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如果再将上面的4个值分别乘以图片的宽度和长度（像素点值）就可以得到边界框的最终位置和大小了。</p>
<h5 id="fine-grained-features">Fine-Grained Features</h5>
<p>YOLOv2的输入图片大小是416<em>416，经过5次2</em>2 maxpooling之后得到13
* 13大小的特征图，并以此特征图采用卷积做预测。虽然13*13的feature
map对于预测大的object以及足够了，但是对于预测小的object就不一定有效。这里主要是添加了一个层：<strong>passthrough
layer</strong>。这个层的作用就是<strong>将前面一层的26*26的feature
map和本层的13*13的feature map进行连接</strong>，有点像ResNet。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-3ba1a8ab912c8f10061929f08a7e0755_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>一拆四的方法如下：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-0055f985ded26205e3bb29b096ccfa63_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h5 id="multi-scale-training多尺度的图像训练">Multi-Scale
Training(多尺度的图像训练)</h5>
<p>为了让YOLOv2模型更加robust，作者引入了Muinti-Scale
Training，简单讲就是在训练时输入图像的size是动态变化的，注意这一步是<strong>在检测数据集上fine
tune时候</strong>采用的，不要跟前面在Imagenet数据集上的两步预训练分类模型混淆。</p>
<p>由于YOLOv2模型中<strong>只有卷积层和池化层</strong>，所以YOLOv2的输入可以不限于
416*416大小的图片。</p>
<p>具体来讲，在训练网络时，每训练10个batch(在一个epoch
中，batch数和迭代数是相等的，例如500个样本为1batch，总样本2000，则一个epoch包含4个batch或者说4个iteration),<strong>网络就会随机选择另一种size的输入</strong>,然后只需要修改对最后检测层的处理就可以重新训练。也就是说downsample的factor是32，因此采用32的倍数作为输入的size:{320,352,…,608}。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-8179e6363bc489268e9ff58281ee3311_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>总结来看，虽然YOLOv2做了很多改进，但是大部分都是借鉴其它论文的一些技巧，如Faster
R-CNN的anchor boxes，YOLOv2采用anchor
boxes和卷积做预测，这基本上与SSD模型（单尺度特征图的SSD）非常类似了，而且SSD也是借鉴了Faster
R-CNN的RPN网络。从某种意义上来说，YOLOv2和SSD这两个one-stage模型与RPN网络本质上无异，只不过RPN不做类别的预测，只是简单地区分物体与背景。在two-stage方法中，RPN起到的作用是给出region
proposals，其实就是作出粗糙的检测，所以另外增加了一个stage，即采用R-CNN网络来进一步提升检测的准确度（包括给出类别预测）。而对于one-stage方法，它们想要一步到位，直接采用“RPN”网络作出精确的预测，要因此要在网络设计上做很多的tricks。YOLOv2的一大创新是采用Multi-Scale
Training策略，这样同一个模型其实就可以适应多种大小的图片了。</strong></p>
<h5 id="fasternew-networkdarknet-19">Faster:new Network:Darknet-19</h5>
<p>在YOLO
v1中，作者采用的训练网络是基于GooleNet,YOLOv2采用了一个新的基础模型（特征提取器），称为Darknet-19，包括19个卷积层和5个maxpooling层.</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-f6a7dc0f4941a754c205b0e0d2978687_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Darknet-19与VGG16模型设计原则是一致的，<strong>主要采用 3×3
卷积，采用 2×2
的maxpooling层，特征图维度降低2倍，同时特征图的channles增加两倍</strong>。与NIN类似，Darknet-19最终<strong>采用global
avgpooling做预测</strong>，并且在 3×3 卷积之间使用 1×1
卷积来压缩特征图channles以降低模型计算量和参数。Darknet-19<strong>每个卷积层后面使用了batch
norm层</strong>以加快收敛速度，降低模型过拟合。</p>
<p><strong>整体网络结构</strong>:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405214852338.png" srcset="/img/loading.gif" lazyload
alt="image-20240405214852338" />
<figcaption aria-hidden="true">image-20240405214852338</figcaption>
</figure>
<h4 id="yolov3">YOLOv3</h4>
<p>详细见<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37541097/article/details/81214953?ops_request_misc=%7B%22request%5Fid%22%3A%22171232888516800227454500%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=171232888516800227454500&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-81214953-null-null.nonecase&amp;utm_term=YOLO&amp;spm=1018.2226.3001.4450">YOLO
v3网络结构分析_yolov3网络结构-CSDN博客</a>.</p>
<p><strong>网络结构</strong>:</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405215233904.png" srcset="/img/loading.gif" lazyload
alt="image-20240405215233904" />
<figcaption aria-hidden="true">image-20240405215233904</figcaption>
</figure>
<h4 id="yolov3-spp">YOLOv3 SPP</h4>
<p>改进见<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38109282/article/details/117293611">YOLO-V3-SPP详细解析_yolov3-spp-CSDN博客</a>.</p>
<h4 id="yolov4">YOLOv4</h4>
<p>见<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37541097/article/details/123229946">YOLOv4网络详解_yolov4网络结构图-CSDN博客</a>.</p>
<h3 id="fermikepler架构">Fermi、Kepler架构</h3>
<ol type="1">
<li><strong>Fermi架构</strong>：
<ul>
<li>Fermi架构是NVIDIA的第一代统一架构，推出于2010年。</li>
<li>它引入了CUDA（Compute Unified Device
Architecture）计算架构，使GPU不仅仅用于图形处理，还能进行通用计算。</li>
<li>Fermi架构支持双精度浮点运算，这对于科学计算和一些专业应用来说是至关重要的。</li>
<li>Fermi GPU的代表产品包括GTX 400和500系列。</li>
</ul></li>
<li><strong>Kepler架构</strong>：
<ul>
<li>Kepler架构是NVIDIA的第二代统一架构，推出于2012年。</li>
<li>它进一步提升了CUDA计算性能，并引入了一些新技术，如GPU
Boost（动态超频）和NVENC（NVIDIA视频编码器）。</li>
<li>Kepler架构在能效方面有所改进，使得GPU在相同功耗下能提供更高的性能。</li>
<li>Kepler GPU的代表产品包括GTX 600和700系列。</li>
</ul></li>
</ol>
<h3 id="sm">SM</h3>
<p><strong>GPU实际上是一个SM的阵列，每个SM包含N个计算核</strong>，现在我们的常用GPU中这个数量一般为128或192。一个GPU设备中包含一个或多个SM，这是处理器具有可扩展性的关键因素。如果向设备中增加更多的SM，GPU就可以在同一时刻处理更多的任务，或者对于同一任务，如果有足够的并行性的话，GPU可以更快完成它。</p>
<p>具体而言，以Fermi架构的GPU为例，其结构如下图。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-3b479ba08f0f5003dc001b3757377625_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>左边是GPU的整体结构，其主要是由大量的SM（Streaming-Multiprocessor）和DRAM存储等构成的。右图是对单个SM进行放大，可以看到SM由大量计算核（有时也称SP或CUDA核）、LDU（Load-Store
Units）、SFU（Special-Function
Units）、寄存器、共享内存等构成。这种结构正是GPU具有高并行度计算能力的基础。<strong>通过一定的层级结构组织大量计算核，并给各级都配有相应的内存系统</strong>，GPU获得了出色的计算能力。</p>
<p>其中流式多处理器（SM）是GPU架构的核心。GPU中的每一个SM都能支持数百个线程并发执行，每个GPU通常有多个SM，所以在一个GPU上并发执行数千个线程是有可能的。当启动一个内核网络时，它的线程块会被分布在可用的SM上来执行。当线程块一旦被调度到一个SM上，其中的线程只会在那个指定的SM上并发执行。多个线程块可能会被分配到同一个SM上，而且是根据SM资源的可用性进行调度的。</p>
<p>再多提一嘴，稍微说说计算核以外的部分。线程束调度器（Warp
Scheduler）顾名思义是进行线程束的调度，负责将软件线程分配到计算核上；LDU（Load-Store
Units）负责将值加载到内存或从内存中加载值；SFU（Special-Function
Units）用来处理sin、cos、求倒数、开平方特殊函数。</p>
<h3 id="heatmap">Heatmap</h3>
<p>CenterNet<strong>将目标当成一个点</strong>来检测，即用<strong>目标box的中心</strong>点来表示这个目标。<strong>预测目标中心的偏移量(offset),宽高size来得到物体实际box</strong>，而heatmap则是表示分类信息。每个类别都有一张heatmap，每一张heatmap上，若某个坐标处有物体目标的中心点，即在该坐标处产生一个keypoint(用高斯圆表示)，如下图所示：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-34ea0c5ba8f21a319745706b2aae63e1_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="focal-loss">Focal Loss</h3>
<p>Focal
Loss（焦点损失）是一种用于解决类别不平衡问题的损失函数，特别是在目标检测任务中常常被使用。它由Lin
et al.在2017年的论文《Focal Loss for Dense Object
Detection》中提出。</p>
<p>在目标检测任务中，由于背景类别的样本数量远远超过目标类别的样本数量，导致了类别不平衡问题。传统的交叉熵损失函数在面对这种不平衡时可能会导致模型过度关注于容易分类的背景样本，而忽视了目标样本的分类。</p>
<p>Focal
Loss通过引入一个可调节的参数，有效地降低了容易分类的样本（例如背景样本）的权重，从而更加关注难以分类的样本。具体来说，焦点损失函数通过降低易分类样本的权重来减少易分类样本对总体损失的贡献，并且对于错误分类的样本给予了更大的权重，这样可以使模型更加关注于难以分类的样本，从而提高了模型对于少数类别目标的检测能力。</p>
<h3 id="loss">loss</h3>
<p>训练的时候应该控制loss的初始值，最好在10以内，才可以控制训练不会飞。</p>
<h2 id="driver-api的层次">Driver API的层次</h2>
<ol type="1">
<li><p>CUDA Driver是与GPU沟通的驱动级别底层API</p></li>
<li><p>对DriverAPI的理解，有利于理解后续的RuntimeAPI</p></li>
<li><p>CUDA
Driver<strong>随显卡驱动发布</strong>，与cudatoolkit<strong>分开看</strong></p></li>
<li><p>CUDA Driver对应于cuda.h和libcuda.so文件</p></li>
<li><p>主要知识点是<strong>Context的管理机制</strong>，以及<strong>CUDA系列接口的开发习惯</strong>（错误检查方法），还有<strong>内存模型</strong></p></li>
</ol>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328221536121.png" srcset="/img/loading.gif" lazyload
alt="image-20240328221536121" />
<figcaption aria-hidden="true">image-20240328221536121</figcaption>
</figure>
<h2 id="context">Context</h2>
<p>有两种：</p>
<ol type="1">
<li>手动管理的context，cuCtxCreate（手动管理，以堆栈方式push/pop）</li>
<li>自动管理的context，cuDevicePrimaryCtxRetain（自动管理，runtime
api以此为基础）</li>
</ol>
<h3 id="手动管理cuctxcreate">手动管理cuCtxCreate</h3>
<p>context是一种上下文，关联对GPU的所有操作。context与一块显卡关联，一个显卡可以被多个context关联。<strong>每个线程都有一个栈结构储存context</strong>，<strong>栈顶是当前使用的context</strong>，对应有push、pop函数操作context的栈，<strong>所有api都以当前context为操作目标</strong>。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328222527402.png" srcset="/img/loading.gif" lazyload
alt="image-20240328222527402" />
<figcaption aria-hidden="true">image-20240328222527402</figcaption>
</figure>
<p><strong>context只是为了方便控制device的一种手段而提出来的，栈的存在是为了方便控制多个设备</strong>。</p>
<h3
id="自动管理cudeviceprimaryctxretain">自动管理cuDevicePrimaryCtxRetain</h3>
<p>由于高频操作，是一个线程基本固定访问一个显卡不变，且只使用一个context，很少会用到多context，这时候CreateContext、PushCurrent、PopCurrent这种多context管理就显得麻烦，还得再简单，因此推出了cuDevicePrimaryCtxRetain，为设备关联主context，分配、释放、设置、栈都不用你管。primaryContext：给我设备id，给你context并设置好，此时<strong>一个显卡对应一个primary
context</strong>。不同线程，只要设备id一样，primary
context就一样。context是线程安全的。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328222751887.png" srcset="/img/loading.gif" lazyload
alt="image-20240328222751887" />
<figcaption aria-hidden="true">image-20240328222751887</figcaption>
</figure>
<h2 id="内存">内存</h2>
<p>有两大类：</p>
<ol type="1">
<li><p>CPU内存，称之为Host Memory</p>
<ol type="1">
<li>Pageable Memory：可分页内存</li>
<li>Page-Locked Memory/pinned memory：页锁定内存</li>
</ol>
<p>可以理解为Page lock memory是vip房间，锁定给你一个人用。而Pageable
memory是普通房间，</p>
<p>在酒店房间不够的时候，选择性的把你的房间腾出来给其他人交换用，这就可以容纳更多人了。<strong>造成房</strong></p>
<p><strong>间很多的假象，代价是性能降低</strong>。</p>
<p>pageable
memory没有锁定特性，对于第三方设备（比如GPU），去访问时，因为无法感知内存是否被交换，可能得不到正确的数据（每次去房间找，说不准
你的房间被人交换了）。所以<strong>GPU可以直接访问pinned
memory而不能访问pageable memory</strong>。</p></li>
<li><p>GPU内存，称之为Device Memory</p>
<ol type="1">
<li><strong>全局内存</strong>(3)：Global Memory
<ol type="1">
<li>速度：普通</li>
<li>读写</li>
<li>显存大小（11GB etc.）</li>
</ol></li>
<li>寄存器内存(1)：Register Memory
<ol type="1">
<li>速度：最快</li>
<li>读写</li>
</ol></li>
<li>纹理内存(2)：Texture Memory
<ol type="1">
<li>速度：快</li>
<li>只读</li>
</ol></li>
<li><strong>共享内存</strong>(2)：Shared Memory
<ol type="1">
<li>速度快</li>
<li>读写</li>
<li>大小：2080Ti有48kb</li>
</ol></li>
<li><strong>常量内存</strong>(2)：Constant Memory
<ol type="1">
<li>速度：快</li>
<li>只读不能写</li>
<li>大小：一般64kb，16bit寻址</li>
<li>通常放一些不修改的东西，速度很快</li>
</ol></li>
<li>本地内存(3)：Local Memory，其实是全局内存，
<ol type="1">
<li>速度普通</li>
<li>读写</li>
<li>大小：可用内存 / (SM数量 *
SM最大常驻线程数)，动态计算的，可用越少值越小</li>
<li>C++中分配的栈空间变量就存在这里，local
memory可以认为是栈空间，为什么说其实是全局内存，因为它和全局内存用的是同一块内存，在cuda核定义一个变量就是在这的</li>
</ol></li>
</ol></li>
</ol>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328221707001.png" srcset="/img/loading.gif" lazyload
alt="image-20240328221707001" />
<figcaption aria-hidden="true">image-20240328221707001</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329213005234.png" srcset="/img/loading.gif" lazyload
alt="image-20240329213005234" />
<figcaption aria-hidden="true">image-20240329213005234</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329213032531.png" srcset="/img/loading.gif" lazyload
alt="image-20240329213032531" />
<figcaption aria-hidden="true">image-20240329213032531</figcaption>
</figure>
<h3 id="内存方面总结">内存方面总结</h3>
<ol type="1">
<li>GPU可以直接访问pinned memory，称之为（DMA Direct Memory
Access）</li>
<li>对于GPU访问而言，距离计算单元越近，效率越高，所以PinnedMemory&lt;GlobalMemory&lt;SharedMemory</li>
<li>代码中，由new、malloc分配的，是pageable
memory，由cudaMallocHost分配的是PinnedMemory，由cudaMalloc分配的是GlobalMemory</li>
<li>尽量多用PinnedMemory储存host数据，或者显式处理Host到Device时，用PinnedMemory做缓存，都是提高性能的关键</li>
</ol>
<h3 id="各函数申请的内存类型">各函数申请的内存类型</h3>
<ol type="1">
<li><p>通过cudaMalloc分配GPU内存，分配到setDevice指定的当前设备上</p></li>
<li><p>通过cudaMallocHost分配page locked memory，即pinned
memory，页锁定内存</p>
<ol type="1">
<li>页锁定内存是主机内存，CPU可以直接访问</li>
<li>页锁定内存也可以被GPU直接访问，使用DMA（Direct Memory Access）技术
<ul>
<li>注意这么做的性能会比较差，因为主机内存距离GPU太远，隔着PCIE等，不适合大量数据传输</li>
</ul></li>
<li>页锁定内存是物理内存，过度使用会导致系统性能低下（导致虚拟内存等一系列技术变慢）</li>
</ol></li>
<li><p>cudaMemcpy</p>
<ol type="1">
<li><p>如果host不是页锁定内存，则：</p>
<ul>
<li>Device To Host的过程，等价于
<ul>
<li>pinned = cudaMallocHost</li>
<li>copy Device to pinned</li>
<li>copy pinned to Host</li>
<li>free pinned</li>
</ul></li>
<li>Host To Device的过程，等价于
<ul>
<li>pinned = cudaMallocHost</li>
<li>copy Host to pinned</li>
<li>copy pinned to Device</li>
<li>free pinned</li>
</ul></li>
</ul></li>
<li><p>如果host是页锁定内存，则：</p>
<ul>
<li>Device To Host的过程，等价于
<ul>
<li>copy Device to Host</li>
</ul></li>
<li>Host To Device的过程，等价于
<ul>
<li>copy Host to Device</li>
</ul></li>
</ul></li>
</ol></li>
</ol>
<h3 id="culnit-驱动初始化">culnit 驱动初始化</h3>
<ol type="1">
<li>cuInit的意义是，初始化驱动API，如果不执行，则所有API都将返回错误，全局执行一次即可</li>
<li>没有对应的cuDestroy，不需要释放，程序销毁自动释放</li>
</ol>
<h2 id="cuda-runtime">cuda-runtime</h2>
<h3 id="stream-流">stream-流</h3>
<ol type="1">
<li>流是一种基于context之上的任务管道抽象，一个context可以创建n个流</li>
<li>流是异步控制的主要方式</li>
<li>nullptr表示默认流，每个线程都有自己的默认流</li>
</ol>
<p>不用流：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404145003423.png" srcset="/img/loading.gif" lazyload
alt="image-20240404145003423" />
<figcaption aria-hidden="true">image-20240404145003423</figcaption>
</figure>
<p>用流：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404145019727.png" srcset="/img/loading.gif" lazyload
alt="image-20240404145019727" />
<figcaption aria-hidden="true">image-20240404145019727</figcaption>
</figure>
<ol type="1">
<li>上面的例子中，男朋友的微信消息，就是任务队列，流的一种抽象</li>
<li>女朋友发出指令后，他可以做任何事情，无需等待指令执行完毕，（指令发出的耗时也是极短的）</li>
<li>即，异步操作，执行的代码，加入流的队列后，立即返回，不耽误时间</li>
<li>女朋友发的指令被送到流中排队，男朋友根据流的队列，顺序执行</li>
<li>女朋友选择性，在需要的时候等待所有的执行结果</li>
<li>新建一个流，就是新建一个男朋友，给他发指令就是给他发微信，你可以新建很多个男朋友</li>
<li>通过cudaEvent可以选择性等待任务队列中的部分任务是否就绪</li>
</ol>
<h4 id="注意事项">注意事项</h4>
<ol type="1">
<li>要十分注意，指令发出后，流队列中储存的是指令参数，<strong>不能加入队列后立即释放参数指针</strong>，这会导致流队列执行该指令时指针失效而出错</li>
<li>应当在十分肯定流已经不需要这个指针后，才进行修改或者释放，否则会有非预期结果出现</li>
<li>举个粒子：你给钱让男朋友买西瓜，他刚到店拿好西瓜，你把转的钱撤回去了。此时你无法预知他是否会跟店家闹起来矛盾，还是屁颠的回去。如果想得到预期结果，必须得让卖西瓜结束再处理钱的事情</li>
</ol>
<h3 id="核函数">核函数</h3>
<p>核函数是cuda编程的关键，通过xxx.cu创建一个cudac程序文件，并把cu交给nvcc编译，才能识别cuda语法</p>
<ul>
<li><strong>线程(Thread)：</strong>一般通过GPU的一个核进行处理;</li>
<li><strong>线程块(Block)：</strong>由多个线程组成；各block是并行执行的，block间无法通信，也没有执行顺序。</li>
<li><strong>线程格(Grid)：</strong>由多个线程块组成。</li>
<li><strong>核函数(Kernel)：</strong>在GPU上执行的函数通常称为核函数;一般通过标识符__global__修饰，调用通过&lt;&lt;&lt;参数1,参数2&gt;&gt;&gt;，用于说明内核函数中的线程数量，以及线程是如何组织的。</li>
<li>host调用核函数：function&lt;&lt;&lt;<strong>gridDim</strong>,
<strong>blockDim</strong>, sharedMemorySize,
stream&gt;&gt;&gt;(args…);</li>
</ul>
<p>画个图直观理解一下，下图是1个线程格，里面包含了27块线程块(蓝色的格子)，每个线程块里面又包含了64个线程(绿色的格子)。线程是最小的单位了，虽然这边我画的还是立方体，但通常是看做一个点。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-f8638235a4047c36053028e0150a46c0_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4
id="threadidxblockidxblockdim和griddim">threadIdx、blockIdx、blockDim和gridDim</h4>
<p>gridDim、blockDim为维度，启动核函数后是固定的</p>
<p><code>gridDim.x</code>、<code>gridDim.y</code>、<code>gridDim.z</code>分别表示<strong>线程格</strong>各个维度的大小，所以有</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gridDim.x=3    gridDim.y=3   gridDim.z=3<br></code></pre></td></tr></table></figure>
<p><strong><code>blockDim.x</code>、<code>blockDim.y</code>、<code>blockDim.z</code>分别表示</strong>线程块<strong>中各个维度的大小，所以有</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">blockDim.x=4   blockDim.y=4  blockDim.z=4<br></code></pre></td></tr></table></figure>
<p>blockIdx、threadIdx为索引，启动核函数后，枚举每一个维度值，不同线程取值不同</p>
<p>blockIdx.x、blockIdx.y、blockIdx.z分别表示<strong>当前线程块所处的线程格的坐标位置</strong>，threadIdx.x、threadIdx.y、threadIdx.z分别表示<strong>当前线程所处的线程块的坐标位置</strong>。</p>
<p><strong>线程格里面总的线程个数N即可通过下面的公式算出</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">N = gridDim.x * gridDim.y * gridDim.z * blockDim.x * blockDim.y * blockDim.z<br></code></pre></td></tr></table></figure>
<p><strong>还有一点要注意</strong>：<strong>blocksize的最大值是1024</strong>，即<code>blockDim.x * blockDim.y * blockDim.z</code>的最大值是1024.</p>
<p>dim和index之间也是有关系的</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404203336452.png" srcset="/img/loading.gif" lazyload
alt="image-20240404203336452" />
<figcaption aria-hidden="true">image-20240404203336452</figcaption>
</figure>
<p>如果gridDim.x为n， 那么对应blockIdx.x的取值范围就是[0, n -
1],其他dim和idx的对应关系也是同理。</p>
<h4 id="线程索引的计算">线程索引的计算</h4>
<p>上面说了线程个数由下面的公式计算：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">N = gridDim.x * gridDim.y * gridDim.z * <span class="hljs-built_in">block</span>Dim.x * <span class="hljs-built_in">block</span>Dim.y * <span class="hljs-built_in">block</span>Dim.z<br></code></pre></td></tr></table></figure>
<p>那么如何计算每个线程对应的索引？对于这样的dim和index</p>
<p>口诀：<strong>左乘右加</strong></p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404204539979.png" srcset="/img/loading.gif" lazyload
alt="image-20240404204539979" />
<figcaption aria-hidden="true">image-20240404204539979</figcaption>
</figure>
<p>伪代码如下：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404204109523.png" srcset="/img/loading.gif" lazyload
alt="image-20240404204109523" />
<figcaption aria-hidden="true">image-20240404204109523</figcaption>
</figure>
<h4 id="参数">&lt;&lt;&lt;&gt;&gt;&gt;参数</h4>
<p>通常的参数是这样的，function&lt;&lt;&lt;<strong>gridDim</strong>,
<strong>blockDim</strong>, sharedMemorySize,
stream&gt;&gt;&gt;(args…);</p>
<p>&lt;&lt;&lt;&gt;&gt;&gt;至少有两个参数，因为gridDim和blockDim是必须的，而后边两个参数是可选的。gridDim和blockDim都是一个三维的向量，有三个维度x,y,z，如果在传参的时候没有传递三维向量会怎么样？</p>
<p>比如传递一个数值，那么会将其解释为x维度，而y和z维度被默认为1。同理，如果传递一个二维向量(1,
2)，那么会将其解释为x和y维度，其中x为1，y为2，而z维度被默认为1。</p>
<p>最后一个参数steam传递nullptr则表示使用默认流。</p>
<h4 id="注意事项-1">注意事项</h4>
<ol type="1">
<li>调用核函数是传值的，不能传引用，可以传递类、结构体等，核函数可以是模板</li>
<li>__global__表示为核函数，由host调用。__device__表示为设备函数，由device调用</li>
<li>__host__表示为主机函数，由host调用。__shared__表示变量为共享变量</li>
<li>host调用核函数：function&lt;&lt;&lt;<strong>gridDim</strong>,
<strong>blockDim</strong>, sharedMemorySize,
stream&gt;&gt;&gt;(args…);</li>
<li>只有__global__修饰的函数才可以用&lt;&lt;&lt;&gt;&gt;&gt;的方式调用</li>
<li>调用核函数是<strong>传值的，不能传引用</strong>，可以传递类、结构体等，核函数可以是模板</li>
<li>核函数的执行，是<strong>异步</strong>的，也就是立即返回的</li>
<li>核函数内访问<strong>线程索引</strong>主要用到threadIdx、blockIdx、blockDim、gridDim这些内置变量</li>
</ol>
<h3 id="cudagetdeviceproperties函数">cudaGetDeviceProperties函数</h3>
<p>cudaGetDeviceProperties得到的prop有很多属性，常见的有：</p>
<ul>
<li><code>totalGlobalMem</code>: 全局内存的总大小</li>
<li><code>sharedMemPerBlock</code>: 每个block的共享内存大小</li>
<li><code>regsPerBlock</code>: 每个block的寄存器数量</li>
<li><code>warpSize</code>: warp的大小</li>
<li><code>memPitch</code>: 内存中允许的最大间距字节数</li>
<li><code>maxThreadsPerBlock</code>: 每个block的最大线程数</li>
<li><code>maxThreadsDim[3]</code>: 块中每个维度的最大线程数</li>
<li><code>maxGridSize[3]</code>: 网格中每个维度的块数量</li>
<li><code>totalConstMem</code>: 可用的常量内存量</li>
</ul>
<h3 id="shared_memory共享内存">shared_memory共享内存</h3>
<p>共享内存是片上内存，更靠近计算单元，因此比globalMem速度更快，通常可以充当缓存使用</p>
<p>定义方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__shared__ <span class="hljs-type">char</span> static_shared_memory;	<span class="hljs-comment">// 静态共享变量</span><br><span class="hljs-keyword">extern</span> __shared__ <span class="hljs-type">char</span> dynamic_shared_memory[]; <span class="hljs-comment">// 动态共享变量</span><br></code></pre></td></tr></table></figure>
<p>动态共享内存需要使用extern来声明，同时静态共享变量的地址会随着定义的变量个数而随之叠加，而动态共享变量无论定义多少个，地址都一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> static_shared_memory_num_element = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 6KB</span><br>__shared__ <span class="hljs-type">char</span> static_shared_memory[static_shared_memory_num_element]; <br>__shared__ <span class="hljs-type">char</span> static_shared_memory2[<span class="hljs-number">2</span>]; <br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">demo1_kernel</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 这里大小不能设定，它的大小是由&lt;&lt;&lt;&gt;&gt;&gt;的第三个参数确定的</span><br>    <span class="hljs-comment">// 动态共享内存和静态共享内存的区别在于动态使用了extern</span><br>    <span class="hljs-keyword">extern</span> __shared__ <span class="hljs-type">char</span> dynamic_shared_memory[];      <span class="hljs-comment">// 静态共享变量和动态共享变量在kernel函数内/外定义都行，没有限制</span><br>    <span class="hljs-keyword">extern</span> __shared__ <span class="hljs-type">char</span> dynamic_shared_memory2[];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;static_shared_memory = %p\n&quot;</span>,   static_shared_memory);   <span class="hljs-comment">// 静态共享变量，定义几个地址随之叠加</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;static_shared_memory2 = %p\n&quot;</span>,  static_shared_memory2); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dynamic_shared_memory = %p\n&quot;</span>,  dynamic_shared_memory);  <span class="hljs-comment">// 动态共享变量，无论定义多少个，地址都一样</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dynamic_shared_memory2 = %p\n&quot;</span>, dynamic_shared_memory2); <br><br>    <span class="hljs-keyword">if</span>(blockIdx.x == <span class="hljs-number">0</span> &amp;&amp; threadIdx.x == <span class="hljs-number">0</span>) <span class="hljs-comment">// 第一个thread</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Run kernel.\n&quot;</span>);<br>&#125;<br><br><br>demo1_kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">nullptr</span>&gt;&gt;&gt;();<br></code></pre></td></tr></table></figure>
<p>可以看到以下输出：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404215109458.png" srcset="/img/loading.gif" lazyload
alt="image-20240404215109458" />
<figcaption aria-hidden="true">image-20240404215109458</figcaption>
</figure>
<p>可以看到，定义的两个静态共享变量的地址是不一样的，而两个动态共享变量的地址是一样的。</p>
<h4 id="指定共享内存大小">指定共享内存大小</h4>
<p>如上面代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">demo_kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">nullptr</span>&gt;&gt;&gt;(); <span class="hljs-comment">// 其中第三个参数12，是指定动态共享内存，而在函数里定义动态共享内存时候不能指定大小</span><br></code></pre></td></tr></table></figure>
<p>另外，如果配置的各类共享内存总和大于sharedMemPerBlock，则核函数执行出错，Invalid
argument</p>
<ul>
<li>不同类型的静态共享变量定义，其内存划分并不一定是连续的</li>
<li>中间会有内存对齐策略，使得第一个和第二个变量之间可能存在空隙</li>
<li>因此你的变量之间如果存在空隙，可能小于全部大小的共享内存就会报错</li>
</ul>
<h2 id="tensorrt基础">tensorRT基础</h2>
<ol type="1">
<li>TensorRT的核心在于对模型算子的优化（<strong>合并算子</strong>、利用GPU特性<strong>选择特定核函数</strong>等多种策略），通过tensorRT，能够在Nvidia系列GPU上获得最好的性能</li>
<li>因此tensorRT的模型，需要在目标GPU上<strong>实际运行</strong>的方式选择最优算法和配置</li>
<li>也因此tensorRT生成的模型只能在<strong>特定条件</strong>下运行（编译的trt版本、cuda版本、编译时的GPU型号）</li>
<li>主要知识点，是<strong>模型结构定义方式、编译过程配置、推理过程实现、插件实现、onnx理解</strong>
<ol type="1">
<li>模型结构定义方式：我现在有一个模型我怎么去告诉tensorRT（权重是多少？）</li>
<li>onnx是一个中间的结构，比如pytorch可以导出到onnx</li>
</ol></li>
</ol>
<h3 id="tensorrt优化原理">tensorRT优化原理</h3>
<p><img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225449969.png" srcset="/img/loading.gif" lazyload
alt="image-20240407225449969" />左侧是没有经过优化的网络，那么在tensorRT执行的时候发现有很多操作（左侧圆圈中的操作)可以简化。</p>
<p>tensorRT提供了C++和python接口，可以通过这些接口定义模型结构（如权重参数）</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225641869.png" srcset="/img/loading.gif" lazyload
alt="C++ tensorRT接口" />
<figcaption aria-hidden="true">C++ tensorRT接口</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225659751.png" srcset="/img/loading.gif" lazyload
alt="python tensorRT接口" />
<figcaption aria-hidden="true">python tensorRT接口</figcaption>
</figure>
<p>但是如果每次都这样那么需要修改的时候就很麻烦，而且不方便调试，因此就提出了几种高级的方式：</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225811793.png" srcset="/img/loading.gif" lazyload
alt="image-20240407225811793" />
<figcaption aria-hidden="true">image-20240407225811793</figcaption>
</figure>
<ul>
<li>UFF：tensorflow可以直接转出为UFF格式，UUF格式里边存储了该有的网络结构以及权重，tensorRT通过libnvparsers.so可以解析UFF格式，然后去调用刚才提到的C++接口去创建网络结构并设置权重，然后交给builder编译，最后得到engine</li>
<li>ONNX：同样，pytorch可以转出为onnx格式，onnx格式存储了网络结构、数据流转以及权重参数，tensorRT通过libonnxparsers.so可以解析onnx模型，然后创建每个layer，设置权重参数，然后进一步编译得到engine</li>
<li>caffe：同样如此，但是这条路用的人已经很少了。</li>
</ul>
<h3 id="常见方案">常见方案</h3>
<p>基于tensorRT的发布，又有人在之上做了工作https://github.com/wang-xinyu/tensorrtx。</p>
<p>tensorRT的api没有实现常见的模型，那么就需要每次自己去设置，所以有人在基础之上为每个模型写硬代码，并已写好了大量的常见模型代码。</p>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407230506860.png" srcset="/img/loading.gif" lazyload
alt="image-20240407230506860" />
<figcaption aria-hidden="true">image-20240407230506860</figcaption>
</figure>
<figure>
<img
src="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407230511427.png" srcset="/img/loading.gif" lazyload
alt="image-20240407230511427" />
<figcaption aria-hidden="true">image-20240407230511427</figcaption>
</figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>tensort学习记录</div>
      <div>https://gstarmin.github.io/2024/03/28/tensort学习记录/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Starmin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/22/raft%E7%AE%97%E6%B3%95/" title="raft算法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">raft算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/11/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" title="面试问题">
                        <span class="hidden-mobile">面试问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
