

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Starmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试问题 C++ C++编译生成可执行文件的顺序  预处理：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。 编译：预处理后的源代码会被编译器编译成汇编代码（Assembly code），汇编代码是与特定架构相关的低级代码。 汇编：汇编器将汇编代码转换为机器代码（Object code），这是由二进制表示的机器可执行代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题">
<meta property="og:url" content="https://gstarmin.github.io/2024/03/11/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">
<meta property="og:site_name" content="私人杂货铺">
<meta property="og:description" content="面试问题 C++ C++编译生成可执行文件的顺序  预处理：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。 编译：预处理后的源代码会被编译器编译成汇编代码（Assembly code），汇编代码是与特定架构相关的低级代码。 汇编：汇编器将汇编代码转换为机器代码（Object code），这是由二进制表示的机器可执行代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820334293.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.1.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.2.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.3.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.4.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.5.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.6.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/mempool.png">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/centralcache.png">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/pagecache.png">
<meta property="article:published_time" content="2024-03-11T08:35:54.000Z">
<meta property="article:modified_time" content="2024-03-11T08:35:54.000Z">
<meta property="article:author" content="Starmin">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg">
  
  
  
  <title>面试问题 - 私人杂货铺</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gstarmin.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Starmin</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试问题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-11 16:35" pubdate>
          2024年3月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          75k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          749 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试问题</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试问题">面试问题</h1>
<h2 id="c">C++</h2>
<h3 id="c编译生成可执行文件的顺序">C++编译生成可执行文件的顺序</h3>
<ol type="1">
<li><strong>预处理</strong>：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。</li>
<li><strong>编译</strong>：预处理后的源代码会被编译器编译成汇编代码（Assembly
code），汇编代码是与特定架构相关的低级代码。</li>
<li><strong>汇编</strong>：汇编器将汇编代码转换为机器代码（Object
code），这是由二进制表示的机器可执行代码。</li>
<li><strong>链接</strong>：在链接阶段，编译器将所有的对象文件和库文件链接在一起，生成最终的可执行文件。这个过程包括解析符号引用、符号重定位和符号表的生成等操作。</li>
<li><strong>生成可执行文件</strong>：最终，链接器生成可执行文件，该文件包含了所有必要的机器代码和元数据，可以在相应的操作系统上运行。</li>
</ol>
<h3
id="c语言指针需要注意的地方腾讯云">C语言，指针需要注意的地方（腾讯云）</h3>
<ol type="1">
<li>要避免使用未初始化的指针</li>
<li>指针赋值时一定要保证类型匹配，由于指针类型确定指针所指向对象的类型，因此初始化或赋值时必须保证类型匹配，这样才能在指针上执行相应的操作。</li>
<li>void *
类型的指针，其实这种形式只是记录了一个地址罢了，如上所说，由于不知道所指向的数据类型是什么所以不能进行相应的操作。其实void
* 指针仅仅支持几种有限的操作：
<ol type="1">
<li>与另外的指针进行比较，因为void
*类型里面就是存的一个地址，所以这点很好理解；</li>
<li>向函数传递void <em>指针或从函数返回void
</em>指针，举个例子吧，我们平时常用的库函数qsort中的比较函数cmp（个人习惯于用这个名字）中传递的两个参数就是const
void *类型的，用过的应该很熟了；</li>
<li>给另一个void * 类型的指针赋值。还是强调一下不能使用void *
指针操纵它所指向的对象。</li>
</ol></li>
<li>在为一个指针再次分配内存之前要保证它原先没有指向其他内存，防止出现内存泄漏。</li>
</ol>
<h3 id="编译链接过程了解过吗腾讯云">编译链接过程了解过吗（腾讯云）</h3>
<h3 id="多态怎样实现的腾讯云">多态怎样实现的（腾讯云）</h3>
<h3
id="字符串中变量的地址相差多少腾讯云">字符串中变量的地址相差多少（腾讯云）</h3>
<h3
id="静态存储区的变量什么时候销毁腾讯云">静态存储区的变量什么时候销毁（腾讯云）</h3>
<h3
id="类中同名对象地址相同吗腾讯云">类中同名对象地址相同吗（腾讯云）</h3>
<h3
id="类中不同类型对象地址相差多少腾讯云">类中不同类型对象地址相差多少（腾讯云）</h3>
<h3 id="listensocketaccpet函数参数">listen、socket、accpet函数参数</h3>
<h3 id="c-vector-sizecapacity-的区别如何缩容">C++ vector size/capacity
的区别，如何缩容？</h3>
<ol type="1">
<li><strong>size()</strong>：返回向量中当前存储的元素数量，即实际使用的元素个数。</li>
<li><strong>capacity()</strong>：返回向量当前分配的内存空间大小，即向量的容量。容量可以大于或等于实际存储的元素数量。</li>
</ol>
<p>如果需要手动缩减向量的容量，可以使用<code>shrink_to_fit()</code>方法。这个方法会释放多余的内存，使得向量的容量等于实际存储的元素数量。</p>
<h3 id="cpp---可执件的过程追问链接阶段的详细过程">.cpp -&gt;
可执⾏⽂件的过程，追问：链接阶段的详细过程</h3>
<ol type="1">
<li><strong>预处理阶段</strong>：
<ul>
<li>预处理器会处理源文件，包括执行宏替换、包含头文件、去除注释等操作，生成预处理后的源文件。</li>
</ul></li>
<li><strong>编译阶段</strong>：
<ul>
<li>编译器会将预处理后的源文件编译成目标文件（object
file），包括词法分析、语法分析、语义分析、优化等步骤。每个源文件对应一个目标文件。</li>
</ul></li>
<li><strong>汇编阶段</strong>：
<ul>
<li>汇编器将编译生成的目标文件转换成机器码，生成可重定位的机器代码文件。</li>
</ul></li>
<li><strong>链接阶段</strong>：
<ul>
<li>链接器将多个目标文件和库文件链接成可执行文件，包括以下步骤：
<ul>
<li><strong>符号解析（Symbol
Resolution）</strong>：链接器会将目标文件中的符号与其定义关联起来，包括函数和全局变量的定义与引用。</li>
<li><strong>地址重定位（Address
Binding）</strong>：链接器会将目标文件中的符号地址与实际内存地址关联起来，生成可执行文件中的地址映射表。</li>
<li><strong>符号合并（Symbol
Merging）</strong>：如果多个目标文件中存在相同的符号，则链接器会将这些符号合并为一个，以避免重复定义。</li>
</ul></li>
</ul></li>
<li><strong>生成可执行文件</strong>：
<ul>
<li>链接器根据符号解析、地址重定位和符号合并生成可执行文件，其中包含了所有的目标文件和库文件，并且解析了所有的符号引用。</li>
</ul></li>
</ol>
<h3 id="有哪些键值型的存储结构">有哪些键值型的存储结构</h3>
<h3 id="stl-的sort是怎么实现的">STL 的sort是怎么实现的？</h3>
<p>STL的sort算法，数据量大时采用<strong>QuickSort快排算法</strong>，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用<strong>Insertion
Sort插入排序</strong>。如果递归层次过深，还会改用<strong>HeapSort堆排序</strong>。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-8fa032e195365f77fb6b980a4ed71958_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="数据库存储为什么-b-树不-avl-树">数据库存储为什么⽤ B+ 树，不⽤
AVL 树。</h3>
<p>思路和不用B树一样，B+树方便遍历，方便范围查找，而且AVL树数据量大的时候可能会频繁旋转调整平衡。</p>
<h3 id="int-和const不同位置代表什么意思">int*
和const不同位置代表什么意思</h3>
<ul>
<li>当<code>const</code>位于指针类型前面时，如<code>const int* ptr</code>，表示指针指向的数据是常量，不能通过指针修改所指向的数据，但指针本身可以修改，即指针是可变的，但指向的数据是不可变的。</li>
<li>当<code>const</code>位于指针类型后面时，如<code>int* const ptr</code>，表示指针本身是常量，不能修改指针指向的内存地址，但指针所指向的数据可以修改。</li>
</ul>
<h3 id="为什么栈的速度比堆快">为什么栈的速度比堆快</h3>
<p>栈是操作系统提供的数据结构，计算机底层对他提供了一系列的支持：分配专门的寄存器存储寄存器地址，压栈和出栈都有相应的指令；
而堆是C/C++库函数提供的，机制复杂，需要一些分配内存，合并内存，释放内存的算法，所以效率低。</p>
<h3 id="detach和join有什么区别">detach和join有什么区别</h3>
<p><code>detach()</code>方法将一个线程从原始线程中分离出来，使其独立运行；而<code>join()</code>方法用于等待一个线程执行完毕后再继续执行原始线程。</p>
<h3 id="c有哪些锁">C++有哪些锁</h3>
<p>线程之间的锁有：
<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong>。一般而言，锁的功能与性能成反比。</p>
<h4 id="互斥锁mutex">互斥锁（Mutex）</h4>
<p>互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。</p>
<h5 id="mutex">mutex</h5>
<p>对于 <code>std::mutex</code>
对象，任意时刻最多允许一个线程对其进行上锁</p>
<ul>
<li>mtx.lock()：调用该函数的线程尝试加锁。如果上锁不成功，即：其它线程已经上锁且未释放，则当前线程<code>block</code>。如果上锁成功，则执行后面的操作，操作完成后要调用
<code>mtx.unlock()</code> 释放锁，否则会导致死锁的产生</li>
<li>mtx.unlock()：释放锁，<code>std::mutex</code>
还有一个操作：<code>mtx.try_lock()</code>，字面意思就是：“尝试上锁”，与
<code>mtx.lock()</code>
的不同点在于：如果上锁不成功，当前线程不阻塞。</li>
</ul>
<h5 id="lock_guard">lock_guard</h5>
<p>虽然 <code>std::mutex</code>
可以对多线程编程中的共享变量提供保护，但是直接使用
<code>std::mutex</code> 的情况并不多。因为仅使用 <code>std::mutex</code>
有时候会发生死锁。</p>
<p>考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2“永久的等待下去”，此时就发生了死锁。</p>
<p><code>std::lock_guard</code>
只有构造函数和析构函数。简单的来说：当调用构造函数时，会自动调用传入的对象的lock()函数，而当调用析构函数时，自动调用
<code>unlock()</code> 函数（这就是所谓的RAII）。</p>
<p><code>lock_guard</code> 还有一个构造函数
<code>lock_guard( mutex_type&amp; m, std::adopt_lock_t t );</code>
其中第二个参数类型为：<code>std::adopt_lock_t</code>。<strong>这个构造函数假定：当前线程已经上锁成功，所以不再调用lock()函数</strong>。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用互斥元保护列表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br> <br>std::list&lt;<span class="hljs-type">int</span>&gt; some_list;<br>std::mutex some_mutex;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_list</span><span class="hljs-params">(<span class="hljs-type">int</span> new_value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(some_mutex)</span></span>;<br>    some_list.<span class="hljs-built_in">push_back</span>(new_value);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="条件锁">条件锁</h4>
<p>当需要死循环判断某个条件成立与否时【true or
false】，我们往往需要开一个线程死循环来判断，这样<strong>非常消耗CPU</strong>。使用条件变量，可以让当前线程
<code>wait</code>，释放CPU，如果条件改变时，我们再<code>notify</code>退出线程，再次进行判断。</p>
<p>条件锁就是所谓的条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程(常和互斥锁配合使用)，唤醒后，需要检查变量，避免虚假唤醒。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<p><strong>c++用法</strong>：</p>
<p>任意要等待 <code>std::condition_variable</code> 的线程必须获取
<code>std::unique_lock&lt;std::mutex&gt;</code>，这个 <code>mutex</code>
正是用来保护共享变量（即“条件”）的。执行 <code>wait</code> ,
<code>wait_for</code> 或者
<code>wait_until</code>。这些等待动作原子性地释放
<code>mutex</code>，并使得线程的执行暂停。</p>
<p>当前线程调用 <code>wait()</code>
后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁
lck)，直到另外某个线程调用 <code>notify_*</code> 唤醒了当前线程。</p>
<p>在线程被阻塞时，该函数会自动调用 <code>lck.unlock()</code>
释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知<code>(notified</code>，通常是另外某个线程调用
<code>notify_*</code> 唤醒了当前线程)，wait() 函数也是自动调用
lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>std::mutex mu;<br>std::condition_variable cond;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span> <span class="hljs-comment">//生产者</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>        q.<span class="hljs-built_in">push_front</span>(count);<br>        locker.<span class="hljs-built_in">unlock</span>();<br>        cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// Notify one waiting thread, if there is one.</span><br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>        count--;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span> <span class="hljs-comment">//消费者</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">empty</span>())<br>            cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// Unlock mu and wait to be notified</span><br>        data = q.<span class="hljs-built_in">back</span>();<br>        q.<span class="hljs-built_in">pop_back</span>();<br>        locker.<span class="hljs-built_in">unlock</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(function_1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(function_2)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="自旋锁">自旋锁</h4>
<p>假设我们有一个两个处理器<code>core1</code>和<code>core2</code>计算机，现在在这台计算机上运行的程序中有两个线程：<code>T1</code>和<code>T2</code>分别在处理器<code>core1</code>和<code>core2</code>上运行，两个线程之间共享着一个资源。</p>
<p>首先我们说明互斥锁的工作原理，互斥锁是是一种
<code>sleep-waiting</code>
的锁。假设线程<code>T1</code>获取互斥锁并且正在<code>core1</code>上运行时，此时线程<code>T2</code>也想要获取互斥锁（pthread_mutex_lock），但是由于<code>T1</code>正在使用互斥锁使得<code>T2</code>被阻塞。当<code>T2</code>处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器<code>core2</code>会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p>而自旋锁就不同了，自旋锁是一种 <code>busy-waiting</code>
的锁。也就是说，如果<code>T1</code>正在使用自旋锁，而<code>T2</code>也去申请这个自旋锁，此时<code>T2</code>肯定得不到这个自旋锁。与互斥锁相反的是，此时运行<code>T2</code>的处理器<code>core2</code>会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。</p>
<p>当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。
通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用户空间用 atomic_flag 实现自旋互斥</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br> <br>std::atomic_flag lock = ATOMIC_FLAG_INIT;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; cnt &lt; <span class="hljs-number">100</span>; ++cnt) &#123;<br>        <span class="hljs-keyword">while</span> (lock.<span class="hljs-built_in">test_and_set</span>(std::memory_order_acquire))  <span class="hljs-comment">// 获得锁</span><br>             ; <span class="hljs-comment">// 自旋</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        lock.<span class="hljs-built_in">clear</span>(std::memory_order_release);               <span class="hljs-comment">// 释放锁</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;std::thread&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">10</span>; ++n) &#123;<br>        v.<span class="hljs-built_in">emplace_back</span>(f, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : v) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>atomic</code> 是C标准程序库中的一个头文件，定义了 C11
标准中的一些表示线程、并发控制时原子操作的类与方法等。此头文件主要声明了两大类原子对象：<code>std::atomic</code>和<code>std::atomic_flag</code>。</p>
<ul>
<li><p><code>atomic_flag</code> 类</p>
<p>是一种简单的原子布尔类型，只支持两种操作：<code>test_and_set(flag=true)</code>
和 <code>clear(flag=false)</code>。</p></li>
<li><p><code>std::atomic</code> 类模板</p></li>
<li><p><code>std::atomic</code>
既不可复制亦不可移动。<code>atomic</code> 对
<code>int</code>、<code>char</code>、<code>bool</code>
等数据结构进行了原子性封装，在多线程环境中，对 <code>std::atomic</code>
对象的访问不会造成竞争-冒险。利用 <code>std::atomic</code>
可实现数据结构的无锁设计。</p></li>
</ul>
<p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。<strong>使用原子操作能大大的提高程序的运行效率</strong>。</p>
<h4 id="读写锁">读写锁</h4>
<p>先看互斥锁，它只有两个状态，要么是加锁状态，要么是不加锁状态。假如现在一个线程
<code>a</code> 只是想读一个共享变量
<code>i</code>，因为不确定是否会有线程去写它，所以我们还是要对它进行加锁。但是这时又有一个线程<code>b</code>试图去读共享变量
<code>i</code>，发现被锁定了，那么<code>b</code>不得不等到<code>a</code>释放了锁后才能获得锁并读取
<code>i</code>
的值，但是两个读取操作即使是同时发生的，也并不会像写操作那样造成竞争，因为它们不修改变量的值。所以我们期望在多个线程试图读取共享变量的时候，它们可以立刻获取因为读而加的锁，而不是需要等待前一个线程释放。</p>
<p>读写锁可以解决上面的问题。它提供了比互斥锁更好的并行性。因为以读模式加锁后，当有多个线程试图再以读模式加锁时，并不会造成这些线程阻塞在等待锁的释放上。</p>
<p>读写锁是多线程同步的另外一个机制。在一些程序中存在读操作和写操作问题，对某些资源的访问会存在两种可能情况，一种情况是访问必须是排他的，就是独占的意思，这种操作称作<strong>写操作</strong>，另外一种情况是访问方式是可以共享的，就是可以有多个线程同时去访问某个资源，这种操作称为<strong>读操作</strong>。这个问题模型是从对文件的读写操作中引申出来的。把对资源的访问细分为读和写两种操作模式，这样可以大大增加并发效率。读写锁比互斥锁适用性更高，并行性也更高。</p>
<p>需要注意的是，这里只是说<strong>并行效率比互斥高，并不是速度一定比互斥锁快，读写锁更复杂，系统开销更大</strong>。并发性好对于用户体验非常重要，假设互斥锁需要0.5秒，使用读写锁需要0.8秒，在类似学生管理系统的软件中，可能90%的操作都是查询操作。如果突然有20个查询请求，使用的是互斥锁，则最后的查询请求被满足需要10秒，估计没人能接受。使用读写锁时，因为读锁能多次获得，所以20个请求中，每个请求都能在1秒左右被满足，用户体验好的多。</p>
<p><strong>特点</strong>：</p>
<ol type="1">
<li>如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样可以有多个线程并行操作。这个时候如果再用写锁加锁就会发生阻塞。写锁请求阻塞后，后面继续有读锁来请求时，这些后来的读锁都将会被阻塞。这样避免读锁长期占有资源，防止写锁饥饿。</li>
<li>如果一个线程用写锁锁住了临界区，那么其他线程无论是读锁还是写锁都会发生阻塞。</li>
</ol>
<p><strong>c++用法</strong>：</p>
<p>STL本身并没有提供读写锁（Read-Write
Lock）的实现。Boost中的<code>boost::shared_mutex</code>和<code>unique_lock</code>提供了读写锁的实现，可以用于实现多读单写的并发控制。</p>
<p>简单的说：</p>
<ol type="1">
<li><code>shared_lock</code> 是
<code>read_lock</code>。被锁后仍允许其他线程执行同样被
<code>shared_lock</code> 的代码。这是一般做读操作时的需要。</li>
<li><code>unique_lock</code> 是
<code>write_lock</code>。被锁后不允许其他线程执行被
<code>shared_lock</code> 或 <code>unique_lock</code>
的代码。在写操作时，一般用这个，可以同时限制 <code>unique_lock</code>
的写和 <code>share_lock</code> 的读。</li>
</ol>
<p>注：C++ 11
中提供了<code>unique_lock</code>且功能和用法与<code>boost::unique_lock</code>一直，但是C++
11并没有提供<code>shared_lock</code></p>
<h4 id="递归锁">递归锁</h4>
<p><code>std::recursive_mutex</code> 与 <code>std::mutex</code>
一样，也是一种可以被上锁的对象，但是和 <code>std::mutex</code>
不同的是，<code>std::recursive_mutex</code>
允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，<code>std::recursive_mutex</code>
释放互斥量时需要调用与该锁层次深度相同次数的
<code>unlock()</code>，可理解为 <code>lock()</code> 次数和
<code>unlock()</code>
次数相同，除此之外，<code>std::recursive_mutex</code> 的特性和
<code>std::mutex</code> 大致相同。</p>
<p>例如函数 <code>a</code> 需要获取锁 <code>mutex</code>，函数
<code>b</code> 也需要获取锁 <code>mutex</code>，同时函数 <code>a</code>
中还会调用函数 <code>b</code>。如果使用<code>std::mutex</code>
必然会造成死锁。但是使用 <code>std::recursive_mutex</code>
就可以解决这个问题。</p>
<p>参考<a
target="_blank" rel="noopener" href="https://www.zywvvd.com/notes/coding/cpp/cpp-lock/cpp-lock/#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89">C++
多线程 —— 锁</a></p>
<h3 id="了解哪些c-11-的新特性">了解哪些C++ 11 的新特性</h3>
<ol type="1">
<li><strong>自动类型推断（auto）</strong>:可以使用<code>auto</code>关键字来声明变量，让编译器根据初始化表达式的类型推断变量的类型。</li>
<li><strong>范围-based for
循环</strong>：使用<code>for</code>循环可以遍历容器中的元素，语法更简洁直观。</li>
<li><strong>nullptr</strong>:引入了空指针常量<code>nullptr</code>，用于表示空指针。</li>
<li><strong>Lambda
表达式</strong>:可以使用Lambda表达式来创建匿名函数，使得在函数式编程风格中更方便地使用。</li>
<li><strong>移动语义和右值引用</strong>：引入了右值引用和移动语义，可以通过移动而不是复制来提高程序的性能。</li>
<li><strong>智能指针</strong>：引入了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>等智能指针，用于管理动态分配的内存，避免内存泄漏和悬空指针问题。</li>
<li><strong>初始化列表</strong>：引入了初始化列表语法，可以通过<code>&#123;&#125;</code>来初始化数组、容器、结构体等。</li>
</ol>
<h3 id="weakptr如何获得sharedptr">weakPtr如何获得sharedPtr</h3>
<p><code>weak_ptr</code>对象不能直接被用于获取指向的对象，因为其不拥有所指向对象的所有权。但是可以通过<code>weak_ptr</code>对象的<code>lock()</code>成员函数获得一个指向所指对象的<code>shared_ptr</code>对象，前提是该对象还存在。</p>
<h3 id="右值引用的用途">右值引用的用途</h3>
<p><strong>移动语义（Move Semantics）</strong>：
右值引用使得移动语义成为可能。传统的复制操作会对资源进行深拷贝，而移动语义则允许将资源从一个对象“移动”到另一个对象，而不是进行昂贵的深拷贝操作。这在动态内存管理、容器类的元素操作以及返回临时对象等场景下都有很大的性能提升。</p>
<p><strong>完美转发（Perfect Forwarding）</strong>：
右值引用可以在函数模板中实现完美转发，即<strong>保持原始参数类型的引用类型</strong>。这使得函数模板可以将参数完全转发给其他函数，而不会对参数类型造成额外的包装或变化，保持了原始参数的准确性。</p>
<h3 id="函数重载底层原理">函数重载底层原理</h3>
<p>首先C语言不支持函数重载，程序在预编译阶段会经历预<strong>处理、编译、汇编和链接生成可执行程序</strong>的过程，在汇编过程中编译器会收集<strong>全局符号</strong>并生成全局符号表（将符号和其相应地址一一对应的表格称为符号表）。C语言不支持函数重载的原因是符号表中的出现了两个具有有效地址的函数名，所以发生了冲突。</p>
<p><strong>C++对写入符号表的函数具有一个修正的过程</strong>，Linux下的命名规则做如下总结：</p>
<blockquote>
<p>**_Z + 函数名长度 + 函数名 + 类型首字母的小写**</p>
</blockquote>
<h3 id="c-编译器都做了哪些优化">C++ 编译器都做了哪些优化？</h3>
<ul>
<li>常量折叠（constant
folding）。编译器将编译期能计算为常量的表达式直接替换为计算结果。</li>
<li>常量传播（constant
propagation）。编译器追踪到一个值的源头，发现它是常量后，会将所有地方出现的这个值替换为常量。</li>
<li>公共子表达式消除（common subexpression
elimination）。将重复的计算过程重写掉，只算一次，其它地方复制结果。</li>
<li>移除死代码（dead code
removal）。用许多其它方法优化后，可能有些代码对输出不产生影响，就可以移除这些代码。这里包含了对没用到的值的读写操作，以及完全没用到的整个函数或表达式。</li>
<li>指令选择（instruction
selection）。这个不算是通常意义的优化，但既然编译器会将程序转换为它的内部表示形式，并生成CPU指令，编译器通常有一个庞大的等效指令序列的集合可供选择。编译需要知道目标处理器架构的细节以作出正确选择。</li>
<li>移动循环中的不变代码（loop invariant code
movement）。编译器能识别一块代码在循环过程中值不变，并将这块代码移出循环。其于此，编译器还能将循环中不变的条件检查移出循环外，再将循环体复制两次：一次针对条件为真，一次针对条件为假。之后还能做进一步优化。</li>
<li>窥孔优化（peephole
optimization）。编译器取一小段指令序列并做局部优化。</li>
<li>尾调用移除（tail call
removal）。一个在结尾处调用自身的递归函数通常可被重写为循环，从而降低函数调用开销，并减小栈溢出的可能。</li>
</ul>
<h3 id="大端小端">大端小端</h3>
<h3 id="大端模式与小端模式">大端模式与小端模式</h3>
<ol type="1">
<li>大端模式是指<strong>数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中</strong>.</li>
<li>小端模式是指<strong>数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中</strong>。</li>
</ol>
<p>例如：</p>
<p>一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122。那么0x11为数据高字节，0x22为数据低字节。</p>
<ol type="1">
<li>对于大端模式，就将0x11放在内存低地址中，即0x0010中；0x22放在内存高地址中，即0x0011中。</li>
<li>小端模式，就将0x11放在内存高地址中，即0x0011中；0x22放在内存低地址中，即0x0010中。</li>
</ol>
<p>怎么判断大端小端？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLittleEndian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 将整数强制转换为字符指针，然后检查第一个字节的值</span><br>    <span class="hljs-comment">// 如果是小端序，最低有效字节会被存储在低地址处</span><br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">char</span> *)&amp;num == <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLittleEndian</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This system is Little Endian.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This system is Big Endian.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如何让哈希表按插入的顺序有序">如何让哈希表按插入的顺序有序</h3>
<p>设置一个哈希表和一个双向链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; umap;<br>list&lt;<span class="hljs-type">int</span>&gt; l;<br></code></pre></td></tr></table></figure>
<p>取值可以使用<code>umap[key]-&gt;val</code>做到<code>O(1)</code>,同时<code>l</code>中也按照插入顺序有序。</p>
<h3
id="make_shared与直接创建shared_ptr的区别">make_shared与直接创建shared_ptr的区别</h3>
<p>make_shared 只需要分配一次内存，而直接创建 shared_ptr
需要分配两次内存。</p>
<p>make_shared也存在缺陷，只有当 _Weaks 为 0 时，控制块才会调用
_Delete_this() 释放自己，weak_ptr会拖延整块内存释放时间。</p>
<h3
id="dynamic_cast把父类指针转为void会怎么样">dynamic_cast把父类指针转为void*会怎么样</h3>
<p>在C++中，<code>dynamic_cast</code>
用于在运行时进行安全的类型转换，通常用于将基类指针或引用转换为派生类指针或引用。如果将父类指针转换为
<code>void*</code>，会丢失类型信息，因此无法在后续代码中准确地确定其类型。具体表现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::foo()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived derivedObj;<br>    Base* basePtr = &amp;derivedObj;<br><br>    <span class="hljs-comment">// 将父类指针转换为 void*</span><br>    <span class="hljs-type">void</span>* voidPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(basePtr);<br><br>    <span class="hljs-comment">// 尝试将 void* 转换回父类指针</span><br>    Base* newBasePtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Base*&gt;(voidPtr); <span class="hljs-comment">// 非法，无法使用 dynamic_cast 将 void* 转换回指针类型</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述示例中，<code>dynamic_cast</code> 无法将 <code>void*</code>
转换回指针类型，因为在将 <code>Base*</code> 转换为 <code>void*</code>
时，类型信息已经丢失。因此，将父类指针转换为 <code>void*</code>
后，再转换回去是不可行的。通常情况下，不建议将指针转换为
<code>void*</code>，除非有特殊的需求。如果你需要从<code>void*</code>转换回具体的类类型指针，应该使用<code>static_cast</code>或<code>reinterpret_cast</code>，但这需要你确保转换的安全性。</p>
<h3
id="什么样的数据类型需要关注大小端字节序">什么样的数据类型需要关注大小端字节序？</h3>
<p>只有超过一个字节的基本数据类型才需要考虑字节序</p>
<h3
id="free释放内存的时候是怎么知道释放内存的大小的">free释放内存的时候是怎么知道释放内存的大小的？</h3>
<p>glibc:<strong>空间的大小记录在参数指针指向地址的前面，free的时候通过这个记录即可知道要释放的内存有多大。</strong></p>
<h3
id="utf-8知道吗了解utf-8与gbk有什么不一样吗">utf-8知道吗？了解utf-8与gbk有什么不一样吗？</h3>
<ul>
<li><strong>ASCII</strong>：ASCII
只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII
编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</li>
<li><strong>Unicode</strong>：由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常<strong>两个字节表示一个字符</strong>，而<strong>ASCII是一个字节表示一个字符</strong>，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</li>
<li><strong>UTF-8</strong>：为了解决上述问题，又出现了把Unicode编码转化为“<strong>可变长编码</strong>”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6个字节</strong>，<strong>英文字母被编码成一个字节，常用汉字被编码成三个字节</strong>，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</li>
<li>UTF-8是一种Unicode字符集的变长字符编码方式，支持包括英文、拉丁文、中文、日文、韩文等在内的几乎所有字符。</li>
<li>GBK是一种针对汉字的字符编码方式，它是在GB2312字符集的基础上扩展而来，支持汉字和一些常用的符号、数字等。</li>
</ul>
<h3
id="static局部变量与普通局部变量区别">static局部变量与普通局部变量区别？</h3>
<ul>
<li>static局部变量只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在。普通局部变量，只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li>
<li>静态局部变量在静态存储区分配空间，局部变量在栈里分配空间。</li>
</ul>
<h3
id="socket写过吗tcp三次握手发生在哪个函数">socket写过吗？tcp三次握手发生在哪个函数？</h3>
<ul>
<li>客户端调用connect()函数，此时客户端会向服务端发送SYN</li>
<li>服务端收到SYN后，会从listen()函数返回SYN+ACK</li>
<li>客户端收到connect()函数的返回，之后向服务端发送最后一个ACK</li>
<li>服务端收到最后一个ACK以后，将该连接请求从未完成连接队列放入已完成连接队列中，等待accept()从该队列中取出</li>
</ul>
<h3 id="内存对齐的好处坏处">内存对齐的好处/坏处</h3>
<h3 id="c浮点数存储方式">C++浮点数存储方式</h3>
<h4 id="float大小为4字节即32位">float：大小为4字节，即32位</h4>
<ol type="1">
<li>最高位 31 位 ,保存符号位 S，“0”表示正数 ,“1”表示负数</li>
<li>第30 位～23 位 ,共 8 位 ,保存指数部分(指数值加上偏移量127)
,称为阶码</li>
<li>第22 位～0 位 ,共 23 位 ,保存系数部分
（整数位的1不保存），称为尾数</li>
</ol>
<h4 id="double大小为8字节即64位">double：大小为8字节，即64位</h4>
<ol type="1">
<li>最高位 63 位 ,保存符号位 S，“0”表示正数 ,“1”表示负数</li>
<li>第 62 位～52 位 ,共 11 位 ,保存指数部分(指数值加上偏移量1023)
,称为阶码</li>
<li>第 51 位～0 位 ,共 52 位 ,保存系数部分
（整数位的1不保存），称为尾数</li>
</ol>
<h3
id="动态链接库和静态链接库的区别都是有多份拷贝吗">动态链接库和静态链接库的区别？都是有多份拷贝吗？</h3>
<p><strong>静态链接库用来和所有的目标文件一起组织成可执行文件，生成的可执行文件可以独立运行</strong>。存在诸多缺点：</p>
<ul>
<li>首先，<strong>可执行文件内部拷贝了所有目标文件和静态链接库的指令和数据，文件本身的体积会很大</strong>。当<strong>系统中存在多个链接同一个静态库的可执行文件时</strong>，<strong>每个可执行文件中都存有一份静态库的指令和数据</strong>，就会造成内存空间的极大浪费。</li>
<li>此外，<strong>一旦程序中有模块更新，整个程序就必须重新链接后才能运行</strong>。假设一个程序有
20 个模块构成，每个模块的大小为 1
MB，那么每次更新任何一个模块，用户就必须重新获取 20 MB
的程序，<strong>对用户很不友好</strong>。</li>
</ul>
<p><strong>动态链接，指的是将链接的时机推迟到程序运行时再进行</strong>。具体来讲，<strong>对于一个以动态链接方式运行的项目，</strong>：</p>
<ul>
<li><strong>首先由静态链接器将所有的目标文件组织成一个可执行文件</strong></li>
<li><strong>运行时将所需的动态链接库全部载入内存，由动态链接器完成可执行文件和动态库文件的链接工作</strong>。</li>
</ul>
<p>和静态链接库相比，动态链接库可以很好地<strong>解决空间浪费</strong>和<strong>更新困难的问题</strong>。</p>
<ul>
<li>动态链接库和可执行文件是分别载入内存的，因此动态链接库的体积通常会小一些。<strong>当有多个程序使用同一个动态链接库时，所有程序可以共享一份动态链接库的指令和数据，避免了空间的浪费</strong>。</li>
<li>采用动态链接的方式<strong>也可以方便程序的更新和升级</strong>，当程序的某个模块更新后，只需要将旧的模块替换掉，程序运行时会自动将所有模板载入内存并动态地链接在一起。</li>
</ul>
<h3 id="动态绑定和静态绑定">动态绑定和静态绑定</h3>
<p>说起静态绑定和动态绑定，我们⾸先要知道<strong>静态类型和动态类型</strong>，静态类型就是它在程序中被声明时所采用的类型，在编译期间确定。动态类型则是指“目前所指对象的实际类型”，在运行期间确定。</p>
<p><strong>静态绑定</strong>，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期间。</p>
<p><strong>动态绑定</strong>，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发生在运行期间。</p>
<p>⽐如说，virtual
函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意，我们<strong>不应该重新定义继承而来的缺省参数，因为即使我们重定义了，也不会起到效果</strong>。因为一个基类的指针指向一个派生类对象，在派生类的对象中针对虚函数的参数缺省值进行了重定义，
但是<strong>缺省参数值是静态绑定的</strong>，静态绑定绑定的是静态类型相关的内容，所以会出现一种派生类的虚函数实现方式结合了基类的缺省参数值的调用效果，这个与所期望的效果不同。</p>
<h3 id="虚函数的额外开销">虚函数的额外开销</h3>
<ol type="1">
<li>空间开销
首先，由于需要为每一个包含虚函数的类生成一个虚函数表，所以程序的二进制文件大小会相应的增大；其次，对于包含虚函数的类的实例来说，每个实例都包含一个虚函数表指针用于指向对应的虚函数表，所以每个实例的空间占用都增加一个指针大小（32位系统4字节，64位系统8字节）。这些空间开销可能会造成缓存的不友好，在一定程度上影响程序性能。</li>
<li>时间开销
虚函数的时间开销主要是增加了一次内存寻址，通过虚函数表指针找到虚函数表，虽对程序性能有一些影响，但是影响并不大。</li>
</ol>
<p>上述虚函数表面上的开销其实是<strong>微不足道</strong>的，真正影响虚函数性能的是隐藏在背后的,关键点在于<strong>分支预测器</strong>,对于直接调用而言，是不存在分支跳转的，因为跳转地址是编译器确定的，CPU直接去跳转地址取后面的指令即可，不存在分支预测，这样可以保证CPU流水线不被打断。而对于间接寻址，由于跳转地址不确定，所以此处会有多个分支可能，这个时候需要分支预测器进行预测，如果分支预测失败，则会导致流水线冲刷，重新进行取指、译码等操作，对程序性能有很大的影响。</p>
<h3 id="如何避免虚函数额外开销">如何避免虚函数额外开销</h3>
<p>使用模板泛型编程,但是这样会导致代码膨胀.</p>
<h3 id="new-operator和operator-new的区别">New operator和operator
new的区别</h3>
<h4 id="operator-new">operator new</h4>
<p>operate new 是一个分配原始内存的函数——至少在概念上，它与 malloc()
没有太大区别。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure>
<p>它的函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<p>当然，重载operator new（全局或类），还需要/需要重载匹配的operator
delete。</p>
<h4 id="new-operator">new operator</h4>
<p>new operate通常用于创建对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">my_class *x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">my_class</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<p>两者的区别在于 operator new 只分配原始内存，没有别的。new
operator首先使用 operator new
分配内存，然后它调用正确类型的对象的构造函数，因此结果是在该内存中创建的真实活动对象。如果该对象包含任何其他对象（嵌入的或作为基类），则这些构造函数也会被调用。</p>
<p>new operator：它先调用operator
new分配内存，然后调用构造函数初始化那段内存。</p>
<p>operator new：可以重载，用于实现不同的内存分配行为。</p>
<h3 id="c的exception机制底层原理">C++的exception机制底层原理</h3>
<p>原理见<a
target="_blank" rel="noopener" href="https://baiy.cn/doc/cpp/inside_exception.htm">C++异常机制的实现方式和开销分析</a>。</p>
<p>主要是在栈框架中添加了一些东西：</p>
<ul>
<li>piPrev
成员指向链表的上一个节点，它主要用于在函数调用栈中逐级向上寻找匹配的
catch 块，并完成<strong>栈回退</strong>工作。</li>
<li>piHandler
成员指向完成异常捕获和栈回退所必须的数据结构（主要是两张记载着关键数据的表：“try”块表：tblTryBlocks
及“栈回退表”：tblUnwind）。</li>
<li>nStep 成员用来定位 try 块，以及在栈回退表中寻找正确的入口。</li>
</ul>
<h3 id="c有哪些可重入锁">C++有哪些可重入锁</h3>
<p>std::recursive_mutex，同一个线程可以多次对std::recursive_mutex进行加锁。</p>
<h3 id="智能指针是线程安全的吗">智能指针是线程安全的吗</h3>
<p>总结:不是</p>
<p>情况一：多线程代码操作的是同一个shared_ptr的对象,这时候不是线程安全的;</p>
<p>情况二：多线程代码操作的不是同一个shared_ptr的对象,这时候是线程安全的.但是这只是说对shared_ptr对象来说是线程安全的,但是这并不意味着shared_ptr所管理的对象是线程安全的.</p>
<h3 id="c与c指针的区别">C与C++指针的区别</h3>
<p>C++和C语言对空指针的定义不同,c++11引入了nullptr</p>
<h2 id="linux">Linux</h2>
<h2
id="linux系统查看cpu占用的命令腾讯云">linux系统查看cpu占用的命令（腾讯云）</h2>
<ol type="1">
<li><p>top命令可以看到总体的系统运行状态和cpu的使用率</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>top -u root<br></code></pre></td></tr></table></figure></p></li>
<li><p>htop命令是top命令的增强版(默认情况htop没有安装在linux上，所以要先安装)</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">htop<br></code></pre></td></tr></table></figure></p></li>
<li><p>使用ps命令来查看cpu使用率</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps aux | sort -nrk 3,3 | head -n 5<br></code></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="gdb如何调试">gdb如何调试</h3>
<ol type="1">
<li><p><strong>编译程序时加上调试信息</strong>：
在使用GDB进行调试之前，需要确保编译程序时包含调试信息。通常可以通过在编译命令中添加<code>-g</code>选项来生成调试信息，例如：</p>
<p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -g -o my_program my_program.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>启动GDB</strong>：
在命令行中输入<code>gdb</code>命令，然后在GDB提示符下输入要调试的可执行文件的名称，例如：</p>
<p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb my_program</span><br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>设置断点</strong>：
在GDB中设置断点，以便在程序执行到指定位置时停止执行。可以通过以下命令设置断点：</p>
<ul>
<li><code>break function_name</code>：在指定函数的入口处设置断点。</li>
<li><code>break line_number</code>：在指定行号处设置断点。</li>
<li><code>break file_name:line_number</code>：在指定文件的指定行号处设置断点。</li>
</ul></li>
</ol>
<h3
id="gdb运行报错如何通过core件找到错误">gdb运行报错如何通过core⽂件找到错误</h3>
<ol type="1">
<li><p><strong>编译程序时包含调试信息</strong>：
在编译程序时确保包含了调试信息，以便在后续调试时能够查看到源代码的信息。使用编译器选项<code>-g</code>来生成调试信息。</p></li>
<li><p><strong>使用GDB调试core文件</strong>：
在命令行中输入以下命令：</p></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb &lt;executable_file&gt; &lt;core_file&gt;<br></code></pre></td></tr></table></figure>
<p>其中，<code>&lt;executable_file&gt;</code>是你编译的可执行文件的名称，<code>&lt;core_file&gt;</code>是core文件的名称。</p>
<p><strong>分析core文件</strong>：
在GDB中加载core文件后，可以使用<code>bt</code>命令查看堆栈回溯信息，以确定程序崩溃时的函数调用栈。例如：</p>
<ol start="3" type="1">
<li><strong>分析core文件</strong>：
在GDB中加载core文件后，可以使用<code>bt</code>命令查看堆栈回溯信息，以确定程序崩溃时的函数调用栈。例如：</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> bt<br></code></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>查看变量值</strong>：
在确定了程序崩溃的位置后，可以使用GDB中的命令查看局部变量、全局变量等的值，以帮助分析错误。例如：</li>
</ol>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">(gdb) p <span class="hljs-keyword">variable</span><span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure>
<ol start="5" type="1">
<li><strong>分析源代码</strong>：
使用GDB中的命令在源代码中查看程序崩溃的位置以及附近的代码，帮助理解问题所在。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) list<br></code></pre></td></tr></table></figure>
<h3 id="如何加断点具体api调">如何加断点，具体api调⽤</h3>
<p>使用break命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break example.c:20<br></code></pre></td></tr></table></figure>
<p>调用api不会</p>
<h3 id="gdb如何查看函数调用栈">gdb如何查看函数调用栈</h3>
<ol type="1">
<li><p>在终端中启动 GDB 并加载你的可执行文件：</p>
<p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb your_executable</span><br></code></pre></td></tr></table></figure></p></li>
<li><p>运行程序，直到你想要查看函数调用栈的地方。</p></li>
<li><p>在 GDB 提示符下，输入 <code>bt</code> 或 <code>backtrace</code>
命令：</p>
<p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> bt<br></code></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="epoll函数参数">epoll函数参数</h3>
<p>在使用 Linux 中的 epoll API 进行事件驱动编程时，主要使用的函数是
<code>epoll_create</code>、<code>epoll_ctl</code> 和
<code>epoll_wait</code>。下面是它们的基本参数：</p>
<ol type="1">
<li><strong>epoll_create(int size)：</strong>
<ul>
<li><code>size</code>：指定需要监听的文件描述符的数量的估计值。这个参数在
epoll
实例被内核创建时用于分配内部数据结构的大小。通常情况下，你可以将其设置为大于
0 的任意值，因为内核会根据需要调整大小。但是，对于 Linux 2.6.8
及更早版本的内核，这个参数被忽略，可以设置为任意值。</li>
</ul></li>
<li><strong>epoll_ctl(int epfd, int op, int fd, struct epoll_event
*event)：</strong>
<ul>
<li><code>epfd</code>：epoll 实例的文件描述符，由
<code>epoll_create</code> 返回。</li>
<li><code>op</code>：表示要执行的操作，可以是以下值之一：
<ul>
<li><code>EPOLL_CTL_ADD</code>：向 epoll
实例中添加一个要监听的文件描述符。</li>
<li><code>EPOLL_CTL_MOD</code>：修改 epoll
实例中某个文件描述符的监听事件。</li>
<li><code>EPOLL_CTL_DEL</code>：从 epoll
实例中删除一个不再需要监听的文件描述符。</li>
</ul></li>
<li><code>fd</code>：要添加、修改或删除的文件描述符。</li>
<li><code>event</code>：指向 <code>struct epoll_event</code>
结构的指针，描述了要监听的事件类型。</li>
</ul></li>
<li><strong>epoll_wait(int epfd, struct epoll_event *events, int
maxevents, int timeout)：</strong>
<ul>
<li><code>epfd</code>：epoll 实例的文件描述符，由
<code>epoll_create</code> 返回。</li>
<li><code>events</code>：用于存储发生事件的文件描述符和事件类型的数组。</li>
<li><code>maxevents</code>：<code>events</code>
数组的大小，表示最多可以存储多少个事件。</li>
<li><code>timeout</code>：等待事件的超时时间，以毫秒为单位。可以有以下几种取值：
<ul>
<li><code>-1</code>：无限等待，直到有事件发生。</li>
<li><code>0</code>：立即返回，不等待事件。</li>
<li><code>&gt;0</code>：等待指定的毫秒数后返回，即使没有事件发生。</li>
</ul></li>
</ul></li>
</ol>
<h3
id="个件有千万有ip地址访问时间url访问topk出现频率的ip或url的命令">⼀个⽂件，有⼏千万⾏，有IP地址、访问时间、url，访问topk出现频率的IP或url的命令</h3>
<p>假设文件名为 <code>access.log</code>，文件内容类似于：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">15</span> /page1<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">20</span> /page2<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">25</span> /page1<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">30</span> /page3<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">35</span> /page2<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">40</span> /page1<br></code></pre></td></tr></table></figure>
<h3 id="统计-ip-地址的频率">统计 IP 地址的频率：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> access.log | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | <span class="hljs-built_in">head</span> -n K<br></code></pre></td></tr></table></figure>
<p>这个命令的含义是：</p>
<ul>
<li>使用 <code>awk '&#123;print $1&#125;'</code> 提取每行的第一个字段（即 IP
地址）。</li>
<li>使用 <code>sort</code> 对 IP 地址进行排序。</li>
<li>使用 <code>uniq -c</code> 对排序后的 IP 地址进行统计，并输出每个 IP
地址出现的次数。</li>
<li>使用 <code>sort -nr</code> 对统计结果进行逆序排序。</li>
<li>使用 <code>head -n K</code> 只输出前 K 个结果，即 Top K 出现频率的
IP 地址。</li>
</ul>
<h3 id="awk命令">awk命令</h3>
<p><code>awk</code>
是一种文本处理工具，通常用于对文本文件进行行处理和字段处理。它以行为单位逐行读取输入文件，并根据用户指定的模式和动作对每行进行处理。<code>awk</code>
的语法比较灵活，可以用于过滤、转换和格式化文本数据。</p>
<p>例如，以下是一个简单的 <code>awk</code>
命令示例，用于提取文本文件中的第二列：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">awk</span> <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$2</span>&#125;&#x27;</span> filename.txt<br></code></pre></td></tr></table></figure>
<p>这个命令会读取 <code>filename.txt</code>
文件的每一行，并将每行的第二列打印输出。</p>
<h3 id="linux的进程调度腾讯云">Linux的进程调度（腾讯云）</h3>
<h3 id="gdb-调试遇到stackovlerflow怎么办">GDB
调试遇到stackovlerflow怎么办？</h3>
<p>如果按照一般的方式编译：</p>
<p>gcc –o stackoverflow stackoverflow.c</p>
<p>linux系统能够探测到程序中的stack
overflow，从而终止程序，如下图所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg" srcset="/img/loading.gif" lazyload
alt="Linux下的栈溢出案例分析-GDB调试操练" />
<figcaption
aria-hidden="true">Linux下的栈溢出案例分析-GDB调试操练</figcaption>
</figure>
<p>那有没有办法让系统不探测到stack
overflow，此处可以在编译时，禁用堆栈保护，具体命令如下：</p>
<p>gcc –fno-stack-protector –o stackoverflow stackoverflow.c</p>
<p>然后采用gdb调试stackoverflow。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820334293.jpg" srcset="/img/loading.gif" lazyload
alt="Linux下的栈溢出案例分析-GDB调试操练" />
<figcaption
aria-hidden="true">Linux下的栈溢出案例分析-GDB调试操练</figcaption>
</figure>
<h3 id="fork函数">fork函数</h3>
<p>for就会复制一份原来的进程即就是创建一个新进程,我们称子进程，而原来的进程我们称为父进程，此时父子进程是共存的，他们一起向下执行代码。</p>
<p>fork的返回值问题:</p>
<p>在父进程中，fork返回新创建子进程的进程ID；</p>
<p>在子进程中，fork返回0；</p>
<p>如果出现错误，fork返回一个负值；</p>
<p>getppid():得到一个进程的父进程的PID;</p>
<p>getpid():得到当前进程的PID;</p>
<h3 id="linux查看现在运行的所有进程">linux查看现在运行的所有进程</h3>
<p>ps aux</p>
<h3 id="linux日志查询">linux日志查询</h3>
<p>cat /var/log/syslog</p>
<h3
id="linux如何在日志中查找某个数据">linux如何在日志中查找某个数据</h3>
<p>grep "keyword" /var/log/syslog</p>
<h3 id="fork-的原理哪里体现了fork分配资源">fork()
的原理，哪里体现了fork分配资源？</h3>
<p>复制堆栈段，数据段，栈段等内存布局，但是代码段是映射的父进程的代码段以节省空间</p>
<h3
id="fork是把进程从1个变成2个那么最初的进程是从哪里来的">fork()是把进程从1个变成2个，那么最初的进程是从哪里来的？</h3>
<p>系统启动时先加载内核，然后通过引导程序启动初始进程init或者叫systemd进程，是整个进程树的根节点</p>
<h4 id="启动进程是用户态还是内核态">启动进程是用户态还是内核态？</h4>
<p>systemd进程是内核直接创建的，因此是内核态进程</p>
<h3
id="栈和堆大小是多少堆动态开辟的话能和内存一样大吗">栈和堆大小是多少，堆动态开辟的话能和内存一样大吗</h3>
<p><strong>Linux下进程栈的默认大小是10M</strong>，可以通过ulimit
-s查看并修改默认栈大小。
默认一个线程要预留1M左右的栈大小，所以进程中有N个线程时，Windows下大概有N*M的栈大小。
堆的大小理论上大概等于<strong>进程虚拟空间大小-内核虚拟内存</strong>大小。</p>
<h3 id="多线程的线程栈分配在哪里">多线程的线程栈分配在哪里？</h3>
<h3 id="什么是协程">什么是协程？</h3>
<p>协程是另一种轻量级的执行单元。协程不是进程或线程，其执行过程更类似于子例程或不带返回值的函数调用。协程的切换开销比线程更小，适用于高并发场景。</p>
<h3
id="linux下rm正在写入的文件会发生什么">Linux下rm正在写入的文件会发生什么？</h3>
<p>如果尝试使用rm命令删除正在写入的文件，可能会导致数据丢失或损坏。因为rm命令会立即删除文件系统的引用，而正在写入的文件可能还有未写入磁盘的缓存数据。</p>
<p><strong>那么该如何在不使用kill的情况下删除该文件</strong>？</p>
<p>可以尝试先停止写入进程（如通过发送信号或优雅地关闭程序），然后再删除文件。</p>
<h3 id="磁盘空间使用情况可以">磁盘空间使用情况可以</h3>
<p>通过df -h命令查看</p>
<h2 id="计算机网络"><strong>计算机网络</strong></h2>
<h3 id="http协议里-301-304啥用处腾讯云">http协议里 301
304啥用处（腾讯云）</h3>
<p>301永久重定向；302临时重定向；304未修改，重定向到已存在的缓存文件</p>
<h3 id="http请求过程腾讯云">http请求过程(腾讯云)</h3>
<ol type="1">
<li>⾸先，我们在浏览器地址栏中，输⼊要查找⻚⾯的URL，按下Enter</li>
<li>浏览器依次在 浏览器缓存 --&gt;&gt;系统缓存
--&gt;&gt;路由器缓存中去寻找匹配的URL，若有，就会直接在屏幕中显示出⻚⾯内容。若没有，则跳到第三步操作</li>
<li>发送HTTP请求前，浏览器需要先进⾏域名解析(即DNS解析)，以获取相应的IP地址;（浏览器DNS缓存、路由器缓存、DNS缓存）</li>
<li>获取到IP地址之后，浏览器向服务器发起TCP连接，与浏览器建⽴TCP三次握⼿</li>
<li>握⼿成功之后，浏览器就会向服务器发送HTTP请求，来请求服务器端的数据包</li>
<li>服务器处理从浏览器端收到的请求，接着将数据返回给浏览器</li>
<li>浏览器收到HTTP响应</li>
<li>查询状态，状态成功则进⾏下⼀步，不成功则弹出相应指示</li>
<li>再读取⻚⾯内容、进⾏浏览器渲染、解析HTML源码;（⽣成DOM树、解析CCS样式、处理JS交互，客户端和
服务器交互）进⾏展示</li>
<li>关闭TCP连接（四次挥⼿）</li>
</ol>
<h3
id="tcp三次握手过程为什么不是两次腾讯云">Tcp三次握手过程，为什么不是两次(腾讯云)</h3>
<h3 id="tcp为什么四次挥手腾讯云">TCP为什么四次挥手（腾讯云）</h3>
<h3 id="tcp的稳定性机制">TCP的稳定性机制</h3>
<p>TCP协议通过以下几种机制来确保数据的可靠传输和接收：</p>
<p><strong>三次握手四次挥手保证建立和断开连接的有效性</strong></p>
<p><strong>序列号和确认应答</strong>：发送方将每个数据包进行编号，并且接收方要对每个数据包进行确认应答。这样可以确保数据包的顺序和完整性。</p>
<p><strong>超时重传</strong>：如果发送方在一定时间内没有收到接收方的确认应答，就会重新发送数据包，以确保数据的可靠传输。</p>
<p><strong>流量控制</strong>：TCP协议使用滑动窗口机制来控制发送方和接收方之间的数据流量，避免发送过多的数据导致接收方无法处理。</p>
<p><strong>拥塞控制</strong>：TCP协议通过拥塞窗口机制来避免网络拥塞，当网络出现拥塞时，发送方会减小发送窗口的大小，以减缓数据包的发送速度。</p>
<p>综合上述机制，TCP协议能够确保数据的可靠传输和接收，从而保证了网络通信的稳定性和可靠性。</p>
<p>关键字：序列号，确认应答，超时重传，流量控制，拥塞控制</p>
<h3
id="服务端出现大量close_wait-的原因可能是什么">服务端出现大量close_wait
的原因可能是什么？</h3>
<p>  <code>close_wait</code>
按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送<code>FIN</code>包告知客户端关闭关闭连接，之后迁移到<code>Last_ACK</code>状态。但是<code>close_wait</code>过多只能说明没有迁移到<code>Last_ACK</code>，也就是服务端是否发送<code>FIN</code>包，只有发送<code>FIN</code>包才会发生迁移，所以问题定位在是否发送<code>FIN</code>包。<code>FIN</code>包的底层实现其实就是调用socket的<code>close</code>方法，这里的问题出在没有执行<code>close</code>方法。说明<strong>服务器CPU处理不过来（CPU太忙）</strong>或者<strong>服务器端忘记调用<code>close</code>函数</strong>或者<strong>应用程序一直睡眠得不到调度</strong>。</p>
<h3
id="解释一下time_wait作用腾讯云">解释一下time_wait作用（腾讯云）</h3>
<ul>
<li><strong>可靠地实现TCP全双工连接的终止</strong></li>
</ul>
<p>在进行关闭连接四次挥手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允许它重发最终的ACK。如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误（在java中会抛出connection
reset的SocketException)。</p>
<p>因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭的客户端必须维持状态信息进入TIME_WAIT状态。</p>
<ul>
<li><strong>允许老的重复分节在网络中消逝</strong></li>
</ul>
<p>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost
duplicate。</p>
<p>在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。</p>
<p>为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。</p>
<h3 id="time_wait状态过多要怎么解决">TIME_WAIT状态过多要怎么解决？</h3>
<p>编辑内核文件/etc/sysctl.conf，加入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间<br></code></pre></td></tr></table></figure>
<h3 id="tcp为什么会粘包腾讯云">TCP为什么会粘包（腾讯云）</h3>
<p>由于Nagle算法的优化会将多个小数据合成大数据发送</p>
<h4 id="粘包的包是在哪合成的">粘包的包是在哪合成的</h4>
<p>TCP粘包的包是在发送方的操作系统合成的。当应用程序通过TCP发送数据时，数据首先会被放入缓冲区。操作系统根据网络条件和其他因素决定何时发送这些缓冲区中的数据。如果一段时间内多个小数据包被放入缓冲区，而发送方的操作系统认为可以发送数据时，它可能会将这些小数据包合并成一个较大的数据包，然后发送到网络中。</p>
<h4
id="nagle算法开启有什么好处和坏处">Nagle算法开启有什么好处和坏处</h4>
<p><strong>好处：</strong></p>
<ol type="1">
<li><strong>减少网络流量：</strong>
通过合并小数据包，减少了网络传输中的数据包数量，降低了网络拥塞的可能性，提高了网络的利用率。</li>
<li><strong>减轻网络负载：</strong>
减少了发送小数据包的频率，降低了网络设备的负载，有助于提高网络的性能。</li>
</ol>
<p><strong>坏处：</strong></p>
<ol type="1">
<li><strong>引入延迟：</strong>
Nagle算法会等待一小段时间，尝试合并多个小数据包成一个大的数据包再进行发送。这样会导致数据的传输延迟增加，尤其是在对实时性要求较高的应用中，如在线游戏或实时视频流。</li>
<li><strong>小消息传输受阻：</strong>
在某些情况下，如果有一些小数据包需要立即发送，启用Nagle算法可能导致这些小数据包被延迟发送，影响了实时性。</li>
</ol>
<h3 id="拆包的原因">拆包的原因</h3>
<p>如果发送端缓冲区的长度大于网卡的MTU时，TCP会将这次发送的数据拆成几个数据包发送出去。也就是说，发送端可能只发送了一次数据，接收端却要分好几次才能收到完整的数据。</p>
<h3 id="粘包问题怎么解决">粘包问题怎么解决？</h3>
<p><strong>发送方</strong>：通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p><strong>接收方</strong>：没有办法直接处理粘包问题，只能交给应用层解决.</p>
<ul>
<li>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</li>
<li>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</li>
<li>将包封装为固定长度，不够长度的用0填充。</li>
</ul>
<p><strong>注意</strong>:TCP头部字段是<strong>头部长度,</strong>并没有标识数据长度的字段.</p>
<h3 id="tcp的重传机制腾讯云">TCP的重传机制（腾讯云）</h3>
<p>数据发送之后会等待对方的确认，如果定时器超时而没有收到确认，发送方就假设数据丢失，触发重传机制。</p>
<p>TCP还采用了一种称为快速重传的机制。如果发送方连续收到三个相同序列号的确认，它会认为在这个序列号之前的数据段已经丢失，会立即重传该数据段，而不等待定时器超时。</p>
<h3
id="拥塞窗口与流量窗口有什么区别腾讯云">拥塞窗口与流量窗口有什么区别（腾讯云）</h3>
<p>拥塞窗口（Congestion Window）和流量窗口（Window
Size）是TCP协议中的两个概念，<strong>它们用于控制和调整数据的传输速率</strong>，但有一些关键的区别。</p>
<ul>
<li>拥塞控制是指根据网络的拥塞程度来调节发送数据的速率，以避免网络拥塞导致丢包和网络性能下降。</li>
<li>流量控制是指接收方通知发送方自己的缓冲区大小，发送方根据接收方的缓冲区大小来控制发送数据的速率，以防止接收方的缓冲区溢出。</li>
</ul>
<h3 id="http状态码">HTTP状态码</h3>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315201411599.png" srcset="/img/loading.gif" lazyload
alt="image-20240315201411599" />
<figcaption aria-hidden="true">image-20240315201411599</figcaption>
</figure>
<h3
id="ssltls建立的时候和域名绑定还是ip绑定">SSL/TLS建立的时候和域名绑定还是ip绑定</h3>
<p>SSL/TLS 建立时是与域名绑定的，而不是 IP 绑定。</p>
<h3 id="dns和域名绑定还是ip绑定">DNS和域名绑定还是ip绑定</h3>
<p>域名</p>
<h3 id="http多个tcp连接怎么实现">HTTP多个TCP连接怎么实现</h3>
<h3 id="http一定要用tcp实现吗">HTTP一定要用TCP实现吗</h3>
<p>不一定，HTTP3就是用UDP实现的。QUIC是谷歌开发的基于UDP的传输协议，旨在提供更快的连接建立和更低的延迟。HTTP/3标准使用了QUIC作为传输层协议，因此可以说HTTP/3是基于QUIC实现的。与TCP相比，QUIC具有更快的连接建立速度和更好的拥塞控制，但也存在部署和兼容性等方面的挑战。</p>
<h3 id="https建立连接的过程">HTTPs建立连接的过程</h3>
<ol type="1">
<li><strong>客户端发起连接请求</strong>：
<ul>
<li>客户端向服务器发起连接请求，请求建立安全连接。客户端会发送一个HTTPS请求，其中包含了一些与SSL/TLS相关的信息，如支持的加密算法和SSL/TLS版本等。</li>
</ul></li>
<li><strong>服务器返回证书</strong>：
<ul>
<li>服务器收到客户端的连接请求后，会向客户端发送服务器的数字证书，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等信息。服务器的证书是由可信任的证书颁发机构（Certificate
Authority，CA）签发的，客户端可以通过CA证书来验证服务器的证书的真实性和合法性。</li>
</ul></li>
<li><strong>客户端验证证书</strong>：
<ul>
<li>客户端收到服务器发送的证书后，会进行证书的验证。客户端会检查证书的有效性、是否由可信任的CA签发、证书的有效期等信息，以确保服务器的身份和证书的合法性。如果证书验证失败，客户端会中断连接，否则继续连接。</li>
</ul></li>
<li><strong>客户端生成随机密钥</strong>：
<ul>
<li>客户端生成一个随机数作为对称密钥，并使用服务器的公钥加密该密钥，然后发送给服务器。对称密钥是用于对数据进行加密和解密的密钥，这样可以保证数据的机密性。</li>
</ul></li>
<li><strong>服务器使用私钥解密密钥</strong>：
<ul>
<li>服务器收到客户端发送的加密后的对称密钥后，使用自己的私钥进行解密，得到对称密钥。</li>
</ul></li>
<li><strong>建立安全通道</strong>：
<ul>
<li>客户端和服务器都使用协商好的对称密钥来加密和解密通信中的数据，从而建立安全的通信通道。此后，客户端和服务器之间的所有数据传输都会通过这个加密通道进行加密和解密，保证了数据的机密性和完整性。</li>
</ul></li>
</ol>
<h3
id="https客户端是怎么验证ca证书的有效性的">HTTPS客户端是怎么验证CA证书的有效性的</h3>
<p>首先 CA
会把持有者的<strong>公钥、用途、颁发者、有效时间</strong>等信息打成一个包，然后对这些信息进行
<strong>Hash 计算</strong>，得到一个 Hash 值；</p>
<p>然后 CA 会使用自己的<strong>私钥</strong>将该 Hash 值加密，生成
Certificate Signature，也就是 CA 对证书做了签名；</p>
<p>最后将 Certificate Signature
添加在文件证书上，形成<strong>数字证书</strong>；</p>
<p>客户端会使用同样的 <strong>Hash 算法获取</strong>该证书的 Hash 值
H1；</p>
<p>通常<strong>浏览器和操作系统</strong>中集成了 <strong>CA
的公钥</strong>信息，浏览器收到证书后可以使用 <strong>CA 的公钥解密
Certificate Signature</strong> 内容，得到一个 Hash 值 H2 ；</p>
<p><strong>最后比较 H1 和
H2，如果值相同，则为可信赖的证书，否则则认为证书不可信</strong>。</p>
<h3 id="很多closewait状态是什么原因">很多closewait状态是什么原因</h3>
<p>服务端的程序没有调用close 函数关闭连接。</p>
<h3
id="客户端close了服务端发送数据会发什么">客户端close了服务端发送数据会发⽣什么</h3>
<p>根据TCP协议，客户端会向服务器发送一个RST（重置）报文，表明这是一个不再有效的连接。服务器端在收到RST报文后，应该意识到连接已经被客户端关闭，并停止尝试发送数据。</p>
<h3 id="vpn在哪层络模型实现的">VPN在哪⼀层⽹络模型实现的</h3>
<p>VPN（虚拟专用网络）可以在不同的网络层次上实现，具体取决于它使用的技术和协议。以下是VPN的一些常见实现层次：</p>
<ul>
<li>应用层：例如SSL VPN</li>
<li>网络层：例如IPSEC VPN、GRE VPN</li>
<li>数据链路层：例如L2TP VPN、PPTP VPN</li>
</ul>
<h3 id="王者荣耀是tcp还是udp链接">王者荣耀是Tcp还是Udp链接？</h3>
<p>王者荣耀游戏的启动和登录采用TCP连接，客户端操作与界面显示是通过UDP数据流与服务器进行交互的。</p>
<h3 id="如何判断tcp还是udp呢">如何判断tcp还是udp呢？</h3>
<ul>
<li><strong>端口号</strong>：一些常见的端口号被分配给了特定的协议，例如
HTTP 使用 TCP 的端口 80，DNS 使用 UDP 的端口 53。</li>
<li><strong>包头标识</strong>：TCP 和 UDP
数据包的包头中包含了不同的字段和标识符。例如，TCP
的包头中有一个字节的标识符字段，用于指示该数据包是 TCP 数据包；而 UDP
的包头中没有类似的标识符字段。因此，可以通过解析数据包的包头来确定其所使用的协议。</li>
<li><strong>协议类型字段</strong>：数据包的协议类型可能会被直接指定在 IP
包头中的协议字段中。TCP 使用值 6 表示，UDP 使用值 17 表示。</li>
</ul>
<h3
id="什么是网络地址转换network-address-translationnat请解释-nat-的原理和应用场景">什么是网络地址转换（Network
Address Translation，NAT）？请解释 NAT 的原理和应用场景。</h3>
<p>网络地址转换（Network Address
Translation，NAT）是一种网络技术，用于将私有网络中的 IP
地址映射到公共网络中的 IP
地址，以便实现私有网络中的多个主机共享一个或多个公共 IP 地址的功能。</p>
<p>NAT 的工作原理如下：</p>
<ol type="1">
<li><strong>内部网络</strong>：在私有网络（如家庭网络、企业网络）中，主机通常使用私有
IP 地址（例如 192.168.x.x、10.x.x.x、172.16.x.x
等）来进行通信，这些地址在全球范围内并不唯一。</li>
<li><strong>NAT 设备</strong>：在私有网络和公共网络之间，存在一个 NAT
设备（通常是路由器或防火墙），它负责管理私有网络和公共网络之间的数据传输。</li>
<li><strong>地址映射</strong>：当内部网络中的主机尝试与外部网络通信时，NAT
设备会将内部主机的私有 IP 地址转换成路由器的公共 IP
地址，然后将数据包发送到外部网络。在数据包返回时，NAT 设备会将公共 IP
地址转换回相应的私有 IP 地址，然后将数据包传递给内部主机。</li>
<li><strong>端口转换</strong>：除了进行 IP 地址的转换之外，NAT
设备还可以进行端口转换，通过修改数据包中的端口号来实现多个内部主机共享一个公共
IP 地址的功能。</li>
</ol>
<p>NAT 的应用场景包括但不限于以下几个方面：</p>
<ol type="1">
<li><strong>节省 IP 地址</strong>：NAT 允许多个内部主机共享一个公共 IP
地址，从而节省了公共 IP 地址的使用，特别是在 IPv4
地址资源日益枯竭的情况下，NAT 可以有效地延长 IPv4 地址的使用寿命。</li>
<li><strong>网络隔离</strong>：NAT
设备可以将内部网络与外部网络隔离开来，从而提高了网络的安全性和隐私保护。</li>
<li><strong>访问控制</strong>：NAT
设备可以实现端口转发和端口过滤等功能，对内部网络的访问进行控制和管理。</li>
<li><strong>动态地址分配</strong>：NAT 设备可以为内部主机动态分配公共 IP
地址，从而实现了灵活的网络配置和管理。</li>
</ol>
<h3
id="什么是虚拟专用网络virtual-private-networkvpn请解释-vpn-的原理和使用场景">什么是虚拟专用网络（Virtual
Private Network，VPN）？请解释 VPN 的原理和使用场景。</h3>
<p>虚拟专用网络（VPN）是一种通过公共网络（通常是互联网）在远程位置之间创建安全连接的技术。它允许用户通过加密通道安全地传输数据，就像在私有网络中一样。</p>
<h4 id="原理">原理：</h4>
<ol type="1">
<li><strong>隧道协议</strong>：虚拟专用网络本质上是在您的本地设备和位置远隔千里的另一台
VPN 服务器之间创建一个安全数据隧道。当您联机时，此 VPN
服务器将成为您接收所有数据的来源。您的网络服务提供商（ISP）和其他第三方将无法再看到您的互联网流量的内容。</li>
<li><strong>加密</strong>：IPSec 等 VPN
协议会对数据进行加密，然后再通过数据隧道发送数据。IPsec
是一个协议套件，通过验证和加密数据流的每个 IP 数据包来保护 Internet
协议（IP）通信。VPN
服务就好比一个筛选器，使您的数据在一端无法读取，并且只在另一端进行解码 –
这可防止个人数据滥用，即使您的网络连接被破坏时也是如此。网络流量不再容易受到攻击，您的互联网连接也是安全的。</li>
</ol>
<h4 id="使用场景">使用场景：</h4>
<ol type="1">
<li><strong>远程访问：</strong>
允许用户通过互联网安全地访问公司内部网络资源。远程工作者可以通过 VPN
连接到公司网络，并访问文件、应用程序和其他资源，就像他们在办公室内一样。</li>
<li><strong>绕过地理限制：</strong> 通过连接到不同地区的 VPN
服务器，用户可以绕过地理限制，访问被限制的内容，如特定国家或地区的网站、流媒体服务等。</li>
<li><strong>保护隐私：</strong> 在连接到公共 Wi-Fi 热点时，使用 VPN
可以增加安全性和隐私保护，防止黑客窃取敏感信息。</li>
</ol>
<h3
id="长连接和短链接以及他们各自的应用场景如何实现一个长连接">长连接和短链接，以及他们各自的应用场景，如何实现一个长连接</h3>
<p><strong>长连接</strong>：长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</p>
<p><strong>短连接</strong>：短连接（short
connnection）是相对于长连接而言的概念，指的是在数据传送过程中，只在需要发送数据时，才去建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。</p>
<h4 id="应用场景">应用场景</h4>
<p><strong>长连接</strong>：长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。</p>
<p><strong>短连接</strong>：而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源。</p>
<h3 id="http报文组成">http报文组成</h3>
<p>HTTP报文分为请求报文和响应报文。</p>
<h4 id="请求报文request-message">请求报文（Request Message）</h4>
<ol type="1">
<li><p><strong>请求行（Request
Line）</strong>：包括请求方法、请求的URL和HTTP协议版本。</p>
<p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">请求方法 <span class="hljs-built_in">URL</span> HTTP协议版本<br></code></pre></td></tr></table></figure></p>
<p>例如：</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">code<br>GET /index.html HTTP/1.1<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>请求头部（Request
Headers）</strong>：包括多个键值对，描述了请求的各种属性和参数。</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">codeHeaderName1: HeaderValue1<br>HeaderName2: HeaderValue2<br>...<br></code></pre></td></tr></table></figure></p>
<p>例如：</p>
<p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">codeHost</span>: www.example.com<br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">88</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4324</span>.<span class="hljs-number">190</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,application/signed-exchange;v=b3;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>空行（Blank
Line）</strong>：请求行和请求头部之后的一个空行，用于分隔请求头部和请求体。</p></li>
<li><p><strong>请求体（Request
Body）</strong>：可选部分，用于传输请求相关的数据。在GET请求中通常为空，而在POST等请求中包含具体的数据。</p></li>
</ol>
<h4 id="响应报文">响应报文</h4>
<ol type="1">
<li><p><strong>状态行（Status
Line）</strong>：包括HTTP协议版本、状态码和状态消息。</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP协议版本 状态码 状态消息<br></code></pre></td></tr></table></figure></p>
<p>例如：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>响应头部（Response
Headers）</strong>：与请求头部类似，包括多个键值对，描述了响应的各种属性和参数。</p></li>
<li><p><strong>空行（Blank
Line）</strong>：状态行和响应头部之后的一个空行，用于分隔响应头部和响应体。</p></li>
<li><p><strong>响应体（Response
Body）</strong>：包含实际的响应数据，例如HTML文档、JSON数据等。</p></li>
</ol>
<p>HTTP报文的组成部分是根据HTTP协议规范定义的，它们共同构成了HTTP通信中传输的数据格式。</p>
<h3
id="http3和http2的区别quic协议原理">HTTP3和HTTP2的区别？QUIC协议原理？</h3>
<p>QUIC:基于UDP,不需要握手和挥手,同时<strong>实现了类似TCP的流量控制、传输可靠性的功能</strong>,<strong>集成了TLS加密功能</strong>,使用TLS1.3,TLS1.2需要1-2RRT才可以建立连接,而1.3完全建立连接需要1个RTT,而恢复会话需要0个RTT;<strong>多路复用，彻底解决TCP中队头阻塞的问题</strong>.</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995109407545622542">解读
HTTP1/HTTP2/HTTP3</a>.</p>
<h3
id="你了解的网络攻击方式有哪些syn攻击的防范方法">你了解的网络攻击方式有哪些？SYN攻击的防范方法？</h3>
<p><strong>攻击方式</strong>：</p>
<ol type="1">
<li><strong>DDoS
攻击</strong>：分布式拒绝服务（DDoS）攻击旨在通过同时向目标系统发送大量请求来耗尽目标系统的资源，使其无法正常工作。</li>
<li><strong>SQL 注入攻击</strong>：SQL
注入攻击是通过向应用程序的输入字段插入恶意 SQL
代码来利用应用程序对数据库的不安全输入验证，从而执行未经授权的数据库操作。</li>
</ol>
<p><strong>SYN攻击</strong>是一种常见的DoS攻击，利用 TCP
协议中的三次握手过程的漏洞，向目标服务器发送大量的伪造 SYN
请求，使目标服务器资源耗尽，无法响应正常用户的请求。防范 SYN
攻击的常用方法包括：</p>
<ol type="1">
<li><strong>SYN
攻击检测与过滤</strong>：通过网络防火墙、入侵检测系统（IDS）等设备，对网络流量进行实时监控，识别并过滤掉恶意的
SYN 请求。</li>
<li><strong>SYN Cookie 技术</strong>：服务器端可以使用 SYN Cookie
技术来减轻 SYN 攻击带来的影响，该技术在处理 TCP
连接请求时不会为每个请求都创建一个完整的连接状态，而是根据请求信息生成一个特殊的
Cookie 值，只有当客户端发送 ACK 确认时，服务器才会创建真正的连接。</li>
<li><strong>增加连接数限制</strong>：在服务器端配置最大连接数限制，防止单个
IP 地址同时建立过多的连接。</li>
<li><strong>使用反向代理</strong>：通过将服务器后面添加反向代理，将真实的服务器地址隐藏起来，减轻攻击对服务器的直接影响。</li>
<li><strong>增加系统资源</strong>：增加服务器的网络带宽、CPU
和内存等资源，提高服务器抵御 SYN 攻击的能力。</li>
</ol>
<h3 id="udp如何变得安全">udp如何变得安全</h3>
<ol type="1">
<li><strong>实现多路径传输</strong>：通过利用多个网络路径同时进行文件传输，分散数据流量，避免单一路径的拥堵问题，提高UDP协议的传输速度和稳定性。</li>
<li><strong>应用数据重传机制</strong>：当接收端收到不完整的数据时，可以请求发送端重新发送丢失的数据段，保证数据的完整性和可用性。</li>
<li><strong>加入安全认证机制</strong>：通过使用加密算法和数字签名等技术，保证数据信息的机密性和完整性，防止黑客攻击和数据泄露。</li>
</ol>
<h3 id="为什么dns协议不用tcp">为什么DNS协议不用TCP？</h3>
<p>UDP更快，TCP还需要三次握手，四次挥手；三次握手的时间UDP已经传完了。</p>
<p>另外，如果本地查询没有查到，需要本地DNS服务器迭代向顶级域名DNS服务器、权威域名DNS服务器迭代查询，如果每次都需要TCP三次握手，四次挥手，那么跟UDP的差距就很大了。</p>
<h2 id="数据库">数据库</h2>
<h3
id="一条mysql语句的执行过程腾讯云">一条MySQL语句的执行过程(腾讯云)</h3>
<ol type="1">
<li><p>连接器:连接器负责跟客户端建立
连接、获取权限、维持和管理连接。</p></li>
<li><p>查询缓存:MySQL拿到 个查询请求后，会先到查询缓存看看，之前是不是执
过这条语句。之前执
过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。</p></li>
<li><p>分析器:你输的是由多个字符串和空格组成的
条SQL语句，MySQL需要识别出的字符串分别是什么，代表什么。</p></li>
<li><p>优化器:优化器是在表<strong>有多个索引的时候，决定使哪个索引</strong>;或者在多个语句有多表关联(join)的时候，决定各个表的连接顺序。</p></li>
<li><p>执行器:MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进
了执器阶段，开始执行语句。</p></li>
</ol>
<h3
id="mysql-中如果修改了个-4kb-的的内容存磁盘时修改的是完整的还是中的段">MySQL
中如果修改了⼀个 4kb
的⻚的内容，存⼊磁盘时修改的是完整的⻚还是⻚中的⼀段</h3>
<p>在MySQL中，如果修改了一个4KB的页（Page）的内容，存入磁盘时通常是修改整个页而不是页中的一段。MySQL使用页作为存储数据的基本单位，通常是以固定大小的4KB为一页。当需要更新页中的数据时，MySQL通常会将整个页加载到内存中进行修改，然后再将整个页写回磁盘。</p>
<p>这样做的原因有几点：</p>
<ol type="1">
<li><strong>简化管理</strong>：通过将整个页作为最小单位进行读取和写入，简化了数据管理和维护操作。</li>
<li><strong>减少I/O开销</strong>：相比于仅写入一页中的一小部分数据，写入整个页可以减少磁盘I/O操作次数，提高性能。</li>
<li><strong>保证数据一致性</strong>：通过整页写入，可以确保页的所有数据都是一致的，避免了部分数据更新而导致的数据不一致问题。</li>
</ol>
<h3 id="b树和b树腾讯云客户端">B树和B+树（腾讯云客户端）</h3>
<h3
id="lru预读失效和缓存污染改进腾讯云">LRU预读失效和缓存污染改进（腾讯云）</h3>
<h4 id="预读失效">预读失效</h4>
<h5 id="什么是预读机制">什么是预读机制？</h5>
<p>Linux 操作系统为基于 Page Cache
的读缓存机制提供预读机制，一个例子是：</p>
<ul>
<li>应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB
范围内的数据，由于磁盘的基本读写单位为
block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page
中装下。</li>
<li>但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块
offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB)
都加载到内存，于是额外在内存中申请了 3 个 page；</li>
</ul>
<p>预读失效会带来什么问题？</p>
<p>如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。</p>
<h5 id="解决方案">解决方案</h5>
<ul>
<li>Linux 操作系统和 MySQL Innodb 通过改进传统 LRU
链表来避免预读失效带来的影响，具体的改进分别如下：</li>
<li>Linux 操作系统实现两个了 LRU 链表：活跃 LRU
链表（active_list）和非活跃 LRU 链表（inactive_list）；</li>
<li>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：young
区域 和 old 区域。</li>
</ul>
<p><strong>Linux</strong>：</p>
<p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU
链表（active_list）和非活跃 LRU 链表（inactive_list）。</p>
<ul>
<li>active
list活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li>inactive
list不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>有了这两个 LRU 链表后，预读页就只需要加入到 inactive list
区域的头部，当页被真正访问的时候，才将页插入 active list
的头部。如果预读的页一直没有被访问，就会从 inactive list
移除，这样就不会影响 active list 中的热点数据。</p>
<p><strong>MySQL</strong>：</p>
<p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，young
区域 和 old 区域。</p>
<p>young 区域在 LRU 链表的前半部分，old
区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/c5ec9c08462a2dd89d1038a144556a47c2b519.png" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>young 区域与 old 区域在 LRU
链表中的占比关系并不是一比一的关系，而是是 7 比 3
（默认比例）的关系。</p>
<p>划分这两个区域后，预读的页就只需要加入到 old
区域的头部，当页被真正访问的时候，才将页插入 young
区域的头部。如果预读的页一直没有被访问，就会从 old
区域移除，这样就不会影响 young 区域中的热点数据。</p>
<h4 id="缓存污染">缓存污染</h4>
<h5 id="什么是缓存污染">什么是缓存污染？</h5>
<p>虽然 Linux （实现两个 LRU 链表）和 MySQL
（划分两个区域）通过改进传统的 LRU
数据结构，避免了预读失效带来的影响。</p>
<p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU
链表头部（或者 young
区域）」这种方式的话，那么还存在缓存污染的问题。</p>
<p>当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃
LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young
区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃
LRU 链表（或者 young 区域）就被污染了。</p>
<h4 id="解决方案-1">解决方案</h4>
<p>前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者
young 区域），这种 LRU 算法<strong>进入活跃 LRU
链表的门槛太低了</strong>！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃
LRU 链表里的热点数据淘汰了。</p>
<p>所以，只要我们提高进入到活跃 LRU 链表（或者 young
区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young
区域）里的热点数据不会被轻易替换掉。</p>
<p>Linux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：</p>
<ul>
<li>Linux 操作系统：在内存页被访问第二次的时候，才将页从 inactive list
升级到 active list 里。</li>
<li>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old
区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：</li>
</ul>
<h3 id="说说你了解的mvcc机制">说说你了解的MVCC机制</h3>
<ol type="1">
<li><strong>事务ID</strong>：每个事务都有一个唯一的ID，用于标识事务的版本。</li>
<li><strong>隐藏列</strong>：在支持MVCC的数据库表中，每行数据通常会有隐藏的列来存储事务ID和回滚指针。</li>
<li><strong>回滚指针</strong>：指向该行数据的前一个版本，这样就形成了一个版本链。</li>
<li><strong>ReadView</strong>：在查询时，数据库会为事务创建一个ReadView，这是一个逻辑上的快照，包含了在查询时刻活跃的所有事务ID。</li>
</ol>
<h3
id="数据库是一阶段提交还是两阶段为什么是两阶段">数据库是一阶段提交还是两阶段？为什么是两阶段？</h3>
<p>数据库日志分为三种：</p>
<ul>
<li>undo log（回滚⽇志）：是 Innodb
存储引擎层⽣成的⽇志，实现了事务中的<strong>原⼦性</strong>，主要⽤于<strong>事务回滚和MVCC</strong>。</li>
<li>redo log（重做⽇志）：是 Innodb
存储引擎层⽣成的⽇志，实现了事务中的<strong>持久性</strong>，主要⽤于掉电等<strong>故障恢复</strong>；</li>
<li>binlog （归档⽇志）：是 Server
层⽣成的⽇志，主要⽤于<strong>数据备份</strong>和<strong>主从复制</strong>；</li>
</ul>
<p>事务提交后，redo log 和 binlog
都要持久化到磁盘，但是这两个是独⽴的逻辑，可能出现半成功的状态，造成两份⽇志之间的逻辑不⼀致。</p>
<ul>
<li>如果在将 redo log 刷⼊到磁盘之后， MySQL 突然宕机了，⽽ binlog
还没有来得及写⼊。MySQL 重启后，通过 redo log 能将 Buffer Pool
恢复到新值，但是 binlog ⾥⾯没有记录这条更新语句，在主从架构中，binlog
会被复制到从库，由于 binlog
丢失了这条更新语句，从库的这⼀⾏是旧值，主从不⼀致。</li>
<li>如果在将 binlog 刷⼊到磁盘之后， MySQL 突然宕机了，⽽ redo log
还没有来得及写入。由于 redo log
还没写，崩溃恢复以后这个事务无效，数据是旧值，⽽ binlog
⾥⾯记录了这条更新语句，在主从架构中，binlog
会被复制到从库，从库执⾏了这条更新语句，这⼀行字段是新值，与主库的值不⼀致性。</li>
</ul>
<p>所以会造成主从环境的数据不⼀致性。因为 redo log
影响主库的数据，binlog 影响从库的数据，redo log 和binlog
必须保持⼀致。</p>
<p>两阶段提交把单个事务的提交拆分成了 2
个阶段，分别是准备(Prepare)阶段和提交(Commit)阶段，每个阶段都由协调者(Coordinator)和参与者(Participant)共同完成。</p>
<h4 id="两阶段提交的过程">两阶段提交的过程</h4>
<p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护
binlog ⽇志与 InnoDB 的 redo log，为了保证这两个⽇志的⼀致性，MySQL
使⽤了<strong>内部 XA 事务</strong>，<strong>内部 XA 事务由 binlog
作为协调者，存储引擎是参与者</strong>。</p>
<p>当客户端执⾏ commit 语句或者在⾃动提交的情况下，MySQL 内部开启⼀个 XA
事务，分两阶段来完成 XA 事务的提交。</p>
<p>事务的提交过程有两个阶段，将 redo log 的写⼊拆成了两个步骤：prepare
和 commit，中间再穿插写⼊binlog：</p>
<ul>
<li>prepare 阶段：将内部 XA 事务的 ID写⼊到 redo log，同时将 redo log
对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘。</li>
<li>commit 阶段：把内部 XA 事务的 ID写⼊到 binlog，然后将 binlog
持久化到磁盘，接着调⽤引擎的提交事务接⼝，将 redo log 状态设置为
commit，此时该状态并不需要持久化到磁盘，只需要 write 到⽂件系统的page
cache 成功，只要 binlog 写磁盘成功，redo log 的状态还是 prepare
也没有关系，⼀样会被认为事务已经执行成功。</li>
</ul>
<h3 id="mysql调优">MySQL调优</h3>
<h4 id="explain语句">explain语句</h4>
<p><code>EXPLAIN</code>是MySQL中的一个关键字，用于分析查询语句的执行计划。通过<code>EXPLAIN</code>关键字，可以查看MySQL执行查询的方法和顺序，帮助优化查询性能。</p>
<p>使用<code>EXPLAIN</code>可以获取查询执行计划的相关信息，包括以下内容：</p>
<ol type="1">
<li>type：显示查询使用了何种类型</li>
<li>rows：预估搜索行数</li>
<li>extra:
<ul>
<li>using index：是否使用了覆盖索引</li>
<li>using filesort：是否使用了外排序</li>
<li>distinct：是否在select部分使用了distinc关键字</li>
<li>Using index condition:使用索引下推</li>
</ul></li>
</ol>
<h4 id="建立索引"><strong>建立索引</strong></h4>
<ul>
<li>为经常被查询的列建立索引，特别是在 WHERE 和 ORDER BY
子句中经常出现的列。</li>
<li>对于经常用于连接的列，考虑创建联合索引。</li>
<li>避免为稀疏列创建索引，因为这会增加索引维护的开销。</li>
</ul>
<h4 id="覆盖查询"><strong>覆盖查询</strong></h4>
<p>尽量避免全表扫描，即使使用索引也需要访问数据行。如果查询只需要索引列的值，可以创建覆盖索引，这样就不需要额外访问数据行了，从而提高查询性能。</p>
<h4 id="避免索引失效"><strong>避免索引失效</strong></h4>
<p>见索引失效。</p>
<h4 id="优化查询语句"><strong>优化查询语句</strong></h4>
<ul>
<li>使用 EXPLAIN
关键字分析查询执行计划，查看是否使用了索引，以及索引的选择器是否合理。</li>
<li>避免一次性返回大量数据，尽量限制查询返回的数据量。</li>
<li>使用合适的 JOIN 类型，避免不必要的笛卡尔积。</li>
</ul>
<h3 id="mysql什么情况下不走索引">MySQL什么情况下不走索引</h3>
<ul>
<li><strong>索引列参与表达式计算</strong></li>
<li><strong>索引列使用了函数</strong></li>
<li><strong>对索引隐式类型转换</strong>：如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</li>
<li><strong>不等号条件</strong>：当查询中包含不等号条件（&lt;&gt;）时。</li>
<li><strong>表连接中的列类型不匹配</strong>：
如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，
一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。</li>
<li><strong>索引列使用了左右模糊匹配</strong>，<code>Like %xxx</code>或者
<code>like %xx%</code></li>
<li><strong>字符串列与数字直接比较</strong></li>
<li><strong>or条件</strong>：除非每个列都建立了索引才会走索引</li>
<li><strong>ORDER BY 操作</strong>：在ORDER
BY操作中，排序的列同时也在WHERE中时，MYSQL将无法使用索引；</li>
<li><strong>联合索引非最左匹配</strong></li>
<li>使用了<code>select *</code></li>
</ul>
<h3
id="为什么要建立索引索引为什么能够加快查询速度">为什么要建立索引？索引为什么能够加快查询速度？</h3>
<p>数据库索引能够加快查询的速度，主要是因为它提供了一种<strong>快速定位数据</strong>的方法，减少了数据库系统需要扫描的数据量。具体来说，数据库索引能够加快查询速度的原因包括以下几点：</p>
<ol type="1">
<li><strong>减少数据扫描量</strong>：数据库索引可以将数据按照索引列的顺序进行组织，<strong>形成一种类似于字典的数据结构。当执行查询操作时，数据库系统可以利用索引快速定位到满足条件的记录</strong>，而不需要扫描整个表的数据。</li>
<li><strong>快速定位数据</strong>：数据库索引通常采用树状结构（如B+树）或哈希表等高效的数据结构来组织索引数据，使得数据库系统能够以O(log
n)或O(1)的时间复杂度快速定位到目标记录，而不受数据量的影响。</li>
<li><strong>避免全表扫描</strong>：在没有索引的情况下，数据库系统可能需要对整个表进行扫描以寻找满足条件的记录，这样的全表扫描会消耗大量的时间和系统资源。而有了索引之后，数据库系统可以通过索引快速定位到符合条件的记录，避免了全表扫描，提高了查询效率。</li>
<li><strong>支持排序和聚合操作</strong>：数据库索引不仅可以加速查询操作，还可以加速排序和聚合操作。例如，在有序索引的情况下，数据库系统可以利用索引的有序性进行高效的范围查询和排序操作；而在哈希索引的情况下，数据库系统可以利用哈希表的快速查找特性进行高效的聚合操作。</li>
</ol>
<h3 id="数据库的几大范式">数据库的几大范式</h3>
<p>数据库的三大范式（Normalization）是关系型数据库设计中的基本原则，旨在帮助设计者有效地组织数据库结构，减少数据冗余和插入、更新、删除异常，提高数据库的数据完整性和灵活性。三大范式包括：</p>
<ol type="1">
<li><strong>第一范式（1NF）</strong>：确保每个字段都是<strong>原子性</strong>的，即确保每<strong>个字段的值都是不可再分的基本单位</strong>，不包含多个值或重复的组合。换句话说，每个字段中不应该有多个值，而是单一的值。这样可以消除重复的数据，并确保每个字段具有唯一性和原子性。</li>
<li><strong>第二范式（2NF）</strong>：在<strong>满足第一范式的基础上，要求表中的非主键字段完全依赖于主键</strong>，而不是依赖于主键的一部分。简单来说，就是要保证表中的每个非主键字段都完全依赖于表的主键，而不是依赖于主键的某个子集。这样可以避免数据冗余和插入、更新、删除异常。</li>
<li><strong>第三范式（3NF）</strong>：在<strong>满足第二范式的基础上，要求表中的每个非主键字段之间不存在传递依赖关系</strong>。换句话说，就是要保证表中的每个非主键字段都直接依赖于主键，而不是依赖于其他非主键字段。这样可以进一步减少数据冗余，确保数据的更新操作不会导致数据不一致。</li>
<li><strong>BC范式（BCNF）</strong>:在第三范式的基础上，如果关系模型R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R为BCNF的模式。</li>
<li><strong>第四范式（4NF）</strong>：如果关系模式 R
中的每一个非平凡多值依赖 A -&gt;&gt; B 都满足以下条件之一，则关系模式 R
符合第四范式：
<ol type="1">
<li>A 是 R 的一个超码。</li>
<li>B 是 R 的一个超码。</li>
</ol></li>
</ol>
<h3 id="可重复读级别为什么还会有幻读">可重复读级别为什么还会有幻读</h3>
<p>可重复读隔离级别通常只针对已有数据的读操作，而不是针对整个查询结果集的完整性。因此，如果其他事务在同一事务中执行了插入、删除等操作，可能会导致幻读的出现。</p>
<h3 id="mysql主从数据一致性怎么保持">MySQL主从数据一致性怎么保持</h3>
<ul>
<li><strong>异步复制</strong>：也是默认的主从同步方式。这种方式的优点是效率高。缺点是不能保证数据一定会到达slave。可能会受到网络等原因出现延迟，导致主从数据不一致。当前对master中的表进行数据操作，master将事务Binlog事件写入到Binlog文件中，此时主库<strong>只会通知一下Dump线程发送这些新的Binlog到slave（</strong>slave的
I/O
线程读取并将事件写入relay-log中）然后主库就会继续处理提交操作，而此时不会保证这些Binlog传到任何一个从库节点上。</li>
<li><strong>全同步复制</strong>：优点是能够保证数据的强一致性，缺点是效率太低。当master上有提交事务之后，D<strong>ump线程发送这些新的Binlog到slave上</strong>，<strong>并且必须等待所有的slave回复成功</strong>（所有从库将事件写入中继日志，并将数据写入数据库）才能继续下一步操作。</li>
<li><strong>半同步复制</strong>：优点是在耗费少量性能的基础上能在一定程度上保证数据的一致性。当master上有提交事务之后，<strong>Dump线程发送这些新的Binlog到slave上，并且必须等待其中一个slave回复成功</strong>（slave将事件写入relay-log）才能继续下一步操作。</li>
</ul>
<h3 id="乐观锁悲观锁使用场景">乐观锁悲观锁使用场景</h3>
<p>乐观锁：适用于读操作频繁、写操作少量的场景，如大部分情况下读操作不会被写操作影响的情况下。</p>
<p>悲观锁：适用于写操作频繁、读操作少量的场景，或者需要保证资源的排他性访问的场景。</p>
<h3
id="数据库的四大隔离级别分别是怎么实现的">数据库的四大隔离级别？分别是怎么实现的？</h3>
<h4 id="四大隔离级别">四大隔离级别</h4>
<p>四大隔离级别：读未提交（read uncommitted）、读提交（read
committed）、可重复读（repeatable read）和串行化（serializable ）</p>
<ul>
<li>读未提交是指，
一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指， 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，
一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<h4 id="实现">实现</h4>
<ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read
View * 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把
Read View
理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个
Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read
View，然后整个事务期间都在用这个 Read View**。</li>
</ul>
<h3 id="什么是索引">什么是索引</h3>
<p>在数据库中，索引是一种数据结构，用于提高数据的检索速度和查询效率。索引可以看作是数据库表中一个或多个列的快速查找表，类似于书籍的目录，它们帮助数据库系统快速定位和访问表中的特定数据行。</p>
<h3 id="mysql怎么避免回表">MySQL怎么避免回表</h3>
<ul>
<li>覆盖索引</li>
<li>索引下推</li>
</ul>
<h3 id="mysql的null值是怎么存储的">MySQL的NULL值是怎么存储的</h3>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL
值并不会存储在行格式中的真实数据部分。</p>
<h3 id="mysql查询优化">mysql查询优化</h3>
<ol type="1">
<li>使用索引</li>
<li>覆盖索引</li>
<li>避免索引失效的情况</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select
的效率，但同时也降低了 insert 及 update 的效率</li>
</ol>
<h3 id="sql-分页查询如何实现offset过大怎么优化">SQL
分页查询如何实现？offset过大怎么优化</h3>
<p>分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。</p>
<p>例如，如果一页为3条数据，那么第一页就是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id, name, gender, score<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>; 	# 从<span class="hljs-number">0</span>开始显示<span class="hljs-number">3</span>条<br></code></pre></td></tr></table></figure>
<p>第二页为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id, name, gender, score<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">3</span>; 	# 从<span class="hljs-number">3</span>开始显示<span class="hljs-number">3</span>条<br></code></pre></td></tr></table></figure>
<p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code></p>
<h4 id="offset过大怎么优化">offset过大怎么优化？</h4>
<p>问题来了，<strong>limit 1451231,30</strong>
就会<strong>扫描145万</strong>行，然后丢掉前145万条只取30条，<strong>数据库压力</strong>能不大么，相对来说limit
30只会扫描30行，速度当然快。</p>
<ol type="1">
<li><p><strong>子查询优化法</strong>
先找出第一条数据，然后大于等于这条数据的id就是要获取的数据
缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性</p></li>
<li><p><strong>倒排表优化法</strong></p>
<p>倒排表法类似建立索引，用一张表来维护页数，然后通过高效的连接得到数据</p>
<p>缺点：只适合数据数固定的情况，数据不能删除，维护页表困难</p></li>
<li><p><strong>反向查找优化法</strong></p>
<p>当偏移超过一半记录数的时候，先用排序，这样偏移就反转了</p>
<p>缺点：order
by优化比较麻烦，要增加索引，索引影响数据的修改效率，并且要知道总记录数
，偏移大于数据的一半</p></li>
<li><p><strong>limit限制优化法</strong></p>
<p>把limit偏移量限制低于某个数。超过这个数等于没数据，我记得alibaba的dba说过他们是这样做的</p></li>
</ol>
<h3 id="数据库与缓存一致性问题">数据库与缓存一致性问题</h3>
<p>见<a
href="https://gstarmin.github.io/2023/12/25/Redis/#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BA%94%E6%98%9F%E9%AB%98%E9%A2%91">如何保证缓存与数据库双写时的数据一致性</a>.</p>
<h3
id="为什么b数比红黑树更适合做索引数据结构">为什么B+数比红黑树更适合做索引数据结构</h3>
<p>AVL
树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。</p>
<p>在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p>
<p><strong>B+树</strong>的子节点大于<strong>红黑树</strong>，<strong>红黑树</strong>只能有2个子节点，<strong>B树</strong>子节点大于2，子节点数多这一特点保证了存储相同大小的<strong>数据</strong>，<strong>树</strong>的高度更小，<strong>数据</strong>局部更加紧凑，而硬盘读取有局部加载的优化</p>
<p>B+树所有数据都在叶子节点，更方便遍历，而红黑树遍历要用中序。</p>
<h3 id="mysql是什么隔离级别">MySQL是什么隔离级别</h3>
<p>MySQL是可重复读级别，但是它很⼤程度上可以避免幻读现象。解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是通过
<strong>MVCC</strong> ⽅式解决了幻读</li>
<li>针对当前读：（select ... for update 等语句），是通过 next-key
lock（记录锁+间隙锁）⽅式解决了幻读，因为当执⾏ select ... for update
语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock
锁范围内插⼊。</li>
</ul>
<h3 id="表连接注意事项">表连接注意事项</h3>
<ol type="1">
<li>应该用小表驱动大表</li>
<li>如果左表比较大，并且业务要求驱动表必须是左表，那么我们可以通过where条件语句，使得<strong>左表</strong>被过滤的小一些</li>
<li>关联字段给索引，因为在mysql的嵌套循环算法中，是通过关联字段进行关联，并查询的，所以给关联字段索引很必要</li>
<li>如果sql里面有排序，请给排序字段加上索引，不然会造成排序使用全表扫描；</li>
<li>能用inner join 就用 inner join</li>
</ol>
<h3 id="mysql-有哪些锁">mysql 有哪些锁？</h3>
<ul>
<li><strong>全局锁</strong>：通过flush tables with read lock
语句会将整个数据库就处于只读状态了，这时其他线程执行以下操作，增删改或者表结构修改都会阻塞。全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li>
<li><strong>表级锁</strong>：MySQL 里面表级别的锁有这几种：
<ul>
<li>表锁：通过lock tables
语句可以对表加表锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</li>
<li>元数据锁：当我们对数据库表进行操作时，会自动给这个表加上
MDL，对一张表进行 CRUD 操作时，加的是 <strong>MDL
读锁</strong>；对一张表做结构变更操作的时候，加的是 <strong>MDL
写锁</strong>；MDL 是为了保证当用户对表执行 CRUD
操作时，防止其他线程对这个表结构做了变更。</li>
<li>意向锁：当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</li>
</ul></li>
<li><strong>行级锁</strong>：InnoDB 引擎是支持行级锁的，而 MyISAM
引擎并不支持行级锁。
<ul>
<li>记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X
锁之分的，满足读写互斥，写写互斥</li>
<li>间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li>
<li>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock
的组合，锁定一个范围，并且锁定记录本身。</li>
</ul></li>
</ul>
<h3
id="一个事务里有特别多sql的弊端即大事务的弊端">一个事务里有特别多sql的弊端（即大事务的弊端）</h3>
<h4 id="大事务产生的原因">大事务产生的原因</h4>
<ul>
<li>操作的数据比较多</li>
<li>大量的锁竞争</li>
<li>事务中有其他非DB的耗时操作</li>
</ul>
<h4 id="大事务造成的影响">大事务造成的影响</h4>
<ul>
<li>并发情况下，数据库连接池容易被撑爆</li>
<li>锁定太多的数据，造成大量的阻塞和锁超时</li>
<li>执行时间长，容易造成主从延迟</li>
<li>回滚所需要的时间比较长</li>
<li>undo log膨胀</li>
</ul>
<h3 id="mysql是什么隔离级别-1">MySQL是什么隔离级别？</h3>
<p>MySQL是可重复读，但是在很大程度上解决了幻读，解决方案有两种：</p>
<ul>
<li>针对快照读（普通 select 语句），是通过 MVCC ⽅式解决了幻读</li>
<li>针对当前读：（select ... for update 等语句），是通过 next-key
lock（记录锁+间隙锁）⽅式解决了幻读，因为当执⾏ select ... for update
语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock
锁范围内插入。</li>
</ul>
<h3 id="sql数据库如何解决死锁">sql数据库如何解决死锁</h3>
<ol type="1">
<li><strong>设置合理的锁超时时间</strong>：当尝试获取锁超过设定的时间后，放弃锁请求，避免长时间等待导致死锁。</li>
<li><strong>优化事务设计</strong>：尽量减小事务的大小和持续时间，减少锁的持有时间，从而降低死锁的风险。</li>
<li><strong>使用低隔离级别</strong>：如果可能，使用较低的隔离级别，以减少锁的需求和冲突。</li>
</ol>
<h3 id="mvcc有什么用">MVCC有什么用</h3>
<p>MVCC（Multiple Version Concurrency
Control）的主要作用是解决读-写和写-写冲突，使得大多数读操作不用加锁，从而提高了并发性能。通过保存数据的多个版本来实现并发访问，避免了读操作之间的锁竞争。</p>
<h3 id="事务的原理">事务的原理</h3>
<p>事务是并发控制的单位，是用户定义的一个操作序列。这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务通常是以BEGIN
TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，即将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。ROLLBACK表示回滚，即在事务运行的过程中发生了某种故障，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态。</p>
<h3
id="如果数据库短时间有大量数据存储比如10分钟存50w条该如何设计">如果数据库短时间有大量数据存储，比如10分钟存50w条，该如何设计</h3>
<h4 id="读写分离">读写分离</h4>
<p>在绝大部分面向用户的系统中，都是读多写少的模型，比如电商，大部分的时候是在搜索和浏览，比如抖音，大部分是在加载短视频，所以我们需要考虑的问题是，数据库如何扛住查询请求。一般的解决方法是<strong>读写分离.</strong></p>
<p>所谓<strong>读写分离</strong>，就是把同一个数据库分离成两份，一份专门用来做事务操作，另一份专门用来做读操作，如图。</p>
<figure>
<img
src="https://img2020.cnblogs.com/other/1666682/202110/1666682-20211020105318832-483361882.png" srcset="/img/loading.gif" lazyload
alt="image-20210625142110740" />
<figcaption aria-hidden="true">image-20210625142110740</figcaption>
</figure>
<p>做了<strong>主从复制</strong>之后，我们就可以在<strong>写入时只写主库</strong>，在<strong>读数据时只读从库</strong>，这样即使写请求会锁表或者锁记录，也不会影响到读请求的执行。同时呢，在读流量比较大的情况下，我们可以部署多个从库共同承担读流量，这就是所说的
<strong>一主多从</strong>
部署方式，在你的垂直电商项目中就可以通过这种方式来抵御较高的并发读流量。另外，从库也可以当成一个备库来使用，以避免主库故障导致数据丢失。</p>
<h4 id="k-v数据库">K-V数据库</h4>
<p>典型的代表就是Redis，也是目前业内非常主流的Nosql数据库。</p>
<p>之所以在IO性能方面比传统关系型数据库高，有两个点</p>
<ul>
<li>数据基于内存，读写效率高</li>
<li>KV型数据，时间复杂度为O(1)，查询速度快</li>
</ul>
<h3 id="dropdeletetruncated的区别">drop，delete，truncated的区别</h3>
<p>数据恢复方面：delete 可以恢复删除的数据，而 truncate 和 drop
不能恢复删除的数据。</p>
<p>执行速度方面：drop &gt; truncate &gt; delete。</p>
<p>删除数据方面：drop 是删除整张表，包含行数据和字段、索引等数据，而
truncate 和 drop 只删除了行数据。</p>
<p>添加条件方面：delete 可以使用 where 表达式添加查询条件，而 truncate
和 drop 不能添加 where 查询条件。</p>
<p>重置自增列方面：在 InnoDB 引擎中，truncate 可以重置自增列，而 delete
不能重置自增列。</p>
<h2 id="操作系统">操作系统</h2>
<h3
id="用户态和内核态的互换条件腾讯云">用户态和内核态的互换、条件（腾讯云）</h3>
<h4 id="切换条件">切换条件</h4>
<p>从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：</p>
<ul>
<li>系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如
Linux 的 int 80h 中断。</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li>
<li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ul>
<h4 id="切换过程">切换过程</h4>
<p>当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）</p>
<ul>
<li>设置处理器至内核态。</li>
<li>保存当前寄存器（栈指针、程序计数器、通用寄存器）。</li>
<li>将栈指针设置指向内核栈地址。</li>
<li>将程序计数器设置为一个事先约定的地址上，该地址上存放的是系统调用处理程序的起始地址。</li>
</ul>
<p>而之后从内核态返回用户态时，又会进行类似的工作。</p>
<h3 id="io-频繁发生内核态和用户态切换怎么解决腾讯云"><strong>I/O
频繁发生内核态和用户态切换，怎么解决</strong>（腾讯云）</h3>
<p>I/O会导致系统调用，从而导致内核态和用户态之间的切换。因为对I/O设备的操作是发生在内核态。那如何减少因为I/O导致的系统调用呢？</p>
<p><strong>答案是：用户进程缓冲区。</strong></p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDUyOTU2,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>用户进程缓冲区</strong>：</p>
<p>程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p><strong>内核缓存区</strong>：</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<h3
id="网卡收到一个包之后到用户读取这个包经历了多少次系统调用有多少次拷贝操作">网卡收到一个包之后到用户读取这个包经历了多少次系统调用，有多少次拷贝操作</h3>
<ol type="1">
<li><strong>网络中断处理：</strong>
当网卡接收到数据包时，会触发网络中断，导致内核调用中断处理程序。这一步并不直接计算在系统调用的范畴内。</li>
<li><strong>协议栈处理：</strong>
数据包会被传递给协议栈中的相应层（例如TCP/IP协议栈）。在这个过程中，内核可能执行一些系统调用来处理网络协议，如<code>ip_rcv</code>和<code>tcp_rcv</code>等。</li>
<li><strong>套接字缓冲区：</strong>
数据包被放置在套接字缓冲区中，等待应用程序读取。这一步可能涉及到一次数据拷贝，将数据从协议栈缓冲区拷贝到套接字缓冲区。</li>
<li><strong>应用程序读取：</strong>
应用程序通过系统调用（例如<code>read</code>或<code>recv</code>）从套接字缓冲区中读取数据。这一步可能涉及到一次数据拷贝，将数据从套接字缓冲区拷贝到用户空间缓冲区。</li>
</ol>
<p>总的来说，通常情况下，至少有两次拷贝操作：一次是从协议栈缓冲区到套接字缓冲区，另一次是从套接字缓冲区到用户空间缓冲区。系统调用的次数会涉及到中断处理、协议栈处理和应用程序读取。每个系统调用都可能涉及到上下文切换和内核态与用户态之间的切换，这可能会引入一些额外的开销。</p>
<h3
id="操作系统如何进行进程的上下文切换">操作系统如何进行进程的上下文切换</h3>
<ol type="1">
<li><strong>保存当前进程状态：</strong>
当操作系统决定需要切换到另一个进程时，首先会保存当前进程的状态。这个状态通常包括
CPU
寄存器的内容（如程序计数器、栈指针、通用寄存器等）、进程控制块（PCB）中的进程信息（如进程
ID、进程状态、程序计数器等）以及其他可能的状态信息。</li>
<li><strong>选择下一个进程：</strong>
操作系统根据调度算法从就绪队列中选择下一个要运行的进程。这个选择可以根据不同的调度算法进行，例如先来先服务（FCFS）、轮转法（Round
Robin）、优先级调度等。</li>
<li><strong>加载下一个进程状态：</strong>
一旦选择了下一个要运行的进程，操作系统就会从该进程的 PCB
中获取其状态信息。这些信息包括进程的程序计数器、栈指针、寄存器值等。然后，操作系统将这些状态加载到
CPU 中，准备开始执行该进程。</li>
<li><strong>切换内存空间：</strong>
在多任务操作系统中，不同进程可能会运行在不同的内存空间中，因此在切换进程时，操作系统可能还需要执行内存空间的切换操作。这包括<strong>更新页表、切换地址空间</strong>等。</li>
<li><strong>恢复运行：</strong> 最后，操作系统会将 CPU
控制权转移到新选择的进程，开始执行其代码。此时，该进程的状态被加载到 CPU
中，从之前保存的状态中恢复，并继续执行其上一次被暂停的位置。</li>
</ol>
<h3 id="线程崩溃进程会崩溃吗">线程崩溃进程会崩溃吗？</h3>
<p>一般情况下，如果一个线程崩溃，那么整个进程很可能会崩溃**。
这是因为线程之间共享地址空间，一个线程的崩溃可能导致内存的不确定性，进而影响到其他线程的执行。</p>
<h3
id="遇到过死锁吗怎么解决的不要背那四条">遇到过死锁吗？怎么解决的，不要背那四条。</h3>
<p>鸵鸟策略，遇到死锁的时候把进程kill掉。</p>
<h3 id="cpu中断后进程的处理流程">cpu中断后，进程的处理流程</h3>
<p>当 CPU
接收到中断信号后，会暂停当前正在执行的进程，并执行中断处理程序。下面是
CPU 中断后进程的处理流程的一般步骤：</p>
<ol type="1">
<li><strong>发生中断</strong>：当外部设备或者软件程序需要处理器的注意或者响应时，会发出中断信号。处理器在接收到中断信号后，会停止当前执行的指令，保存当前执行现场，并跳转到中断处理程序执行。</li>
<li><strong>中断响应</strong>：处理器接收到中断信号后，会根据中断向量表找到对应的中断处理程序的入口地址。处理器会保存当前执行现场（如程序计数器、寄存器状态等），以便在中断处理完成后能够恢复执行。</li>
<li><strong>中断处理</strong>：处理器跳转到中断处理程序的入口地址开始执行中断处理程序。中断处理程序会根据中断类型进行相应的处理，可能涉及到保存现场、处理中断事件、执行特定任务等。</li>
</ol>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E4%B8%AD%E6%96%AD-17112032380592.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="说说你对信号量的理解">说说你对信号量的理解</h3>
<p>信号量是一种用于进程间同步和互斥的同步原语。它通常用于解决多个进程或线程之间共享资源的并发访问问题。信号量可以是计数器或标志，用于控制对临界区的访问。</p>
<p>在操作系统中，信号量通常分为两种类型：</p>
<ol type="1">
<li><strong>二进制信号量（Binary
Semaphore）</strong>：也称为互斥锁，只能取两个值，通常为 0 或
1。它用于实现临界区的互斥访问，保证在同一时刻只有一个进程可以访问临界资源。</li>
<li><strong>计数信号量（Counting
Semaphore）</strong>：可以取多个值，通常用于控制共享资源的访问数量。它允许多个进程同时访问临界资源，但是需要限制资源的数量。</li>
</ol>
<p>信号量的基本操作包括：</p>
<ul>
<li><strong>初始化</strong>：创建信号量，并设置其初始值。</li>
<li><strong>P 操作（Wait
操作）</strong>：尝试获取信号量资源，如果资源不可用，则进入等待状态，直到资源可用。如果是二进制信号量，P
操作会将信号量值减 1。</li>
<li><strong>V 操作（Signal
操作）</strong>：释放信号量资源，如果有等待的进程，通知它们资源可用。如果是二进制信号量，V
操作会将信号量值加 1。</li>
</ul>
<p>信号量的使用场景包括：</p>
<ul>
<li><strong>临界区的互斥访问</strong>：多个进程需要对临界资源进行互斥访问，防止竞争条件（Race
Condition）的发生。</li>
<li><strong>生产者消费者问题</strong>：多个生产者和消费者共享一个有限的缓冲区，需要控制缓冲区的访问数量。</li>
<li><strong>读者写者问题</strong>：多个读者和写者共享一个数据资源，需要控制读写操作的并发访问。</li>
</ul>
<h3
id="说说你对虚拟内存的理解尽可能多">说说你对虚拟内存的理解，尽可能多</h3>
<p>虚拟内存是一种计算机操作系统的内存管理技术，它将物理内存（RAM）和磁盘存储结合起来，为每个进程提供了一个连续的、私有的地址空间。虚拟内存使得多个进程可以同时运行，并且可以让每个进程感觉自己拥有整个系统的内存空间。</p>
<p>以下是对虚拟内存的更详细理解：</p>
<ol type="1">
<li><strong>地址映射</strong>：虚拟内存将进程中的逻辑地址（虚拟地址）映射到物理内存中的物理地址。这样，进程看到的地址空间是连续的，但实际上数据可能存储在物理内存中的不同位置，或者甚至存储在磁盘上。</li>
<li><strong>页面</strong>：虚拟内存将地址空间分割成固定大小的页面（Page），通常为
4KB 或
8KB。物理内存也被分割成相同大小的页面。每个页面都有一个对应的页表（Page
Table）记录它在物理内存中的位置。</li>
<li><strong>页面置换</strong>：当物理内存不足以容纳所有进程的数据时，虚拟内存使用页面置换算法将一部分数据从物理内存中换出到磁盘上的交换空间（Swap
Space），以释放物理内存供其他进程使用。常见的页面置换算法有最近最少使用（LRU）、先进先出（FIFO）等。</li>
<li><strong>虚拟内存管理</strong>：虚拟内存管理包括地址映射、页面分配、页面置换等功能。操作系统负责管理虚拟内存的分配和释放，以及页面置换算法的选择和执行。</li>
<li><strong>内存保护</strong>：虚拟内存可以为每个页面设置不同的访问权限，如读、写、执行等，以保护进程的内存安全。</li>
<li><strong>内存共享</strong>：虚拟内存允许多个进程共享内存页面，这些页面可以映射到不同的进程地址空间中，实现共享数据或代码。</li>
</ol>
<h3
id="操作系统通过什么方式向用户提供系统调用">操作系统通过什么方式向用户提供系统调用</h3>
<p>操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境，但是计算机系统的各种硬件资源是有限的，因此为了保证每一个进程都能安全的执行。处理器设有两种模式：“用户模式”与“内核模式”。一些容易发生安全问题的操作都被限制在只有内核模式下才可以执行，例如I/O操作，修改基址寄存器内容等。<strong>而连接用户模式和内核模式的接口称之为系统调用。</strong></p>
<p><strong>应用程序代码运行在用户模式下，当应用程序需要实现内核模式下的指令时，先向操作系统发送调用请求。操作系统收到请求后，执行系统调用接口，使处理器进入内核模式。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。</strong></p>
<ol type="1">
<li><strong>系统调用接口</strong>：
<ul>
<li>操作系统会提供一组系统调用接口，这些接口定义了用户程序可以调用的操作系统服务和功能。这些接口通常以函数的形式提供给用户空间的应用程序，用户程序可以通过调用这些函数来请求操作系统执行特定的任务，如文件操作、进程管理、网络通信等。</li>
</ul></li>
<li><strong>软中断或陷阱指令</strong>：
<ul>
<li>当用户程序调用系统调用接口时，通常会触发一个软中断（Software
Interrupt）或者陷阱指令（Trap
Instruction）。这些指令会使处理器从用户态切换到内核态，进入操作系统的执行环境。在这个过程中，操作系统会检测到这个中断或者陷阱，并根据用户请求执行相应的系统调用服务。</li>
</ul></li>
</ol>
<h3 id="应用程序到磁盘读写完整流程">应用程序到磁盘读写完整流程</h3>
<p>在Linux系统中，应用程序到磁盘的读写流程是一个复杂的过程，涉及多个系统层面的交互。以下是一个简化的描述：</p>
<ol type="1">
<li><strong>应用程序发起读写请求</strong>：当应用程序需要读取或写入数据时，它会通过系统调用（如<code>read()</code>或<code>write()</code>）请求操作系统进行数据传输。</li>
<li><strong>系统调用转换为内核操作</strong>：系统调用将用户空间的请求转换为内核空间的操作。在内核空间，数据会被写入到页缓存（PageCache）中，这是一种利用内存作为缓冲区的机制，可以提高数据访问速度。</li>
<li><strong>页缓存和磁盘交互</strong>：如果是读操作，内核会检查页缓存中是否有请求的数据。如果没有，它会从磁盘读取数据并加载到页缓存中。如果是写操作，数据首先被写入页缓存，并标记为“脏”，之后在适当的时候由flusher线程写回磁盘。</li>
<li><strong>DMA控制器参与数据传输</strong>：为了减轻CPU的负担，直接内存访问（DMA）控制器会被用来在内存和磁盘之间传输数据，无需CPU的直接干预。</li>
<li><strong>数据写入磁盘</strong>：最终，数据会被写入磁盘。这个过程可能是由flusher线程触发的，也可能是应用程序通过调用如<code>fsync()</code>的系统调用显式请求的。</li>
</ol>
<h3 id="数据在操作系统中的存储形式">数据在操作系统中的存储形式</h3>
<ol type="1">
<li><strong>文件系统</strong>：操作系统通过文件系统管理数据的存储和组织。文件系统将数据以文件的形式存储在存储设备（如硬盘、固态硬盘等）上，并提供对这些文件的管理、访问和操作。</li>
<li><strong>数据库</strong>：数据库系统是一种专门用于管理和组织数据的软件。数据库中的数据以表格的形式进行组织，可以使用结构化查询语言（SQL）等方式对数据进行查询、更新和操作。</li>
<li><strong>内存</strong>：操作系统使用内存来存储正在运行的程序和它们所需的数据。内存是临时存储，当计算机关闭时，其中的数据通常会丢失。</li>
<li><strong>缓存</strong>：为了提高数据访问的速度，操作系统通常会使用缓存来临时存储最近访问过的数据。缓存位于内存中，可以减少对存储设备的访问次数，加快数据的访问速度。</li>
<li><strong>寄存器</strong>：寄存器是位于处理器内部的存储单元，用于暂存和处理指令和数据。寄存器的访问速度非常快，但容量较小，通常用于存储临时数据和处理器状态信息。</li>
</ol>
<h3 id="如何解决死锁">如何解决死锁</h3>
<ol type="1">
<li><strong>预防死锁</strong>：通过一次性分配所有资源、按序请求资源等方式来预防死锁的发生。</li>
<li><strong>避免死锁</strong>：通过银行家算法等来判断并避免系统进入不安全状态，从而避免死锁。</li>
<li><strong>检测与解除死锁</strong>：定期检测系统中是否发生死锁，一旦发生死锁，则采取解除死锁的措施。解除死锁通常涉及撤销一些进程，以便回收它们的资源，从而使得其他进程能够继续执行。
<ol type="1">
<li>死锁定理：系统处于死锁的<strong>充分条件</strong>是：当且仅当次状态的进程－资源分配图是不可简化的。</li>
</ol></li>
</ol>
<h3 id="软连接和硬链接的区别">软连接和硬链接的区别</h3>
<p><strong>物理实现</strong>：</p>
<ul>
<li>软链接：
软链接是⼀个独⽴的⽂件，它包含了指向⽬标⽂件或⽬录的路径。软链接实际上是⼀个特殊的⽂件，其中包含有关⽬标⽂件的引⽤。</li>
<li>硬链接：
硬链接是⽬标⽂件的⼀个额外的⽬录项。⽬录项指向相同的物理数据块，实际上只是⽂件系统中的两个或多个⽬录项指向相同的inode。</li>
</ul>
<p><strong>链接的目标</strong>：</p>
<ul>
<li>软链接：
软链接可以链接到⽂件或⽬录，甚⾄可以链接到不存在的⽂件。</li>
<li>硬链接： 硬链接只能链接到⽂件，⽽且必须是同⼀⽂件系统中的。</li>
</ul>
<p><strong>对链接的影响</strong>：</p>
<ul>
<li>软链接：
如果原始⽂件被删除或移动，软链接仍然存在，但链接将失效。软链接可以跨⽂件系统，但如果⽬标⽂件被删除，软链接将成为坏链接（dangling
link）。</li>
<li>硬链接：
删除或移动原始⽂件并不会影响硬链接，因为硬链接只是inode的另⼀个引⽤。只有当所有硬链接都被删除后，inode的数据块才会被释放。</li>
</ul>
<p><strong>创建方式</strong>：</p>
<ul>
<li>软链接： 使⽤ln -s 命令创建软链接。例如， ln -s target_file
link_name 。</li>
<li>硬链接： 使⽤ln 命令创建硬链接。例如， ln target_file link_name
。</li>
</ul>
<p><strong>链接数量</strong>：</p>
<ul>
<li>软链接：
软链接只会增加⽬标⽂件的链接计数，⽽不会增加inode的链接计数。</li>
<li>硬链接：
硬链接会增加⽬标⽂件的链接计数，也会增加inode的链接计数。当链接计数为零时，⽂件系统才会释放相关的数据块。</li>
</ul>
<h3 id="位和32位的区别及原理">64位和32位的区别及原理</h3>
<p>我们通常说的64位技术是相对于32位而言的，这个位数指的是CPU
GPRs(General-Purpose
Registers，通用寄存器)的数据宽度为64位，64位指令集就是运行64位数据的指令，也就是说处理器一次可以运行64bit数据。</p>
<p>32位处理器一次只能处理32位，也就是4个字节的数据；而64位处理器一次就能处理64位，即8个字节的数据。如果将总长128位的指令分别按16位、32位、64位为单位进行编辑的话：32位的处理器需要4个指令，而64位处理器则只要两个指令。显然，在工作频率相同的情况下，64位处理器的处理速度比32位的更快。除了运算能力之外，与32位处理器相比，64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，而64位处理器的一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。传统32位处理器的寻址空间最大为4GB，而64位的处理器在理论上则可以达到1800万个TB（1TB=1024GB）。</p>
<h3 id="多进程和多线程如何选择">多进程和多线程如何选择？</h3>
<ul>
<li><strong>需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）</strong></li>
<li><strong>需要进行大量计算的优先使用线程（CPU频繁切换）</strong></li>
</ul>
<h2 id="设计模式">设计模式</h2>
<h3 id="面向对象设计的六大原则">面向对象设计的六大原则</h3>
<ol type="1">
<li><strong>单一职责（Single Responsibility
Principle）</strong>:一个类应该只负责一个职责，术语叫：仅有一个引起其变化的原因。</li>
<li><strong>开闭原则（Open Close
Principle）</strong>:一个类一旦开发完成，后续增加新的功能就不应该通过修改这个类来完成，而是通过继承，增加新的类。</li>
<li><strong>里氏替换原则（Liskov Substitution
Principle）</strong>:一个软件系统中所有用到一个类的地方都替换成其子类，系统应该仍然可以正常工作。</li>
<li><strong>依赖倒置原则（Dependence Inversion
Principle）</strong>:是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。
<ol type="1">
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li>
</ol></li>
<li><strong>接口隔离原则(Interface Segregation Principle,
ISP)</strong>：客户端不应该依赖它不需要的接口。</li>
<li><strong>迪米特法则(Law of Demeter, LoD)</strong>,
最少知识原则(Principle of Least Knowledge)： 1.
每个对象应该对其他对象尽可能最少的知道 2.
每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</li>
</ol>
<h3 id="单例模式实现的优点">单例模式实现的优点</h3>
<ol type="1">
<li>因为单例模式在内存中就只有一个实例，其主要优点可以<strong>减少内存的开支</strong>。尤其是一个对象需要频繁地创建销毁时，毕竟创建或销毁时性能又无法优化,
那么单例模式就非常合适了；</li>
<li>因为单例模式只生成一个实例，所以，其主要优点可以<strong>减少系统的性能开销</strong>，当一个对象产生需要比较多的资源时，比如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决；</li>
<li>同时单例模式可以<strong>避免对资源的多重占用</strong>，比如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写的操作；</li>
<li>单例模式可以在系统设置全局的访问点，<strong>优化和共享资源</strong>访问，可以设计一个单例类，负责所有数据表的映射处理等。</li>
</ol>
<h3
id="怎么提前销毁懒汉式局部静态变量">怎么提前销毁懒汉式局部静态变量？</h3>
<h3 id="三种工厂模式的区别">三种工厂模式的区别</h3>
<ul>
<li>简单工厂模式只有一个抽象产品类，只有一个具体的工厂类。</li>
<li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。</li>
<li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个具体产品类的实例。</li>
</ul>
<h3 id="使用工厂模式的好处">使用工厂模式的好处？</h3>
<p>可以将对象的创建和实现解耦。</p>
<h4 id="总结-1">总结</h4>
<p><strong>简单工厂模式</strong>：让一个工厂类负责创建所有对象；但没有考虑后期扩展和维护，修改违背开闭原则，静态方法不能被继承。</p>
<p><strong>工厂方法模式</strong>：主要思想是继承，修改符合开闭原则；但每个工厂只能创建一种类型的产品。</p>
<p><strong>抽象工厂模式</strong>：主要思想是组合，本质是产品族，实际包含了很多工厂方法，修改符合开闭原则；但只适用于增加同类工厂这种横向扩展需求，不适合新增功能方法这种纵向扩展。</p>
<h2 id="redis">Redis</h2>
<p>常见的有五种数据结构：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315221909012.png" srcset="/img/loading.gif" lazyload
alt="image-20240315221909012" />
<figcaption aria-hidden="true">image-20240315221909012</figcaption>
</figure>
<h4 id="redis底层数据结构">redis底层数据结构</h4>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315223431452.png" srcset="/img/loading.gif" lazyload
alt="image-20240315223431452" />
<figcaption aria-hidden="true">image-20240315223431452</figcaption>
</figure>
<h3
id="redis做缓存有哪些问题如何解决">redis做缓存有哪些问题？如何解决？</h3>
<p>从缓存穿透，缓存击穿，缓存雪崩，缓存⼀致性等⽅⾯来答。参考<a
href="https://gstarmin.github.io/2023/12/25/Redis/#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">缓存雪崩、缓存穿透、缓存预热、缓存击穿、服务降级</a></p>
<h3 id="跳表的插入与删除">跳表的插入与删除</h3>
<h4 id="插入">插入</h4>
<p>向一个跳跃表中插入元素可以分为三步：</p>
<ol type="1">
<li>找到各层的插入位置 。</li>
</ol>
<p>和单链表一样，要插入一个元素，需要找到前驱节点。跳跃表是多层链表，
那么需要找到各层的前驱节点。</p>
<p>下图中，要插入一个新元素 20 ，其中数组 last[k] 表示找到的第 k
阶上的前驱节点。</p>
<p>找的方法和查找过程一样，只需要记住每一层可以向右考察到的最后一个节点即可。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.1.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li>决定新节点的阶 。</li>
</ol>
<p>用上面提到的 随机函数 RandLevel 决定它的阶。
如果得到比整个跳跃表还要高的阶，需要把头节点的阶增高，与之对齐。
以便任何节点都可以从左上角的头节点出发找到。</p>
<p>由于 last
数组的含义是各层的插入位置，而且，接下来将要把头节点在新增高的这些层上指向新节点，
于是把头节点 head 记为 last 数组在这些层上的值。</p>
<p>下图中，假如生成了一个大的阶 4 ，那么跳跃表的阶将会增高到 4， 并设置
last[4] = head 。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.2.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="3" type="1">
<li>各层执行插入动作 。</li>
</ol>
<p>仍然和单链表一样，插入一个新节点的过程，就是把新节点和前驱、后驱节点分别搭线。
只不过跳跃表是在多层上进行。</p>
<p>在每一层，前驱节点 last[k] 指向新节点，新节点指向 last[k]
原来的后驱节点。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.3.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="删除">删除</h4>
<p>同样地，从一个跳跃表中删除元素可以也可以分为三步：</p>
<ol type="1">
<li>找到各层的前驱节点和要删除的节点 。</li>
</ol>
<p>从单链表中删除一个元素，需找到前驱节点。跳跃表是多层链表，也需找到各层的前驱节点。</p>
<p>和前面一样，last 数组来存放各层的前驱节点。 查找元素的过程，即可记录
last 数组。</p>
<p>同时查找结束后，亦可判断要删除的元素是否存在于表中。</p>
<p>下图以删除元素 22 为例：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.4.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li>各层执行删除 。</li>
</ol>
<p>仍然与单链表是类似。在各层上，前驱节点直接指向要删除的节点的后驱节点。
最终释放要删除的节点的内存即可。</p>
<p>不过，并非 last 数组的每一项都是待删除节点的前驱节点，
在删除时需要注意过滤。</p>
<p>以删除 22 为例，具体的删除动作就是，如果 last[k] 的后驱是 22， 则将
last[k] 的后驱指向 22 的后驱。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.5.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="3" type="1">
<li>抹去删除节点后可能残留的孤零的高阶 。</li>
</ol>
<p>如果删除的元素是一个高阶节点，可能让跳跃表的头节点残留下孤零零的高阶。</p>
<p>这一步是可选的，即使不清理也无大碍。</p>
<p>以删除高阶节点 33 为例，删除 33 后，头节点的阶可以由 4 降为 3 。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.6.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3
id="什么情况使用mysql什么情况使用redis">什么情况使用MySQL，什么情况使用Redis</h3>
<p>Redis适合处理高性能读写、缓存、实时通信等场景，而MySQL适合存储和处理结构化数据、支持复杂查询和事务处理的场景。</p>
<h2 id="项目">项目</h2>
<h3 id="muduo">muduo</h3>
<p>服务器通信网络库重写并简化了muduo网络库，使用C++11去除了boost库的依赖，使用基于OOP思想，reactor模型。one
loop per thread的模型，通过epoll +
线程池，使用多线程和事件循环机制实现高并发处理。</p>
<h3 id="channel">channel</h3>
<p><strong>Channel类其实相当于一个文件描述符的保姆</strong>,想要IO多路复用监听某个文件描述符，就要把这个fd和该fd感兴趣的事件通过epoll_ctl<strong>注册</strong>到IO多路复用模块（我管它叫<strong>事件监听器</strong>）上。当事件监听器监听到该fd发生了某个事件。事件监听器返回
[发生事件的fd集合]以及[每个fd都发生了什么事件].Channel类则封装了一个
[fd] 和这个 [fd感兴趣事件] 以及事件监听器监听到
[该fd实际发生的事件].</p>
<h3 id="poller">Poller</h3>
<p><strong>负责监听文件描述符事件是否触发</strong>以及<strong>返回发生事件的文件描述符以及具体事件</strong>的模块就是Poller。所以<strong>一个Poller对象对应一个事件监听器</strong>（这里我不确定要不要把Poller就当作事件监听器）。在multi-reactor模型中，有多少reactor就有多少Poller。(这个Poller是个抽象虚类，由EpollPoller和PollPoller继承实现)</p>
<ul>
<li><code>epollfd_</code>就是用<code>epoll_create</code>方法返回的epoll句柄，这个是常识。</li>
<li><code>channels_</code>：这个变量是<code>std::unordered_map&lt;int, Channel*&gt;</code>类型，负责记录
文件描述符 ---&gt;
Channel的映射，也帮忙保管所有注册在你这个Poller上的Channel。</li>
<li><code>ownerLoop_</code>：所属的EventLoop对象，看到后面你懂了。</li>
</ul>
<p><strong>EpollPoller给外部提供的最重要的方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TimeStamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span></span><br></code></pre></td></tr></table></figure>
<p>这个函数可以说是<strong>Poller的核心</strong>了，当外部调用<code>poll</code>方法的时候，该方法底层其实是通过<code>epoll_wait</code>获取这个事件监听器上发生事件的fd及其对应发生的事件，我们知道每个fd都是由一个Channel封装的，通过哈希表<code>channels_</code>可以根据fd找到封装这个fd的Channel。<strong>将事件监听器监听到该fd发生的事件写进这个Channel中的revents成员变量中。</strong>然后把这个Channel装进<code>activeChannels</code>中（它是一个vector&lt;Channel*&gt;）。这样，当外界调用完<code>poll</code>之后就能拿到事件监听器的<strong>监听结果（<code>activeChannels_</code>）</strong></p>
<h3 id="eventloop">EventLoop</h3>
<p>EventLoop就是负责实现<strong>“循环”</strong>，负责驱动<strong>“循环”</strong>的重要模块！！Channel和Poller其实相当于EventLoop的手下，EventLoop整合封装了二者并向上提供了更方便的接口来使用。</p>
<p>每个EventLoop对象都唯一绑定了一个线程，这个线程其实就在一直执行这个函数里面的while循环，这个while循环的大致逻辑比较简单。就是调用<code>Poller::poll</code>方法获取事件监听器上的监听结果。接下来在loop里面就会调用监听结果中每一个Channel的处理函数<code>HandlerEvent( )</code>。每一个Channel的处理函数会根据Channel类中封装的实际发生的事件，执行Channel类中封装的各事件处理函数。（比如一个Channel发生了可读事件，可写事件，则这个Channel的<code>HandlerEvent( )</code>就会调用提前注册在这个Channel的可读事件和可写事件处理函数，又比如另一个Channel只发生了可读事件，那么<code>HandlerEvent( )</code>就只会调用提前注册在这个Channel中的可读事件处理函数)</p>
<h3
id="acceptor-接受新用户连接并分发连接给subreactorsubeventloop"><strong>Acceptor:
接受新用户连接并分发连接给SubReactor（SubEventLoop）</strong></h3>
<h3 id="tcpconnection类">TcpConnection类</h3>
<p><strong>主要</strong>封装了一个已建立的TCP连接，以及控制该TCP连接的方法（连接建立和关闭和销毁），以及该连接发生的各种事件（读/写/错误/连接）对应的处理函数，以及这个TCP连接的服务端和客户端的套接字地址信息等。</p>
<p><strong>我个人觉得TcpConnection类和Acceptor类是兄弟关系，Acceptor用于main
EventLoop中，对服务器监听套接字fd及其相关方法进行封装（监听、接受连接、分发连接给SubEventLoop等），TcpConnection用于SubEventLoop中，对连接套接字fd及其相关方法进行封装（读消息事件、发送消息事件、连接关闭事件、错误事件等）。</strong></p>
<h3 id="项目的流程">项目的流程</h3>
<ol type="1">
<li>建立连接：创建<code>TcpServer</code>对象，并在<code>TcpServer</code>的构造函数实例化了一个<code>Acceptor</code>对象，并往这个<code>Acceptor</code>对象注册了一个回调函数<code>TcpServer::newConnection()</code>。实例化Acceptor对象时，Acceptor的构造函数中实例化了一个Channel对象，即<code>acceptChannel_</code>，该Channel对象封装了服务器监听套接字文件描述符（尚未注册到main
EventLoop的事件监听器上）。接着Acceptor构造函数将<code>Acceptor::handleRead( )</code>方法注册进<code>acceptChannel_</code>中，这也意味着，日后如果事件监听器监听到<code>acceptChannel_</code>发生可读事件，将会调用<code>Acceptor::handleRead( )</code>函数。当有连接到来的时候，会在
<code>Acceptor::handleRead( )</code>中调用<code>TcpServer::newConnection()</code>将建立好的连接封装成TcpConnection对象然后发送到sub
Eventloop上。</li>
<li>消息读取：sub eventloop和main
eventloop一样，也是用Poller调用poll函数获取事件监听结果，然后同样调用channel监听到的事件并调用提前注册好的事件处理函数。这里<code>readCallback_</code>保存的函数其实是<code>TcpConnection::handleRead( )</code>，<strong>消息读取的处理逻辑也就是由这个函数提供的</strong>。函数首先调用<code>Buffer_.readFd(channel_-&gt;fd(), &amp;saveErrno)</code>，该函数底层调用linux的<code>readv()</code>将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中（<code>inputBuffer_</code>）。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在<code>savedErrno</code>中。如果当<code>readFd( )</code>返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用<code>messageCallback_</code>中保存的用户自定义的读取消息后的处理函数。</li>
<li>消息发送：<code>TcpConnection::send(buf)</code>函数内部其实是调用了Linux的函数<code>write( )</code>，如果TCP发送缓冲区能一次性容纳buf，那这个<code>write( )</code>函数将buf全部拷贝到发送缓冲区中。<strong>如果TCP发送缓冲区内不能一次性容纳buf：</strong>
<ol type="1">
<li>这时候<code>write( )</code>函数<code>buf</code>数据尽可能地拷贝到TCP发送缓冲区中，并且将errno设置为<code>EWOULDBLOCK</code>。</li>
<li>剩余未拷贝到TCP发送缓冲区中的<code>buf</code>数据会被存放在<code>TcpConnection::outputBuffer_</code>中。并且向事件监听器上<strong>注册该<code>TcpConnection::channel_</code>的可写事件</strong>。</li>
<li>事件监听器监听到该Tcp连接可写事件，就会调用<code>TcpConnection::handleWrite( )</code>函数把<code>TcpConnection::outputBuffer_</code>中剩余的数据发送出去。</li>
<li>在<code>TcpConnection::handleWrite( )</code>函数中，通过调用<code>Buffer::writeFd()</code>函数将<code>outputBuffer_</code>的数据写入到Tcp发送缓冲区，如果Tcp发送缓冲区能容纳全部剩余的未发送数据，那最好不过了。如果Tcp发送缓冲区依旧没法容纳剩余的未发送数据，那就尽可能地将数据拷贝到Tcp发送缓冲区中，继续保持可写事件的监听。</li>
<li>当数据全部拷贝到Tcp发送缓冲区之后，就会调用用户自定义的【写完后的事件处理函数】，并且<strong>移除该TcpConnection在事件监听器上的可写事件</strong>。（移除可写事件是为了提高效率，不会让<code>epoll_wait()</code>
毫无意义的频繁触发可写事件。因为大多数时候是没有数据需要发送的，频繁触发可写事件但又没有数据可写。）</li>
</ol></li>
<li>断开连接：
<ol type="1">
<li>被动断开：服务端<code>TcpConnection::handleRead()</code>中感知到客户端把连接断开了。<code>TcpConnection::handleRead( )</code>函数内部调用了Linux的函数<code>readv( )</code>，当<code>readv( )</code>返回0的时候，服务端就知道客户端断开连接了。然后就接着调用<code>TcpConnection::handleClose( )</code>。<code>TcpServer::removeConnection( )</code>函数调用了<code>remvoveConnectionInLoop( )</code>函数，把unordered_map中该tcpconnection的对象映射删除，该函数的运行是在MainEventLoop线程中执行的，这里涉及到线程切换。因为该函数主要是从TcpServer对象中删除某条数据。而TcpServer对象是属于MainEventLoop的。这也是贯彻了One
Loop Per
Thread的理念。<code>TcpConnection::connectDestroyed( )</code>函数的执行是又跳回到了subEventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外SubEventLoop中的Poller类对象还保存着这条Tcp连接的<code>channel_</code>，所以调用<code>channel_.remove( )</code>将这个Tcp连接的channel对象从Poller内的数据结构中删除。</li>
<li>主动断开：服务器主动关闭时，调用<code>TcpServer::~TcpServer()</code>析构函数。不断循环的让这个TcpConnection对象所属的SubEventLoop线程执行<code>TcpConnection::connectDestroyed()</code>函数，同时在MainEventLoop的<code>TcpServer::~TcpServer()</code>函数中调用<code>item.second.reset()</code>释放保管TcpConnection对象的共享智能指针，以达到释放TcpConnection对象的堆内存空间的目的。</li>
</ol></li>
</ol>
<h3 id="channel的生命周期">channel的生命周期</h3>
<p>从Acceptor的构造函数开始被构造，然后在断开连接时候的<code>TcpConnection::connectDestroyed( )</code>中被删除。</p>
<h3 id="tcpconnection的生命周期">TcpConnection的生命周期</h3>
<p>连接到来的时候<code>Acceptor::handleRead( )</code>中调用<code>TcpServer::newConnection()</code>将建立好的连接封装成TcpConnection对象然后发送到sub
Eventloop上。在断开连接的时候<code>TcpConnection::connectDestroyed</code>执行完毕就销毁。详细看https://www.cnblogs.com/Qiu-Bai/p/17127757.html，之后再补充。</p>
<h3
id="如果tcpconnection中有正在发送的数据怎么保证在触发tcpconnection关闭机制后能先让tcpconnection先把数据发送完再释放tcpconnection对象的资源">如果<strong>TcpConnection中有正在发送的数据，怎么保证在触发TcpConnection关闭机制后，能先让TcpConnection先把数据发送完再释放TcpConnection对象的资源？</strong></h3>
<p>TcpConnection类继承了enable_shared_from_this类，继承了这个类之后能使用shared_from_this()函数。假如我们在TcpConnection对象（我们管这个对象叫TCA）中的成员函数中调用了<code>shared_from_this()</code>，该函数可以返回一个shared_ptr，并且这个shared_ptr指向的对象是TCA。</p>
<p>接着这个shared_ptr就作为channel_的<code>Channel::tie()</code>函数的函数参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****  Channel.h   ******/</span><br>std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; tie_; <br><span class="hljs-comment">/*****  Channel.cc   ******/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::tie</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;<span class="hljs-type">void</span>&gt;&amp; obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    tie_ = obj;<br>    tied_ = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::HandlerEvent</span><span class="hljs-params">(TimeStamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tied_)&#123;<br>        shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>            <span class="hljs-built_in">HandleEventWithGuard</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        。。。。一般不会执行到这里其实。我实在想不到正常运行的情况下怎么会执行到这里，可能是我比较菜。<br>        <span class="hljs-built_in">HandleEventWithGuard</span>(receiveTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当事件监听器返回监听结果，就要对每一个发生事件的channel对象调用他们的<code>HandlerEvent()</code>函数。在这个<code>HandlerEvent</code>函数中，会先把<code>tie_</code>这个weak_ptr提升为强共享智能指针。这个强共享智能指针会指向当前的TcpConnection对象。就算你外面调用删除析构了其他所有的指向该TcpConnection对象的智能指针。你只要<code>HandleEventWithGuard()</code>函数没执行完，你这个TcpConnetion对象都不会被析构释放堆内存。而<code>HandleEventWithGuard()</code>函数里面就有负责处理消息发送事件的逻辑。当<code>HandleEventWithGuard()</code>函数调用完毕，这个<code>guard</code>智能指针就会被释放。</p>
<h3 id="buffer类">buffer类</h3>
<p><strong>readv和writev允许单个系统调用读入到或写出自一个或多个缓冲区</strong>。</p>
<h4
id="bufferreadfd函数剖析"><strong>Buffer::readFd()函数剖析</strong></h4>
<p>这个readFd巧妙的设计，可以让用户一次性把所有TCP接收缓冲区的所有数据全部都读出来并放到用户自定义的缓冲区Buffer中。用户自定义缓冲区Buffer是有大小限制的，我们一开始不知道TCP接收缓冲区中的数据量有多少，如果一次性读出来会不会导致Buffer装不下而溢出。所以在<code>readFd( )</code>函数中会在栈上创建一个临时空间<code>extrabuf</code>，然后使用<code>readv</code>的分散读特性，将TCP缓冲区中的数据先拷贝到Buffer中，如果Buffer容量不够，就把剩余的数据都拷贝到<code>extrabuf</code>中，然后再调整Buffer的容量(动态扩容)，再把<code>extrabuf</code>的数据拷贝到Buffer中。当这个函数结束后，<code>extrabuf</code>也会被释放。另外<code>extrabuf</code>是在栈上开辟的空间，速度比在堆上开辟还要快。</p>
<h3 id="线程池的好处">线程池的好处</h3>
<p>线程池<strong>为避免频繁创建、销毁线程</strong>，提供一组子线程，能从工作队列取任务、执行任务，而用户可以向工作队列加入任务，从而完成用户任务。可以更加高效。</p>
<h3 id="跳表和红黑树的优劣">跳表和红黑树的优劣</h3>
<h4 id="红黑树">红黑树</h4>
<ol type="1">
<li>节点要么是黑色，要么是红色</li>
<li>根节点和叶子节点（NIL）都是黑色</li>
<li>每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
<li>从上一条可以推出，如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li>
</ol>
<h4 id="为什么不使用红黑树">为什么不使用红黑树</h4>
<p>跳表和红黑树复杂度一样，但是并发环境下，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。</p>
<h3 id="内存池">内存池</h3>
<p>内存缓存模块仿写了Google的tcmalloc，实现了高效的多线程内存管理，使用基于页面的内存分配机制，用于替换系统的内存分配相关函数
malloc 和 free、使用三层 Cache结构，Thread
Cache：主要解决锁竞争的问题；Central Cache：主要负责居中调度的问题；Page
Cache：主要负责提供以页为单位的大块内存；减少多线程场景下的锁竞争和系统开销，提高内存分配和释放的速度和效率。</p>
<p>span管理以页为单位的大内存块。</p>
<p>线程局部存储通过thread_local声明即可，例如<strong><em>int thread_
local errCode;</em></strong></p>
<h3 id="内存池的实现">内存池的实现</h3>
<p>该项目所使用的内存池原型是 Google 的开源项目 tcmalloc，其全称为
Thread-Caching Malloc，即线程缓存的
malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数，即
malloc 和 free。</p>
<p>内存池主要解决的就是效率问题，它能够避免让程序频繁的向系统申请和释放内存。其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题，内存碎片分为如下两种：</p>
<ul>
<li><strong>外部碎片</strong>：指的是空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配的需求。</li>
<li><strong>内部碎片</strong>：指的是由于一些对齐的需求，导致分配出去的空间中一些内存无法被充分利用。</li>
</ul>
<blockquote>
<p>内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p>
</blockquote>
<p>该内存池的整体架构如下图所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/mempool.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>其主要由以下三个部分组成：</p>
<ul>
<li><code>Thread Cache</code>: 线程缓存是每个线程独有的，用于小于等于
256KB 的内存分配，每个线程独享一个 ThreaCache了。</li>
<li><code>Central Cache</code>: 中心缓存是所有线程共享的，当 ThreadCache
需要内存时会按需从 CentralCache 中获取内存，而当 ThreadCache
中的内存满足一定条件时，CentralCache 也会在合适的时机对其进行回收。</li>
<li><code>Page Cache</code>:
页缓存中存储的内存是以页为单位进行存储及分配的，当 CentralCache
需要内存时，PageCache 会分配出一定数量的页给 CentralCache，而当
CentralCache 中的内存满足一定条件时，PageCache
也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</li>
</ul>
<p>上述三个部分的主要作用如下：</p>
<ul>
<li>Thread Cache: 主要解决锁竞争的问题；</li>
<li>Central Cache: 主要负责居中调度的问题；</li>
<li>Page Cache: 主要负责提供以页为单位的大块内存；</li>
</ul>
<h3 id="threadcache">1.ThreadCache</h3>
<p>Thread Cache 的结构如下图所示：</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/Kohirus/Apollo/blob/main/screenshot/threadcache.png"><img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/threadcache.png" srcset="/img/loading.gif" lazyload
alt="img" /></a></p>
<p>通过使用<strong>字节对齐</strong>的方法来减少哈希桶的数目，并且进一步增加内存利用率，在设计时，让不同的范围的字节数按照不同的对齐数进行对齐，具体的对齐方式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节数</th>
<th>对齐数</th>
<th>哈希桶下标</th>
<th>自由链表数目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1, 128]</td>
<td>8</td>
<td>[0, 16)</td>
<td>16</td>
</tr>
<tr class="even">
<td>[129, 1024]</td>
<td>16</td>
<td>[16, 72)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[1025, 8 * 1024]</td>
<td>128</td>
<td>[72, 128)</td>
<td>56</td>
</tr>
<tr class="even">
<td>[8 * 1024+1, 64 * 1024]</td>
<td>1024</td>
<td>[128, 184)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[64 * 1024+1, 256 * 1024]</td>
<td>8*1024</td>
<td>[184, 208)</td>
<td>24</td>
</tr>
</tbody>
</table>
<p>为了实现每个线程无锁访问属于自己的 Thread
Cache，就需要用到<strong>线程局部存储</strong>(Thread Local Storage,
TLS)，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其它线程访问到，这样就保证了数据的线程独立性。</p>
<p>当某个线程申请的对象不用了，可以将其释放给 Thread Cache，然后 Thread
Cache 将该对象插入到哈希桶的自由链表当中即可。</p>
<p>但是随着线程不断地释放，对应自由链表中的长度也会越来越长，这些内存堆积在一个
Thread Cache 中就是一种浪费，此时应该将这些内存还给 Central
Cache，这样一来，这些内存对于其它线程来说就是可申请的，因此当 Thread
Cache 中某个桶当中的自由链表太长时，可以将其释放给 Central Cache。</p>
<h3 id="centralcache">2. CentralCache</h3>
<p>当线程申请某一大小的内存时，如果 Thread Cache
中对应的自由链表不为空，那么直接取出一个内存块返回即可，但如果此时该自由链表为空，那么这时
Thread Cache 就需要向 Central Cache 申请内存了。</p>
<p>Central Cache 的结构与 Thread Cache
是一样的，都是哈希桶结构，并且所遵循的对齐规则也一致。这样做的好处是当
Thread Cache 的某个桶中没有内存时，就可以直接到 Central Cache
中相对应的哈希桶中取内存。</p>
<p>Central Cache 与 Thread Cache 不同之处有两点：</p>
<ol type="1">
<li>Central Cache 是所有线程共享的，而 Thread Cache 是线程独享的；</li>
<li>Central Cache 的哈希桶中挂载的是 Span，而 Thread Cache
的哈希桶中挂载的是切好的内存块；</li>
</ol>
<p>其结构如下所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/centralcache.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于 Central Cache 是所有线程共享的，多个 Thread Cache
可能在同一时刻向 Central Cache
申请内存块，因此为了保证线程安全，需要<strong>加锁控制</strong>。此外，由于只有多个线程同时访问
Central Cache
的同一个桶时才会存在锁竞争，因此无需用锁来锁住所有哈希桶，只需锁住当前所访问的哈希桶即可。</p>
<p>当 Thread Cache 向 Central Cache 申请内存时，如果给的太少，那么
Thread Cache 在短时间用完了又会再来申请；但是如果给的太多，那么 Thread
Cache
可能用不完而浪费大量的空间。为此，此处采用<strong>慢反馈调节算法</strong>，当
Thread Cache 向 Central Cache
申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p>
<p>当 Thread Cache 中的某个自由链表太长时，会将自由链表中的对象归还给
Central Cache 中的 Span。但是需要注意的是，归还给 Central Cache
的这些对象不一定都属于同一个 Span 的，且 Central Cache
中的每个哈希桶中都可能不止一个
Span，因此归还时不仅需要知道该对象属于哪一个桶，还需要知道它属于这个桶中的哪一个
Span。为了建立页号和 Span
之间的映射，需要使用一种哈希表结构进行管理，一种方式是采用 C++ 中的
unordered_map，另一种方式是采用<strong>基数树</strong>数据结构。</p>
<h3 id="pagecache">3. PageCache</h3>
<p>Page Cache 的结构与 Central Cache 一样，都是哈希桶的结构，并且 Page
Cache 的每个哈希桶中都挂的是一个个的 Span，这些 Span
也是按照双向链表的结构连接起来的。</p>
<p>但是，Page Cache 的映射规则与 Central Cache 和 Thread Cache
不同，其采用的是<strong>直接定址法</strong>，比如 1 号桶挂的都是 1 页的
Span，2 号桶挂的都是 2 页的 Span，以此类推。</p>
<p>其次，Central Cache 每个桶中的 Span
都被切为了一个个对应大小的对象，以供 Thread Cache 申请。而 Page Cache
服务的是 Central Cache，当 Central Cache 中没有 Span 时，向 Page Cache
申请的是某一固定页数的 Span。而如果切分这个申请到的 Span 就应该由
Central Cache 自己来决定。</p>
<p>其结构如下图所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/pagecache.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>当每个线程的 Thread Cache 没有内存时都会向 Central Cache
申请，此时多个线程的 Thread Cache 如果访问的不是 Central Cache
的同一个桶，那么这些线程是可以同时进行访问的。这时 Central Cache
的多个桶就可能同时向 Page Cache 申请内存，所以 Page Cache
也是存在线程安全问题的，因此在访问 Page Cache 时也必须要加锁。</p>
<p>但是此处的 Page Cache 不能使用桶锁，因为当 Central Cache 向 Page
Cache 申请内存时，Page Cache 可能会将其他桶中大页的 Span 切小后再给
Central Cache。此外，当 Central Cache 将某个 Span 归还给 Page Cache
时，Page Cache 也会尝试将该 Span 与其它桶当中的 Span 进行合并。</p>
<p>也就是说，在访问 Page Cache
时，可能同时需要访问多个哈希桶，如果使用桶锁则可能造成大量频繁的加锁和解锁，导致程序的效率底下。因此在访问
Page Cache 时没有使用桶锁，而是用一个大锁将整个 Page Cache 锁住。</p>
<p>如果 Central Cache 中有某个 Span 的 <code>useCnt_</code> 减到 0
了，那么 Central Cache 就需要将这个 Span 归还给 Page Cache
了。为了缓解内存碎片问题，Page Cache 还需要尝试将还回来的 Span
与其它空闲的 Span 进行合并。</p>
<h3 id="基数树">4. 基数树</h3>
<p>由于在 PageCache 中最初建立页号与 Span 之间的映射关系时，采用的是
unordered_map 数据结构，但是通过性能测试发现，内存池的性能并未优于原生的
malloc/free 接口，因此通过 Visual Studio 的性能分析工具发现性能瓶颈位于
unordered_map 处。</p>
<p>这主要是因为 unordered_map
不是线程安全的，在多线程环境下需要加锁，而大量的加锁则会导致资源的消耗和性能的下降，因此在映射页号与
Span 之间的关系时，采用基数树（Radix Tree）数据结构来进行优化。</p>
<p>当采用如下图所示的单层基数树时，在 32 位平台下，以一页大小为 8K(<span
class="math inline">\(2^{13}\)</span>) 为例，此时页的数目就是 <span
class="math inline">\(2^{32}\div
2^{13}=2^{19}\)</span>，因此存储页号最多需要 19 个比特位，同时由于 32
位平台下的指针大小为 4 字节，因此该数组的大小就是 <span
class="math inline">\(2^{19}\times
4=2^{21}=2M\)</span>，内存消耗不大，是可行的。但是如果是在 64
位平台下，此时该数组的大小就是 <span class="math inline">\(2^{51}\times
8=2^{54}=2^{24}G\)</span>，这显然是不可行的：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225048027-1025596599.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如下图所示，为二层基数树，同样在 32 位平台下，以一页的大小为 8K
为例来说明，此时存储页号最多需要 19 个比特位。而二层基数树实际上就是把这
19 个比特位分为两次进行映射。例如，前 5
个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号所对应的
Span 指针。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225105536-756632135.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在二层基数树中，第一层的数组占用 <span
class="math inline">\(2^5\times 4=2^7\)</span> Bytes
空间，第二层的数组最多占用 <span class="math inline">\(2^5\times
2^{14}\times
4=2^{21}=2M\)</span>。二层基数树相比与一层基数树的好处就是，一层基数树必须一开始就把
2M
的数组开辟出来，而二层基数树一开始只需要将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p>
<p>在 32 位平台下，一层基数树和二层基数树都是适用的，但是在 64
位平台下，就需要使用下图所示的三层基数树了。三层基数树类似于二层基数树，实际上就是把存储页号的若干比特分为三次进行映射，而且只有当需要建立某一页号的映射关系时，才会开辟对应的数组空间，在一定程度上节约了内存空间：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225124800-503935249.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="简单介绍一下你的项目"><strong>简单介绍一下你的项目</strong></h3>
<p>我的这个项目是一个分布式K-V缓存系统，基于CS架构，服务器由一个中心节点和一系列存储节点构成。为客户端提供数据的基于内存的数据缓存功能。底层存储结构是通过跳表实现的。</p>
<h3 id="为什么要做这个项目"><strong>为什么要做这个项目？</strong></h3>
<p>这个项目综合性比较强，包括分布式缓存系统、服务器通信网络库以及内存池，主要是为了学习跳表、分布式存储、网络编程以及内存池等知识，将学习的东西综合应用。</p>
<h3 id="项目是为了解决什么问题">项目是为了解决什么问题？</h3>
<p>为了解决在高并发场景中的通过分布式横向扩展节点来处理更多的数据和请求，从而提高系统的容量和吞吐量。并且通过一致性哈希实现负载均衡，防止单个节点的性能瓶颈。</p>
<h3 id="有什么亮点难点"><strong>有什么亮点？难点？</strong></h3>
<p>亮点是通过一致性哈希能够实现负载均衡，并且把数据备份到下一个节点。有单一节点故障的恢复能力，能够灵活增添节点。</p>
<p>难点是在处理增添节点的时候数据的备份问题，还有服务器之间的数据传递问题。</p>
<h3 id="项目遇到哪些困难怎么解决的">项目遇到哪些困难，怎么解决的？</h3>
<h3 id="运用了哪些技术"><strong>运用了哪些技术?</strong></h3>
<p>用了一致性哈希，跳表，LRU缓存，重写Muduo网络库，以及重写了google的tcmalloc内存池。</p>
<h3 id="有什么收获"><strong>有什么收获？</strong></h3>
<p>主要是学习到了网络编程、还有分布式缓存的相关的知识，主要就是提高了C++的编码能力，没做项目之前对这些还比较陌生。</p>
<h3
id="web服务器里怎么设计的io复用"><strong>Web服务器里怎么设计的IO复用</strong></h3>
<p>使用的epoll，通过EventLoop循环调用实现。</p>
<h3
id="项目里用了线程池线程池怎么建立起来的为什么要用线程池"><strong>项目里用了线程池，线程池怎么建立起来的，为什么要用线程池</strong></h3>
<p>Muduo是one Loop per
thread模式，也就是一个线程一个事件循环。通过封装一个事件循环的线程类EventLoopThread，底层的线程通过C++11的thread类创建。然后通过for循环创新事件循环线程类，创建指定个数，会返回相应的EventLoop。当有新连接到来的时候，会调用getnextloop函数在主线程中通过轮询分配EventLoop。</p>
<p>因为单线程处理能力有限，如果多CPU的话可以并行处理数据，实现服务器的高并发。</p>
<h3
id="为什么需要使用内存池"><strong>为什么需要使用内存池？</strong></h3>
<p>因为这是基于内存的缓存系统，频繁的内存申请和释放会影响效率，而且还会出现内存碎片的问题，所以使用内存池解决这些问题。</p>
<h3
id="web服务器这个项目你用了线程池线程池开多大的呢"><strong>Web服务器这个项目你用了线程池，线程池开多大的呢</strong></h3>
<p>线程池一般是根据CPU的数量来开的，有一个主线程，线程池一般就是CPU数量
- 1个。</p>
<h3
id="整个开发过程中有没有遇到困难怎么解决的"><strong>整个开发过程中有没有遇到困难，怎么解决的</strong></h3>
<p>在数据迁移或者数据恢复的出现与预期不对的情况，通过画图，模拟哪些数据应该备份到哪里，然后调试一步一步观察数据的流动进行排错。</p>
<h3
id="能介绍一下在web服务器项目中做了什么样的测试和学习有什么样的体会"><strong>能介绍一下在web服务器项目中做了什么样的测试和学习，有什么样的体会</strong></h3>
<p>通过手动模拟计算哈希和画图查看数据迁移过程，手动添加新的节点以及Kill掉某一个节点查看系统是否正常运行。</p>
<h3
id="web服务器最主要的一个考量指标是并发处理能力想问你为了提高并发量做了怎么样的操作"><strong>web服务器最主要的一个考量指标是并发处理能力，想问你为了提高并发量做了怎么样的操作</strong></h3>
<p>网络服务器中，通过IO多路用以及线程池提高并发，存储通节点并且过内存池管理内存。</p>
<h3 id="什么是跳表"><strong>什么是跳表</strong></h3>
<p>跳表其实就是多层的有序链表，在最底层跳跃长度是1也就是普通的链表，越往上层走，跳表的下一个节点跳得越远，每一层成指数级增长。所以增删改查只需要log(N)的复杂度。</p>
<h3
id="为什么不用哈希算法或者红黑树"><strong>为什么不用哈希算法或者红黑树</strong></h3>
<p>相比哈希表，跳表是有序的，对于范围查询更有优势。而且也无需重新哈希。
相比红黑树，插入和删除操作的简便性，无需红黑树复杂的平衡操作，而且范围查询更加容易。</p>
<h3
id="一致性哈希算法是什么是用什么数据结构实现的"><strong>一致性哈希算法是什么，是用什么数据结构实现的</strong></h3>
<p>一致性哈希算法是用于分布式数据分片的做法，利用一个哈希环，将服务器节点名字哈希后注册到哈希环中。当有数据存储或者查询操作时通过哈希算法选择对应的存储节点。当发送数据迁移或者新增节点时无需进行大量数据迁移，而是只需要迁移在哈希环中有影响的节点数据即可。
使用的数据结构是红黑树（c++的map结构），方便快速寻找指定哈希值的前后节点。</p>
<h3 id="基数树是什么">基数树是什么</h3>
<p>基数树的特点是它在树中的每个节点上都存储了一串位数字或者字母，而不是单一的元素。使用三层，第一层存储0-6字节。</p>
<h3 id="为什么需要-io-多路复">为什么需要 I/O 多路复⽤？</h3>
<ol type="1">
<li><strong>提高性能</strong>：使用I/O多路复用可以减少I/O操作的开销。相比于每个I/O操作都创建一个线程或进程来处理，多路复用可以使用少量的线程或进程同时监视多个I/O通道，从而减少了上下文切换的开销，提高了系统的性能。</li>
<li><strong>节省资源</strong>：创建和管理线程或进程需要消耗系统资源，而且线程或进程的数量受到系统资源的限制。通过使用I/O多路复用，可以减少同时活跃的线程或进程数量，从而节省了系统资源。</li>
<li><strong>支持高并发</strong>：在高并发的场景下，使用I/O多路复用可以更有效地处理大量的并发连接。通过复用少量的线程或进程来处理多个I/O通道，可以更好地支持高并发的需求，提高系统的扩展性和稳定性。</li>
<li><strong>支持非阻塞I/O</strong>：I/O多路复用通常与非阻塞I/O配合使用，可以实现非阻塞的I/O操作。这样可以避免因为I/O操作阻塞导致的线程或进程被长时间挂起，提高了系统的响应速度和吞吐量。</li>
<li><strong>简化编程模型</strong>：使用I/O多路复用可以简化编程模型。开发人员不需要关注多个I/O操作的具体细节，而是可以使用简单的事件驱动模型来处理I/O事件。这样可以降低编程复杂度，提高代码的可读性和可维护性。</li>
</ol>
<h3 id="创建线程用什么api">创建线程用什么api</h3>
<p>std::thread</p>
<h3
id="如何销毁线程detach和join有什么区别">如何销毁线程，detach和join有什么区别？</h3>
<ol type="1">
<li><strong>调用
<code>std::thread::join()</code></strong>：在主线程中调用
<code>std::thread</code> 对象的 <code>join()</code>
方法可以等待该线程执行完成。主线程会阻塞，直到被等待的线程执行完成。在被等待的线程执行完成后，<code>join()</code>
方法返回，线程对象被销毁。</li>
<li><strong>调用
<code>std::thread::detach()</code></strong>：在创建线程后，可以调用
<code>std::thread</code> 对象的 <code>detach()</code>
方法将该线程“分离”出来。分离后，线程将在后台运行，不再与主线程同步。当线程执行完成后，其资源会自动释放，线程对象也会被销毁。</li>
</ol>
<h3
id="怎么保证线程安全互斥锁粒度大怎么办">怎么保证线程安全？互斥锁粒度大怎么办？</h3>
<p>使用互斥锁，锁粒度大可以使用细粒度锁。</p>
<h3
id="怎么压测压测的瓶颈在哪里是如何检测这个瓶颈的">怎么压测，压测的瓶颈在哪里，是如何检测这个瓶颈的</h3>
<p>使用webbench，例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">webbench -c 并发数 -t 运行测试时间 URL<br>例子:webbench -c 500 -t 600 http://192.168.15.112:8006/  <br></code></pre></td></tr></table></figure>
<p><strong>webbench
做压力测试时，该软件自身也会消耗CPU和内存资源，为了测试准确，请将
webbench 安装在别的服务器上。</strong></p>
<p><strong>测试时并发应当由小逐渐加大，比如并发100时观察一下网站负载是多少、打开页面是否流畅，并发200时又是多少、网站打开缓慢时并发是多少、网站打不开时并发又是多少；</strong></p>
<h4 id="瓶颈来源">瓶颈来源</h4>
<ol type="1">
<li><strong>数据库瓶颈</strong></li>
<li><strong>应用瓶颈</strong></li>
<li><strong>压测工具瓶颈</strong></li>
<li><strong>Linux 机器出现异常</strong></li>
</ol>
<h4 id="cpu"><strong>cpu</strong></h4>
<p>下面以 top 命令的输出例，对 CPU 各项主要指标进行说明：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-282ff76264cb6195e0c1cd794910ac07_720w-17112667882629.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><strong>us(user)：运行（未调整优先级的）用户进程所消耗的 CPU
时间的百分比。</strong>像 shell 程序、各种语言的编译器、数据库应用、web
服务器和各种桌面应用都算是运行在用户地址空间的进程。这些程序如果不是处于
idle 状态，那么绝大多数的 CPU 时间都是运行在用户态。</li>
<li><strong>sy(system)：运行内核进程所消耗的 CPU
时间的百分比。</strong>所有进程要使用的系统资源都是由 Linux
内核处理的。当处于用户态（用户地址空间）的进程需要使用系统的资源时，比如需要分配一些内存、或是执行
I/O
操作、再或者是去创建一个子进程，此时就会进入内核态（内核地址空间）运行。事实上，决定进程在下一时刻是否会被运行的进程调度程序就运行在内核态。对于操作系统的设计来说，消耗在内核态的时间应该是越少越好。通常
sy
比例过高意味着被测服务在用户态和系统态之间切换比较频繁，此时系统整体性能会有一定下降。<strong>在实践中有一类典型的情况会使
sy 变大，那就是大量的 I/O 操作，因此在调查 I/O
相关的问题时需要着重关注它。大部分后台服务使用的 CPU 时间片中 us 和 sy
的占用比例是最高的。同时这两个指标又是互相影响的，us 的比例高了，sy
的比例就低，反之亦然。另外，在使用多核 CPU 的服务器上，CPU 0 负责 CPU
各核间的调度，CPU 0 上的使用率过高会导致其他 CPU
核心之间的调度效率变低。因此测试过程中需要重点关注 CPU 0。</strong></li>
<li><strong>id(idle)：空闲的 CPU 时间百分比。</strong>一般情况下， us +
ni + id 应该接近 100%。线上服务运行过程中，需要保留一定的 id
冗余来应对突发的流量激增。在性能测试过程中，如果 id
一直很低，吞吐量上不去，需要检查被测服务线程/进程配置、服务器系统配置等。</li>
<li><strong>wa(I/O wait)：CPU 等待 I/O 完成时间百分比。</strong>和 CPU
的处理速度相比，磁盘 I/O 操作是非常慢的。有很多这样的操作，比如：CPU
在启动一个磁盘读写操作后，需要等待磁盘读写操作的结果。在磁盘读写操作完成前，CPU
只能处于空闲状态。<strong>Linux 系统在计算系统平均负载时会把 CPU 等待
I/O 操作的时间也计算进去，所以在我们看到系统平均负载过高时，可以通过 wa
来判断系统的性能瓶颈是不是过多的 I/O 操作造成的。磁盘、网络等 I/O
操作会导致 CPU 的 wa 指标提高。通常情况下，网络 I/O 占用的 wa
资源不会很高，而频繁的磁盘读写会导致 wa 激增。</strong>如果被测服务不是
I/O 密集型的服务，那需要检查被测服务的日志量、数据载入频率等。如果 wa
高于 10% 则系统开始出现卡顿；若高于 20% 则系统几乎动不了；若高于 50%
则很可能磁盘出现故障。</li>
</ul>
<h5 id="分析思路">分析思路</h5>
<ul>
<li>wa（IO wait）的值过高，表示硬盘存在 I/O 瓶颈。</li>
<li>id（idle）值高，表示 CPU 较空闲。</li>
<li>如果 id 值高但系统响应慢时，有可能是 CPU
等待分配内存，此时应加大内存容量。</li>
<li>如果 id 值持续低于 10，那么系统的 CPU
处理能力相对较低，表明系统中最需要解决的资源是 CPU。</li>
</ul>
<h4 id="磁盘-io">磁盘 I/O</h4>
<p><strong>iostat 参数详解</strong></p>
<p>Linux 下可以用 iostat 命令来监控磁盘状态。</p>
<p>iostat -d 2 10 表示每 2 秒统计一次基础数据，统计 10 次：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-5b2e0bd8593a1a5aca9c13f2d9ea7e2f_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>tps：该设备每秒的传输次数。“一次传输”意思是“一次 I/O
请求”。多个逻辑请求可能会被合并为“一次 I/O
请求”。“一次传输”请求的大小是未知的。</li>
<li>kB_read/s：每秒从设备（driveexpressed）读取的数据量，单位为
Kilobytes。</li>
<li>kB_wrtn/s：每秒向设备（driveexpressed）写入的数据量，单位为
Kilobytes。</li>
<li>kB_read：读取的总数据量，单位为 Kilobytes。</li>
<li>kB_wrtn：写入的总数量数据量，单位为 Kilobytes。</li>
</ul>
<h4 id="数据库-1">数据库</h4>
<p>首先找<strong>慢查询</strong></p>
<ol type="1">
<li><p>通过 SQL 语句定位到慢查询日志的所在目录，然后查看日志。</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;slow%&quot;;<br></code></pre></td></tr></table></figure></p></li>
<li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题时，查询慢查询日志并不能定位问题。这时可以使用<strong>show
processlist</strong>命令查看当前 MySQL
正在进行的线程状态，可以实时地查看 SQL 的执行情况。</p></li>
<li><p>找到慢查询 SQL 后可以用执行计划（explain）进行分析</p></li>
</ol>
<h3
id="单reactor单线程到多reactor多线程">单reactor单线程到多reactor多线程</h3>
<h4 id="单reactor单线程">单reactor单线程</h4>
<p>这种模型在Reactor中处理事件，并分发事件，如果是连接事件交给acceptor处理，如果是读写事件和业务处理就交给handler处理，但始终只有一个线程执行所有的事情。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-a3a7f2b064f424fbb11e77f019123e62_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>该线程模型的不足</p>
<ol type="1">
<li>仅用一个线程处理请求，对于多核资源机器来说是有点浪费的</li>
<li>当处理读写任务的线程负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差</li>
<li>单线程也会有可靠性的问题</li>
</ol>
<h4 id="单reactor多线程">单reactor多线程</h4>
<p>这种模型和第一种模型到的主要区别是把业务处理从之前的单一线程脱离出来，换成线程池处理，也就是Reactor线程只处理连接事件和读写事件，业务处理交给线程池处理，充分利用多核机器的资源、提高性能并且增加可靠性。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-d60a5c2c930e3ec611855d387d2429ec_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>该线程模型的不足</p>
<p>Reactor线程承担所有的事件，例如监听和响应，高并发场景下单线程存在性能问题</p>
<h4 id="多reactor多线程">多reactor多线程</h4>
<p>这种模型下和第二种模型相比是把Reactor线程拆分了mainReactor和subReactor两个部分，mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-ca0ee6f64ec8654ba143c30548874095_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>mainRactor只处理连接事件，用一个线程来处理就好。处理读写事件的subReactor个数一般和CPU数量相等，一个subReactor对应一个线程，业务逻辑由线程池处理</p>
<p>这种模型使各个模块职责单一，降低耦合度，性能和稳定性都有提高。这种模型在许多项目中广泛应用，比如Netty的主从线程模型等</p>
<h4
id="reactor三种模式形象比喻"><strong>Reactor三种模式形象比喻</strong></h4>
<p>餐厅一般有接待员和服务员，接待员负责在门口接待顾客，服务员负责全程服务顾客
Reactor的三种线程模型可以用接待员和服务员类比</p>
<ol type="1">
<li>单Reactor单线程模型：接待员和服务员是同一个人，一直为顾客服务。客流量较少适合</li>
<li>单Reactor多线程模型：一个接待员，多个服务员。客流量大，一个人忙不过来，由专门的接待员在门口接待顾客，然后安排好桌子后，由一个服务员一直服务，一般每个服务员负责一片中的几张桌子</li>
<li>多Reactor多线程模型：多个接待员，多个服务员。这种就是客流量太大了，一个接待员忙不过来了</li>
</ol>
<h3
id="free函数如何知道要释放的空间大小">free()函数如何知道要释放的空间大小？</h3>
<p>free()函数如何知道要释放的空间大小？ - 卡麦哈麦哈的回答 - 知乎
https://www.zhihu.com/question/302440083/answer/544571934</p>
<h3
id="epoll一定要比select快吗能举个例子吗">epoll一定要比select快吗，能举个例子吗？</h3>
<p><strong>不一定</strong>，文件描述符非常多时，每次都要对文件描述符进行一些操作并对参数读入时内核和用户态的切换操作导致select效率比较低。</p>
<p>但是网络环境非常好，即干扰很少，某个服务器只接受固定的计算机发来的数据(例如10台），这种情况下连接非常少，
使得epoll高效的上述因素显然不能成立了，此时可以认为epoll和select效率近似。</p>
<h3
id="epoll最多能有多少个连接这个了解吗">epoll最多能有多少个连接这个了解吗？</h3>
<p>8G内存，
一个epoll服务端，15个客户端（通过增加虚拟IP，每个客户端5万个连接），能支持的并发连接数是接近70万。</p>
<h3
id="客户端与服务器端建立tcp连接当服务器端进程core-dump之后会发生什么">客户端与服务器端建立TCP连接，当服务器端进程core
dump之后会发生什么</h3>
<p>当服务器端进程发生core
dump后，TCP连接通常会因为服务器进程的终止而关闭。客户端可能会收到一个错误，如<code>ECONNRESET</code>，表明连接被对方重置。此外，客户端的任何后续尝试发送或接收数据都会失败，因为TCP连接不再有效。</p>
<h3 id="有没有避免死锁的机制">有没有避免死锁的机制</h3>
<h3 id="介绍以下内存池怎么实现的">介绍以下内存池怎么实现的？</h3>
<h3 id="介绍以下muduo库">介绍以下muduo库</h3>
<h3
id="你了解什么是负载均衡吗腾讯云">你了解什么是负载均衡吗？（腾讯云）</h3>
<h3 id="解释一下epoll腾讯云">解释一下epoll（腾讯云）</h3>
<h3 id="红黑树腾讯云">红黑树（腾讯云）</h3>
<h3 id="跳表红黑树avl树的区别">跳表、红黑树、AVL树的区别</h3>
<h3
id="跳表红黑树avl树分别适用于什么场景">跳表、红黑树、AVL树分别适用于什么场景</h3>
<h2 id="手撕代码">手撕代码</h2>
<h3 id="线程安全的循环队列">线程安全的循环队列</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;T&gt; queue;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-type">int</span> rear;<br>    std::mutex mtx;<br>    std::condition_variable not_full;<br>    std::condition_variable not_empty;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CircularQueue</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity</span>(capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">front</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">rear</span>(<span class="hljs-number">-1</span>) &#123;<br>        queue.<span class="hljs-built_in">resize</span>(capacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        not_full.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-keyword">return</span> size &lt; capacity; &#125;);<br><br>        rear = (rear + <span class="hljs-number">1</span>) % capacity;<br>        queue[rear] = item;<br>        size++;<br><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        not_empty.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        not_empty.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-keyword">return</span> size &gt; <span class="hljs-number">0</span>; &#125;);<br><br>        T item = queue[front];<br>        front = (front + <span class="hljs-number">1</span>) % capacity;<br>        size--;<br><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        not_full.<span class="hljs-built_in">notify_one</span>();<br><br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_full</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="无锁队列">无锁队列</h3>
<p>每个节点的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueNode</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>        val;<br>    QueueNode* next;<br>    <span class="hljs-built_in">QueueNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">val</span>(val) &#123;<br>        next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而对于一个无锁队列对象而言，包含以下部分</p>
<ul>
<li>数据：队列的最大长度、链表头结点、链表尾节点</li>
<li>函数：初始化（构造函数）、入队、出队</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">lass LockFreeQueue &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LockFreeQueue</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">dequeue</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">LockFreeQueue</span>();<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>        queue_size; <span class="hljs-comment">// 暂时未使用，论文里并没有提及最大资源数</span><br>    QueueNode* tail;<br>    QueueNode* head;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/20201221172747323.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h5 id="入队操作">入队操作</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LockFreeQueue::enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    QueueNode* cur_node;<br>    QueueNode* add_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueNode</span>(val);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cur_node = tail;<br>        <span class="hljs-keyword">if</span> (__sync_bool_compare_and_swap(&amp;(cur_node-&gt;next), <span class="hljs-literal">NULL</span>, add_node)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            __sync_bool_compare_and_swap(&amp;tail, cur_node, cur_node-&gt;next);<br>        &#125;<br>    &#125;<br>    __sync_bool_compare_and_swap(&amp;tail, cur_node, add_node);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ol type="1">
<li>加入成功，那么退出循环进入倒数第三行</li>
<li>加入不成功，说明这时候有其他线程抢先往里面插入了一个节点，那么就把当前节点的位置更新为尾节点，再次进入循环直到能正确更新</li>
</ol>
<p>到了最后一个CAS的时候，只需要进行一次置尾操作，并不需要循环，原因是：如果当前线程将节点已经加进去了的话，那么其他所有线程的操作都会失败，只有当前线程更新尾节点完成后，其他线程的第二个CAS操作才能成功。</p>
<p>这里有一个小trick，明明第6行每次循环时都会更新节点，为什么还需要第二个CAS操作呢？因为在极端情况下，一个线程已经完成了增加节点操作，在置尾操作（第三个CAS）之前突然挂了，这时候就导致其他所有线程全部不能更新。</p>
<p>在左耳朵耗子的博客中，对于上述问题的解决方法描述是选用了《Implementing
Lock-Free
Queues》论文中提到的第二个方法，该方法采用的是一开始在head，然后不断找next直到找尾节点（通过多个线程共用fetch来减少开销）。本文以论文中提到的第一个方法为例进行描述（因为我觉得它更优雅）。</p>
<h5 id="出队操作">出队操作</h5>
<p>与入队操作类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LockFreeQueue::dequeue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QueueNode* cur_node;<br>    <span class="hljs-type">int</span>        val;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cur_node = head;<br>        <span class="hljs-keyword">if</span> (cur_node-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (__sync_bool_compare_and_swap(&amp;head, cur_node, cur_node-&gt;next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    val = cur_node-&gt;next-&gt;val;<br>    <span class="hljs-keyword">delete</span> cur_node;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3
id="o1时间复杂度内删除链表中的一个节点">O(1)时间复杂度内删除链表中的一个节点</h3>
<p>给你头节点head和待删除节点node，要求在O(1)时间复杂度删除node</p>
<h4 id="若node不是最后一个节点">若node不是最后一个节点</h4>
<p>把node的值与node-&gt;next的值交换，然后删除node-&gt;next即可。</p>
<h4 id="若node是最后一个节点">若node是最后一个节点</h4>
<p>仍然需要从head遍历到node的上一个节点，然后删除node，但是只有这一种个情况是O(n)，所以平均时间复杂度仍然是O（1）</p>
<h3
id="string类实现包括构造函数拷贝构造函数赋值构造析构函数">string类实现，包括构造函数，拷贝构造函数，赋值构造，析构函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str; <span class="hljs-comment">// 字符串指针</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">String</span>() &#123;<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 空字符串</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 空指针处理</span><br>            str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>            str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(str, s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; other) &#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(other.str);<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(str, other.str);<br>    &#125;<br><br>    <span class="hljs-comment">// 赋值构造函数</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 检查自赋值</span><br>        <span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 释放原有的内存空间</span><br><br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(other.str);<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(str, other.str);<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">String</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 释放内存空间</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取字符串</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3
id="实现vector类要求实现这些方法初始化整体拷贝push_backpop_backvectorpos获取指定位置的元素">实现Vector类，要求实现这些方法：初始化、整体拷贝、push_back、pop_back、vector[pos]获取指定位置的元素</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T *data; <span class="hljs-comment">// 存储元素的数组</span><br>    <span class="hljs-type">size_t</span> capacity; <span class="hljs-comment">// 数组容量</span><br>    <span class="hljs-type">size_t</span> size; <span class="hljs-comment">// 元素个数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Vector</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">capacity</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">size_t</span> initialCapacity) : <span class="hljs-built_in">capacity</span>(initialCapacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        data = <span class="hljs-keyword">new</span> T[capacity];<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">const</span> Vector&amp; other) : <span class="hljs-built_in">capacity</span>(other.capacity), <span class="hljs-built_in">size</span>(other.size) &#123;<br>        data = <span class="hljs-keyword">new</span> T[capacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            data[i] = other.data[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Vector</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加元素到末尾</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size &gt;= capacity) &#123;<br>            <span class="hljs-built_in">resize</span>(capacity * <span class="hljs-number">2</span>); <span class="hljs-comment">// 如果容量不足，扩大数组</span><br>        &#125;<br>        data[size++] = value;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除末尾元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            --size;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取指定位置的元素</span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取指定位置的元素（const版本）</span><br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前元素个数</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 调整数组容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> newCapacity)</span> </span>&#123;<br>        T *newData = <span class="hljs-keyword">new</span> T[newCapacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            newData[i] = data[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        data = newData;<br>        capacity = newCapacity;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3
id="快乐数每一位平方求和循环操作是否可以变为1">快乐数，每一位平方求和，循环操作是否可以变为1</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/description/">LC.202快乐数</a>.</p>
<h3 id="链表快排">链表快排</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">solve</span><span class="hljs-params">(ListNode* head, ListNode* pend)</span></span>&#123;<br>    <span class="hljs-comment">//链表是空或者只有一个元素就返回</span><br>    <span class="hljs-keyword">if</span>(!head||head-&gt;next==pend) <span class="hljs-keyword">return</span> head;<br>    <span class="hljs-type">int</span> val = head-&gt;val; <span class="hljs-comment">//哨兵值</span><br>    ListNode* p = head; <span class="hljs-comment">//记录“哨兵”的位置</span><br>    ListNode* q = p-&gt;next; <span class="hljs-comment">//用于遍历待排序链表的指针</span><br>    <span class="hljs-keyword">while</span>(q!=pend)&#123;<br>        <span class="hljs-comment">//发现比哨兵结点小的值就交换。从而保证p指针所指的结点比哨兵值小</span><br>        <span class="hljs-keyword">if</span>(q-&gt;val &lt; val)&#123;<br>            p = p-&gt;next;<br>            <span class="hljs-built_in">swap</span>(p-&gt;val, q-&gt;val);<br>        &#125;<br>        q = q-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//交换哨兵和p指针指向值，至此哨兵的位置就固定了</span><br>    <span class="hljs-built_in">swap</span>(head-&gt;val, p-&gt;val);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="判断一个点是否在三角形内">判断一个点是否在三角形内</h3>
<p>使用叉乘判断点是否在三角形内:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>	<span class="hljs-type">double</span> x;<br>	<span class="hljs-type">double</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInsideTriangle</span><span class="hljs-params">(Point p, Point A, Point B, Point C)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">double</span> AB = (B.x - A.x) * (p.y - A.y) - (B.y - A.y) * (p.x - A.x);<br>	<span class="hljs-type">double</span> BC = (C.x - B.x) * (p.y - B.y) - (C.y - B.y) * (p.x - B.x);<br>	<span class="hljs-type">double</span> CA = (A.x - C.x) * (p.y - C.y) - (A.y - C.y) * (p.x - C.x);<br><br>	<span class="hljs-keyword">if</span> (((AB &gt; <span class="hljs-number">0</span> &amp;&amp; BC &gt; <span class="hljs-number">0</span> &amp;&amp; CA &gt; <span class="hljs-number">0</span>) || (AB &lt; <span class="hljs-number">0</span> &amp;&amp; BC &lt; <span class="hljs-number">0</span> &amp;&amp; CA &lt; <span class="hljs-number">0</span>)))<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Point p = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>	Point A = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;;<br>	Point B = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;;<br>	Point C = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsInsideTriangle</span>(p, A, B, C))<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Point is inside the triangle.&quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Point is outside the triangle.&quot;</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="反转链表倒数k个节点前的节点">反转链表倒数k个节点前的节点</h3>
<h3 id="lc151.-反转字符串中的单词要求原地翻转">LC151.
反转字符串中的单词（要求原地翻转）</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">LC151.
反转字符串中的单词</a>.</p>
<h3 id="lc236.-二叉树的最近公共祖先">LC236. 二叉树的最近公共祖先</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">LC236.
二叉树的最近公共祖先</a>.</p>
<h3 id="lc39.-组合总和">LC39. 组合总和</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/">LC39.
组合总和</a>.</p>
<h3 id="lc7.-整数反转">LC7. 整数反转</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-integer/description/">整数反转</a>.</p>
<h3 id="稀疏矩阵乘法要优化之后的">稀疏矩阵乘法（要优化之后的）</h3>
<p>见<a
target="_blank" rel="noopener" href="https://developer.aliyun.com/article/346625">稀疏矩阵相乘</a>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 执行矩阵乘法的函数</span><br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixMul2</span>(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; A, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; B) &#123;<br>    <span class="hljs-comment">// 获取矩阵的维度</span><br>    <span class="hljs-type">int</span> m = A.<span class="hljs-built_in">size</span>();    <span class="hljs-comment">// 矩阵 A 的行数</span><br>    <span class="hljs-type">int</span> n = A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 矩阵 A 的列数 / 矩阵 B 的行数</span><br>    <span class="hljs-type">int</span> p = B[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 矩阵 B 的列数</span><br><br>    <span class="hljs-comment">// 向量用于跟踪全零的行和列</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">r_all0</span><span class="hljs-params">(m, <span class="hljs-literal">true</span>)</span></span>; <span class="hljs-comment">// 最初将所有行标记为全零</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">c_all0</span><span class="hljs-params">(p, <span class="hljs-literal">true</span>)</span></span>; <span class="hljs-comment">// 最初将所有列标记为全零</span><br><br>    <span class="hljs-comment">// 检查矩阵 A 的每一行是否有非零元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (A[i][j] != <span class="hljs-number">0</span>) &#123;<br>                r_all0[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将行标记为非全零</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不需要检查剩余元素</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查矩阵 B 的每一列是否有非零元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; p; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (B[i][j] != <span class="hljs-number">0</span>) &#123;<br>                c_all0[j] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将列标记为非全零</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不需要检查剩余元素</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 用零初始化结果矩阵</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(m, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(p, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 执行矩阵乘法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; p; ++j) &#123;<br>            <span class="hljs-comment">// 如果整行或整列都是零，则跳过计算</span><br>            <span class="hljs-keyword">if</span> (r_all0[i] || c_all0[j]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> sum_ = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于存储乘积和的变量</span><br>            <span class="hljs-comment">// 计算矩阵 A 的第 i 行与矩阵 B 的第 j 列的点积</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>                sum_ += A[i][k] * B[k][j];<br>            &#125;<br>            ans[i][j] = sum_; <span class="hljs-comment">// 存储结果</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回结果矩阵</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="lc343.-整数拆分割绳子">LC343. 整数拆分(割绳子)</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">整数拆分</a>.</p>
<h3 id="lc54.-螺旋矩阵">LC54. 螺旋矩阵</h3>
<p>见<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">螺旋矩阵</a>.</p>
<h3
id="手撕代码将一个字符串转换成字符加出现次数的形式比如aaabb转换成a3b2要求不能用任何int转str的api腾讯云">手撕代码：将一个字符串转换成字符加出现次数的形式，比如aaabb转换成a3b2（要求不能用任何int转str的api）（腾讯云）</h3>
<h3 id="手写线程池腾讯云">手写线程池（腾讯云）</h3>
<h3 id="手写智能指针腾讯云">手写智能指针（腾讯云）</h3>
<h3 id="手写读者写者">手写读者写者</h3>
<h3 id="口算99999995">口算(9^999999)%5=?</h3>
<p>求（a^b）%n。本质是快速幂，只写出递归。a、b、n都很⼤，int会爆，必须⽤long</p>
<h2 id="比赛">比赛</h2>
<h3 id="金融科技建模大赛">金融科技建模大赛</h3>
<h4 id="赛题设置">赛题设置</h4>
<p>比赛的主题是“<strong>客户复购行为预测</strong>”。银行不仅关注新客户获客，也关注老客户的复购行为，希望增加客户黏性。客户在金融产品和服务上的重复购买行为越多，客户黏性越大。银行可以通过识别这些黏性客户，更好地分析他们的需求，并向他们推送新产品，进行客户关系管理。本次比赛的目标是对客户复购频率的三分类预测。比赛选手需要根据客户信息（包括基础客户画像信息、产品购买行为信息以及第三方客户画像补充信息）预测客户复购行为标签：<strong>低频（0）、中频（1）、高频（2），并根据客户平均价值（低频1、中频3、高频5），在独立样本上检验预测准确性（加权准确性）。</strong></p>
<h4 id="数据">数据</h4>
<p>分为3个表，X1表为客户基本信息，X2表为客户消费相关信息，X3为其他信息</p>
<p>初赛训练集</p>
<p>复赛训练集15000条，测试集8000条</p>
<h4 id="特征工程">特征工程</h4>
<ul>
<li>缺失值填充：对于连续型数值特征使用均值填充，对于离散型数值使用众数填充，对于类别特征使用unknown填充</li>
<li>特征经过脱敏，比如像X1表很多只写了基本特征，可以根据其格式判断是省份，身份证号。然后可以进一步根据省份划分出东中西部地区。身份证号其实就跟省份冲突。</li>
<li>根据catboost的特征重要性分析提取出强特征，然后对强特征做交叉特征（加减乘除），然后过滤掉重要性比较低的衍生特征</li>
<li>每个客户都有多条消费记录，把这些消费记录按照客户编号进行分桶，然后统计诸如消费次数，消费平均金额，并对里边如果是数值的特征做众数、中位数、平均数、最大最小值作为新特征，以及连续消费的天数，如果是字符串的话统计不同字符串的个数，等特征（这个对于性能提升是很大的）</li>
<li>对一些重要性不是特别重要的特征但是之间可能有关联的特征，这些特征单个可能不是很重要，但是做交叉之后重要性会更高（客户货款偿付比例与收入增长的关系。这可能反映了客户的财务稳定性和收入增长的能力）</li>
</ul>
<h4 id="训练">训练</h4>
<p>使用catboost模型，使用GridSearchCV网格搜索最优参数</p>
<h3 id="xgboostcatboostlightgbm">xgboost、catboost、lightgbm</h3>
<p>选择哪个算法取决于数据集的规模、特征的类型以及任务的要求。LightGBM
适用于大规模数据和高维特征，XGBoost 适用于一般规模的数据和任务，而
CatBoost 则适用于处理类别型特征和稀疏数据的场景。</p>
<h3
id="第五届全国大学生计算机能力挑战赛">第五届全国大学生计算机能力挑战赛</h3>
<h4 id="赛题描述">赛题描述</h4>
<p>给予一批随机目标图片，选手需要将这些图片中的目标进行检测目标位置并识别目标类别。</p>
<h4 id="数据集描述">数据集描述</h4>
<p>提供少量训练集（训练集1500张图片、测试集500张图片），会在数据开放下载后陆续公布，总体为低资源的竞赛任务。训练集用于选手的模型训练，测试集存在服务器后台，用于最终结果的评测提交，不提供给选手。</p>
<p>训练集包含：1.图片文件;2.描述图片目标位置和类别文件。</p>
<h4 id="yolov8结构">YOLOv8结构</h4>
<ul>
<li>输入端：缩放图片尺寸数据、适应模型训练；</li>
<li>Backbone：模型主网络，通过卷积层数的增加，提取P1-P5不同感受野的feature
map，依次感受野逐渐增加；</li>
<li>Neck：呈现FPN和PAN结构，其中FPN (feature pyramid
networks)：特征金字塔网络，采用多尺度来对不同size的目标进行检测；PAN：自底向上的特征金字塔。这样结合操作，FPN层自顶向下传达强语义特征，而特征金字塔则自底向上传达强定位特征，两两联手，从不同的主干层对不同的检测层进行特征聚合。</li>
<li>Prediction：为model框架中的Head头，用于最终的预测输出，P3 -&gt; P4
-&gt; P5过程中，感受野是增大的，所以依次预测目标为小 -&gt; 中 -&gt;
大。</li>
</ul>
<h4 id="使用的优化方法">使用的优化方法</h4>
<h2 id="场景题">场景题</h2>
<h3
id="一个数据流中随机抽样固定大小样本字节懂车帝">一个数据流中随机抽样固定大小样本（字节懂车帝）</h3>
<p>蓄水池抽样：</p>
<ol type="1">
<li>从数据流中读取前k个元素，依次放入水塘中。</li>
<li>对于第i个元素（i &gt;
k），以1/i的概率随机选择是否将其替换水塘中的某个元素。如果被选择，则随机选择水塘中的一个位置，用当前元素替换该位置的元素。</li>
<li>处理完整个数据流后，水塘中的k个元素即为随机抽样得到的样本。</li>
</ol>
<h3
id="圆上三个点构成锐角三角形的概率">圆上三个点构成锐角三角形的概率</h3>
<p>1 / 4</p>
<h3
id="美团用户点外卖场景-如何快速筛选距离比较近的商家不要求很精确">美团用户点外卖场景
，如何快速筛选距离比较近的商家，不要求很精确</h3>
<p>ElasticSearch，倒排索引(inverted index)。</p>
<p><strong>正排索引</strong>是从文档角度来找其中的单词，表示每个文档（用文档ID标识）都含有哪些单词，以及每个单词出现了多少次（词频）及其出现位置（相对于文档首部的偏移量）。所以每次搜索都是遍历所有文章。</p>
<p><strong>倒排索引</strong>是从单词角度找文档，标识每个单词分别在那些文档中出现(文档ID)，以及在各自的文档中每个单词分别出现了多少次（词频）及其出现位置（相对于该文档首部的偏移量）。</p>
<h4 id="搜索的过程">搜索的过程：</h4>
<p>当用户输入任意的词条时，</p>
<ol type="1">
<li>首先对用户输入的数据进行分词，得到用户要搜索的所有词条。</li>
<li>然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。</li>
<li>最后根据这些编号去文档列表中找到文档</li>
</ol>
<h4 id="创建倒排索引分为以下几步">创建倒排索引，分为以下几步：</h4>
<ol type="1">
<li>创建文档列表：lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表</li>
<li>创建倒排索引列表：然后对文档中数据进行分词，得到词条。对词条进行编号，以词条创建索引。然后记录下包含该词条的所有文档编号（及其它信息）。</li>
</ol>
<h3
id="我有1t空间的url怎么考虑统计出现top10000的url">我有1T空间的url，怎么考虑统计出现top10000的url</h3>
<p>处理1TB数据以找到出现次数最多的前10000个URL是一个大数据问题。这里有一个可能的解决方案，使用MapReduce编程模型：</p>
<ol type="1">
<li><strong>Map阶段</strong>：将数据分割成更小的块，每个块由一个Map任务处理。Map任务读取URL，然后为每个URL生成键值对，键是URL，值是1。</li>
<li><strong>Shuffle阶段</strong>：系统将所有键值对按键（URL）进行排序和合并，以便所有相同的键（URL）都在一起。</li>
<li><strong>Reduce阶段</strong>：每个Reduce任务处理一组具有相同键的键值对，累加值以计算每个URL的总出现次数。</li>
<li><strong>最后处理</strong>：所有Reduce任务的输出被合并，然后可以使用一个排序算法来找到出现次数最多的前10000个URL。</li>
</ol>
<h4
id="如果是分布式的场景即有多个机子上都有很多url现在怎么考虑">如果是分布式的场景，即有多个机子上都有很多url，现在怎么考虑</h4>
<p>在分布式系统中处理大量URL的情况，你可以采用以下步骤：</p>
<ol type="1">
<li><strong>数据分片</strong>：首先，将1TB的数据均匀分配到多个机器上。</li>
<li><strong>本地统计</strong>：每台机器上运行<strong>MapReduce</strong>任务，本地统计每个URL出现的次数。</li>
<li><strong>全局合并</strong>：将所有机器上的本地统计结果合并，这通常涉及到一个中心节点或使用另一个MapReduce作业来完成。</li>
<li><strong>Top K算法</strong>：在合并后的全局数据上运行Top
K算法（如Min-Heap或<strong>MapReduce</strong>中的Secondary
Sort）来找到出现次数最多的前10000个URL。</li>
</ol>
<h3
id="有140g沙子现在有7g和2g的砝码各一个并有一个天平用最少次数把沙子分为50g和90g">有140g沙子，现在有7g和2g的砝码各一个，并有一个天平，用最少次数把沙子分为50g和90g</h3>
<ol type="1">
<li>用7 + 2 = 9g称两次得到18g</li>
<li>用7g称一次加上之前的18g一共是25g</li>
<li>用这25g沙子再称25g沙子得到50g</li>
</ol>
<p>一共4次。</p>
<h2 id="其他">其他</h2>
<h3 id="你都知道哪些消息队列">你都知道哪些消息队列</h3>
<ul>
<li>Kafka</li>
<li>RocketMQ</li>
<li>RabbitMQ</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试问题</div>
      <div>https://gstarmin.github.io/2024/03/11/面试问题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Starmin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/28/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="tensort学习记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">tensort学习记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/10/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="海量数据处理">
                        <span class="hidden-mobile">海量数据处理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
