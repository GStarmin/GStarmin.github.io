

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Starmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试问题 C++ C++编译生成可执行文件的顺序  预处理：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。 编译：预处理后的源代码会被编译器编译成汇编代码（Assembly code），汇编代码是与特定架构相关的低级代码。 汇编：汇编器将汇编代码转换为机器代码（Object code），这是由二进制表示的机器可执行代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题">
<meta property="og:url" content="https://gstarmin.github.io/2024/03/11/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">
<meta property="og:site_name" content="私人杂货铺">
<meta property="og:description" content="面试问题 C++ C++编译生成可执行文件的顺序  预处理：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。 编译：预处理后的源代码会被编译器编译成汇编代码（Assembly code），汇编代码是与特定架构相关的低级代码。 汇编：汇编器将汇编代码转换为机器代码（Object code），这是由二进制表示的机器可执行代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820334293.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.1.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.2.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.3.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.4.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.5.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.6.jpg">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/mempool.png">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/centralcache.png">
<meta property="og:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/pagecache.png">
<meta property="article:published_time" content="2024-03-11T08:35:54.000Z">
<meta property="article:modified_time" content="2024-03-11T08:35:54.000Z">
<meta property="article:author" content="Starmin">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gstarmin.github.io/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg">
  
  
  
  <title>面试问题 - 私人杂货铺</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gstarmin.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Starmin</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试问题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-11 16:35" pubdate>
          2024年3月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          403 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试问题</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试问题">面试问题</h1>
<h2 id="c">C++</h2>
<h3 id="c编译生成可执行文件的顺序">C++编译生成可执行文件的顺序</h3>
<ol type="1">
<li><strong>预处理</strong>：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。</li>
<li><strong>编译</strong>：预处理后的源代码会被编译器编译成汇编代码（Assembly
code），汇编代码是与特定架构相关的低级代码。</li>
<li><strong>汇编</strong>：汇编器将汇编代码转换为机器代码（Object
code），这是由二进制表示的机器可执行代码。</li>
<li><strong>链接</strong>：在链接阶段，编译器将所有的对象文件和库文件链接在一起，生成最终的可执行文件。这个过程包括解析符号引用、符号重定位和符号表的生成等操作。</li>
<li><strong>生成可执行文件</strong>：最终，链接器生成可执行文件，该文件包含了所有必要的机器代码和元数据，可以在相应的操作系统上运行。</li>
</ol>
<h3
id="c语言指针需要注意的地方腾讯云">C语言，指针需要注意的地方（腾讯云）</h3>
<ol type="1">
<li>要避免使用未初始化的指针</li>
<li>指针赋值时一定要保证类型匹配，由于指针类型确定指针所指向对象的类型，因此初始化或赋值时必须保证类型匹配，这样才能在指针上执行相应的操作。</li>
<li>void *
类型的指针，其实这种形式只是记录了一个地址罢了，如上所说，由于不知道所指向的数据类型是什么所以不能进行相应的操作。其实void
* 指针仅仅支持几种有限的操作：
<ol type="1">
<li>与另外的指针进行比较，因为void
*类型里面就是存的一个地址，所以这点很好理解；</li>
<li>向函数传递void <em>指针或从函数返回void
</em>指针，举个例子吧，我们平时常用的库函数qsort中的比较函数cmp（个人习惯于用这个名字）中传递的两个参数就是const
void *类型的，用过的应该很熟了；</li>
<li>给另一个void * 类型的指针赋值。还是强调一下不能使用void *
指针操纵它所指向的对象。</li>
</ol></li>
<li>在为一个指针再次分配内存之前要保证它原先没有指向其他内存，防止出现内存泄漏。</li>
</ol>
<h3 id="编译链接过程了解过吗腾讯云">编译链接过程了解过吗（腾讯云）</h3>
<h3 id="多态怎样实现的腾讯云">多态怎样实现的（腾讯云）</h3>
<h3
id="字符串中变量的地址相差多少腾讯云">字符串中变量的地址相差多少（腾讯云）</h3>
<h3
id="静态存储区的变量什么时候销毁腾讯云">静态存储区的变量什么时候销毁（腾讯云）</h3>
<h3
id="类中同名对象地址相同吗腾讯云">类中同名对象地址相同吗（腾讯云）</h3>
<h3
id="类中不同类型对象地址相差多少腾讯云">类中不同类型对象地址相差多少（腾讯云）</h3>
<h3 id="listensocketaccpet函数参数">listen、socket、accpet函数参数</h3>
<h3 id="c-vector-sizecapacity-的区别如何缩容">C++ vector size/capacity
的区别，如何缩容？</h3>
<ol type="1">
<li><strong>size()</strong>：返回向量中当前存储的元素数量，即实际使用的元素个数。</li>
<li><strong>capacity()</strong>：返回向量当前分配的内存空间大小，即向量的容量。容量可以大于或等于实际存储的元素数量。</li>
</ol>
<p>如果需要手动缩减向量的容量，可以使用<code>shrink_to_fit()</code>方法。这个方法会释放多余的内存，使得向量的容量等于实际存储的元素数量。</p>
<h3 id="cpp---可执件的过程追问链接阶段的详细过程">.cpp -&gt;
可执⾏⽂件的过程，追问：链接阶段的详细过程</h3>
<ol type="1">
<li><strong>预处理阶段</strong>：
<ul>
<li>预处理器会处理源文件，包括执行宏替换、包含头文件、去除注释等操作，生成预处理后的源文件。</li>
</ul></li>
<li><strong>编译阶段</strong>：
<ul>
<li>编译器会将预处理后的源文件编译成目标文件（object
file），包括词法分析、语法分析、语义分析、优化等步骤。每个源文件对应一个目标文件。</li>
</ul></li>
<li><strong>汇编阶段</strong>：
<ul>
<li>汇编器将编译生成的目标文件转换成机器码，生成可重定位的机器代码文件。</li>
</ul></li>
<li><strong>链接阶段</strong>：
<ul>
<li>链接器将多个目标文件和库文件链接成可执行文件，包括以下步骤：
<ul>
<li><strong>符号解析（Symbol
Resolution）</strong>：链接器会将目标文件中的符号与其定义关联起来，包括函数和全局变量的定义与引用。</li>
<li><strong>地址重定位（Address
Binding）</strong>：链接器会将目标文件中的符号地址与实际内存地址关联起来，生成可执行文件中的地址映射表。</li>
<li><strong>符号合并（Symbol
Merging）</strong>：如果多个目标文件中存在相同的符号，则链接器会将这些符号合并为一个，以避免重复定义。</li>
</ul></li>
</ul></li>
<li><strong>生成可执行文件</strong>：
<ul>
<li>链接器根据符号解析、地址重定位和符号合并生成可执行文件，其中包含了所有的目标文件和库文件，并且解析了所有的符号引用。</li>
</ul></li>
</ol>
<h3 id="有哪些键值型的存储结构">有哪些键值型的存储结构</h3>
<h3 id="stl-的sort是怎么实现的">STL 的sort是怎么实现的？</h3>
<p>STL的sort算法，数据量大时采用<strong>QuickSort快排算法</strong>，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用<strong>Insertion
Sort插入排序</strong>。如果递归层次过深，还会改用<strong>HeapSort堆排序</strong>。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-8fa032e195365f77fb6b980a4ed71958_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="数据库存储为什么-b-树不-avl-树">数据库存储为什么⽤ B+ 树，不⽤
AVL 树。</h3>
<p>思路和不用B树一样，B+树方便遍历，方便范围查找，而且AVL树数据量大的时候可能会频繁旋转调整平衡。</p>
<h3 id="int-和const不同位置代表什么意思">int*
和const不同位置代表什么意思</h3>
<ul>
<li>当<code>const</code>位于指针类型前面时，如<code>const int* ptr</code>，表示指针指向的数据是常量，不能通过指针修改所指向的数据，但指针本身可以修改，即指针是可变的，但指向的数据是不可变的。</li>
<li>当<code>const</code>位于指针类型后面时，如<code>int* const ptr</code>，表示指针本身是常量，不能修改指针指向的内存地址，但指针所指向的数据可以修改。</li>
</ul>
<h3 id="为什么栈的速度比堆快">为什么栈的速度比堆快</h3>
<p>栈是操作系统提供的数据结构，计算机底层对他提供了一系列的支持：分配专门的寄存器存储寄存器地址，压栈和出栈都有相应的指令；
而堆是C/C++库函数提供的，机制复杂，需要一些分配内存，合并内存，释放内存的算法，所以效率低。</p>
<h3 id="detach和join有什么区别">detach和join有什么区别</h3>
<p><code>detach()</code>方法将一个线程从原始线程中分离出来，使其独立运行；而<code>join()</code>方法用于等待一个线程执行完毕后再继续执行原始线程。</p>
<h3 id="c有哪些锁">C++有哪些锁</h3>
<p>线程之间的锁有：
<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong>。一般而言，锁的功能与性能成反比。</p>
<h4 id="互斥锁mutex">互斥锁（Mutex）</h4>
<p>互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。</p>
<h5 id="mutex">mutex</h5>
<p>对于 <code>std::mutex</code>
对象，任意时刻最多允许一个线程对其进行上锁</p>
<ul>
<li>mtx.lock()：调用该函数的线程尝试加锁。如果上锁不成功，即：其它线程已经上锁且未释放，则当前线程<code>block</code>。如果上锁成功，则执行后面的操作，操作完成后要调用
<code>mtx.unlock()</code> 释放锁，否则会导致死锁的产生</li>
<li>mtx.unlock()：释放锁，<code>std::mutex</code>
还有一个操作：<code>mtx.try_lock()</code>，字面意思就是：“尝试上锁”，与
<code>mtx.lock()</code>
的不同点在于：如果上锁不成功，当前线程不阻塞。</li>
</ul>
<h5 id="lock_guard">lock_guard</h5>
<p>虽然 <code>std::mutex</code>
可以对多线程编程中的共享变量提供保护，但是直接使用
<code>std::mutex</code> 的情况并不多。因为仅使用 <code>std::mutex</code>
有时候会发生死锁。</p>
<p>考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2“永久的等待下去”，此时就发生了死锁。</p>
<p><code>std::lock_guard</code>
只有构造函数和析构函数。简单的来说：当调用构造函数时，会自动调用传入的对象的lock()函数，而当调用析构函数时，自动调用
<code>unlock()</code> 函数（这就是所谓的RAII）。</p>
<p><code>lock_guard</code> 还有一个构造函数
<code>lock_guard( mutex_type&amp; m, std::adopt_lock_t t );</code>
其中第二个参数类型为：<code>std::adopt_lock_t</code>。<strong>这个构造函数假定：当前线程已经上锁成功，所以不再调用lock()函数</strong>。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用互斥元保护列表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br> <br>std::list&lt;<span class="hljs-type">int</span>&gt; some_list;<br>std::mutex some_mutex;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_list</span><span class="hljs-params">(<span class="hljs-type">int</span> new_value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(some_mutex)</span></span>;<br>    some_list.<span class="hljs-built_in">push_back</span>(new_value);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="条件锁">条件锁</h4>
<p>当需要死循环判断某个条件成立与否时【true or
false】，我们往往需要开一个线程死循环来判断，这样<strong>非常消耗CPU</strong>。使用条件变量，可以让当前线程
<code>wait</code>，释放CPU，如果条件改变时，我们再<code>notify</code>退出线程，再次进行判断。</p>
<p>条件锁就是所谓的条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程(常和互斥锁配合使用)，唤醒后，需要检查变量，避免虚假唤醒。</p>
<p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p>
<p><strong>c++用法</strong>：</p>
<p>任意要等待 <code>std::condition_variable</code> 的线程必须获取
<code>std::unique_lock&lt;std::mutex&gt;</code>，这个 <code>mutex</code>
正是用来保护共享变量（即“条件”）的。执行 <code>wait</code> ,
<code>wait_for</code> 或者
<code>wait_until</code>。这些等待动作原子性地释放
<code>mutex</code>，并使得线程的执行暂停。</p>
<p>当前线程调用 <code>wait()</code>
后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁
lck)，直到另外某个线程调用 <code>notify_*</code> 唤醒了当前线程。</p>
<p>在线程被阻塞时，该函数会自动调用 <code>lck.unlock()</code>
释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知<code>(notified</code>，通常是另外某个线程调用
<code>notify_*</code> 唤醒了当前线程)，wait() 函数也是自动调用
lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>std::mutex mu;<br>std::condition_variable cond;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span> <span class="hljs-comment">//生产者</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>        q.<span class="hljs-built_in">push_front</span>(count);<br>        locker.<span class="hljs-built_in">unlock</span>();<br>        cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// Notify one waiting thread, if there is one.</span><br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>        count--;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span> <span class="hljs-comment">//消费者</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">empty</span>())<br>            cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// Unlock mu and wait to be notified</span><br>        data = q.<span class="hljs-built_in">back</span>();<br>        q.<span class="hljs-built_in">pop_back</span>();<br>        locker.<span class="hljs-built_in">unlock</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(function_1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(function_2)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="自旋锁">自旋锁</h4>
<p>假设我们有一个两个处理器<code>core1</code>和<code>core2</code>计算机，现在在这台计算机上运行的程序中有两个线程：<code>T1</code>和<code>T2</code>分别在处理器<code>core1</code>和<code>core2</code>上运行，两个线程之间共享着一个资源。</p>
<p>首先我们说明互斥锁的工作原理，互斥锁是是一种
<code>sleep-waiting</code>
的锁。假设线程<code>T1</code>获取互斥锁并且正在<code>core1</code>上运行时，此时线程<code>T2</code>也想要获取互斥锁（pthread_mutex_lock），但是由于<code>T1</code>正在使用互斥锁使得<code>T2</code>被阻塞。当<code>T2</code>处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器<code>core2</code>会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p>
<p>而自旋锁就不同了，自旋锁是一种 <code>busy-waiting</code>
的锁。也就是说，如果<code>T1</code>正在使用自旋锁，而<code>T2</code>也去申请这个自旋锁，此时<code>T2</code>肯定得不到这个自旋锁。与互斥锁相反的是，此时运行<code>T2</code>的处理器<code>core2</code>会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p>
<p>从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。</p>
<p>当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。
通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用户空间用 atomic_flag 实现自旋互斥</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br> <br>std::atomic_flag lock = ATOMIC_FLAG_INIT;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; cnt &lt; <span class="hljs-number">100</span>; ++cnt) &#123;<br>        <span class="hljs-keyword">while</span> (lock.<span class="hljs-built_in">test_and_set</span>(std::memory_order_acquire))  <span class="hljs-comment">// 获得锁</span><br>             ; <span class="hljs-comment">// 自旋</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        lock.<span class="hljs-built_in">clear</span>(std::memory_order_release);               <span class="hljs-comment">// 释放锁</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;std::thread&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">10</span>; ++n) &#123;<br>        v.<span class="hljs-built_in">emplace_back</span>(f, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : v) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>atomic</code> 是C标准程序库中的一个头文件，定义了 C11
标准中的一些表示线程、并发控制时原子操作的类与方法等。此头文件主要声明了两大类原子对象：<code>std::atomic</code>和<code>std::atomic_flag</code>。</p>
<ul>
<li><p><code>atomic_flag</code> 类</p>
<p>是一种简单的原子布尔类型，只支持两种操作：<code>test_and_set(flag=true)</code>
和 <code>clear(flag=false)</code>。</p></li>
<li><p><code>std::atomic</code> 类模板</p></li>
<li><p><code>std::atomic</code>
既不可复制亦不可移动。<code>atomic</code> 对
<code>int</code>、<code>char</code>、<code>bool</code>
等数据结构进行了原子性封装，在多线程环境中，对 <code>std::atomic</code>
对象的访问不会造成竞争-冒险。利用 <code>std::atomic</code>
可实现数据结构的无锁设计。</p></li>
</ul>
<p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。<strong>使用原子操作能大大的提高程序的运行效率</strong>。</p>
<h4 id="读写锁">读写锁</h4>
<p>先看互斥锁，它只有两个状态，要么是加锁状态，要么是不加锁状态。假如现在一个线程
<code>a</code> 只是想读一个共享变量
<code>i</code>，因为不确定是否会有线程去写它，所以我们还是要对它进行加锁。但是这时又有一个线程<code>b</code>试图去读共享变量
<code>i</code>，发现被锁定了，那么<code>b</code>不得不等到<code>a</code>释放了锁后才能获得锁并读取
<code>i</code>
的值，但是两个读取操作即使是同时发生的，也并不会像写操作那样造成竞争，因为它们不修改变量的值。所以我们期望在多个线程试图读取共享变量的时候，它们可以立刻获取因为读而加的锁，而不是需要等待前一个线程释放。</p>
<p>读写锁可以解决上面的问题。它提供了比互斥锁更好的并行性。因为以读模式加锁后，当有多个线程试图再以读模式加锁时，并不会造成这些线程阻塞在等待锁的释放上。</p>
<p>读写锁是多线程同步的另外一个机制。在一些程序中存在读操作和写操作问题，对某些资源的访问会存在两种可能情况，一种情况是访问必须是排他的，就是独占的意思，这种操作称作<strong>写操作</strong>，另外一种情况是访问方式是可以共享的，就是可以有多个线程同时去访问某个资源，这种操作称为<strong>读操作</strong>。这个问题模型是从对文件的读写操作中引申出来的。把对资源的访问细分为读和写两种操作模式，这样可以大大增加并发效率。读写锁比互斥锁适用性更高，并行性也更高。</p>
<p>需要注意的是，这里只是说<strong>并行效率比互斥高，并不是速度一定比互斥锁快，读写锁更复杂，系统开销更大</strong>。并发性好对于用户体验非常重要，假设互斥锁需要0.5秒，使用读写锁需要0.8秒，在类似学生管理系统的软件中，可能90%的操作都是查询操作。如果突然有20个查询请求，使用的是互斥锁，则最后的查询请求被满足需要10秒，估计没人能接受。使用读写锁时，因为读锁能多次获得，所以20个请求中，每个请求都能在1秒左右被满足，用户体验好的多。</p>
<p><strong>特点</strong>：</p>
<ol type="1">
<li>如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样可以有多个线程并行操作。这个时候如果再用写锁加锁就会发生阻塞。写锁请求阻塞后，后面继续有读锁来请求时，这些后来的读锁都将会被阻塞。这样避免读锁长期占有资源，防止写锁饥饿。</li>
<li>如果一个线程用写锁锁住了临界区，那么其他线程无论是读锁还是写锁都会发生阻塞。</li>
</ol>
<p><strong>c++用法</strong>：</p>
<p>STL本身并没有提供读写锁（Read-Write
Lock）的实现。Boost中的<code>boost::shared_mutex</code>和<code>unique_lock</code>提供了读写锁的实现，可以用于实现多读单写的并发控制。</p>
<p>简单的说：</p>
<ol type="1">
<li><code>shared_lock</code> 是
<code>read_lock</code>。被锁后仍允许其他线程执行同样被
<code>shared_lock</code> 的代码。这是一般做读操作时的需要。</li>
<li><code>unique_lock</code> 是
<code>write_lock</code>。被锁后不允许其他线程执行被
<code>shared_lock</code> 或 <code>unique_lock</code>
的代码。在写操作时，一般用这个，可以同时限制 <code>unique_lock</code>
的写和 <code>share_lock</code> 的读。</li>
</ol>
<p>注：C++ 11
中提供了<code>unique_lock</code>且功能和用法与<code>boost::unique_lock</code>一直，但是C++
11并没有提供<code>shared_lock</code></p>
<h4 id="递归锁">递归锁</h4>
<p><code>std::recursive_mutex</code> 与 <code>std::mutex</code>
一样，也是一种可以被上锁的对象，但是和 <code>std::mutex</code>
不同的是，<code>std::recursive_mutex</code>
允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，<code>std::recursive_mutex</code>
释放互斥量时需要调用与该锁层次深度相同次数的
<code>unlock()</code>，可理解为 <code>lock()</code> 次数和
<code>unlock()</code>
次数相同，除此之外，<code>std::recursive_mutex</code> 的特性和
<code>std::mutex</code> 大致相同。</p>
<p>例如函数 <code>a</code> 需要获取锁 <code>mutex</code>，函数
<code>b</code> 也需要获取锁 <code>mutex</code>，同时函数 <code>a</code>
中还会调用函数 <code>b</code>。如果使用<code>std::mutex</code>
必然会造成死锁。但是使用 <code>std::recursive_mutex</code>
就可以解决这个问题。</p>
<p>参考<a
target="_blank" rel="noopener" href="https://www.zywvvd.com/notes/coding/cpp/cpp-lock/cpp-lock/#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89">C++
多线程 —— 锁</a></p>
<h3 id="了解哪些c-11-的新特性">了解哪些C++ 11 的新特性</h3>
<ol type="1">
<li><strong>自动类型推断（auto）</strong>:可以使用<code>auto</code>关键字来声明变量，让编译器根据初始化表达式的类型推断变量的类型。</li>
<li><strong>范围-based for
循环</strong>：使用<code>for</code>循环可以遍历容器中的元素，语法更简洁直观。</li>
<li><strong>nullptr</strong>:引入了空指针常量<code>nullptr</code>，用于表示空指针。</li>
<li><strong>Lambda
表达式</strong>:可以使用Lambda表达式来创建匿名函数，使得在函数式编程风格中更方便地使用。</li>
<li><strong>移动语义和右值引用</strong>：引入了右值引用和移动语义，可以通过移动而不是复制来提高程序的性能。</li>
<li><strong>智能指针</strong>：引入了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>等智能指针，用于管理动态分配的内存，避免内存泄漏和悬空指针问题。</li>
<li><strong>初始化列表</strong>：引入了初始化列表语法，可以通过<code>&#123;&#125;</code>来初始化数组、容器、结构体等。</li>
</ol>
<h3 id="weakptr如何获得sharedptr">weakPtr如何获得sharedPtr</h3>
<p><code>weak_ptr</code>对象不能直接被用于获取指向的对象，因为其不拥有所指向对象的所有权。但是可以通过<code>weak_ptr</code>对象的<code>lock()</code>成员函数获得一个指向所指对象的<code>shared_ptr</code>对象，前提是该对象还存在。</p>
<h3 id="右值引用的用途">右值引用的用途</h3>
<p><strong>移动语义（Move Semantics）</strong>：
右值引用使得移动语义成为可能。传统的复制操作会对资源进行深拷贝，而移动语义则允许将资源从一个对象“移动”到另一个对象，而不是进行昂贵的深拷贝操作。这在动态内存管理、容器类的元素操作以及返回临时对象等场景下都有很大的性能提升。</p>
<p><strong>完美转发（Perfect Forwarding）</strong>：
右值引用可以在函数模板中实现完美转发，即<strong>保持原始参数类型的引用类型</strong>。这使得函数模板可以将参数完全转发给其他函数，而不会对参数类型造成额外的包装或变化，保持了原始参数的准确性。</p>
<h3 id="函数重载底层原理">函数重载底层原理</h3>
<p>首先C语言不支持函数重载，程序在预编译阶段会经历预<strong>处理、编译、汇编和链接生成可执行程序</strong>的过程，在汇编过程中编译器会收集<strong>全局符号</strong>并生成全局符号表（将符号和其相应地址一一对应的表格称为符号表）。C语言不支持函数重载的原因是符号表中的出现了两个具有有效地址的函数名，所以发生了冲突。</p>
<p><strong>C++对写入符号表的函数具有一个修正的过程</strong>，Linux下的命名规则做如下总结：</p>
<blockquote>
<p>**_Z + 函数名长度 + 函数名 + 类型首字母的小写**</p>
</blockquote>
<h3 id="c-编译器都做了哪些优化">C++ 编译器都做了哪些优化？</h3>
<ul>
<li>常量折叠（constant
folding）。编译器将编译期能计算为常量的表达式直接替换为计算结果。</li>
<li>常量传播（constant
propagation）。编译器追踪到一个值的源头，发现它是常量后，会将所有地方出现的这个值替换为常量。</li>
<li>公共子表达式消除（common subexpression
elimination）。将重复的计算过程重写掉，只算一次，其它地方复制结果。</li>
<li>移除死代码（dead code
removal）。用许多其它方法优化后，可能有些代码对输出不产生影响，就可以移除这些代码。这里包含了对没用到的值的读写操作，以及完全没用到的整个函数或表达式。</li>
<li>指令选择（instruction
selection）。这个不算是通常意义的优化，但既然编译器会将程序转换为它的内部表示形式，并生成CPU指令，编译器通常有一个庞大的等效指令序列的集合可供选择。编译需要知道目标处理器架构的细节以作出正确选择。</li>
<li>移动循环中的不变代码（loop invariant code
movement）。编译器能识别一块代码在循环过程中值不变，并将这块代码移出循环。其于此，编译器还能将循环中不变的条件检查移出循环外，再将循环体复制两次：一次针对条件为真，一次针对条件为假。之后还能做进一步优化。</li>
<li>窥孔优化（peephole
optimization）。编译器取一小段指令序列并做局部优化。</li>
<li>尾调用移除（tail call
removal）。一个在结尾处调用自身的递归函数通常可被重写为循环，从而降低函数调用开销，并减小栈溢出的可能。</li>
</ul>
<h3 id="大端小端">大端小端</h3>
<h3 id="大端模式与小端模式">大端模式与小端模式</h3>
<ol type="1">
<li>大端模式是指<strong>数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中</strong>.</li>
<li>小端模式是指<strong>数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中</strong>。</li>
</ol>
<p>例如：</p>
<p>一个16bit的short型x，在<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>中的地址为0x0010，x的值为0x1122。那么0x11为数据高字节，0x22为数据低字节。</p>
<ol type="1">
<li>对于大端模式，就将0x11放在内存低地址中，即0x0010中；0x22放在内存高地址中，即0x0011中。</li>
<li>小端模式，就将0x11放在内存高地址中，即0x0011中；0x22放在内存低地址中，即0x0010中。</li>
</ol>
<p>怎么判断大端小端？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLittleEndian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 将整数强制转换为字符指针，然后检查第一个字节的值</span><br>    <span class="hljs-comment">// 如果是小端序，最低有效字节会被存储在低地址处</span><br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">char</span> *)&amp;num == <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLittleEndian</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This system is Little Endian.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This system is Big Endian.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如何让哈希表按插入的顺序有序">如何让哈希表按插入的顺序有序</h3>
<p>设置一个哈希表和一个双向链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; umap;<br>list&lt;<span class="hljs-type">int</span>&gt; l;<br></code></pre></td></tr></table></figure>
<p>取值可以使用<code>umap[key]-&gt;val</code>做到<code>O(1)</code>,同时<code>l</code>中也按照插入顺序有序。</p>
<h3
id="make_shared与直接创建shared_ptr的区别">make_shared与直接创建shared_ptr的区别</h3>
<p>make_shared 只需要分配一次内存，而直接创建 shared_ptr
需要分配两次内存。</p>
<p>make_shared也存在缺陷，只有当 _Weaks 为 0 时，控制块才会调用
_Delete_this() 释放自己，weak_ptr会拖延整块内存释放时间。</p>
<h2 id="linux">Linux</h2>
<h2
id="linux系统查看cpu占用的命令腾讯云">linux系统查看cpu占用的命令（腾讯云）</h2>
<ol type="1">
<li><p>top命令可以看到总体的系统运行状态和cpu的使用率</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>top -u root<br></code></pre></td></tr></table></figure></p></li>
<li><p>htop命令是top命令的增强版(默认情况htop没有安装在linux上，所以要先安装)</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">htop<br></code></pre></td></tr></table></figure></p></li>
<li><p>使用ps命令来查看cpu使用率</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps aux | sort -nrk 3,3 | head -n 5<br></code></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="gdb如何调试">gdb如何调试</h3>
<ol type="1">
<li><p><strong>编译程序时加上调试信息</strong>：
在使用GDB进行调试之前，需要确保编译程序时包含调试信息。通常可以通过在编译命令中添加<code>-g</code>选项来生成调试信息，例如：</p>
<p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -g -o my_program my_program.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>启动GDB</strong>：
在命令行中输入<code>gdb</code>命令，然后在GDB提示符下输入要调试的可执行文件的名称，例如：</p>
<p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb my_program</span><br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>设置断点</strong>：
在GDB中设置断点，以便在程序执行到指定位置时停止执行。可以通过以下命令设置断点：</p>
<ul>
<li><code>break function_name</code>：在指定函数的入口处设置断点。</li>
<li><code>break line_number</code>：在指定行号处设置断点。</li>
<li><code>break file_name:line_number</code>：在指定文件的指定行号处设置断点。</li>
</ul></li>
</ol>
<h3
id="gdb运行报错如何通过core件找到错误">gdb运行报错如何通过core⽂件找到错误</h3>
<ol type="1">
<li><p><strong>编译程序时包含调试信息</strong>：
在编译程序时确保包含了调试信息，以便在后续调试时能够查看到源代码的信息。使用编译器选项<code>-g</code>来生成调试信息。</p></li>
<li><p><strong>使用GDB调试core文件</strong>：
在命令行中输入以下命令：</p></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb &lt;executable_file&gt; &lt;core_file&gt;<br></code></pre></td></tr></table></figure>
<p>其中，<code>&lt;executable_file&gt;</code>是你编译的可执行文件的名称，<code>&lt;core_file&gt;</code>是core文件的名称。</p>
<p><strong>分析core文件</strong>：
在GDB中加载core文件后，可以使用<code>bt</code>命令查看堆栈回溯信息，以确定程序崩溃时的函数调用栈。例如：</p>
<ol start="3" type="1">
<li><strong>分析core文件</strong>：
在GDB中加载core文件后，可以使用<code>bt</code>命令查看堆栈回溯信息，以确定程序崩溃时的函数调用栈。例如：</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> bt<br></code></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>查看变量值</strong>：
在确定了程序崩溃的位置后，可以使用GDB中的命令查看局部变量、全局变量等的值，以帮助分析错误。例如：</li>
</ol>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">(gdb) p <span class="hljs-keyword">variable</span><span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure>
<ol start="5" type="1">
<li><strong>分析源代码</strong>：
使用GDB中的命令在源代码中查看程序崩溃的位置以及附近的代码，帮助理解问题所在。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) list<br></code></pre></td></tr></table></figure>
<h3 id="如何加断点具体api调">如何加断点，具体api调⽤</h3>
<p>使用break命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break example.c:20<br></code></pre></td></tr></table></figure>
<p>调用api不会</p>
<h3 id="gdb如何查看函数调用栈">gdb如何查看函数调用栈</h3>
<ol type="1">
<li><p>在终端中启动 GDB 并加载你的可执行文件：</p>
<p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb your_executable</span><br></code></pre></td></tr></table></figure></p></li>
<li><p>运行程序，直到你想要查看函数调用栈的地方。</p></li>
<li><p>在 GDB 提示符下，输入 <code>bt</code> 或 <code>backtrace</code>
命令：</p>
<p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> bt<br></code></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="epoll函数参数">epoll函数参数</h3>
<p>在使用 Linux 中的 epoll API 进行事件驱动编程时，主要使用的函数是
<code>epoll_create</code>、<code>epoll_ctl</code> 和
<code>epoll_wait</code>。下面是它们的基本参数：</p>
<ol type="1">
<li><strong>epoll_create(int size)：</strong>
<ul>
<li><code>size</code>：指定需要监听的文件描述符的数量的估计值。这个参数在
epoll
实例被内核创建时用于分配内部数据结构的大小。通常情况下，你可以将其设置为大于
0 的任意值，因为内核会根据需要调整大小。但是，对于 Linux 2.6.8
及更早版本的内核，这个参数被忽略，可以设置为任意值。</li>
</ul></li>
<li><strong>epoll_ctl(int epfd, int op, int fd, struct epoll_event
*event)：</strong>
<ul>
<li><code>epfd</code>：epoll 实例的文件描述符，由
<code>epoll_create</code> 返回。</li>
<li><code>op</code>：表示要执行的操作，可以是以下值之一：
<ul>
<li><code>EPOLL_CTL_ADD</code>：向 epoll
实例中添加一个要监听的文件描述符。</li>
<li><code>EPOLL_CTL_MOD</code>：修改 epoll
实例中某个文件描述符的监听事件。</li>
<li><code>EPOLL_CTL_DEL</code>：从 epoll
实例中删除一个不再需要监听的文件描述符。</li>
</ul></li>
<li><code>fd</code>：要添加、修改或删除的文件描述符。</li>
<li><code>event</code>：指向 <code>struct epoll_event</code>
结构的指针，描述了要监听的事件类型。</li>
</ul></li>
<li><strong>epoll_wait(int epfd, struct epoll_event *events, int
maxevents, int timeout)：</strong>
<ul>
<li><code>epfd</code>：epoll 实例的文件描述符，由
<code>epoll_create</code> 返回。</li>
<li><code>events</code>：用于存储发生事件的文件描述符和事件类型的数组。</li>
<li><code>maxevents</code>：<code>events</code>
数组的大小，表示最多可以存储多少个事件。</li>
<li>timeout：等待事件的超时时间，以毫秒为单位。可以有以下几种取值：
<ul>
<li><code>-1</code>：无限等待，直到有事件发生。</li>
<li><code>0</code>：立即返回，不等待事件。</li>
<li><code>&gt;0</code>：等待指定的毫秒数后返回，即使没有事件发生。</li>
</ul></li>
</ul></li>
</ol>
<h3
id="个件有千万有ip地址访问时间url访问topk出现频率的ip或url的命令">⼀个⽂件，有⼏千万⾏，有IP地址、访问时间、url，访问topk出现频率的IP或url的命令</h3>
<p>假设文件名为 <code>access.log</code>，文件内容类似于：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">15</span> /page1<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">20</span> /page2<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">25</span> /page1<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">30</span> /page3<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">35</span> /page2<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">40</span> /page1<br></code></pre></td></tr></table></figure>
<h3 id="统计-ip-地址的频率">统计 IP 地址的频率：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> access.log | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | <span class="hljs-built_in">head</span> -n K<br></code></pre></td></tr></table></figure>
<p>这个命令的含义是：</p>
<ul>
<li>使用 <code>awk '&#123;print $1&#125;'</code> 提取每行的第一个字段（即 IP
地址）。</li>
<li>使用 <code>sort</code> 对 IP 地址进行排序。</li>
<li>使用 <code>uniq -c</code> 对排序后的 IP 地址进行统计，并输出每个 IP
地址出现的次数。</li>
<li>使用 <code>sort -nr</code> 对统计结果进行逆序排序。</li>
<li>使用 <code>head -n K</code> 只输出前 K 个结果，即 Top K 出现频率的
IP 地址。</li>
</ul>
<h3 id="awk命令">awk命令</h3>
<p><code>awk</code>
是一种文本处理工具，通常用于对文本文件进行行处理和字段处理。它以行为单位逐行读取输入文件，并根据用户指定的模式和动作对每行进行处理。<code>awk</code>
的语法比较灵活，可以用于过滤、转换和格式化文本数据。</p>
<p>例如，以下是一个简单的 <code>awk</code>
命令示例，用于提取文本文件中的第二列：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">awk</span> <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$2</span>&#125;&#x27;</span> filename.txt<br></code></pre></td></tr></table></figure>
<p>这个命令会读取 <code>filename.txt</code>
文件的每一行，并将每行的第二列打印输出。</p>
<h3 id="linux的进程调度腾讯云">Linux的进程调度（腾讯云）</h3>
<h3 id="gdb-调试遇到stackovlerflow怎么办">GDB
调试遇到stackovlerflow怎么办？</h3>
<p>如果按照一般的方式编译：</p>
<p>gcc –o stackoverflow stackoverflow.c</p>
<p>linux系统能够探测到程序中的stack
overflow，从而终止程序，如下图所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg" srcset="/img/loading.gif" lazyload
alt="Linux下的栈溢出案例分析-GDB调试操练" />
<figcaption
aria-hidden="true">Linux下的栈溢出案例分析-GDB调试操练</figcaption>
</figure>
<p>那有没有办法让系统不探测到stack
overflow，此处可以在编译时，禁用堆栈保护，具体命令如下：</p>
<p>gcc –fno-stack-protector –o stackoverflow stackoverflow.c</p>
<p>然后采用gdb调试stackoverflow，</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820334293.jpg" srcset="/img/loading.gif" lazyload
alt="Linux下的栈溢出案例分析-GDB调试操练" />
<figcaption
aria-hidden="true">Linux下的栈溢出案例分析-GDB调试操练</figcaption>
</figure>
<h3 id="fork函数">fork函数</h3>
<p>for就会复制一份原来的进程即就是创建一个新进程,我们称子进程，而原来的进程我们称为父进程，此时父子进程是共存的，他们一起向下执行代码。</p>
<p>fork的返回值问题:</p>
<p>在父进程中，fork返回新创建子进程的进程ID；</p>
<p>在子进程中，fork返回0；</p>
<p>如果出现错误，fork返回一个负值；</p>
<p>getppid():得到一个进程的父进程的PID;</p>
<p>getpid():得到当前进程的PID;</p>
<h2 id="计算机网络"><strong>计算机网络</strong></h2>
<h2 id="http协议里-301-304啥用处腾讯云">http协议里 301
304啥用处（腾讯云）</h2>
<p>301永久重定向；302临时重定向；304未修改，重定向到已存在的缓存文件</p>
<h2 id="http请求过程腾讯云">http请求过程(腾讯云)</h2>
<ol type="1">
<li>⾸先，我们在浏览器地址栏中，输⼊要查找⻚⾯的URL，按下Enter</li>
<li>浏览器依次在 浏览器缓存 --&gt;&gt;系统缓存
--&gt;&gt;路由器缓存中去寻找匹配的URL，若有，就会直接在屏幕中显示出⻚⾯内容。若没有，则跳到第三步操作</li>
<li>发送HTTP请求前，浏览器需要先进⾏域名解析(即DNS解析)，以获取相应的IP地址;（浏览器DNS缓存、路由器缓存、DNS缓存）</li>
<li>获取到IP地址之后，浏览器向服务器发起TCP连接，与浏览器建⽴TCP三次握⼿</li>
<li>握⼿成功之后，浏览器就会向服务器发送HTTP请求，来请求服务器端的数据包</li>
<li>服务器处理从浏览器端收到的请求，接着将数据返回给浏览器</li>
<li>浏览器收到HTTP响应</li>
<li>查询状态，状态成功则进⾏下⼀步，不成功则弹出相应指示</li>
<li>再读取⻚⾯内容、进⾏浏览器渲染、解析HTML源码;（⽣成DOM树、解析CCS样式、处理JS交互，客户端和
服务器交互）进⾏展示</li>
<li>关闭TCP连接（四次挥⼿）</li>
</ol>
<h3
id="tcp三次握手过程为什么不是两次腾讯云">Tcp三次握手过程，为什么不是两次(腾讯云)</h3>
<h3 id="tcp为什么四次挥手腾讯云">TCP为什么四次挥手（腾讯云）</h3>
<h3
id="解释一下time_wait作用腾讯云">解释一下time_wait作用（腾讯云）</h3>
<h3 id="tcp的稳定性机制">TCP的稳定性机制</h3>
<p>TCP协议通过以下几种机制来确保数据的可靠传输和接收：</p>
<p><strong>三次握手四次挥手保证建立和断开连接的有效性</strong></p>
<p><strong>序列号和确认应答</strong>：发送方将每个数据包进行编号，并且接收方要对每个数据包进行确认应答。这样可以确保数据包的顺序和完整性。</p>
<p><strong>超时重传</strong>：如果发送方在一定时间内没有收到接收方的确认应答，就会重新发送数据包，以确保数据的可靠传输。</p>
<p><strong>流量控制</strong>：TCP协议使用滑动窗口机制来控制发送方和接收方之间的数据流量，避免发送过多的数据导致接收方无法处理。</p>
<p><strong>拥塞控制</strong>：TCP协议通过拥塞窗口机制来避免网络拥塞，当网络出现拥塞时，发送方会减小发送窗口的大小，以减缓数据包的发送速度。</p>
<p>综合上述机制，TCP协议能够确保数据的可靠传输和接收，从而保证了网络通信的稳定性和可靠性。</p>
<p>关键字：序列号，确认应答，超时重传，流量控制，拥塞控制</p>
<h3
id="服务端出现量close_wait-的原因可能是什么">服务端出现⼤量close_wait
的原因可能是什么？</h3>
<p>出现大量的<code>CLOSE_WAIT</code>状态连接通常意味着服务端在关闭连接时没有正确释放资源或处理连接。<code>CLOSE_WAIT</code>状态是指服务端已经收到了客户端的关闭请求，但是服务端还没有执行关闭操作，处于等待关闭的状态。</p>
<ol type="1">
<li><strong>服务端未正确关闭连接</strong>：服务端在处理完客户端请求后，未正确调用<code>close()</code>函数关闭连接，导致连接进入<code>CLOSE_WAIT</code>状态而不是直接关闭。</li>
<li><strong>服务端连接处理慢</strong>：服务端在处理连接请求时速度过慢，导致连接累积在<code>CLOSE_WAIT</code>状态。这可能是因为服务端处理请求的逻辑复杂或者资源不足导致的。</li>
<li><strong>客户端异常关闭</strong>：如果客户端异常关闭连接，而服务端未及时检测到连接已关闭，也会导致服务端的连接进入<code>CLOSE_WAIT</code>状态。</li>
</ol>
<h3 id="tcp为什么会粘包腾讯云">TCP为什么会粘包（腾讯云）</h3>
<p>由于Nagle算法的优化会将多个小数据合成大数据发送</p>
<h4 id="粘包的包是在哪合成的">粘包的包是在哪合成的</h4>
<p>TCP粘包的包是在发送方的操作系统合成的。当应用程序通过TCP发送数据时，数据首先会被放入缓冲区。操作系统根据网络条件和其他因素决定何时发送这些缓冲区中的数据。如果一段时间内多个小数据包被放入缓冲区，而发送方的操作系统认为可以发送数据时，它可能会将这些小数据包合并成一个较大的数据包，然后发送到网络中。</p>
<h4
id="nagle算法开启有什么好处和坏处">Nagle算法开启有什么好处和坏处</h4>
<p><strong>好处：</strong></p>
<ol type="1">
<li><strong>减少网络流量：</strong>
通过合并小数据包，减少了网络传输中的数据包数量，降低了网络拥塞的可能性，提高了网络的利用率。</li>
<li><strong>减轻网络负载：</strong>
减少了发送小数据包的频率，降低了网络设备的负载，有助于提高网络的性能。</li>
</ol>
<p><strong>坏处：</strong></p>
<ol type="1">
<li><strong>引入延迟：</strong>
Nagle算法会等待一小段时间，尝试合并多个小数据包成一个大的数据包再进行发送。这样会导致数据的传输延迟增加，尤其是在对实时性要求较高的应用中，如在线游戏或实时视频流。</li>
<li><strong>小消息传输受阻：</strong>
在某些情况下，如果有一些小数据包需要立即发送，启用Nagle算法可能导致这些小数据包被延迟发送，影响了实时性。</li>
</ol>
<h3 id="tcp的重传机制腾讯云">TCP的重传机制（腾讯云）</h3>
<p>数据发送之后会等待对方的确认，如果定时器超时而没有收到确认，发送方就假设数据丢失，触发重传机制。</p>
<p>TCP还采用了一种称为快速重传的机制。如果发送方连续收到三个相同序列号的确认，它会认为在这个序列号之前的数据段已经丢失，会立即重传该数据段，而不等待定时器超时。</p>
<h3
id="拥塞窗口与流量窗口有什么区别腾讯云">拥塞窗口与流量窗口有什么区别（腾讯云）</h3>
<p>拥塞窗口（Congestion Window）和流量窗口（Window
Size）是TCP协议中的两个概念，<strong>它们用于控制和调整数据的传输速率</strong>，但有一些关键的区别。</p>
<ul>
<li>拥塞控制是指根据网络的拥塞程度来调节发送数据的速率，以避免网络拥塞导致丢包和网络性能下降。</li>
<li>流量控制是指接收方通知发送方自己的缓冲区大小，发送方根据接收方的缓冲区大小来控制发送数据的速率，以防止接收方的缓冲区溢出。</li>
</ul>
<h3 id="http状态码">HTTP状态码</h3>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315201411599.png" srcset="/img/loading.gif" lazyload
alt="image-20240315201411599" />
<figcaption aria-hidden="true">image-20240315201411599</figcaption>
</figure>
<h3
id="ssltls建立的时候和域名绑定还是ip绑定">SSL/TLS建立的时候和域名绑定还是ip绑定</h3>
<p>SSL/TLS 建立时是与域名绑定的，而不是 IP 绑定。</p>
<h3 id="dns和域名绑定还是ip绑定">DNS和域名绑定还是ip绑定</h3>
<p>域名</p>
<h3 id="http多个tcp连接怎么实现">HTTP多个TCP连接怎么实现</h3>
<h3 id="http一定要用tcp实现吗">HTTP一定要用TCP实现吗</h3>
<p>不一定，HTTP3就是用UDP实现的。QUIC是谷歌开发的基于UDP的传输协议，旨在提供更快的连接建立和更低的延迟。HTTP/3标准使用了QUIC作为传输层协议，因此可以说HTTP/3是基于QUIC实现的。与TCP相比，QUIC具有更快的连接建立速度和更好的拥塞控制，但也存在部署和兼容性等方面的挑战。</p>
<h3 id="https建立连接的过程">HTTPs建立连接的过程</h3>
<ol type="1">
<li><strong>客户端发起连接请求</strong>：
<ul>
<li>客户端向服务器发起连接请求，请求建立安全连接。客户端会发送一个HTTPS请求，其中包含了一些与SSL/TLS相关的信息，如支持的加密算法和SSL/TLS版本等。</li>
</ul></li>
<li><strong>服务器返回证书</strong>：
<ul>
<li>服务器收到客户端的连接请求后，会向客户端发送服务器的数字证书，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等信息。服务器的证书是由可信任的证书颁发机构（Certificate
Authority，CA）签发的，客户端可以通过CA证书来验证服务器的证书的真实性和合法性。</li>
</ul></li>
<li><strong>客户端验证证书</strong>：
<ul>
<li>客户端收到服务器发送的证书后，会进行证书的验证。客户端会检查证书的有效性、是否由可信任的CA签发、证书的有效期等信息，以确保服务器的身份和证书的合法性。如果证书验证失败，客户端会中断连接，否则继续连接。</li>
</ul></li>
<li><strong>客户端生成随机密钥</strong>：
<ul>
<li>客户端生成一个随机数作为对称密钥，并使用服务器的公钥加密该密钥，然后发送给服务器。对称密钥是用于对数据进行加密和解密的密钥，这样可以保证数据的机密性。</li>
</ul></li>
<li><strong>服务器使用私钥解密密钥</strong>：
<ul>
<li>服务器收到客户端发送的加密后的对称密钥后，使用自己的私钥进行解密，得到对称密钥。</li>
</ul></li>
<li><strong>建立安全通道</strong>：
<ul>
<li>客户端和服务器都使用协商好的对称密钥来加密和解密通信中的数据，从而建立安全的通信通道。此后，客户端和服务器之间的所有数据传输都会通过这个加密通道进行加密和解密，保证了数据的机密性和完整性。</li>
</ul></li>
</ol>
<h3 id="很多closewait状态是什么原因">很多closewait状态是什么原因</h3>
<p>服务端的程序没有调用close 函数关闭连接。</p>
<h3
id="客户端close了服务端发送数据会发什么">客户端close了服务端发送数据会发⽣什么</h3>
<p>根据TCP协议，客户端会向服务器发送一个RST（重置）报文，表明这是一个不再有效的连接。服务器端在收到RST报文后，应该意识到连接已经被客户端关闭，并停止尝试发送数据。</p>
<h3 id="vpn在哪层络模型实现的">VPN在哪⼀层⽹络模型实现的</h3>
<p>VPN（虚拟专用网络）可以在不同的网络层次上实现，具体取决于它使用的技术和协议。以下是VPN的一些常见实现层次：</p>
<ul>
<li>应用层：例如SSL VPN1</li>
<li>网络层：例如IPSEC VPN、GRE VPN</li>
<li>数据链路层：例如L2TP VPN、PPTP VPN</li>
</ul>
<h3 id="王者荣耀是tcp还是udp链接">王者荣耀是Tcp还是Udp链接？</h3>
<p>王者荣耀游戏的启动和登录采用TCP连接，客户端操作与界面显示是通过UDP数据流与服务器进行交互的。</p>
<h3 id="如何判断tcp还是udp呢">如何判断tcp还是udp呢？</h3>
<ul>
<li><strong>端口号</strong>：一些常见的端口号被分配给了特定的协议，例如
HTTP 使用 TCP 的端口 80，DNS 使用 UDP 的端口 53。</li>
<li><strong>包头标识</strong>：TCP 和 UDP
数据包的包头中包含了不同的字段和标识符。例如，TCP
的包头中有一个字节的标识符字段，用于指示该数据包是 TCP 数据包；而 UDP
的包头中没有类似的标识符字段。因此，可以通过解析数据包的包头来确定其所使用的协议。</li>
<li><strong>协议类型字段</strong>：数据包的协议类型可能会被直接指定在 IP
包头中的协议字段中。TCP 使用值 6 表示，UDP 使用值 17 表示。</li>
</ul>
<h3
id="什么是网络地址转换network-address-translationnat请解释-nat-的原理和应用场景">什么是网络地址转换（Network
Address Translation，NAT）？请解释 NAT 的原理和应用场景。</h3>
<p>网络地址转换（Network Address
Translation，NAT）是一种网络技术，用于将私有网络中的 IP
地址映射到公共网络中的 IP
地址，以便实现私有网络中的多个主机共享一个或多个公共 IP 地址的功能。</p>
<p>NAT 的工作原理如下：</p>
<ol type="1">
<li><strong>内部网络</strong>：在私有网络（如家庭网络、企业网络）中，主机通常使用私有
IP 地址（例如 192.168.x.x、10.x.x.x、172.16.x.x
等）来进行通信，这些地址在全球范围内并不唯一。</li>
<li><strong>NAT 设备</strong>：在私有网络和公共网络之间，存在一个 NAT
设备（通常是路由器或防火墙），它负责管理私有网络和公共网络之间的数据传输。</li>
<li><strong>地址映射</strong>：当内部网络中的主机尝试与外部网络通信时，NAT
设备会将内部主机的私有 IP 地址转换成路由器的公共 IP
地址，然后将数据包发送到外部网络。在数据包返回时，NAT 设备会将公共 IP
地址转换回相应的私有 IP 地址，然后将数据包传递给内部主机。</li>
<li><strong>端口转换</strong>：除了进行 IP 地址的转换之外，NAT
设备还可以进行端口转换，通过修改数据包中的端口号来实现多个内部主机共享一个公共
IP 地址的功能。</li>
</ol>
<p>NAT 的应用场景包括但不限于以下几个方面：</p>
<ol type="1">
<li><strong>节省 IP 地址</strong>：NAT 允许多个内部主机共享一个公共 IP
地址，从而节省了公共 IP 地址的使用，特别是在 IPv4
地址资源日益枯竭的情况下，NAT 可以有效地延长 IPv4 地址的使用寿命。</li>
<li><strong>网络隔离</strong>：NAT
设备可以将内部网络与外部网络隔离开来，从而提高了网络的安全性和隐私保护。</li>
<li><strong>访问控制</strong>：NAT
设备可以实现端口转发和端口过滤等功能，对内部网络的访问进行控制和管理。</li>
<li><strong>动态地址分配</strong>：NAT 设备可以为内部主机动态分配公共 IP
地址，从而实现了灵活的网络配置和管理。</li>
</ol>
<h3
id="什么是虚拟专用网络virtual-private-networkvpn请解释-vpn-的原理和使用场景">什么是虚拟专用网络（Virtual
Private Network，VPN）？请解释 VPN 的原理和使用场景。</h3>
<p>虚拟专用网络（VPN）是一种通过公共网络（通常是互联网）在远程位置之间创建安全连接的技术。它允许用户通过加密通道安全地传输数据，就像在私有网络中一样。</p>
<h4 id="原理">原理：</h4>
<ol type="1">
<li><strong>隧道协议</strong>：虚拟专用网络本质上是在您的本地设备和位置远隔千里的另一台
VPN 服务器之间创建一个安全数据隧道。当您联机时，此 VPN
服务器将成为您接收所有数据的来源。您的网络服务提供商（ISP）和其他第三方将无法再看到您的互联网流量的内容。</li>
<li><strong>加密</strong>：IPSec 等 VPN
协议会对数据进行加密，然后再通过数据隧道发送数据。IPsec
是一个协议套件，通过验证和加密数据流的每个 IP 数据包来保护 Internet
协议（IP）通信。VPN
服务就好比一个筛选器，使您的数据在一端无法读取，并且只在另一端进行解码 –
这可防止个人数据滥用，即使您的网络连接被破坏时也是如此。网络流量不再容易受到攻击，您的互联网连接也是安全的。</li>
</ol>
<h4 id="使用场景">使用场景：</h4>
<ol type="1">
<li><strong>远程访问：</strong>
允许用户通过互联网安全地访问公司内部网络资源。远程工作者可以通过 VPN
连接到公司网络，并访问文件、应用程序和其他资源，就像他们在办公室内一样。</li>
<li><strong>绕过地理限制：</strong> 通过连接到不同地区的 VPN
服务器，用户可以绕过地理限制，访问被限制的内容，如特定国家或地区的网站、流媒体服务等。</li>
<li><strong>保护隐私：</strong> 在连接到公共 Wi-Fi 热点时，使用 VPN
可以增加安全性和隐私保护，防止黑客窃取敏感信息。</li>
</ol>
<h3
id="长连接和短链接以及他们各自的应用场景如何实现一个长连接">长连接和短链接，以及他们各自的应用场景，如何实现一个长连接</h3>
<p><strong>长连接</strong>：长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</p>
<p><strong>短连接</strong>：短连接（short
connnection）是相对于长连接而言的概念，指的是在数据传送过程中，只在需要发送数据时，才去建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。</p>
<h4 id="应用场景">应用场景</h4>
<p><strong>长连接</strong>：长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。</p>
<p><strong>短连接</strong>：而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源。</p>
<h2 id="数据库">数据库</h2>
<h3
id="一条mysql语句的执行过程腾讯云">一条MySQL语句的执行过程(腾讯云)</h3>
<p>1.连接器:连接器负责跟客户端建立 连接、获取权限、维持和管理连接。</p>
<ol start="2" type="1">
<li>查询缓存:MySQL拿到 个查询请求后，会先到查询缓存看看，之前是不是执
过这条语句。之前执
过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。</li>
<li>分析器:你输 的是由多个字符串和空格组成的 条SQL语句，MySQL需要识别出
的字符串分别是什么，代表什么。</li>
<li>优化器:优化器是在表 有多个索引的时候，决定使 哪个索引;或者在
个语句有多表关联(join)的时候，决定各个表的连接顺序。</li>
<li>执行器:MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进
了执器阶段，开始执行语句。</li>
</ol>
<h3
id="mysql-中如果修改了个-4kb-的的内容存磁盘时修改的是完整的还是中的段">MySQL
中如果修改了⼀个 4kb
的⻚的内容，存⼊磁盘时修改的是完整的⻚还是⻚中的⼀段</h3>
<p>在MySQL中，如果修改了一个4KB的页（Page）的内容，存入磁盘时通常是修改整个页而不是页中的一段。MySQL使用页作为存储数据的基本单位，通常是以固定大小的4KB为一页。当需要更新页中的数据时，MySQL通常会将整个页加载到内存中进行修改，然后再将整个页写回磁盘。</p>
<p>这样做的原因有几点：</p>
<ol type="1">
<li><strong>简化管理</strong>：通过将整个页作为最小单位进行读取和写入，简化了数据管理和维护操作。</li>
<li><strong>减少I/O开销</strong>：相比于仅写入一页中的一小部分数据，写入整个页可以减少磁盘I/O操作次数，提高性能。</li>
<li><strong>保证数据一致性</strong>：通过整页写入，可以确保页的所有数据都是一致的，避免了部分数据更新而导致的数据不一致问题。</li>
</ol>
<h3 id="b树和b树腾讯云客户端">B树和B+树（腾讯云客户端）</h3>
<h3
id="lru预读失效和缓存污染改进腾讯云">LRU预读失效和缓存污染改进（腾讯云）</h3>
<h4 id="预读失效">预读失效</h4>
<h5 id="什么是预读机制">什么是预读机制？</h5>
<p>Linux 操作系统为基于 Page Cache
的读缓存机制提供预读机制，一个例子是：</p>
<ul>
<li>应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB
范围内的数据，由于磁盘的基本读写单位为
block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page
中装下。</li>
<li>但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块
offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB)
都加载到内存，于是额外在内存中申请了 3 个 page；</li>
</ul>
<p>预读失效会带来什么问题？</p>
<p>如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。</p>
<h5 id="解决方案">解决方案</h5>
<ul>
<li>Linux 操作系统和 MySQL Innodb 通过改进传统 LRU
链表来避免预读失效带来的影响，具体的改进分别如下：</li>
<li>Linux 操作系统实现两个了 LRU 链表：活跃 LRU
链表（active_list）和非活跃 LRU 链表（inactive_list）；</li>
<li>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：young
区域 和 old 区域。</li>
</ul>
<p><strong>Linux</strong>：</p>
<p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU
链表（active_list）和非活跃 LRU 链表（inactive_list）。</p>
<ul>
<li>active
list活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li>inactive
list不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>有了这两个 LRU 链表后，预读页就只需要加入到 inactive list
区域的头部，当页被真正访问的时候，才将页插入 active list
的头部。如果预读的页一直没有被访问，就会从 inactive list
移除，这样就不会影响 active list 中的热点数据。</p>
<p><strong>MySQL</strong>：</p>
<p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，young
区域 和 old 区域。</p>
<p>young 区域在 LRU 链表的前半部分，old
区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/c5ec9c08462a2dd89d1038a144556a47c2b519.png" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>young 区域与 old 区域在 LRU
链表中的占比关系并不是一比一的关系，而是是 7 比 3
（默认比例）的关系。</p>
<p>划分这两个区域后，预读的页就只需要加入到 old
区域的头部，当页被真正访问的时候，才将页插入 young
区域的头部。如果预读的页一直没有被访问，就会从 old
区域移除，这样就不会影响 young 区域中的热点数据。</p>
<h4 id="缓存污染">缓存污染</h4>
<h5 id="什么是缓存污染">什么是缓存污染？</h5>
<p>虽然 Linux （实现两个 LRU 链表）和 MySQL
（划分两个区域）通过改进传统的 LRU
数据结构，避免了预读失效带来的影响。</p>
<p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU
链表头部（或者 young
区域）」这种方式的话，那么还存在缓存污染的问题。</p>
<p>当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃
LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young
区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃
LRU 链表（或者 young 区域）就被污染了。</p>
<h4 id="解决方案-1">解决方案</h4>
<p>前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者
young 区域），这种 LRU 算法<strong>进入活跃 LRU
链表的门槛太低了</strong>！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃
LRU 链表里的热点数据淘汰了。</p>
<p>所以，只要我们提高进入到活跃 LRU 链表（或者 young
区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young
区域）里的热点数据不会被轻易替换掉。</p>
<p>Linux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：</p>
<ul>
<li>Linux 操作系统：在内存页被访问第二次的时候，才将页从 inactive list
升级到 active list 里。</li>
<li>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old
区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：</li>
</ul>
<h3 id="说说你了解的mvcc机制">说说你了解的MVCC机制</h3>
<ol type="1">
<li><strong>事务ID</strong>：每个事务都有一个唯一的ID，用于标识事务的版本。</li>
<li><strong>隐藏列</strong>：在支持MVCC的数据库表中，每行数据通常会有隐藏的列来存储事务ID和回滚指针。</li>
<li><strong>回滚指针</strong>：指向该行数据的前一个版本，这样就形成了一个版本链。</li>
<li><strong>ReadView</strong>：在查询时，数据库会为事务创建一个ReadView，这是一个逻辑上的快照，包含了在查询时刻活跃的所有事务ID。</li>
</ol>
<h3
id="数据库是一阶段提交还是两阶段为什么是两阶段">数据库是一阶段提交还是两阶段？为什么是两阶段？</h3>
<p>数据库日志分为三种：</p>
<ul>
<li>undo log（回滚⽇志）：是 Innodb
存储引擎层⽣成的⽇志，实现了事务中的<strong>原⼦性</strong>，主要⽤于<strong>事务回滚和MVCC</strong>。</li>
<li>redo log（重做⽇志）：是 Innodb
存储引擎层⽣成的⽇志，实现了事务中的<strong>持久性</strong>，主要⽤于掉电等<strong>故障恢复</strong>；</li>
<li>binlog （归档⽇志）：是 Server
层⽣成的⽇志，主要⽤于<strong>数据备份</strong>和<strong>主从复制</strong>；</li>
</ul>
<p>事务提交后，redo log 和 binlog
都要持久化到磁盘，但是这两个是独⽴的逻辑，可能出现半成功的状态，造成两份⽇志之间的逻辑不⼀致。</p>
<ul>
<li>如果在将 redo log 刷⼊到磁盘之后， MySQL 突然宕机了，⽽ binlog
还没有来得及写⼊。MySQL 重启后，通过 redo log 能将 Buffer Pool
恢复到新值，但是 binlog ⾥⾯没有记录这条更新语句，在主从架构中，binlog
会被复制到从库，由于 binlog
丢失了这条更新语句，从库的这⼀⾏是旧值，主从不⼀致。</li>
<li>如果在将 binlog 刷⼊到磁盘之后， MySQL 突然宕机了，⽽ redo log
还没有来得及写入。由于 redo log
还没写，崩溃恢复以后这个事务无效，数据是旧值，⽽ binlog
⾥⾯记录了这条更新语句，在主从架构中，binlog
会被复制到从库，从库执⾏了这条更新语句，这⼀行字段是新值，与主库的值不⼀致性。</li>
</ul>
<p>所以会造成主从环境的数据不⼀致性。因为 redo log
影响主库的数据，binlog 影响从库的数据，redo log 和binlog
必须保持⼀致。</p>
<p>两阶段提交把单个事务的提交拆分成了 2
个阶段，分别是准备(Prepare)阶段和提交(Commit)阶段，每个阶段都由协调者(Coordinator)和参与者(Participant)共同完成。</p>
<h4 id="两阶段提交的过程">两阶段提交的过程</h4>
<p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护
binlog ⽇志与 InnoDB 的 redo log，为了保证这两个⽇志的⼀致性，MySQL
使⽤了<strong>内部 XA 事务</strong>，<strong>内部 XA 事务由 binlog
作为协调者，存储引擎是参与者</strong>。</p>
<p>当客户端执⾏ commit 语句或者在⾃动提交的情况下，MySQL 内部开启⼀个 XA
事务，分两阶段来完成 XA 事务的提交。</p>
<p>事务的提交过程有两个阶段，将 redo log 的写⼊拆成了两个步骤：prepare
和 commit，中间再穿插写⼊binlog：</p>
<ul>
<li>prepare 阶段：将内部 XA 事务的 ID写⼊到 redo log，同时将 redo log
对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘。</li>
<li>commit 阶段：把内部 XA 事务的 ID写⼊到 binlog，然后将 binlog
持久化到磁盘，接着调⽤引擎的提交事务接⼝，将 redo log 状态设置为
commit，此时该状态并不需要持久化到磁盘，只需要 write 到⽂件系统的page
cache 成功，只要 binlog 写磁盘成功，redo log 的状态还是 prepare
也没有关系，⼀样会被认为事务已经执行成功。</li>
</ul>
<h3 id="mysql调优">MySQL调优</h3>
<h4 id="explain语句">explain语句</h4>
<p><code>EXPLAIN</code>是MySQL中的一个关键字，用于分析查询语句的执行计划。通过<code>EXPLAIN</code>关键字，可以查看MySQL执行查询的方法和顺序，帮助优化查询性能。</p>
<p>使用<code>EXPLAIN</code>可以获取查询执行计划的相关信息，包括以下内容：</p>
<ol type="1">
<li><strong>查询的执行顺序</strong>：查询中涉及的表和索引的访问顺序，以及连接操作的执行顺序。</li>
<li><strong>访问类型</strong>：对每个表访问的方式，包括<code>ALL</code>（全表扫描）、<code>INDEX</code>（索引扫描）、<code>RANGE</code>（索引范围扫描）等。</li>
<li><strong>使用的索引</strong>：哪些索引被用到，以及如何使用索引进行查询。</li>
<li><strong>行数估算</strong>：MySQL估算的结果集行数，以及每个表的扫描行数。</li>
<li><strong>连接类型</strong>：如果查询涉及到多个表的连接，会显示连接的类型，如<code>Nested Loop</code>、<code>Hash Join</code>、<code>Merge Join</code>等。</li>
</ol>
<h4 id="建立索引"><strong>建立索引</strong></h4>
<ul>
<li>为经常被查询的列建立索引，特别是在 WHERE 和 ORDER BY
子句中经常出现的列。</li>
<li>对于经常用于连接的列，考虑创建联合索引。</li>
<li>避免为稀疏列创建索引，因为这会增加索引维护的开销。</li>
</ul>
<h4 id="覆盖查询"><strong>覆盖查询</strong></h4>
<p>尽量避免全表扫描，即使使用索引也需要访问数据行。如果查询只需要索引列的值，可以创建覆盖索引，这样就不需要额外访问数据行了，从而提高查询性能。</p>
<h4 id="避免索引失效"><strong>避免索引失效</strong></h4>
<p>见索引失效。</p>
<h4 id="优化查询语句"><strong>优化查询语句</strong></h4>
<ul>
<li>使用 EXPLAIN
关键字分析查询执行计划，查看是否使用了索引，以及索引的选择器是否合理。</li>
<li>避免一次性返回大量数据，尽量限制查询返回的数据量。</li>
<li>使用合适的 JOIN 类型，避免不必要的笛卡尔积。</li>
</ul>
<h3 id="mysql什么情况下不走索引">MySQL什么情况下不走索引</h3>
<ul>
<li><strong>索引列参与表达式计算</strong></li>
<li><strong>索引列使用了函数</strong></li>
<li><strong>对索引隐式类型转换</strong>：如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</li>
<li><strong>不等号条件</strong>：当查询中包含不等号条件（&lt;&gt;）时。</li>
<li><strong>表连接中的列类型不匹配</strong>：
如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，
一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。</li>
<li><strong>索引列使用了左右模糊匹配</strong>，<code>Like %xxx</code>或者
<code>like %xx%</code></li>
<li><strong>字符串列与数字直接比较</strong></li>
<li><strong>or条件</strong>：除非每个列都建立了索引才会走索引</li>
<li><strong>ORDER BY 操作</strong>：在ORDER
BY操作中，排序的列同时也在WHERE中时，MYSQL将无法使用索引；</li>
<li><strong>联合索引非最左匹配</strong></li>
<li>使用了<code>select *</code></li>
</ul>
<h3
id="为什么要建立索引索引为什么能够加快查询速度">为什么要建立索引？索引为什么能够加快查询速度？</h3>
<p>数据库索引能够加快查询的速度，主要是因为它提供了一种<strong>快速定位数据</strong>的方法，减少了数据库系统需要扫描的数据量。具体来说，数据库索引能够加快查询速度的原因包括以下几点：</p>
<ol type="1">
<li><strong>减少数据扫描量</strong>：数据库索引可以将数据按照索引列的顺序进行组织，<strong>形成一种类似于字典的数据结构。当执行查询操作时，数据库系统可以利用索引快速定位到满足条件的记录</strong>，而不需要扫描整个表的数据。</li>
<li><strong>快速定位数据</strong>：数据库索引通常采用树状结构（如B+树）或哈希表等高效的数据结构来组织索引数据，使得数据库系统能够以O(log
n)或O(1)的时间复杂度快速定位到目标记录，而不受数据量的影响。</li>
<li><strong>避免全表扫描</strong>：在没有索引的情况下，数据库系统可能需要对整个表进行扫描以寻找满足条件的记录，这样的全表扫描会消耗大量的时间和系统资源。而有了索引之后，数据库系统可以通过索引快速定位到符合条件的记录，避免了全表扫描，提高了查询效率。</li>
<li><strong>支持排序和聚合操作</strong>：数据库索引不仅可以加速查询操作，还可以加速排序和聚合操作。例如，在有序索引的情况下，数据库系统可以利用索引的有序性进行高效的范围查询和排序操作；而在哈希索引的情况下，数据库系统可以利用哈希表的快速查找特性进行高效的聚合操作。</li>
</ol>
<h3 id="数据库的几大范式">数据库的几大范式</h3>
<p>数据库的三大范式（Normalization）是关系型数据库设计中的基本原则，旨在帮助设计者有效地组织数据库结构，减少数据冗余和插入、更新、删除异常，提高数据库的数据完整性和灵活性。三大范式包括：</p>
<ol type="1">
<li><strong>第一范式（1NF）</strong>：确保每个字段都是<strong>原子性</strong>的，即确保每<strong>个字段的值都是不可再分的基本单位</strong>，不包含多个值或重复的组合。换句话说，每个字段中不应该有多个值，而是单一的值。这样可以消除重复的数据，并确保每个字段具有唯一性和原子性。</li>
<li><strong>第二范式（2NF）</strong>：在<strong>满足第一范式的基础上，要求表中的非主键字段完全依赖于主键</strong>，而不是依赖于主键的一部分。简单来说，就是要保证表中的每个非主键字段都完全依赖于表的主键，而不是依赖于主键的某个子集。这样可以避免数据冗余和插入、更新、删除异常。</li>
<li><strong>第三范式（3NF）</strong>：在<strong>满足第二范式的基础上，要求表中的每个非主键字段之间不存在传递依赖关系</strong>。换句话说，就是要保证表中的每个非主键字段都直接依赖于主键，而不是依赖于其他非主键字段。这样可以进一步减少数据冗余，确保数据的更新操作不会导致数据不一致。</li>
<li><strong>BC范式（BCNF）</strong>:在第三范式的基础上，如果关系模型R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R为BCNF的模式。</li>
<li><strong>第四范式（4NF）</strong>：如果关系模式 R
中的每一个非平凡多值依赖 A -&gt;&gt; B 都满足以下条件之一，则关系模式 R
符合第四范式：
<ol type="1">
<li>A 是 R 的一个超码。</li>
<li>B 是 R 的一个超码。</li>
</ol></li>
</ol>
<h3 id="可重复读级别为什么还会有幻读">可重复读级别为什么还会有幻读</h3>
<p>可重复读隔离级别通常只针对已有数据的读操作，而不是针对整个查询结果集的完整性。因此，如果其他事务在同一事务中执行了插入、删除等操作，可能会导致幻读的出现。</p>
<h3 id="mysql主从数据一致性怎么保持">MySQL主从数据一致性怎么保持</h3>
<ul>
<li><strong>异步复制</strong>：也是默认的主从同步方式。这种方式的优点是效率高。缺点是不能保证数据一定会到达slave。可能会受到网络等原因出现延迟，导致主从数据不一致。当前对master中的表进行数据操作，master将事务Binlog事件写入到Binlog文件中，此时主库<strong>只会通知一下Dump线程发送这些新的Binlog到slave（</strong>slave的
I/O
线程读取并将事件写入relay-log中）然后主库就会继续处理提交操作，而此时不会保证这些Binlog传到任何一个从库节点上。</li>
<li><strong>全同步复制</strong>：优点是能够保证数据的强一致性，缺点是效率太低。当master上有提交事务之后，D<strong>ump线程发送这些新的Binlog到slave上</strong>，<strong>并且必须等待所有的slave回复成功</strong>（所有从库将事件写入中继日志，并将数据写入数据库）才能继续下一步操作。</li>
<li><strong>半同步复制</strong>：优点是在耗费少量性能的基础上能在一定程度上保证数据的一致性。当master上有提交事务之后，<strong>Dump线程发送这些新的Binlog到slave上，并且必须等待其中一个slave回复成功</strong>（slave将事件写入relay-log）才能继续下一步操作。</li>
</ul>
<h3 id="乐观锁悲观锁使用场景">乐观锁悲观锁使用场景</h3>
<p>乐观锁：适用于读操作频繁、写操作少量的场景，如大部分情况下读操作不会被写操作影响的情况下。</p>
<p>悲观锁：适用于写操作频繁、读操作少量的场景，或者需要保证资源的排他性访问的场景。</p>
<h3
id="数据库的四大隔离级别分别是怎么实现的">数据库的四大隔离级别？分别是怎么实现的？</h3>
<h4 id="四大隔离级别">四大隔离级别</h4>
<p>四大隔离级别：读未提交（read uncommitted）、读提交（read
committed）、可重复读（repeatable read）和串行化（serializable ）</p>
<ul>
<li>读未提交是指，
一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指， 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，
一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<h4 id="实现">实现</h4>
<ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read
View * 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把
Read View
理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个
Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read
View，然后整个事务期间都在用这个 Read View**。</li>
</ul>
<h3 id="什么是索引">什么是索引</h3>
<p>在数据库中，索引是一种数据结构，用于提高数据的检索速度和查询效率。索引可以看作是数据库表中一个或多个列的快速查找表，类似于书籍的目录，它们帮助数据库系统快速定位和访问表中的特定数据行。</p>
<h3 id="explain有哪些重要字段">explain有哪些重要字段</h3>
<ul>
<li>type：显示查询使用了何种类型</li>
<li>rows：预估搜索行数</li>
<li>extra:
<ul>
<li>using index：是否使用了覆盖索引</li>
<li>using filesort：是否使用了外排序</li>
<li>distinct：是否在select部分使用了distinc关键字</li>
</ul></li>
</ul>
<h3 id="mysql怎么避免回表">MySQL怎么避免回表</h3>
<ul>
<li>覆盖索引</li>
<li>索引下推</li>
</ul>
<h3 id="mysql的null值是怎么存储的">MySQL的NULL值是怎么存储的</h3>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL
值并不会存储在行格式中的真实数据部分。</p>
<h3 id="mysql查询优化">mysql查询优化</h3>
<ol type="1">
<li>使用索引</li>
<li>覆盖索引</li>
<li>避免索引失效的情况</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select
的效率，但同时也降低了 insert 及 update 的效率</li>
</ol>
<h2 id="操作系统">操作系统</h2>
<h3
id="用户态和内核态的互换条件腾讯云">用户态和内核态的互换、条件（腾讯云）</h3>
<h4 id="切换条件">切换条件</h4>
<p>从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：</p>
<p>其实系统调用本身就是中断，但是软件中断，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如
Linux 的 int 80h 中断。</p>
<p>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中
外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</p>
<h4 id="切换过程">切换过程</h4>
<p>当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）</p>
<ul>
<li>设置处理器至内核态。</li>
<li>保存当前寄存器（栈指针、程序计数器、通用寄存器）。</li>
<li>将栈指针设置指向内核栈地址。</li>
<li>将程序计数器设置为一个事先约定的地址上，该地址上存放的是系统调用处理程序的起始地址。</li>
<li>而之后从内核态返回用户态时，又会进行类似的工作。</li>
</ul>
<h3 id="io-频繁发生内核态和用户态切换怎么解决腾讯云"><strong>I/O
频繁发生内核态和用户态切换，怎么解决</strong>（腾讯云）</h3>
<p>I/O会导致系统调用，从而导致内核态和用户态之间的切换。因为对I/O设备的操作是发生在内核态。那如何减少因为I/O导致的系统调用呢？</p>
<p><strong>答案是：用户进程缓冲区。</strong></p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDUyOTU2,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>用户进程缓冲区</strong>：</p>
<p>程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p><strong>内核缓存区</strong>：</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<h3
id="网卡收到一个包之后到用户读取这个包经历了多少次系统调用有多少次拷贝操作">网卡收到一个包之后到用户读取这个包经历了多少次系统调用，有多少次拷贝操作</h3>
<ol type="1">
<li><strong>网络中断处理：</strong>
当网卡接收到数据包时，会触发网络中断，导致内核调用中断处理程序。这一步并不直接计算在系统调用的范畴内。</li>
<li><strong>协议栈处理：</strong>
数据包会被传递给协议栈中的相应层（例如TCP/IP协议栈）。在这个过程中，内核可能执行一些系统调用来处理网络协议，如<code>ip_rcv</code>和<code>tcp_rcv</code>等。</li>
<li><strong>套接字缓冲区：</strong>
数据包被放置在套接字缓冲区中，等待应用程序读取。这一步可能涉及到一次数据拷贝，将数据从协议栈缓冲区拷贝到套接字缓冲区。</li>
<li><strong>应用程序读取：</strong>
应用程序通过系统调用（例如<code>read</code>或<code>recv</code>）从套接字缓冲区中读取数据。这一步可能涉及到一次数据拷贝，将数据从套接字缓冲区拷贝到用户空间缓冲区。</li>
</ol>
<p>总的来说，通常情况下，至少有两次拷贝操作：一次是从协议栈缓冲区到套接字缓冲区，另一次是从套接字缓冲区到用户空间缓冲区。系统调用的次数会涉及到中断处理、协议栈处理和应用程序读取。每个系统调用都可能涉及到上下文切换和内核态与用户态之间的切换，这可能会引入一些额外的开销。</p>
<h3
id="操作系统如何进行进程的上下文切换">操作系统如何进行进程的上下文切换</h3>
<ol type="1">
<li><strong>保存当前进程状态：</strong>
当操作系统决定需要切换到另一个进程时，首先会保存当前进程的状态。这个状态通常包括
CPU
寄存器的内容（如程序计数器、栈指针、通用寄存器等）、进程控制块（PCB）中的进程信息（如进程
ID、进程状态、程序计数器等）以及其他可能的状态信息。</li>
<li><strong>选择下一个进程：</strong>
操作系统根据调度算法从就绪队列中选择下一个要运行的进程。这个选择可以根据不同的调度算法进行，例如先来先服务（FCFS）、轮转法（Round
Robin）、优先级调度等。</li>
<li><strong>加载下一个进程状态：</strong>
一旦选择了下一个要运行的进程，操作系统就会从该进程的 PCB
中获取其状态信息。这些信息包括进程的程序计数器、栈指针、寄存器值等。然后，操作系统将这些状态加载到
CPU 中，准备开始执行该进程。</li>
<li><strong>切换内存空间：</strong>
在多任务操作系统中，不同进程可能会运行在不同的内存空间中，因此在切换进程时，操作系统可能还需要执行内存空间的切换操作。这包括<strong>更新页表、切换地址空间</strong>等。</li>
<li><strong>恢复运行：</strong> 最后，操作系统会将 CPU
控制权转移到新选择的进程，开始执行其代码。此时，该进程的状态被加载到 CPU
中，从之前保存的状态中恢复，并继续执行其上一次被暂停的位置。</li>
</ol>
<h3 id="线程崩溃进程会崩溃吗">线程崩溃进程会崩溃吗？</h3>
<p>一般情况下，如果一个线程崩溃，那么整个进程很可能会崩溃**。
这是因为线程之间共享地址空间，一个线程的崩溃可能导致内存的不确定性，进而影响到其他线程的执行。</p>
<h3
id="遇到过死锁吗怎么解决的不要背那四条">遇到过死锁吗？怎么解决的，不要背那四条。</h3>
<p>鸵鸟策略，遇到死锁的时候把进程kill掉。</p>
<h3 id="cpu中断后进程的处理流程">cpu中断后，进程的处理流程</h3>
<p>当 CPU
接收到中断信号后，会暂停当前正在执行的进程，并执行中断处理程序。下面是
CPU 中断后进程的处理流程的一般步骤：</p>
<ol type="1">
<li><strong>中断响应</strong>：CPU
响应中断信号，停止当前正在执行的指令，并保存当前进程的执行状态（如程序计数器、寄存器状态等）。</li>
<li><strong>中断处理</strong>：CPU 跳转到中断向量表（Interrupt Vector
Table）中对应的中断处理程序入口点，开始执行中断处理程序。中断处理程序负责处理特定类型的中断，如时钟中断、硬件故障中断等。</li>
<li><strong>保存上下文</strong>：中断处理程序会保存当前进程的上下文（Context），包括进程的寄存器状态、堆栈指针等信息，以便稍后恢复进程的执行状态。</li>
<li><strong>处理中断请求</strong>：中断处理程序根据中断类型和中断源的不同，执行相应的处理逻辑，可能包括设备的输入输出操作、错误处理、进程调度等。</li>
<li><strong>恢复进程执行</strong>：中断处理程序完成后，会根据需要选择是否恢复当前被中断的进程的执行。如果需要切换到其他进程执行，会进行进程调度，选择合适的进程，并加载其执行状态。</li>
<li><strong>恢复上下文</strong>：如果恢复了之前被中断的进程的执行，中断处理程序会恢复该进程的执行状态，包括恢复寄存器状态、堆栈指针等，使进程可以继续执行中断发生之前的指令。</li>
<li><strong>继续执行</strong>：CPU
继续执行中断处理程序之后的指令，或者切换到其他进程执行，完成整个中断处理过程。</li>
</ol>
<h3 id="说说你对信号量的理解">说说你对信号量的理解</h3>
<p>信号量是一种用于进程间同步和互斥的同步原语。它通常用于解决多个进程或线程之间共享资源的并发访问问题。信号量可以是计数器或标志，用于控制对临界区的访问。</p>
<p>在操作系统中，信号量通常分为两种类型：</p>
<ol type="1">
<li><strong>二进制信号量（Binary
Semaphore）</strong>：也称为互斥锁，只能取两个值，通常为 0 或
1。它用于实现临界区的互斥访问，保证在同一时刻只有一个进程可以访问临界资源。</li>
<li><strong>计数信号量（Counting
Semaphore）</strong>：可以取多个值，通常用于控制共享资源的访问数量。它允许多个进程同时访问临界资源，但是需要限制资源的数量。</li>
</ol>
<p>信号量的基本操作包括：</p>
<ul>
<li><strong>初始化</strong>：创建信号量，并设置其初始值。</li>
<li><strong>P 操作（Wait
操作）</strong>：尝试获取信号量资源，如果资源不可用，则进入等待状态，直到资源可用。如果是二进制信号量，P
操作会将信号量值减 1。</li>
<li><strong>V 操作（Signal
操作）</strong>：释放信号量资源，如果有等待的进程，通知它们资源可用。如果是二进制信号量，V
操作会将信号量值加 1。</li>
</ul>
<p>信号量的使用场景包括：</p>
<ul>
<li><strong>临界区的互斥访问</strong>：多个进程需要对临界资源进行互斥访问，防止竞争条件（Race
Condition）的发生。</li>
<li><strong>生产者消费者问题</strong>：多个生产者和消费者共享一个有限的缓冲区，需要控制缓冲区的访问数量。</li>
<li><strong>读者写者问题</strong>：多个读者和写者共享一个数据资源，需要控制读写操作的并发访问。</li>
</ul>
<h3
id="说说你对虚拟内存的理解尽可能多">说说你对虚拟内存的理解，尽可能多</h3>
<p>虚拟内存是一种计算机操作系统的内存管理技术，它将物理内存（RAM）和磁盘存储结合起来，为每个进程提供了一个连续的、私有的地址空间。虚拟内存使得多个进程可以同时运行，并且可以让每个进程感觉自己拥有整个系统的内存空间。</p>
<p>以下是对虚拟内存的更详细理解：</p>
<ol type="1">
<li><strong>地址映射</strong>：虚拟内存将进程中的逻辑地址（虚拟地址）映射到物理内存中的物理地址。这样，进程看到的地址空间是连续的，但实际上数据可能存储在物理内存中的不同位置，或者甚至存储在磁盘上。</li>
<li><strong>页面</strong>：虚拟内存将地址空间分割成固定大小的页面（Page），通常为
4KB 或
8KB。物理内存也被分割成相同大小的页面。每个页面都有一个对应的页表（Page
Table）记录它在物理内存中的位置。</li>
<li><strong>页面置换</strong>：当物理内存不足以容纳所有进程的数据时，虚拟内存使用页面置换算法将一部分数据从物理内存中换出到磁盘上的交换空间（Swap
Space），以释放物理内存供其他进程使用。常见的页面置换算法有最近最少使用（LRU）、先进先出（FIFO）等。</li>
<li><strong>虚拟内存管理</strong>：虚拟内存管理包括地址映射、页面分配、页面置换等功能。操作系统负责管理虚拟内存的分配和释放，以及页面置换算法的选择和执行。</li>
<li><strong>内存保护</strong>：虚拟内存可以为每个页面设置不同的访问权限，如读、写、执行等，以保护进程的内存安全。</li>
<li><strong>内存共享</strong>：虚拟内存允许多个进程共享内存页面，这些页面可以映射到不同的进程地址空间中，实现共享数据或代码。</li>
</ol>
<h2 id="设计模式">设计模式</h2>
<h3 id="单例模式实现的优点">单例模式实现的优点</h3>
<ol type="1">
<li>因为单例模式在内存中就只有一个实例，其主要优点可以<strong>减少内存的开支</strong>。尤其是一个对象需要频繁地创建销毁时，毕竟创建或销毁时性能又无法优化,
那么单例模式就非常合适了；</li>
<li>因为单例模式只生成一个实例，所以，其主要优点可以<strong>减少系统的性能开销</strong>，当一个对象产生需要比较多的资源时，比如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决；</li>
<li>同时单例模式可以<strong>避免对资源的多重占用</strong>，比如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写的操作；</li>
<li>单例模式可以在系统设置全局的访问点，<strong>优化和共享资源</strong>访问，可以设计一个单例类，负责所有数据表的映射处理等。</li>
</ol>
<h3
id="怎么提前销毁懒汉式局部静态变量">怎么提前销毁懒汉式局部静态变量？</h3>
<h3 id="三种工厂模式的区别">三种工厂模式的区别</h3>
<ul>
<li>简单工厂模式只有一个抽象产品类，只有一个具体的工厂类。</li>
<li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。</li>
<li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个具体产品类的实例。</li>
</ul>
<h2 id="redis">Redis</h2>
<p>常见的有五种数据结构：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315221909012.png" srcset="/img/loading.gif" lazyload
alt="image-20240315221909012" />
<figcaption aria-hidden="true">image-20240315221909012</figcaption>
</figure>
<h4 id="redis底层数据结构">redis底层数据结构</h4>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315223431452.png" srcset="/img/loading.gif" lazyload
alt="image-20240315223431452" />
<figcaption aria-hidden="true">image-20240315223431452</figcaption>
</figure>
<h3
id="redis做缓存有哪些问题如何解决">redis做缓存有哪些问题？如何解决？</h3>
<p>从缓存穿透，缓存击穿，缓存雪崩，缓存⼀致性等⽅⾯来答。参考<a
href="https://gstarmin.github.io/2023/12/25/Redis/#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">缓存雪崩、缓存穿透、缓存预热、缓存击穿、服务降级</a></p>
<h3 id="跳表的插入与删除">跳表的插入与删除</h3>
<h4 id="插入">插入</h4>
<p>向一个跳跃表中插入元素可以分为三步：</p>
<ol type="1">
<li>找到各层的插入位置 。</li>
</ol>
<p>和单链表一样，要插入一个元素，需要找到前驱节点。跳跃表是多层链表，
那么需要找到各层的前驱节点。</p>
<p>下图中，要插入一个新元素 20 ，其中数组 last[k] 表示找到的第 k
阶上的前驱节点。</p>
<p>找的方法和查找过程一样，只需要记住每一层可以向右考察到的最后一个节点即可。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.1.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li>决定新节点的阶 。</li>
</ol>
<p>用上面提到的 随机函数 RandLevel 决定它的阶。
如果得到比整个跳跃表还要高的阶，需要把头节点的阶增高，与之对齐。
以便任何节点都可以从左上角的头节点出发找到。</p>
<p>由于 last
数组的含义是各层的插入位置，而且，接下来将要把头节点在新增高的这些层上指向新节点，
于是把头节点 head 记为 last 数组在这些层上的值。</p>
<p>下图中，假如生成了一个大的阶 4 ，那么跳跃表的阶将会增高到 4， 并设置
last[4] = head 。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.2.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="3" type="1">
<li>各层执行插入动作 。</li>
</ol>
<p>仍然和单链表一样，插入一个新节点的过程，就是把新节点和前驱、后驱节点分别搭线。
只不过跳跃表是在多层上进行。</p>
<p>在每一层，前驱节点 last[k] 指向新节点，新节点指向 last[k]
原来的后驱节点。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.3.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="删除">删除</h4>
<p>同样地，从一个跳跃表中删除元素可以也可以分为三步：</p>
<ol type="1">
<li>找到各层的前驱节点和要删除的节点 。</li>
</ol>
<p>从单链表中删除一个元素，需找到前驱节点。跳跃表是多层链表，也需找到各层的前驱节点。</p>
<p>和前面一样，last 数组来存放各层的前驱节点。 查找元素的过程，即可记录
last 数组。</p>
<p>同时查找结束后，亦可判断要删除的元素是否存在于表中。</p>
<p>下图以删除元素 22 为例：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.4.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li>各层执行删除 。</li>
</ol>
<p>仍然与单链表是类似。在各层上，前驱节点直接指向要删除的节点的后驱节点。
最终释放要删除的节点的内存即可。</p>
<p>不过，并非 last 数组的每一项都是待删除节点的前驱节点，
在删除时需要注意过滤。</p>
<p>以删除 22 为例，具体的删除动作就是，如果 last[k] 的后驱是 22， 则将
last[k] 的后驱指向 22 的后驱。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.5.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="3" type="1">
<li>抹去删除节点后可能残留的孤零的高阶 。</li>
</ol>
<p>如果删除的元素是一个高阶节点，可能让跳跃表的头节点残留下孤零零的高阶。</p>
<p>这一步是可选的，即使不清理也无大碍。</p>
<p>以删除高阶节点 33 为例，删除 33 后，头节点的阶可以由 4 降为 3 。</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.6.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="项目">项目</h2>
<h3 id="内存池的实现">内存池的实现</h3>
<p>该项目所使用的内存池原型是 Google 的开源项目 tcmalloc，其全称为
Thread-Caching Malloc，即线程缓存的
malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数，即
malloc 和 free。</p>
<p>内存池主要解决的就是效率问题，它能够避免让程序频繁的向系统申请和释放内存。其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题，内存碎片分为如下两种：</p>
<ul>
<li><strong>外部碎片</strong>：指的是空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配的需求。</li>
<li><strong>内部碎片</strong>：指的是由于一些对齐的需求，导致分配出去的空间中一些内存无法被充分利用。</li>
</ul>
<blockquote>
<p>内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p>
</blockquote>
<p>该内存池的整体架构如下图所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/mempool.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>其主要由以下三个部分组成：</p>
<ul>
<li><code>Thread Cache</code>: 线程缓存是每个线程独有的，用于小于等于
256KB 的内存分配，每个线程独享一个 ThreaCache了。</li>
<li><code>Central Cache</code>: 中心缓存是所有线程共享的，当 ThreadCache
需要内存时会按需从 CentralCache 中获取内存，而当 ThreadCache
中的内存满足一定条件时，CentralCache 也会在合适的时机对其进行回收。</li>
<li><code>Page Cache</code>:
页缓存中存储的内存是以页为单位进行存储及分配的，当 CentralCache
需要内存时，PageCache 会分配出一定数量的页给 CentralCache，而当
CentralCache 中的内存满足一定条件时，PageCache
也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</li>
</ul>
<p>上述三个部分的主要作用如下：</p>
<ul>
<li>Thread Cache: 主要解决锁竞争的问题；</li>
<li>Central Cache: 主要负责居中调度的问题；</li>
<li>Page Cache: 主要负责提供以页为单位的大块内存；</li>
</ul>
<h3 id="threadcache">1.ThreadCache</h3>
<p>Thread Cache 的结构如下图所示：</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/Kohirus/Apollo/blob/main/screenshot/threadcache.png"><img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/threadcache.png" srcset="/img/loading.gif" lazyload
alt="img" /></a></p>
<p>通过使用<strong>字节对齐</strong>的方法来减少哈希桶的数目，并且进一步增加内存利用率，在设计时，让不同的范围的字节数按照不同的对齐数进行对齐，具体的对齐方式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节数</th>
<th>对齐数</th>
<th>哈希桶下标</th>
<th>自由链表数目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1, 128]</td>
<td>8</td>
<td>[0, 16)</td>
<td>16</td>
</tr>
<tr class="even">
<td>[129, 1024]</td>
<td>16</td>
<td>[16, 72)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[1025, 8 * 1024]</td>
<td>128</td>
<td>[72, 128)</td>
<td>56</td>
</tr>
<tr class="even">
<td>[8 * 1024+1, 64 * 1024]</td>
<td>1024</td>
<td>[128, 184)</td>
<td>56</td>
</tr>
<tr class="odd">
<td>[64 * 1024+1, 256 * 1024]</td>
<td>8*1024</td>
<td>[184, 208)</td>
<td>24</td>
</tr>
</tbody>
</table>
<p>为了实现每个线程无锁访问属于自己的 Thread
Cache，就需要用到<strong>线程局部存储</strong>(Thread Local Storage,
TLS)，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其它线程访问到，这样就保证了数据的线程独立性。</p>
<p>当某个线程申请的对象不用了，可以将其释放给 Thread Cache，然后 Thread
Cache 将该对象插入到哈希桶的自由链表当中即可。</p>
<p>但是随着线程不断地释放，对应自由链表中的长度也会越来越长，这些内存堆积在一个
Thread Cache 中就是一种浪费，此时应该将这些内存还给 Central
Cache，这样一来，这些内存对于其它线程来说就是可申请的，因此当 Thread
Cache 中某个桶当中的自由链表太长时，可以将其释放给 Central Cache。</p>
<h3 id="centralcache">2. CentralCache</h3>
<p>当线程申请某一大小的内存时，如果 Thread Cache
中对应的自由链表不为空，那么直接取出一个内存块返回即可，但如果此时该自由链表为空，那么这时
Thread Cache 就需要向 Central Cache 申请内存了。</p>
<p>Central Cache 的结构与 Thread Cache
是一样的，都是哈希桶结构，并且所遵循的对齐规则也一致。这样做的好处是当
Thread Cache 的某个桶中没有内存时，就可以直接到 Central Cache
中相对应的哈希桶中取内存。</p>
<p>Central Cache 与 Thread Cache 不同之处有两点：</p>
<ol type="1">
<li>Central Cache 是所有线程共享的，而 Thread Cache 是线程独享的；</li>
<li>Central Cache 的哈希桶中挂载的是 Span，而 Thread Cache
的哈希桶中挂载的是切好的内存块；</li>
</ol>
<p>其结构如下所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/centralcache.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于 Central Cache 是所有线程共享的，多个 Thread Cache
可能在同一时刻向 Central Cache
申请内存块，因此为了保证线程安全，需要<strong>加锁控制</strong>。此外，由于只有多个线程同时访问
Central Cache
的同一个桶时才会存在锁竞争，因此无需用锁来锁住所有哈希桶，只需锁住当前所访问的哈希桶即可。</p>
<p>当 Thread Cache 向 Central Cache 申请内存时，如果给的太少，那么
Thread Cache 在短时间用完了又会再来申请；但是如果给的太多，那么 Thread
Cache
可能用不完而浪费大量的空间。为此，此处采用<strong>慢反馈调节算法</strong>，当
Thread Cache 向 Central Cache
申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p>
<p>当 Thread Cache 中的某个自由链表太长时，会将自由链表中的对象归还给
Central Cache 中的 Span。但是需要注意的是，归还给 Central Cache
的这些对象不一定都属于同一个 Span 的，且 Central Cache
中的每个哈希桶中都可能不止一个
Span，因此归还时不仅需要知道该对象属于哪一个桶，还需要知道它属于这个桶中的哪一个
Span。为了建立页号和 Span
之间的映射，需要使用一种哈希表结构进行管理，一种方式是采用 C++ 中的
unordered_map，另一种方式是采用<strong>基数树</strong>数据结构。</p>
<h3 id="pagecache">3. PageCache</h3>
<p>Page Cache 的结构与 Central Cache 一样，都是哈希桶的结构，并且 Page
Cache 的每个哈希桶中都挂的是一个个的 Span，这些 Span
也是按照双向链表的结构连接起来的。</p>
<p>但是，Page Cache 的映射规则与 Central Cache 和 Thread Cache
不同，其采用的是<strong>直接定址法</strong>，比如 1 号桶挂的都是 1 页的
Span，2 号桶挂的都是 2 页的 Span，以此类推。</p>
<p>其次，Central Cache 每个桶中的 Span
都被切为了一个个对应大小的对象，以供 Thread Cache 申请。而 Page Cache
服务的是 Central Cache，当 Central Cache 中没有 Span 时，向 Page Cache
申请的是某一固定页数的 Span。而如果切分这个申请到的 Span 就应该由
Central Cache 自己来决定。</p>
<p>其结构如下图所示：</p>
<figure>
<img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/pagecache.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>当每个线程的 Thread Cache 没有内存时都会向 Central Cache
申请，此时多个线程的 Thread Cache 如果访问的不是 Central Cache
的同一个桶，那么这些线程是可以同时进行访问的。这时 Central Cache
的多个桶就可能同时向 Page Cache 申请内存，所以 Page Cache
也是存在线程安全问题的，因此在访问 Page Cache 时也必须要加锁。</p>
<p>但是此处的 Page Cache 不能使用桶锁，因为当 Central Cache 向 Page
Cache 申请内存时，Page Cache 可能会将其他桶中大页的 Span 切小后再给
Central Cache。此外，当 Central Cache 将某个 Span 归还给 Page Cache
时，Page Cache 也会尝试将该 Span 与其它桶当中的 Span 进行合并。</p>
<p>也就是说，在访问 Page Cache
时，可能同时需要访问多个哈希桶，如果使用桶锁则可能造成大量频繁的加锁和解锁，导致程序的效率底下。因此在访问
Page Cache 时没有使用桶锁，而是用一个大锁将整个 Page Cache 锁住。</p>
<p>如果 Central Cache 中有某个 Span 的 <code>useCnt_</code> 减到 0
了，那么 Central Cache 就需要将这个 Span 归还给 Page Cache
了。为了缓解内存碎片问题，Page Cache 还需要尝试将还回来的 Span
与其它空闲的 Span 进行合并。</p>
<h3 id="基数树">4. 基数树</h3>
<p>由于在 PageCache 中最初建立页号与 Span 之间的映射关系时，采用的是
unordered_map 数据结构，但是通过性能测试发现，内存池的性能并未优于原生的
malloc/free 接口，因此通过 Visual Studio 的性能分析工具发现性能瓶颈位于
unordered_map 处。</p>
<p>这主要是因为 unordered_map
不是线程安全的，在多线程环境下需要加锁，而大量的加锁则会导致资源的消耗和性能的下降，因此在映射页号与
Span 之间的关系时，采用基数树（Radix Tree）数据结构来进行优化。</p>
<p>当采用如下图所示的单层基数树时，在 32 位平台下，以一页大小为 8K(<span
class="math inline">\(2^{13}\)</span>) 为例，此时页的数目就是 <span
class="math inline">\(2^{32}\div
2^{13}=2^{19}\)</span>，因此存储页号最多需要 19 个比特位，同时由于 32
位平台下的指针大小为 4 字节，因此该数组的大小就是 <span
class="math inline">\(2^{19}\times
4=2^{21}=2M\)</span>，内存消耗不大，是可行的。但是如果是在 64
位平台下，此时该数组的大小就是 <span class="math inline">\(2^{51}\times
8=2^{54}=2^{24}G\)</span>，这显然是不可行的：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225048027-1025596599.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如下图所示，为二层基数树，同样在 32 位平台下，以一页的大小为 8K
为例来说明，此时存储页号最多需要 19 个比特位。而二层基数树实际上就是把这
19 个比特位分为两次进行映射。例如，前 5
个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号所对应的
Span 指针。</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225105536-756632135.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在二层基数树中，第一层的数组占用 <span
class="math inline">\(2^5\times 4=2^7\)</span> Bytes
空间，第二层的数组最多占用 <span class="math inline">\(2^5\times
2^{14}\times
4=2^{21}=2M\)</span>。二层基数树相比与一层基数树的好处就是，一层基数树必须一开始就把
2M
的数组开辟出来，而二层基数树一开始只需要将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p>
<p>在 32 位平台下，一层基数树和二层基数树都是适用的，但是在 64
位平台下，就需要使用下图所示的三层基数树了。三层基数树类似于二层基数树，实际上就是把存储页号的若干比特分为三次进行映射，而且只有当需要建立某一页号的映射关系时，才会开辟对应的数组空间，在一定程度上节约了内存空间：</p>
<figure>
<img
src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225124800-503935249.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="简单介绍一下你的项目"><strong>简单介绍一下你的项目</strong></h3>
<p>我的这个项目是一个分布式K-V缓存系统，基于CS架构，服务器由一个中心节点和一系列存储节点构成。为客户端提供数据的基于内存的数据缓存功能。底层存储结构是通过跳表实现的。</p>
<h3 id="为什么要做这个项目"><strong>为什么要做这个项目？</strong></h3>
<p>这个项目综合性比较强，包括分布式缓存系统、服务器通信网络库以及内存池，主要是为了学习跳表、分布式存储、网络编程以及内存池等知识，将学习的东西综合应用。</p>
<h3 id="项目是为了解决什么问题">项目是为了解决什么问题？</h3>
<p>为了解决在高并发场景中的通过分布式横向扩展节点来处理更多的数据和请求，从而提高系统的容量和吞吐量。并且通过一致性哈希实现负载均衡，防止单个节点的性能瓶颈。</p>
<h3 id="有什么亮点难点"><strong>有什么亮点？难点？</strong></h3>
<p>亮点是通过一致性哈希能够实现负载均衡，并且把数据备份到下一个节点。有单一节点故障的恢复能力，能够灵活增添节点。</p>
<p>难点是在处理增添节点的时候数据的备份问题，还有服务器之间的数据传递问题。</p>
<h3 id="项目遇到哪些困难怎么解决的">项目遇到哪些困难，怎么解决的？</h3>
<h3 id="运用了哪些技术"><strong>运用了哪些技术?</strong></h3>
<p>用了一致性哈希，跳表，LRU缓存，重写Muduo网络库，以及重写了google的tcmalloc内存池。</p>
<h3 id="有什么收获"><strong>有什么收获？</strong></h3>
<p>主要是学习到了网络编程、还有分布式缓存的相关的知识，主要就是提高了C++的编码能力，没做项目之前对这些还比较陌生。</p>
<h3
id="web服务器里怎么设计的io复用"><strong>Web服务器里怎么设计的IO复用</strong></h3>
<p>使用的epoll，通过EventLoop循环调用实现。</p>
<h3
id="项目里用了线程池线程池怎么建立起来的为什么要用线程池"><strong>项目里用了线程池，线程池怎么建立起来的，为什么要用线程池</strong></h3>
<p>Muduo是one Loop per
thread模式，也就是一个线程一个事件循环。通过封装一个事件循环的线程类EventLoopThread，底层的线程通过C++11的thread类创建。然后通过for循环创新事件循环线程类，创建指定个数，会返回相应的EventLoop。当有新连接到来的时候，会调用getnextloop函数在主线程中通过轮询分配EventLoop。</p>
<p>因为单线程处理能力有限，如果多CPU的话可以并行处理数据，实现服务器的高并发。</p>
<h3
id="为什么需要使用内存池"><strong>为什么需要使用内存池？</strong></h3>
<p>因为这是基于内存的缓存系统，频繁的内存申请和释放会影响效率，而且还会出现内存碎片的问题，所以使用内存池解决这些问题。</p>
<h3
id="web服务器这个项目你用了线程池线程池开多大的呢"><strong>Web服务器这个项目你用了线程池，线程池开多大的呢</strong></h3>
<p>线程池一般是根据CPU的数量来开的，有一个主线程，线程池一般就是CPU数量
- 1个。</p>
<h3
id="整个开发过程中有没有遇到困难怎么解决的"><strong>整个开发过程中有没有遇到困难，怎么解决的</strong></h3>
<p>在数据迁移或者数据恢复的出现与预期不对的情况，通过画图，模拟哪些数据应该备份到哪里，然后调试一步一步观察数据的流动进行排错。</p>
<h3
id="能介绍一下在web服务器项目中做了什么样的测试和学习有什么样的体会"><strong>能介绍一下在web服务器项目中做了什么样的测试和学习，有什么样的体会</strong></h3>
<p>通过手动模拟计算哈希和画图查看数据迁移过程，手动添加新的节点以及Kill掉某一个节点查看系统是否正常运行。</p>
<h3
id="web服务器最主要的一个考量指标是并发处理能力想问你为了提高并发量做了怎么样的操作"><strong>web服务器最主要的一个考量指标是并发处理能力，想问你为了提高并发量做了怎么样的操作</strong></h3>
<p>网络服务器中，通过IO多路用以及线程池提高并发，存储通节点并且过内存池管理内存。</p>
<h3 id="什么是跳表"><strong>什么是跳表</strong></h3>
<p>跳表其实就是多层的有序链表，在最底层跳跃长度是1也就是普通的链表，越往上层走，跳表的下一个节点跳得越远，每一层成指数级增长。所以增删改查只需要log(N)的复杂度。</p>
<h3
id="为什么不用哈希算法或者红黑树"><strong>为什么不用哈希算法或者红黑树</strong></h3>
<p>相比哈希表，跳表是有序的，对于范围查询更有优势。而且也无需重新哈希。
相比红黑树，插入和删除操作的简便性，无需红黑树复杂的平衡操作，而且范围查询更加容易。</p>
<h3
id="一致性哈希算法是什么是用什么数据结构实现的"><strong>一致性哈希算法是什么，是用什么数据结构实现的</strong></h3>
<p>一致性哈希算法是用于分布式数据分片的做法，利用一个哈希环，将服务器节点名字哈希后注册到哈希环中。当有数据存储或者查询操作时通过哈希算法选择对应的存储节点。当发送数据迁移或者新增节点时无需进行大量数据迁移，而是只需要迁移在哈希环中有影响的节点数据即可。
使用的数据结构是红黑树（c++的map结构），方便快速寻找指定哈希值的前后节点。</p>
<h3 id="基数树是什么">基数树是什么</h3>
<p>基数树的特点是它在树中的每个节点上都存储了一串位数字或者字母，而不是单一的元素。使用三层，第一层存储0-6字节。</p>
<h3 id="为什么需要-io-多路复">为什么需要 I/O 多路复⽤？</h3>
<ol type="1">
<li><strong>提高性能</strong>：使用I/O多路复用可以减少I/O操作的开销。相比于每个I/O操作都创建一个线程或进程来处理，多路复用可以使用少量的线程或进程同时监视多个I/O通道，从而减少了上下文切换的开销，提高了系统的性能。</li>
<li><strong>节省资源</strong>：创建和管理线程或进程需要消耗系统资源，而且线程或进程的数量受到系统资源的限制。通过使用I/O多路复用，可以减少同时活跃的线程或进程数量，从而节省了系统资源。</li>
<li><strong>支持高并发</strong>：在高并发的场景下，使用I/O多路复用可以更有效地处理大量的并发连接。通过复用少量的线程或进程来处理多个I/O通道，可以更好地支持高并发的需求，提高系统的扩展性和稳定性。</li>
<li><strong>支持非阻塞I/O</strong>：I/O多路复用通常与非阻塞I/O配合使用，可以实现非阻塞的I/O操作。这样可以避免因为I/O操作阻塞导致的线程或进程被长时间挂起，提高了系统的响应速度和吞吐量。</li>
<li><strong>简化编程模型</strong>：使用I/O多路复用可以简化编程模型。开发人员不需要关注多个I/O操作的具体细节，而是可以使用简单的事件驱动模型来处理I/O事件。这样可以降低编程复杂度，提高代码的可读性和可维护性。</li>
</ol>
<h3 id="创建线程用什么api">创建线程用什么api</h3>
<p>std::thread</p>
<h3
id="如何销毁线程detach和join有什么区别">如何销毁线程，detach和join有什么区别？</h3>
<ol type="1">
<li><strong>调用
<code>std::thread::join()</code></strong>：在主线程中调用
<code>std::thread</code> 对象的 <code>join()</code>
方法可以等待该线程执行完成。主线程会阻塞，直到被等待的线程执行完成。在被等待的线程执行完成后，<code>join()</code>
方法返回，线程对象被销毁。</li>
<li><strong>调用
<code>std::thread::detach()</code></strong>：在创建线程后，可以调用
<code>std::thread</code> 对象的 <code>detach()</code>
方法将该线程“分离”出来。分离后，线程将在后台运行，不再与主线程同步。当线程执行完成后，其资源会自动释放，线程对象也会被销毁。</li>
</ol>
<h3
id="怎么保证线程安全互斥锁粒度大怎么办">怎么保证线程安全？互斥锁粒度大怎么办？</h3>
<p>使用互斥锁，锁粒度大可以使用细粒度锁。</p>
<h3 id="介绍以下内存池怎么实现的">介绍以下内存池怎么实现的？</h3>
<h3 id="介绍以下muduo库">介绍以下muduo库</h3>
<h3
id="你了解什么是负载均衡吗腾讯云">你了解什么是负载均衡吗？（腾讯云）</h3>
<h3 id="解释一下epoll腾讯云">解释一下epoll（腾讯云）</h3>
<h3 id="红黑树腾讯云">红黑树（腾讯云）</h3>
<h3 id="跳表红黑树avl树的区别">跳表、红黑树、AVL树的区别</h3>
<h3
id="跳表红黑树avl树分别适用于什么场景">跳表、红黑树、AVL树分别适用于什么场景</h3>
<h2 id="手撕代码">手撕代码</h2>
<h3
id="手撕代码将一个字符串转换成字符加出现次数的形式比如aaabb转换成a3b2要求不能用任何int转str的api腾讯云">手撕代码：将一个字符串转换成字符加出现次数的形式，比如aaabb转换成a3b2（要求不能用任何int转str的api）（腾讯云）</h3>
<h3 id="手写线程池腾讯云">手写线程池（腾讯云）</h3>
<h3 id="手写智能指针腾讯云">手写智能指针（腾讯云）</h3>
<h3 id="手写读者写者">手写读者写者</h3>
<h3 id="口算99999995">口算(9^999999)%5=?</h3>
<p>求（a^b）%n。本质是快速幂，只写出递归。a、b、n都很⼤，int会爆，必须⽤long</p>
<h2 id="比赛">比赛</h2>
<h3 id="金融科技建模大赛">金融科技建模大赛</h3>
<h4 id="赛题设置">赛题设置</h4>
<p>比赛的主题是“<strong>客户复购行为预测</strong>”。银行不仅关注新客户获客，也关注老客户的复购行为，希望增加客户黏性。客户在金融产品和服务上的重复购买行为越多，客户黏性越大。银行可以通过识别这些黏性客户，更好地分析他们的需求，并向他们推送新产品，进行客户关系管理。本次比赛的目标是对客户复购频率的三分类预测。比赛选手需要根据客户信息（包括基础客户画像信息、产品购买行为信息以及第三方客户画像补充信息）预测客户复购行为标签：<strong>低频（0）、中频（1）、高频（2），并根据客户平均价值（低频1、中频3、高频5），在独立样本上检验预测准确性（加权准确性）。</strong></p>
<h4 id="数据">数据</h4>
<p>分为3个表，X1表为客户基本信息，X2表为客户消费相关信息，X3为其他信息</p>
<p>初赛训练集</p>
<p>复赛训练集15000条，测试集8000条</p>
<h4 id="特征工程">特征工程</h4>
<ul>
<li>缺失值填充：对于连续型数值特征使用均值填充，对于离散型数值使用众数填充，对于类别特征使用unknown填充</li>
<li>特征经过脱敏，比如像X1表很多只写了基本特征，可以根据其格式判断是省份，身份证号。然后可以进一步根据省份划分出东中西部地区。身份证号其实就跟省份冲突。</li>
<li>根据catboost的特征重要性分析提取出强特征，然后对强特征做交叉特征（加减乘除），然后过滤掉重要性比较低的衍生特征</li>
<li>每个客户都有多条消费记录，把这些消费记录按照客户编号进行分桶，然后统计诸如消费次数，消费平均金额，并对里边如果是数值的特征做众数、中位数、平均数、最大最小值作为新特征，以及连续消费的天数，如果是字符串的话统计不同字符串的个数，等特征（这个对于性能提升是很大的）</li>
<li>对一些重要性不是特别重要的特征但是之间可能有关联的特征，这些特征单个可能不是很重要，但是做交叉之后重要性会更高（客户货款偿付比例与收入增长的关系。这可能反映了客户的财务稳定性和收入增长的能力）</li>
</ul>
<h4 id="训练">训练</h4>
<p>使用catboost模型，使用GridSearchCV网格搜索最优参数</p>
<h3 id="xgboostcatboostlightgbm">xgboost、catboost、lightgbm</h3>
<p>选择哪个算法取决于数据集的规模、特征的类型以及任务的要求。LightGBM
适用于大规模数据和高维特征，XGBoost 适用于一般规模的数据和任务，而
CatBoost 则适用于处理类别型特征和稀疏数据的场景。</p>
<h3
id="第五届全国大学生计算机能力挑战赛">第五届全国大学生计算机能力挑战赛</h3>
<h4 id="赛题描述">赛题描述</h4>
<p>给予一批随机目标图片，选手需要将这些图片中的目标进行检测目标位置并识别目标类别。</p>
<h4 id="数据集描述">数据集描述</h4>
<p>提供少量训练集（训练集1500张图片、测试集500张图片），会在数据开放下载后陆续公布，总体为低资源的竞赛任务。训练集用于选手的模型训练，测试集存在服务器后台，用于最终结果的评测提交，不提供给选手。</p>
<p>训练集包含：1.图片文件;2.描述图片目标位置和类别文件。</p>
<h4 id="yolov8结构">YOLOv8结构</h4>
<ul>
<li>输入端：缩放图片尺寸数据、适应模型训练；</li>
<li>Backbone：模型主网络，通过卷积层数的增加，提取P1-P5不同感受野的feature
map，依次感受野逐渐增加；</li>
<li>Neck：呈现FPN和PAN结构，其中FPN (feature pyramid
networks)：特征金字塔网络，采用多尺度来对不同size的目标进行检测；PAN：自底向上的特征金字塔。这样结合操作，FPN层自顶向下传达强语义特征，而特征金字塔则自底向上传达强定位特征，两两联手，从不同的主干层对不同的检测层进行特征聚合。</li>
<li>Prediction：为model框架中的Head头，用于最终的预测输出，P3 -&gt; P4
-&gt; P5过程中，感受野是增大的，所以依次预测目标为小 -&gt; 中 -&gt;
大。</li>
</ul>
<h4 id="使用的优化方法">使用的优化方法</h4>
<h2 id="场景题">场景题</h2>
<h3
id="一个数据流中随机抽样固定大小样本字节懂车帝">一个数据流中随机抽样固定大小样本（字节懂车帝）</h3>
<p>蓄水池抽样：</p>
<ol type="1">
<li>从数据流中读取前k个元素，依次放入水塘中。</li>
<li>对于第i个元素（i &gt;
k），以1/i的概率随机选择是否将其替换水塘中的某个元素。如果被选择，则随机选择水塘中的一个位置，用当前元素替换该位置的元素。</li>
<li>处理完整个数据流后，水塘中的k个元素即为随机抽样得到的样本。</li>
</ol>
<h3
id="圆上三个点构成锐角三角形的概率">圆上三个点构成锐角三角形的概率</h3>
<p>1 / 4</p>
<h2 id="其他">其他</h2>
<h3 id="你都知道哪些消息队列">你都知道哪些消息队列</h3>
<ul>
<li>Kafka</li>
<li>RocketMQ</li>
<li>RabbitMQ</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试问题</div>
      <div>https://gstarmin.github.io/2024/03/11/面试问题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Starmin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/10/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="海量数据处理">
                        <span class="hidden-mobile">海量数据处理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
