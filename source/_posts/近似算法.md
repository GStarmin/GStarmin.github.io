---
title: 近似算法
tags: 
    - 算法
    - 高级算法设计与分析
categories: 
    - 算法
--- 

## 近似算法
假设现在需要解决一个NP-Hard问题，但是又不太可能在多项式时间内求解，但是我们可以退而求其次，那么就必须要牺牲下面的其中一项：

- 求得最优解
- 在多项式时间内完成
- 覆盖问题的所有例子


而牺牲第二条是不能接受的，当我们选择满足后两者（也就是牺牲第一项），即对解的优越性放宽要求时，设计出的算法被称为**近似算法**。

## Load Balancing问题
给定$m$台相同的机器，$n$个任务，任务$j$需要的处理时间为$t_j$,且每个任务$j$必须在一台机器上连续完成。

令$J(i)$为分配给机器$i$的任务子集，机器$i$的负载为$L_i=\sum\limits_{j \in J(i)}t_j$,该问题的时间跨度(makespan)为所有机器上的结束时间最大值$L=\max\limits_i L_i$。

**Load Balancing**：求上述问题中的任务分配使得时间跨度最小。

### 贪心算法
每次将任务$j$分配在当前负载最小的机器上：
![](/img/近似算法/LoadBalancing贪心算法.png)



**引理1**：最优解makespan$L^* \ge \max\limits_j t_j$。

用时最长的这个任务总需要分配到一个机器上完成.

**引理2**:最优解makespan $L^* \ge \frac{1}{m} \sum\limits_j t_j$

所有任务的总运行时间为$\sum\limits_j t_j$,那么$L^*$的时间跨度必然选自$m$个机器中的一个,而每个机器的最小时间跨度为$\frac{1}{m}$的总运行时间.

**定理:贪心算法是Load Balancing问题的二倍近似算法。**

证明:

假设负载$L_i$为问题的平静,令$j$为最后一个分配到该机器的任务,由贪心算法,在任务$j$分配之前,机器$i$的负载是最小的.$j$分配之前机器$i$的负载为$L_i - t_j$,也就是说在准备分配$j$的时候有$L_i - t_j$小于或等于所有机器上的负载$L_k, 1 \le k \le m$

![](/img/近似算法/LoadBalancing贪心算法证明-1.png)

分配任务$j$之前,由引理1:
$$  \begin{aligned}
    L_i - t_j &\le \frac{1}{m}\sum\limits_k L_k \\
        &=  \frac{1}{m} \sum\limits_k t_k \\
        &\le L^*
    \end{aligned}$$

分配任务$j$后,由上式以及引理2:
$$L_i = (L_i -t_i) + t_j \le L^* + \max\limits_j t_j \le L^* + L^* = 2L^*$$

那么贪心算法是Load Balancing的紧2倍近似算法吗?判断$\rho$-近似算法是否紧的要看该算法相比于最优解有比$\rho$更低的近似率吗?若有则说明其并不是紧的。

答:大致是的,考虑下面的一个Load Balancing的实例,有$m$个机器,$m^2$个任务,其中有$m(m-1)$个任务运行时间为1,一个任务的运行时间为$m$.贪心算法的结果如下图所示:

![](/img/近似算法/LoadBalancing实例-贪心算法.png)

而最优解的结果为:

![](/img/近似算法/LoadBalancing实例-最优解.png)

这个实例里贪心算法的时间跨度为19,而最优解的时间跨度为10.

### LPT(longest Processing Time)算法
LPT算法是在上面的贪心算法基础之上,先对$n$个任务按时间降序排序,然后再按照上面的贪心算法执行.

![](/img/近似算法/LoadBalancingLPT算法.png)

通过观察可以得出,当任务数小于或等于机器数的时候,LRT算法就是最优解.这时候只需要把任务$i$分配给机器$i$.

**引理3**:如果任务数多于机器数$m$,有$L^* \ge 2t_{m+1}$.

设前$m+1$个任务的运行时间分别为$t_1,\dots,t_{m+1}$,由于运行时间$t_i$是按照降序排列,所以前$m+1$个任务的运行时间都不小于$t_{m
+1}$,且由于鸽笼原则,至少有一个机器会被分配两个任务.

**定理:LPT算法是Load Balancing的一个$\frac{3}{2}$近似算法.**

证明:与证明贪心算法相同的方法
$$L_i=(L_i - t_j) + t_j \le L^* + \frac{1}{2}L^* = \frac{3}{2}L$$

那么LPT算法是Load Balancing的紧$\frac{3}{2}$倍近似算法吗?不是;LPT算法是Load Balancing的紧$\frac{4}{3}$倍近似算法吗?很可能是.


## Centrer Selection Problem(中心选址问题)
定义:给定一个大小为$n$个地址集合$s_1,s_2,\dots,s_n$以及一个整数$k>0$,选择$k$个中心使所有地址到离它最近的中心距离的最大值最短.

![](/img/近似算法/CentrerSelectionProblem.png)

几个概念:

- $dist(x, y)$:$x,y$的距离.
- $dist(s_i, C)=\min\limits_{c \in C}$:$s_i$到离它最近的中心的距离,这里采用欧式距离.
- $r(C)=\max\limits_{i} dist(s_i,C)$:最小的覆盖半径.

中心选址问题的目标便是找到一个中心集合$C$使覆盖半径$r(C)$最小,其中中心的数量等于$k$.

距离的一些性质:
$$dist(x,x)=0 \tag{同一性}$$
$$dist(x,y)=dist(y,x) \tag{对称性}$$
$$dist(x,y) \le dist(x,z) + dist(z,y) \tag{三角不等式}$$


### 贪心算法
开始时我们任意选取一个地址作为中心，接着选择离第一个中心最远的那个地址作为第二个中心，如此的重复进行,直到选了$k$个中心为止。

![](/img/近似算法/CentrerSelectionProblem贪心算法.png)

**定理：贪心算法是中心选址问题的2倍近似解**

证明(反证法)：


假设$r(C^*)<\frac{1}{2}r(C)$

- 对近似解集合$C$的中心$c_i$，总有一个最优解的中心$c_i^*$在$c_i$的圆中(任意一个最优解的中心$c_i^*$的圆里最少有一个地址$s$,而贪心算法选址都是在地址集合中选的，并且$c_i$的半径 $>$ $c_i^*$的半径，所以$c_i^*$必然在某一个中心$c_i$的圆里)
- 令$c_i$是与$c_i^*$对应的中心
- 对于任意一个离最优解$c_i^*$最近的地址$s$,有

$$dist(s,C) \le dist(s, c_i) \le dist(s, c_i^*) + dist(c_i^*, c_i) \le r(C^*) + r(C^*) = 2r(C^*)$$

上式与假设$r(C^*)<\frac{1}{2}r(C)$相违背，故有$r(C^*) \ge \frac{1}{2}r(C)$,即贪心算法是中心选址问题的2倍近似解。

中心选址问题有没有$\frac{3}{2}$倍近似解或者$\frac{4}{3}$倍近似解？

答：没有，除非P＝NP，否则中心选址问题没有倍率比2小的近似算法。

## Weighted Vertex Cover
带权值的顶点覆盖：对于给出的一个顶点带权值的图$G$，找到一个顶点覆盖，使它们的权值之和最小。 （这里我们主要解决的是：求图$G=(V,E)$的顶点覆盖$S$，要使顶点集合$S$中所有顶点的权值之和最小。

![](/img/近似算法/WeightedVertexCover.png)

### Pricing Method
**定价法**：因为顶点覆盖要求每条边至少有一个顶点在集合$S$里,每条边必须被一些顶点所覆盖，根据顶点$i$和$j$，给边$e = (i, j)$ 标上价格$P_e$。

公平性：与顶点$i$所连接的所有边的价格（权值）之和必须小于顶点$i$的权值。

引理：：图$G$的所有边的价格（权值）之和 $\le$ 顶点覆盖$S$中所有顶点的权值之和（两个简单的缩放）。

![](/img/近似算法/WeightedVertexCover-不等式放缩.png)

上面第一个$\le$不能写成等号，等号只在每条边都恰好只有一个顶点在$S$中时才成立，若有边的两个顶点都在$S$中，那么这条边就会被计算两次。

求解过程：边的价格设置与找寻顶点覆盖同时进行

![](/img/近似算法/WeightedVertexCover-PricingMethod-求解过程.png)

例子：

![](/img/近似算法/WeightedVertexCover-PricingMethod-例子.png)


**Pricing Method是Weighted Vertex Cover**的一个2倍近似算法。

证明：

首先证明$S$是一个点覆盖：

算法结束条件：在while循环的每次迭代结束之后，至少有一个顶点会是紧致的（除非图没有边），所以在算法结束的时候每条边的两个顶点中至少有一个是紧的，即每条边至少有一个顶点在$S$中，而Vertex Cover要求每条边至少有一个顶点在$S$中，所以$S$必然是一个点覆盖，否则循环就不会停止。

然后再证明$S$是最优解的一个2倍近似解：

![](/img/近似算法/证明PricingMethod2倍近似解.png)

第一处放缩很容易得出，$S$肯定为顶点集$V$的一个子集；$\sum\limits_{i \in V} \sum\limits_{e=(i,j)} p_e = 2 \sum\limits_{e \in E} p_e$是因为计算与$V$中所有顶点相连的边时，每条边会被计算两次；最右边一个放缩为引理的结论。
















