---
title: NP问题
tags: 
    - 算法
    - 算法设计与分析
categories: 算法
---

## P、NP、NPC、NPH问题
**P问题**：存在多项式时间算法的决策问题。

**NP问题** ：能在多项式时间内验证某个猜想答案的正确性，但问题求解可能在无法在多项式时间内完成。比如Composite问题、3-Satisfiability、Hamiltonian Cycle，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。

**结论1**：P $\subseteq$ NP

**结论2**：NP $\subseteq$ EXP

**EXP**：存在指数时间算法的决策问题。


**NPC问题**: 需要满足两个条件
    
- 它是一个NP问题
- 所有的NP问题都可以规约到NP-complete

**定理**：若Y是一个NPC问题，那么Y可以在多项式时间内求解**当且仅当**P$=$NP

证明：

$\Rightarrow$

若P $=$ NP，那么Y可以在多项式时间求解，因为Y是NP（NPC的第一个条件：它要先是一个NP）

$\Leftarrow$

若Y可以在多项式时间求解：
- 令X为任意一个NP问题，因为X $\le_p$ Y，而Y可以在多项式时间求解，故X也可以在多项式时间求解。NP $\subseteq$ P
- 又已知P $\subseteq$ NP,所以 P $=$ NP


**如果**我们给NPC问题找到了一个多项式时间复杂度的算法，那么也就意味着我们给所有的NP问题找到了多项式时间复杂度的算法，从而NP=P，因为P=NP，所以“P对NP问题”就可以被解决。但给NPC问题找一个多项式时间复杂度的算法太难了，所以现在人们普遍相信P≠NP。


**NPH问题** ：满足上面NPC问题的第二个条件，但不一定要满足第一个条件，所以NPH的范围比HPC更大。

### 证明一个问题是NPC问题的步骤
- 证明这个问题Y属于NP
- 选择一个NPC问题X
- 证明X可以多项式规约到Y

### 证明一个问题是NPH问题的步骤
要证明一个问题是NP-hard，通常是找到一个已被证明了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC $\le$ NP-hard）,简单来说就是：
- 对问题A给定限制条件得到一个特例B问题
- 证明问题B是NPC问题


