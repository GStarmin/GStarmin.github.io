<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WSL下添加系统调用</title>
    <link href="/2023/06/05/WSL%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2023/06/05/WSL%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl下添加系统调用">WSL下添加系统调用</h1><p>由于WSL的内核是在原版基础之上有做修改的，所以要先去下载内核的源码。https://github.com/microsoft/WSL2-Linux-Kernel.</p><p>查看当前系统内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>然后去源码中找到对应的版本并下载，下载完成后解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zvxf linux-msft-wsl-5.15.90.1.tar.gz<br><span class="hljs-built_in">cd</span> WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1<br></code></pre></td></tr></table></figure><h2 id="新增系统调用号">新增系统调用号</h2><p>在arch/x86/include/generated/uapi/asm/unistd_64.h中添加系统调用号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_my_func 335</span><br></code></pre></td></tr></table></figure><p>注意这里的系统调用号可以随便取，但一定要是唯一的，不然会报错。<code>my_func</code>是系统调用名。</p><h2 id="修改系统调用向量表">修改系统调用向量表</h2><p>修改arch/x86/entry/syscalls/syscall_64.tbl文件</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">335 </span><span class="hljs-number">64</span> my_oper sys_my_func<br></code></pre></td></tr></table></figure><p>此处的系统调用号必须与之前声明的保持一致，<code>my_func</code>为调用函数名，<code>sys_my_func</code>为实际调用的函数。</p><h2 id="添加系统调用的声明">添加系统调用的声明</h2><p>在include/linux/syscalls.h中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>;<br></code></pre></td></tr></table></figure><p>其中<code>asmlinkage</code>是一个宏，用于声明函数的调用方式，<code>long</code>是返回值类型，<code>sys_my_func</code>为函数名，<code>int count</code>为函数参数。</p><h2 id="添加具体实现">添加具体实现</h2><p>在kernel/sys.c中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-title function_">my_oper</span><span class="hljs-params">(<span class="hljs-type">int</span> *result, <span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">char</span> *op)</span><br>&#123;<br><span class="hljs-keyword">if</span>(op)<br>&#123;<br><span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;+&#x27;</span>)<br>*result = num1 + num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>*result = num1 - num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;*&#x27;</span>)<br>*result = num1 * num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;\\&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(num2 != <span class="hljs-number">0</span>)<br>*result = num1 / num2;<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;divided number can&#x27;t bere zero.\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;operator is empty.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>SYSCALL_DEFINE1(my_func, <span class="hljs-type">int</span>, count)<br>&#123;<br>printk(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">tstart</span>, <span class="hljs-title">tend</span>;</span><br>ktime_get_real_ts64(&amp;tstart);<br><span class="hljs-type">int</span> i, result, times = count / <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_add = <span class="hljs-string">&#x27;+&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, &amp;op_add);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_add is ok. op_add count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_sub = <span class="hljs-string">&#x27;-&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;op_sub);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_sub is ok. op_sub count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_mul = <span class="hljs-string">&#x27;*&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, &amp;op_mul);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_mul is ok. op_mul count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_div = <span class="hljs-string">&#x27;\\&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;op_div);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_div is ok. op_div count is :%d&quot;</span>, i);<br>ktime_get_real_ts64(&amp;tend);<br>printk(<span class="hljs-string">&quot;my_func running time is %ld usec/n&quot;</span>, <span class="hljs-number">1000000000</span> * (tend.tv_sec-tstart.tv_sec) + (tend.tv_nsec-tstart.tv_nsec));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>DEFINE后面的数字是传入的参数个数,这里是1个，所以是1。<code>my_func</code>是系统调用名，<code>count</code>是传入的参数。</p><p>注意：函数实现不要写在条件编译的范围内。</p><h2 id="编译内核">编译内核</h2><p>编译内核需要.config配置文件，可以通过<code>make menuconfig</code>生成，也可以直接复制现有的.config文件。这里使用<code>make menuconfig</code>生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><p><img src="/img/Linux/make-menuconfig.png" /></p><p><code>make menuconfig</code>会打开一个配置界面，这里不需要修改别的配置，只需要修改内核版本号，以便与现在的内核区分开，然后保存退出。</p><p>编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make<br></code></pre></td></tr></table></figure><p>编译完成后，生成的内核文件在项目目录arch/x86/boot下面，文件名为bzImage。</p><h2 id="替换内核">替换内核</h2><p>将内核文件bzImage从wsl系统中拷贝出来，放在windows文件系统中任意路径下，例如C:_usr_kernel</p><p>然后进入C:.wslconfig 的文件，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[wsl2]<br>kernel=C:\\wsl_usr_kernel\\bzImage<br></code></pre></td></tr></table></figure><p>注意双反斜杠，否则不生效。然后在powershell中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><p>重启wsl系统，查看内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>可以看到内核版本已经变成了我们刚刚编译的版本。</p><p>如果要恢复原来的内核，只需要删除.wslconfig文件，然后执行<code>wsl --shutdown</code>重启wsl系统即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据期末复习</title>
    <link href="/2023/06/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据期末复习">大数据期末复习</h1><h2 id="ch1-intruction">Ch1 Intruction</h2><h3 id="what-is-big-data">What is big data?</h3><p><strong>Big data</strong> is used to describe a massive volume ofboth structured and unstructured data that is so large that it'sdifficult to process using traditional database and softwaretechniques.</p><p><strong>大数据</strong>用来描述大量的结构化和非结构化的数据，这些数据非常大，难以用传统的数据库和软件技术来处理。</p><h3 id="the-4v-features-of-big-data">The 4V Features of big data</h3><p><img src="/img/大数据/4V-features.png" /></p><ul><li>Volume (Scale of Data)</li><li>Velocity (Data Stream)</li><li>Variety (Different types of data)</li><li>Veracity (Uncertainty, missing value)</li></ul><h3 id="what-is-data-mining">What is data mining?</h3><p><strong>Data mining</strong> consists of <strong>applying dataanalysis</strong> and <strong>discovery algorithms</strong> that, underacceptable computational efficiency limitations, produce a particularenumeration of patterns over the data.</p><p><strong>数据挖掘</strong>包括<strong>应用数据分析</strong>和<strong>发现算法</strong>，在可接受的计算效率限制下，在数据上产生特定的模式列举。</p><h3 id="the-kdd-processcore-part">The KDD Process(core part)</h3><p><img src="/img/大数据/KDD-process.png" /></p><h3 id="the-main-tasks-of-data-mining">The main tasks of Datamining</h3><ul><li>Association Rule Mining(关联规则挖掘)</li><li>Cluster Analysis(聚类分析)</li><li>Classification/Prediction(分类/预测)</li><li>Outlier Detection(异常点检测)</li></ul><h3id="the-relationship-between-data-minning-and-other-subjectse.g.-database">Therelationship between Data minning and other subjects(e.g. Database)</h3><p>Data mining is known as Knowledge Discovery in Database (KDD) in thefield of artificial intelligence, is also considered as a fundamentalstep in the process of knowledge discovery in database.</p><p>数据挖掘在人工智能领域被称为数据库知识发现（KDD），也被认为是数据库知识发现过程中的一个基本步骤。</p><h3 id="the-challenges-of-big-data-mining">The challenges of big datamining</h3><ul><li>Curse of dimensionality(维度灾难)</li><li>Storage cost</li><li>Query speed <!-- - Data Quality- Data Complexity- Data Privacy and Security- Scalability- Ethics(伦理学)- interpretability --></li></ul><h2 id="ch2-foundations-of-data-mining">Ch2 Foundations of DataMining</h2><h3id="supervised-learningunsupervised-learningsemi-supervised-learning">Supervisedlearning/Unsupervised learning/Semi-supervised learning</h3><ul><li><strong>Supervised learning</strong>: targets to learn the mappingfunction or relationship between the features and the labels based onthe labeled data. Namely, <span class="math inline">\(𝑌=𝐹(𝑋|𝜃)\)</span>.(e.g. Classification, Prediction)</li><li><strong>Unsupervised learning</strong>: aims at learning theintrinsic structure from unlabeled data. (e.g. Clustering, Latent FactorLearning and Frequent Items Mining)</li><li><strong>Semi-supervised learning</strong>: can be regarded as theunsupervised learning with some constraints on labels, or the supervisedlearning with additional information on the distribution of data.</li></ul><h3 id="loss-function">LOSS FUNCTION</h3><p><img src="/img/大数据/ch2-lossfunction.png" /></p><p><span class="math inline">\(l_1\)</span> norm:</p><p><span class="math display">\[L(\beta) =\frac{1}{N}\sum\limits_{i =1}^{N}L(Y_i, F(X_i | \beta)) + \frac{\lambda}{2} || \beta||_2\]</span></p><p><span class="math inline">\(l_2\)</span> norm:</p><p><span class="math display">\[L(\beta) =\frac{1}{N}\sum\limits_{i =1}^{N}L(Y_i, F(X_i | \beta)) + \frac{\lambda}{2} || \beta||_1\]</span></p><p><span class="math inline">\(||A||_∗\)</span> nuclear norm:</p><p><span class="math display">\[||A||_∗=∑\limits_i{σ_i}(A).\]</span></p><h3 id="overfittingunderfitting-problem">Overfitting/Underfittingproblem</h3><p><strong>Reason</strong>?</p><p><strong>How to avoid overfitting</strong>?</p><h3 id="classfied-algorithms">Classfied Algorithms</h3><h4 id="decision-tree">Decision Tree</h4><ul><li>How to construct DT?</li><li>Attribute selection Criteria<ul><li>Information Gain</li><li>Information Gain Ratio</li><li>Gini index</li></ul></li></ul><h4 id="knn">KNN</h4><p><strong>Lazy Learning</strong>: Lazy Learning does not extract rulesor generalizations from a specific model. Instead, it searches forhistorical instances that are similar to the testing instance and makesa prediction based on their output results. (LazyLearning并没有从特定的模型中提取基本规则或一般情况，而是在预测时查找与测试实例相似的历史实例，并根据它们的输出结果做出预测)</p><p><strong>advantage</strong>:</p><ul><li>local data distribution（适用本地数据分布）</li><li>Incremental/online learning（渐进式/在线学习）</li><li>large number of classes（可以对很大的类型数量分类）</li></ul><p><strong>disvantage</strong>:</p><ul><li>parameter k(要设置参数k)</li><li>imbalanced data（数据不平衡时分类效果差）</li><li>slow inference（推理慢）</li></ul><h4 id="naive-bayse">Naive bayse</h4><p><strong>basic idea</strong></p><p><strong>advantage</strong></p><h4 id="svm">SVM</h4><ol type="1"><li>basic concept</li><li>Linear seperation problem<ol type="1"><li>Why SVM works well on small size of samples?<ol type="1"><li>可以处理高维空间</li><li>可以控制正则化参数防止过拟合</li><li>对噪声鲁棒性强</li><li>适用非线性分类</li></ol></li><li>Good generalization</li></ol></li><li>NonLinear problem<ol type="1"><li>solution: map data into high dimension space</li><li>Trick: kernel Trick <span class="math inline">\(K(X,Y) = \Phi(X)\Phi(Y)\)</span></li><li>Kernel function: Gaussian kernel, polynormial kernel</li></ol></li></ol><p>损失函数是平方损失加上L1正则化</p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2 + \alpha \sum_{j=1}^n|\theta_j|\]</span></p><p>其中，第一项是平方损失，第二项是L1正则化项，<spanclass="math inline">\(\alpha\)</span>是正则化参数。</p><h3 id="ensemble-learning">Ensemble Learning</h3><p>Rationale for Ensemble Learning: No Free Lunch thm: There is noalgorithm that is always the most accurate</p><p><strong>Two Criteria</strong>:</p><ul><li>Good base learner</li><li>diversity</li></ul><p><strong>Three Strategies</strong>:</p><ul><li>Bagging(Random Forest)</li><li>Boosting(AdaBoost)</li><li>Stacking</li></ul><h3 id="clustering">Clustering</h3><h4 id="k-means-procedure-and-darwbacks">K-means procedure anddarwbacks</h4><p>K-means procedure:</p><ol type="1"><li>从数据中选择k个对象作为初始聚类中心;</li><li>计算每个聚类对象到聚类中心的距离来划分；</li><li>再次计算每个聚类中心;</li><li>计算标准测度函数，之道达到最大迭代次数，则停止，否则，继续操作。</li></ol><p>优点：</p><ul><li>原理简单，实现容易；</li><li>复杂度与样本数量线性相关，对于处理大数据集合，该算法非常高效，且伸缩性较好。</li></ul><p>drawbacks（缺点）:</p><ul><li>K需要事先给定；</li><li>Kmeans需要人为地确定初始聚类中心，不同的初始聚类中心可能导致完全不同的聚类结果；</li><li>结果不一定是全局最优，只能保证局部最优；</li><li>对噪声和离群点敏感；</li><li>该方法不适于发现非凸面形状的簇或大小差别很大的簇；</li><li>需样本存在均值（限定数据种类）。</li></ul><h4 id="dbscan">DBSCAN</h4><p><strong>Advantage</strong>:</p><ul><li>可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</li><li>可以在聚类的同时发现异常点，对数据集中的异常点不敏感;</li><li>聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</li></ul><p><strong>Disadvantage</strong>:</p><ul><li>如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差。If thedensity of the sample set is not uniform and the distance betweenclusters is very different, the clustering quality is poor.</li><li>如果样本集较大时，聚类收敛时间较长。If the sample set is large, theclustering convergence time is long.</li><li>调参相对于传统的K-Means之类的聚类算法稍复杂. Parameter adjustment ismore complex than K-means.</li></ul><h3 id="subspace-learning">Subspace learning</h3><h4 id="dimension-reduction">Dimension Reduction</h4><p><strong>Models</strong>:</p><ul><li>Linear methods<ul><li>PCA(Principal Component Analysis)</li><li>MDS(Multi-Dimensional Scaling)</li></ul></li><li>Nonlinear methods<ul><li>LLE(Locally Linear Embedding)</li><li>LEM(Laplacian eigenmaps)</li><li>Isomap</li></ul></li></ul><h4 id="feature-selectionclassification">Featureselection(Classification)</h4><ul><li>Filter Method(IG, <span class="math inline">\(\mathcal{X}^2\)</span>)</li><li>wrapper Method</li><li>Embedded Methods</li></ul><h3 id="subspace-clustering子空间聚类">SubspaceClustering(子空间聚类)</h3><ul><li>Sparse subspace clustering (SSC)</li><li>Low-rank representation (LRR)</li></ul><h2 id="ch3-hashing">Ch3 Hashing</h2><h3 id="the-role-of-hashing作用">The role of Hashing(作用)</h3><ul><li>After using the hash code to represent the data, <strong>therequired storage space will be greatlyreduced</strong>（使用哈希码表示数据后，所需要的存储空间会被大幅减小）</li><li>Can <strong>reduce data dimensionality</strong>, thereby alleviatingthe <strong>dimensionality curseproblem</strong>(可以降低数据维度，从而减轻维度灾难问题)</li><li>Can realize fast neighbor retrieval at constant or sub-linear level,and provide support for the rapid realization of upper-level learningtasks(可以实现常数或者次线性级别的快速近邻检索，为上层学习任务的快速实现提供支撑)</li></ul><h3 id="find-similar-items">Find similar items</h3><p>Three Essential Techniques for Similar items:</p><ul><li><strong>K-Shingling</strong>：convert documents, emails, etc., tosets.</li><li><strong>Min-hashing</strong>：convert large sets to shortsignatures, while preserving similarity.</li><li><strong>Locality-sensitive hashing</strong> : focus on pairs ofsignatures likely to be similar.</li></ul><p><img src="/img/大数据/ch3-the-big-pic.png" /></p><h4 id="shingles">Shingles</h4><p>A k-shingle (or k-gram) for a document is <strong>a sequence of kcharacters that appears in the document</strong>.一个文件的k-shingle（或k-gram）是一个出现在文件中的k个字符的序列。</p><p>Example: <span class="math inline">\(k=2; doc = abcab\)</span>. Setof 2-shingles = <span class="math inline">\(\{ab, bc, ca\}\)</span>.</p><h4 id="min-hashing">min-hashing</h4><p>definition:min-hash is an algorithm for <strong>text and datasimilarity comparison</strong> that efficiently extracts the signatureof each data from large-scale data, thus supporting fast comparison oftheir similarity.min-hash是一种用于文本和数据相似度比较的算法，它可以高效地从大规模数据中提取每个数据的签名，从而支持快速地比较它们之间的相似程度。</p><h5 id="signature-matrix-rightarrow-how-to-compute-similarity">signaturematrix <span class="math inline">\(\Rightarrow\)</span> how to computesimilarity</h5><p><img src="/img/大数据/ch3-similarity.png" /></p><p>Jaccard similarity：不将<spanclass="math inline">\((0,0)\)</span>计入分母，相同的行占全部行的比率</p><p>matrix similarity：相同的行占全部行的比率</p><p><strong>Signature Matrix的计算方法</strong>：</p><p><img src="/img/大数据/ch3-signature计算方法.png" /></p><p>上图中间矩阵是输入矩阵，左侧的每一列都代表输入矩阵行的一种排列，那么signaturematrix的每一行都对应左侧的一种排列方式，该行的每列数字对应该种排列方式对应列的第一个1的出现行数。</p><h5 id="locality-sensitive-hashinglsh">Locality-SensitiveHashing（LSH）</h5><p>假设我们在主内存中有代表大量对象的数据</p><ul><li>可能是对象本身</li><li>可能是min-hashing中的签名</li></ul><p>我们要逐一进行比较，找到那些足够相似的pair。但是检查所有的pair是很困难的。</p><ul><li>一般的想法：使用一个函数f(x,y)，告诉人们x和y是否是一个候选对：一对元素的相似性必须被评估。</li><li>对于min-hash矩阵：哈希列到许多桶中，并使同一桶中的元素成为候选对。</li></ul><p>基本思想：Generate from the collection of all elements (signatures inour example) a small list of candidate pairs: pairs of elements whosesimilarity must be evaluated.</p><p>简单来说就是从我们Min-hashing得到的标记矩阵生成可能相似的文档对列表。</p><p>候选相似文档对 <span class="math inline">\(\Rightarrow\)</span>这一对的Jaccard相似度必须被准确计算出来</p><p>方法：</p><ul><li>选一个相似度标准 <span class="math inline">\(t\)</span>，并且 <spanclass="math inline">\(t&lt;1\)</span>，如果两个文档的相似度大于 <spanclass="math inline">\(t\)</span>，则认为这两个文档相似。</li><li>如果列<span class="math inline">\(c\)</span>和列<spanclass="math inline">\(d\)</span>被视为候选文档对，那么他们一定要满足<spanclass="math inline">\(M(i,c)=M(i,d)&gt;=t\)</span>，其中M是标记矩阵。</li></ul><h5 id="lsh-for-minhashing-signatures">LSH for MinhashingSignatures</h5><p>总体思想：把标记矩阵里的hash很多遍，只有hash到同一个桶(bucket)里的列才被认为是可能相似的。</p><p><strong>Partion Into Bands</strong></p><p><img src="/img/大数据/Partion-Into-Bands.png" /></p><p>Divide matrix M into b bands of r rows. For each band, hash itsportion of each column to a hash table with k buckets.如图所示，把标记矩阵(signature matrix)的所有行分成 <spanclass="math inline">\(b\)</span> 个带(bands)，每个带有 <spanclass="math inline">\(r\)</span>行。对于每条带，对带里面每列进行hash，分别hash到<spanclass="math inline">\(k\)</span>个桶中，并让<spanclass="math inline">\(k\)</span>尽可能得大。</p><p>只有有<spanclass="math inline">\(&gt;=1\)</span>的band哈希到同一个桶中，就把这两列当作候选相似对。</p><p><img src="/img/大数据/Partion-Into-Bands-例子.png" /></p><h5 id="example---bands">Example - Bands</h5><p>假设有 100,000 列，每列有100个标记，因此存储标记需要40MB;我们希望找到所以相似度大于80%的文档对，用上面的方法，把标记分为20个带，每个带里有5个标记。</p><p>这样的话，如果文档<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的相似度是<spanclass="math inline">\(80\%\)</span>，那么他们的任意一个带的<spanclass="math inline">\(5\)</span>个标记都相同的概率是: <spanclass="math inline">\((0.8)^5=0.328\)</span>，看起来好像不大，但是只要有任意一个带都相同就被认为是候选对，所以他们不被选上的概率，即20个带都不相同的概率为：<spanclass="math inline">\((1−0.328)^20=0.00035\)</span> ，也就是每<spanclass="math inline">\(3000\)</span>个相似度为<spanclass="math inline">\(80\%\)</span>的文档对里才会有一对漏选。</p><p>我们再考虑文档<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>只有<spanclass="math inline">\(40\%\)</span>的相似度，那么他们任意一个带的<spanclass="math inline">\(5\)</span>个标记都相同的概率为 <spanclass="math inline">\((0.4)^5=0.01\)</span>，则文档<spanclass="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>被选为候选对的概率，即他们中有一个带完全相同的概率为:<span class="math inline">\(C^1_{20}×0.01=0.2\)</span> ，就是说每<spanclass="math inline">\(5\)</span>个<spanclass="math inline">\(40\%\)</span>相似度的文档对里就有一对会被误选为候选对。但是相似度小于<spanclass="math inline">\(40\%\)</span>的文档对里误选的概率就非常小了。</p><h3 id="learn-to-hash">Learn to Hash</h3><ol type="1"><li>Data indenpendent:Random projection</li><li>Data dependent:<ol type="1"><li>PCA hashing</li><li>Spectral Hashing</li></ol></li></ol><h4 id="pca-hashing">PCA hashing</h4><p>分为两个阶段</p><p><strong>Projection Stage（投影阶段）</strong>:</p><p>用一个转换矩阵<span class="math inline">\(W\)</span>,可以将<spanclass="math inline">\(x\)</span>投影到一个新的特征平面。</p><p><span class="math display">\[Y=W^T X\]</span></p><p><strong>Quantization Stage（量化阶段）</strong>:</p><p><span class="math display">\[h(x) = sgn(W^T X)\]</span></p><p>最小化quantization loss（量化损失）</p><p><span class="math display">\[Q(B,Y) = ||B - Y^T R||^2_F\]</span></p><p><span class="math inline">\(R\)</span>是正交矩阵. <spanclass="math inline">\(B = Sgn(Y^T R)\)</span></p><p>基本思想是旋转数据以最小化量化损失。</p><p>实现方法：从<spanclass="math inline">\(R\)</span>的随机初始化开始，采用类似K-means的迭代算法来优化<spanclass="math inline">\(R\)</span>。在每次迭代中，每个数据点首先被分配到最近的聚类中心，然后更新<spanclass="math inline">\(R\)</span>以使量化损失最小化。</p><h4 id="spectral-hashing谱哈希">Spectral Hashing（谱哈希）</h4><p><img src="/img/大数据/Spectral-Hashing公式.png" /></p><h4id="general-approach-to-learning-based-hashinglearning-based哈希的一般方法">GeneralApproach to Learning-Based Hashing(Learning-Based哈希的一般方法)</h4><p>将哈希学习问题分解为两个步骤：</p><ol type="1"><li>hash bit learning. 哈希比特学习</li><li>hash function learning based on the learned bits.基于所学习的哈希比特的哈希函数学习</li></ol><p><img src="/img/大数据/ch3-Learning-Based-Hashing-步骤.png" /></p><h2 id="ch4-sampling">Ch4 Sampling</h2><p>Why sampling?</p><ul><li>Big data issue<ul><li>Store complexity</li><li>Calculate complexity</li></ul></li><li>Posterior estimation<ul><li>Expectation estimation</li></ul></li></ul><h3 id="inverse-transform-sampling逆采样变换">Inverse TransformSampling(逆采样变换)</h3><p>Inverse Transform Sampling based on the inverse of CumulativeDistribution Function (CDF). 逆采样变换（Inverse TransformSampling）是伪随机数采样的一种基本方法。在已知任意概率分布的累积分布函数<spanclass="math inline">\(CDF\)</span>时，可以通过<spanclass="math inline">\(CDF\)</span>的逆函数来实现随机数的采样。</p><p>简单来说，假设<spanclass="math inline">\(X\)</span>为一个连续随机变量，其概率密度函数为<spanclass="math inline">\(PDF(X)\)</span>，累计分布函数为<spanclass="math inline">\(CDF(X)\)</span>。这时候若想生成符合<spanclass="math inline">\(X\)</span>分布的随机变量样本，只需在<spanclass="math inline">\([0, 1]\)</span>范围内生成随机变量<spanclass="math inline">\(x\)</span>,然后放入<spanclass="math inline">\(CDF\)</span>的反函数中，即可得到符合<spanclass="math inline">\(X\)</span>分布的随机变量样本。</p><p>方法：</p><p><img src="/img/大数据/ch4-CDF.png" /></p><p>优点：</p><ul><li>简单</li><li>适用于任意分布</li></ul><p>缺点：</p><ul><li>Hard to get the inverse function. 很难确定逆函数</li></ul><h3 id="rejection-sampling拒绝采样">Rejection Sampling(拒绝采样)</h3><p>Rejection Sampling accept the samples in the region under the graphof its density function and reject others. 拒绝采样（RejectionSampling）是一种基本的随机数采样方法。它的基本思想是：对于一个难以采样的分布，我们可以找到一个容易采样的分布，使得容易采样的分布包含难以采样的分布，然后从容易采样的分布中采样，若采样的点在难以采样的分布中，则接受该点，否则拒绝该点。</p><p>方法：</p><p><img src="/img/大数据/ch4-Rejection-Sampling.png" /></p><p>步骤：</p><p><img src="/img/大数据/ch4-Rejection-Sampling-步骤.png" /></p><p>这就使得Proposal Distribution <spanclass="math inline">\(q(x)\)</span>的支撑集（support）要大于目标分布<spanclass="math inline">\(p(x)\)</span>的支撑集。所以<spanclass="math inline">\(q(x)\)</span>的分布选择很重要。</p><h3 id="importance-sampling重要性采样">ImportanceSampling(重要性采样)</h3><p>Importance Sampling not reject but assign weight to each instance sothat the correct distribution is targeted. 重要性采样（ImportanceSampling）与RejectionSampling(拒绝采样)的区别在于，重要性采样不会拒绝采样的点，而是对采样的点赋予一个权重，使得采样的点更多地来自于目标分布。</p><h3 id="importance-sampling和rejection-sampling的区别">ImportanceSampling和Rejection Sampling的区别</h3><ul><li>RS的实例有一个相同的权重，只有部分的实例会被保留</li><li>IS的实例有不同的权重，所有的实例都会被保留</li><li>IS对对proposal distribution的选择更不敏感</li></ul><h3 id="markov-chain-monte-carlomcmc">Markov Chain MonteCarlo(MCMC)</h3><p>MCMC methods are a class of algorithms for <strong>sampling from aprobability distribution based on constructing a Markov chain</strong>that has the desired distribution as its <strong>equilibriumdistribution</strong>. The state of the chain after a number of steps isthen used as a sample of the desired distribution.</p><p>马尔可夫链蒙特卡洛（Markov Chain MonteCarlo，MCMC）是一种基于马尔可夫链的随机采样方法。它的基本思想是：对于一个难以采样的分布，我们可以构造一个马尔可夫链，使得该马尔可夫链的平稳分布为该难以采样的分布，然后从该马尔可夫链中采样，得到的样本服从该难以采样的分布。</p><p><strong>蒙特卡洛法</strong>：</p><p>蒙特卡洛法（Monte CarloMethod）是一种基于随机数的数值计算方法。它的基本思想是：对于一个难以计算的问题，我们可以构造一个概率分布，使得该概率分布的期望为该问题的解，然后从该概率分布中采样，得到的样本的平均值即为该问题的解。</p><h4 id="detailed-balance-condition细致平衡条件">Detailed BalanceCondition(细致平衡条件)</h4><p>细致平衡条件（Detailed BalanceCondition）是马尔可夫链平稳分布的一个必要条件。它的基本思想是：对于一个马尔可夫链，若该马尔可夫链的平稳分布为<spanclass="math inline">\(\pi(x)\)</span>，则该马尔可夫链的任意两个状态<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>满足：</p><p><span class="math display">\[\pi(x)P(x, y) = \pi(y)P(y,x)\]</span></p><p>其中<span class="math inline">\(P(x, y)\)</span>为从状态<spanclass="math inline">\(x\)</span>转移到状态<spanclass="math inline">\(y\)</span>的概率,<spanclass="math inline">\(\pi(x)\)</span>为状态<spanclass="math inline">\(x\)</span>的概率。那么<spanclass="math inline">\(\pi(x)\)</span>就是该马尔可夫链的平稳分布。</p><h4 id="the-procedure-of-mcmcmcmc的流程">The Procedure ofMCMC(MCMC的流程)</h4><p><img src="/img/大数据/ch4-MCMC流程.png" /></p><h3 id="metropolis-hastings-algorithmmh算法">Metropolis-HastingsAlgorithm(MH算法)</h3><p>由于MCMC采样有收敛太慢的问题,所以在MCMC的基础之上进行改进，引出MH算法。</p><p><img src="/img/大数据/ch4-MH算法流程.png" /></p><p>MH算法的具体流程如下：</p><p><img src="/img/大数据/ch4-MH算法具体流程.png" /></p><p>一般来说M-H采样算法较MCMC算法应用更广泛，然而在大数据时代，M-H算法面临着两个问题：</p><ol type="1"><li>在高维时的计算量很大，算法效率很低，同时存在拒绝转移的问题，也会加大计算量</li><li>由于特征维度大，很多时候我们甚至很难求出目标的各特征维度联合分布，但是可以方便求出各个特征之间的条件概率分布（因此就思考是否能只知道条件概率分布的情况下进行采样）。</li></ol><h3 id="gibbs-sampling">Gibbs Sampling</h3><p>Gibbs Sampling是MH算法的一种特殊情况。它的基本思想是：</p><p><img src="/img/大数据/ch4-Gibbs.png" /> <imgsrc="/img/大数据/ch4-Gibbs-1.png" /></p><p>因此可以得出在二维的情况下Gibbs采样算法的流程如下：</p><p><img src="/img/大数据/ch4-Gibbs-二维流程.png" /></p><p>而在多维的情况下，比如一个n维的概率分布<spanclass="math inline">\(π(x_1, x_2, ...x_n)\)</span>，我们可以通过在<spanclass="math inline">\(n\)</span>个坐标轴上轮换采样，来得到新的样本。对于轮换到的任意一个坐标轴<spanclass="math inline">\(x_i\)</span>上的转移，马尔科夫链的状态转移概率为<spanclass="math inline">\(P(x_i|x_1, x_2, ..., x_{i−1}, x_{i+1}, ...,x_n)\)</span>，即固定<spanclass="math inline">\(n−1\)</span>个坐标轴，在某一个坐标轴上移动。而在多维的情况下Gibbs采样算法的流程如下：</p><p><img src="/img/大数据/ch4-Gibbs-多维流程.png" /></p><h3 id="gibbs-sampling和mh算法的联系与区别">GibbsSampling和MH算法的联系与区别</h3><ul><li>Gibbs Sampling和MH都是MCMC</li><li>Acceptance Ratio:<ul><li>Gibbs Sampling: <span class="math inline">\(1\)</span></li><li>MH: <span class="math inline">\(\frac{\pi(y)q(y, x)}{\pi(x)q(x, y)}&lt; 1\)</span></li></ul></li><li>MH不需要知道条件概率，而Gibbs Sampling需要知道条件概率</li></ul><h3 id="reservoir-sampling">Reservoir sampling</h3><p>Reservoirsampling是一种随机采样算法，它的基本思想是：对于一个数据流，我们希望从中随机采样出<spanclass="math inline">\(k\)</span>个样本，但是我们不知道数据流的长度，也就是说我们不知道<spanclass="math inline">\(k\)</span>的大小。具体流程如下：</p><p><img src="/img/大数据/ch4-Reservoir.png" /></p><h2 id="ch5-data-stream-mining">Ch5 Data Stream Mining</h2><h3 id="data-stream">Data Stream</h3><p><strong>What is Data Stream?</strong></p><p>A data stream is a massive sequence of data objects which have someunique features.</p><h4 id="properity-of-data-stream">Properity of Data Stream</h4><p>数据流（Data Stream）是一种连续不断的数据，它的特点是：</p><ul><li>One by One(逐个到达)</li><li>Potentially Unbounded(无界)</li><li><strong>Concept Drift(概念漂移)</strong></li></ul><h4 id="conncept-drift概念漂移">Conncept Drift(概念漂移)</h4><p>Concept Drift is the probability distribution changes.</p><p>概念漂移（ConceptDrift）是指数据流中的数据分布随着时间的推移而发生变化的现象。概念漂移分为两种类型：</p><ul><li>Real concept drift (真实概念漂移)</li><li>Virtual concept drift (虚假概念漂移)</li></ul><h4 id="concept-drift-detection概念漂移检测">Concept DriftDetection(概念漂移检测)</h4><ol type="1"><li>Distribution-based detector(基于分布的检测器)</li></ol><p>监测两个固定或可变化的数据窗口之间的数据分布变化，如果数据分布发生变化，则认为发生了概念漂移。方法很简单：只要<spanclass="math inline">\(W\)</span>的两个足够大的子窗口<spanclass="math inline">\(W_1\)</span>和<spanclass="math inline">\(W_2\)</span>的数据分布不同，就认为发生了概念漂移，这时较旧的窗口就被放弃。</p><p><strong>draw back(缺点)</strong>：</p><ul><li>Hard to determine window size.</li><li>Learn concept drift slower</li><li>Virtual concept drift</li></ul><p><strong>Adaptive Windowing(ADWIN)</strong>:</p><p>ADWIN 的思想是从时间窗口 <span class="math inline">\(W\)</span>开始，在上下文没有明显变化时动态增大窗口 <spanclass="math inline">\(W\)</span>，并在检测到变化时将其缩小。该算法试图找到显示不同平均值的 <span class="math inline">\(W -w_0\)</span> 和 <span class="math inline">\(w_1\)</span> 的两个子窗口。这意味着窗口的旧部分 <span class="math inline">\(- w_0\)</span>是基于与实际不同的数据分布，因此被删除。</p><ol type="1"><li>Error-rate based detector(基于错误率的检测器)</li></ol><p>根据分类性能的变化来捕捉概念的漂移,如果分类器的错误率超过了某个阈值，则认为发生了概念漂移。</p><p>DDM算法：</p><p>DDM算法的基本思想是：在数据流中，如果某个时间点的错误率比之前的错误率大很多，则认为发生了概念漂移。确定错误率的变化是否显著的方法如下公式：</p><p><span class="math display">\[p_i + s_i \ge p_{min} + 3 \timess_{min}\]</span></p><p>误差率是指观察到错误的概率<spanclass="math inline">\(p_i\)</span>，其标准差为<spanclass="math inline">\(s_i = sqrt(p_i (1 - p_i) / i)\)</span></p><p><strong>draw back(缺点)</strong>：</p><ul><li>Sensitive to noise</li><li>Hard to deal with gradual concept drift</li><li>Depend on learning model itself heavily</li></ul><h4 id="data-stream面临的挑战">Data Stream面临的挑战</h4><ul><li>Infinite Length(无限长度)</li><li>Evolving Nature(不断变化的数据)</li></ul><h3 id="data-stream-clissification数据流分类">Data StreamClissification(数据流分类)</h3><p>流程：</p><ul><li>从数据流中读取下一个可用数据(要求1)</li><li>用读取的数据更新分类器，并且这样做不回超过对它设置的内存限制(要求2)，并尽可能快地完成（要求3）</li><li>算法已经学习了足够的数据，以便在新数据上进行分类(要求4)</li></ul><p><strong>典型算法</strong>：</p><ul><li>VFDT(very fast decision tree, KDD'00)</li><li>CVFDT(Concept-adapting very fast decision tree, KDD'01)</li><li>SyncStream(同步流算法, KDD'14)</li></ul><h4 id="vfdt">VFDT</h4><p>Hoeffding树是一种基于决策树学习的数据流分类算法，在处理数据流时，可以保证挖掘效率的同时，达到对数据流一些必要操作的要求。该算法简单的对数据流中的每个样本检查一次，并逐步生成一颗决策树，而在这些样本更新完决策树之后无需进行存储。在内存中只需维护决策树信息，因为在决策树的叶结点中存储着决策树扩展所必须的统计信息，并且在处理训练数据集时，可以用决策树中的信息进行预测。</p><p>VFDT（very fast decision tree）是基于Hoeffdingtree改进的算法和系统，它和Hoeffdingtree算法相似之处在于都是根据<strong>Hoeffding不等式</strong>来决定决策节点的最佳属性从而建立决策树模型。</p><p>Hoeffding 不等式:</p><p>Hoeffding不等式适用于有界的随机变量。设有两两独立的一系列随机变量<spanclass="math inline">\(X_1, X_2, ..., X_n\)</span>，且<spanclass="math inline">\(X_i\)</span>的取值范围是<spanclass="math inline">\([a_i, b_i]\)</span>，这<spanclass="math inline">\(n\)</span>个随机变量的经验期望<spanclass="math inline">\(\bar{X}=\frac{X_1 + \dots +X_n}{n}\)</span>满足以下不等式：</p><p><span class="math display">\[P(|\bar{X} - E(\bar{X})| \ge \epsilon)\ge \exp(-\frac{2n^2\epsilon^2}{\sum_{i=1}^n(b_i - a_i)^2})\]</span></p><p><span class="math display">\[P(|\bar{X} - E(\bar{X})| \ge \epsilon)\le 2 \exp(-\frac{2n^2\epsilon^2}{\sum_{i=1}^n(b_i -a_i)^2})\]</span></p><p>其中<span class="math inline">\(E(\bar{X})\)</span>是<spanclass="math inline">\(\bar{X}\)</span>的期望，<spanclass="math inline">\(\epsilon\)</span>是一个正数。</p><p>VFDT系统解决了Hoeffdingtree算法没有提到的实际问题，就是当两个属性的信息熵差不多时，这个时候就会发生两个属性之间的权衡。这是系统需要花费大量的时间和空间，利用更多的样本来决定选择哪个属性为最佳的决策节点的属性，而这显然是浪费的。</p><p>VFDT算法相较于Hoeffding Tress算法的改进：</p><ul><li>提供了一个用户定义的阈值<span class="math inline">\(τ\)</span>用来解决“两个属性的信息熵差不多时的博弈”。当信息熵差值小于某个阈值时，即可判定其为决策节点属性。</li><li>允许设定节点的最小样本个数值<spanclass="math inline">\(n_{min}\)</span>，在用户能够承受的置信度下，让用户设定每个节点最小的样本数将有效的减少样本信息熵<spanclass="math inline">\(G\)</span>的计算而消耗的时间复杂度。</li><li>提供重新扫描数据集和二次抽样的功能，并且在数据流中的样本数减少时，决策树的精度也会无限逼近于读取所有样本建立决策树的精度。</li></ul><p><strong>以下是 VFDT 算法的基本流程</strong>：</p><ol type="1"><li><p>构建决策树：对于一个分类问题，首先需要构建一颗决策树。该决策树会被VFDT 算法不断地更新和重新构建。</p></li><li><p>建立示例集：随机选择一些实例作为示例集。</p></li><li><p>计算初始统计信息：对于示例集中的每个实例，计算它们分类结果的概率分布。</p></li><li><p>增量统计每个实例：对于新增加的每个实例，将其加入当前的示例集，并更新分类结果的概率分布。</p></li><li><p>检查增量误差：计算每个分类器的误差，并选择一个误差最小的分类器来更新决策树。</p></li><li><p>执行更新：将当前分类器放到决策树上对应的位置，并更新决策树。</p></li></ol><p>重复步骤 4-6，直到决策树满足一定条件。</p><p>VFDT算法是一种增量式建树算法，它通过不断更新决策树的方法来尽可能地减小误差。这种算法的好处是，可以随时加入新的数据，更新模型，同时不需要重新训练整个模型。但是，VFDT算法也存在一些缺点，比如计算复杂度较高，对异常数据较为敏感等。</p><h5 id="vfdt的优缺点">VFDT的优缺点</h5><p><strong>优点</strong>：</p><ul><li>Scales better than traditional methods(比传统方法更好)<ul><li>Sublinear with sampling(子线性采样)</li><li>Very small memory utilization(非常小的内存使用率)</li></ul></li><li>Incremental(增量学习)<ul><li>Make class predictions in parallel(并行预测分类)</li><li>New examples are added as they come(新的样本随着到来而添加)</li></ul></li></ul><p><strong>缺点</strong>：</p><ul><li>Could spend a lot of time with ties(可能会花费很多时间)</li><li>Memory used with tree expansion(内存使用率随着树的扩展而增加)</li><li>Number of candidate attributes(候选属性的数量大)</li></ul><h4id="cvfdtconcept-adapting-very-fast-decision-tree">CVFDT(Concept-adaptingvery fast decision tree)</h4><p>CVFDT是VFDT的改进版，它保持了VFDT的精度和速度，VFDT算法假设所分析处理的数据流是平稳分布的，所以应对数据流中概念变化时采用的是单一的决策树模型，这就导致VFDT的决策树模型不能及时反映数据流随时间变化的趋势。</p><p>另外VFDT也没有处理连续值属性的问题。因为在CVFDT中滑动窗口的引入，过时的样本都被删除，所以 CVFDT 树比 VFDT 树要小很多。CVFDT根据滑动窗口中的数据流样本来持续检测旧的决策树的有效性从而保证建立模型与概念漂移同步。</p><p>CVFDT算法对VFDT算法的改进如下：</p><ul><li><strong>CVFDT算法解决了VFDT算法不能处理数据流中概念漂移的问题</strong>。通过在VFDT算法基础上添加滑动窗口使得建立决策树模型的数据流能够不断实现更新，保证在概念漂移的数据流中保持模型的准确率。</li><li>对于每个节点包括根节点都有相应的ID。样本遍历每个节点时不仅会在节点处保存其样本的属性信息，同时窗口中的样本也会保存其遍历过的节点信息。当样本滑出窗口时，该样本所经历过的节点统计值将依次减一。</li><li>CVFDT还为每个决策节点设置备选子树，周期性的检测每个决策节点的准确率从而决定替代子树是否替换当前的决策节点，从而也有效的提高了决策树模型的准确率。</li></ul><p>CVFDT算法流程如下：</p><p><img src="/img/大数据/ch5-CVFDT-流程.png" /></p><p>CVFDT算法采用增量的方式训练决策树，解决了VFDT算法不能处理连续属性的问题，并且在处理大规模数据时效率更高。</p><h4 id="syncstream">SyncStream</h4><p>KNN style</p><!-- 待完善 --><h4 id="open-set-problem">Open-set problem</h4><ul><li>Novel class Dection(Extreme Value Theory,EVT)</li></ul><p>EVT 中心思想是概率分布，可给出事件发生概率的数学公式。</p><ul><li>Continued learning(Elastic Weight Consolidation,EWC)</li></ul><p>EWC的基本思想：模型中的一些参数对前面的任务很重要。只改变不重要的参数</p><p>Gradient Episodic Memory(GEM)的基本思想:限制梯度的方向来改善之前的工作</p><ul><li>Class-incremental learning</li></ul><p>问题：</p><ol type="1"><li>怎么平衡新旧类的样本</li><li>怎么平衡新旧类的样本的重要性</li><li>怎么提取榜样样本(exemplars examples)</li></ol><p><strong>Knowledge Distillation(知识蒸馏)</strong>:</p><p><strong>Weight Aligning(权重对齐)</strong>:通过对齐权重来减少模型的参数数量</p><h3 id="data-stream-clustering流聚类">Data StreamClustering(流聚类)</h3><h4 id="framework">Framework</h4><p>有两个阶段</p><ol type="1"><li>online Dataabstraction(数据抽象):将数据归纳为具有内存效率的数据结构</li><li>offline clustering(离线聚类):使用聚类算法来寻找数据类别</li></ol><!-- online阶段首先根据K-mens算法生成p个初始的聚类中心(micro clusters)，并为每一个簇提供一个独一无二的ID，其中P是大于具体的聚类数目但是要远远小于具体数据点的个数。对于每一个到来的数据点，要么被现有的微集群吸收（是否在一个集群的最大边界内-均值根偏差RMS），要么自己成立一个集群。但是数据点不属于现有的集群有两种情况，一种是该点是一个异常点，第二种是该点是一个新集群的起始点。那么如果要新建立一个集群的话，就需要将已有的集群删除一个或者合并两个相似的集群。若要删除一个集群的话，首先判断删除该集群是否会有不良的影响，所以根据该集群的数据点的时间戳信息来判断，如果该簇的时间戳不满足设定的阈值，将其删除。合并集群的话，将两个最近的集群进行合并。 --><p>流聚类算法：</p><p><img src="/img/大数据/ch5-流聚类算法.png" /></p><!-- offline clustering(离线聚类)根据用户输入的需要查看的时间，从特征金字塔中取出两个时间段的汇总信息，相减之后就得到用户所需时间段的近似数据集，在此基础上进行聚类即可。 --><h4 id="online-data-abstraction">online Data abstraction</h4><p><strong>Micro-Cluster</strong>: A Micro-Cluster is a set ofindividual data points that are close to each other and will be treatedas a single unit in further offlineMacro-clustering.(Micro-Cluster是一组彼此接近的单个数据点，将在进一步的离线宏聚类中作为单个单元处理。)</p><p><strong>Cluster Feature</strong>:用来表示一个Micro-Cluster的属性，<span class="math inline">\(CF = (N,LS, SS)\)</span></p><p>其中<span class="math inline">\(LS = \sum\limits_{i=1}^N X_i, SS =\sum\limits_{i=1}^N X_i^2\)</span></p><p>其中<span class="math inline">\(N\)</span>是数据点，<spanclass="math inline">\(LS,SS\)</span>中的<spanclass="math inline">\(X_i\)</span>是一个向量。</p><p><strong>Cluster Feature</strong>的属性：Additivity Property</p><p><img src="/img/大数据/ch5-CF属性-1.png" /> <imgsrc="/img/大数据/ch5-CF属性-2.png" /></p><ol type="1"><li>动态选择short-term和long-term的代表性example，代表性高的保留，代表性低的删除，没有，若代表性没有改变，就进行statisticsummary(摘要统计)</li><li>Cluster Feature的属性：Additivity Property</li></ol><h2 id="ch6-graph-mining">Ch6 Graph Mining</h2><h3 id="key-node-identification">Key Node Identification</h3><h4 id="centrality">Centrality</h4><p><strong>DegreeCentrality</strong>:节点度的大小用来衡量节点的重要性（节点的直接影响）。</p><p><strong>BetweennessCentrality</strong>：每个顶点的间性中心度是通过该顶点的这些最短路径的数量。</p><p><strong>ClosenessCentrality</strong>：计算为节点与图中所有其他节点之间的最短路径长度之和。</p><h3 id="k-shell-decomposition">K-shell Decomposition</h3><p>将图中结点度为1的所有结点和对应的连边去掉后，新的网络中可能会有新的度为1的结点，把这些结点和边也去掉，重复操作，直到不再有度为1的结点为止。这种操作类似于剥去网络最外面一层壳，所以把所有去除的结点以及他们之间的连边称为网络的1-壳(1-shell)。网络中度为0的独立结点称为0-壳(0-shell)。在去除1-壳后的网络中，所有结点度都大于等于2，因此，接着把度为2的结点和对应连边去掉，直到不再有度为2的结点为止，则去除的结点和边称为2-壳(2-shell)。依此类推，直到网络中每个结点都划分到相应k-shell中，就得到网络的k-shell分解。</p><p>每个结点都唯一对应一个k-shell，这个k-shell中的结点的度一定大于等于k。但是注意，度相同的结点不一定属于同一个k-shell。并且，度大的结点既可能属于k值大的k-shell(最内层)，可能能属于k值较小的shell(外层)。所以，度值大的未必就重要。</p><p>优点：</p><ul><li>计算复杂度低</li><li>直观的揭示了网络的层次结构</li></ul><p>缺点：</p><ul><li>不能在很多网络中使用，如星形网络、树形网络等。</li><li>不能很好地反映网络的重要性，有时候甚至不如单纯用节点度值衡量效果好。</li></ul><h3id="eigenvector特征向量e.g.pagerank">Eigenvector（特征向量）e.g.PageRank</h3><p>PageRank是Google最早的搜索引擎核心用的就是这个算法</p><p>PageRank基本思想：如果一个页面被很多其他页面链接到的话说明这个页面比较重要，如果一个页面被一个很重要的页面链接到的话，那么这个页面也很重要。</p><h3 id="community-detection">Community Detection</h3><h4 id="cut-based-methods">Cut-based Methods</h4><h5 id="minimum-cut">Minimum Cut</h5><p>由于大多数节点互动是在组内进行的，而组与组之间的互动则很少。所以我们可以把communitydetection问题转换为一个最小割问题。最小割问题是指在一个无向图中，找到一条边的集合，使得这些边的权重之和最小，且删除这些边之后，图被分成两个部分。</p><h5 id="ratio-cut-normalized-cut">Ratio Cut &amp; Normalized Cut</h5><p>由于最小割往往返回一个不平衡的partation，其中的一个集合是一个单点，所以我们可以用RatioCut和NormalizedCut来解决这个问题。思想是在最小割的基础之上修改目标函数以考虑到partation的平衡性。</p><p><img src="/img/大数据/ch6-ratio-cut.png" /></p><p><img src="/img/大数据/ch6-norm-cut.png" /></p><p>其中<span class="math inline">\(C_i\)</span>是一个子集和，<spanclass="math inline">\(\bar{C_i}\)</span>是<spanclass="math inline">\(C_i\)</span>的补集，<spanclass="math inline">\(|C_i|\)</span>是子集和的大小，<spanclass="math inline">\(vol(C_i)\)</span>是子集和中所有节点的度之和。</p><p>在 RatioCut切图中，不仅要考虑使不同组之间的权重最小化，也考虑了使每个组中的样本点尽量多。</p><p>在 Norm Cut切图中，除了考虑最小化损失函数之外，还考虑了子图之间的权重大小。</p><p>由于子图样本的个数多并不一定权重就大，切图时基于权重也更合目标，因此一般来说Normcut 切图优于 RatioCut 切图。</p><h5 id="modularity-maximization模块度最大化">ModularityMaximization(模块度最大化)</h5><p>模块度通过考虑度分布来衡量Community partition的强度。</p><p>给定一个有<spanclass="math inline">\(m\)</span>条边的网络，学位为<spanclass="math inline">\(d_i\)</span>和<spanclass="math inline">\(d_j\)</span>的两个节点之间的预期边数为<spanclass="math inline">\(d_i d_j / 2 m\)</span></p><p>给定如下例子：</p><p><img src="/img/大数据/ch6-Modularity-Maximization-例子图.png" /></p><p>则节点<span class="math inline">\(1\)</span>和<spanclass="math inline">\(2\)</span>之间的预期边数为<spanclass="math inline">\(3 * 2 / (2 * 14)\)</span></p><p>Strength of a community: <span class="math inline">\(\sum\limits_{i\in C, j \in C} A_{ij} - \frac{d_i d_j}{2m}\)</span></p><p>Modularity(模块度)：<span class="math inline">\(Q =\frac{1}{2m}\sum\limits_{l =1}^k \sum\limits_{i \in C, j \in C} (A_{ij}- \frac{d_i d_j}{2m})\)</span> )</p><p>数值越大，表明community structure越好.</p><h5 id="simulatingdistance-dynamics">Simulating:Distance Dynamics</h5><p>动态距离(Distance Dynamics)是CommunityDetection的一种新视角，它的基本思想是模拟边距离的动态变化。</p><p>它将整个网络视为一个动态系统，根据不同的互动模式模拟距离动态（距离动态与节点动态）.所有边的距离都会收敛，从而直观地识别出社区结构。</p><p>如果两个节点相连，每个节点都会吸引另一个节点，使得另一个节点移动到自己身边.</p><p>边距离:受三种不同类型节点的影响:(a)直接链接节点;(b)共同邻居;(c)独占邻居</p><ul><li>直接链接节点的影响：使u和v更接近。</li><li>共同邻居的影响：使u和v更接近。</li><li>独占邻居的影响：使u和v更接近或更远。</li></ul><p>Distance Dynamics的步骤：</p><ol type="1"><li>Initialization：计算每条边的Jaccard距离</li><li>Dynamics: 研究每条边距离的变化</li><li>Community Detection : 删除距离为1的边</li></ol><p><img src="/img/大数据/ch6-Distance-Dynamics-流程.png" /></p><h3 id="graph-embedding">Graph embedding</h3><h4 id="motivation">Motivation</h4><ul><li>网络包含数十亿的节点和边，对整个网络进行复杂的推理是难以实现的。</li><li>机器学习算法需要向量表示</li><li>如何在Graph embedding的过程中保留Commmunity structure</li><li>如何有效地处理大规模网络</li></ul><p>Graph embedding的目标是将每个节点映射到一个低维空间。</p><p>图是一种非欧几里得结构，图的属性：</p><ul><li>节点的编号是任意的</li><li>图具有任意的大小</li><li>结构复杂</li></ul><p>困难：</p><ul><li>衡量节点之间的相似度</li><li>编码网络信息并生成节点表示</li></ul><h4 id="deepwalk">DeepWalk</h4><!-- DeepWalk的思想类似word2vec，使用图中节点与节点的共现关系来学习节点的向量表示。那么关键的问题就是如何来描述节点与节点的共现关系，DeepWalk给出的方法是使用随机游走(RandomWalk)的方式在图中进行节点采样。RandomWalk是一种可重复访问已访问节点的深度优先遍历算法。给定当前访问起始节点，从其邻居中随机采样节点作为下一个访问节点，重复此过程，直到访问序列长度满足预设条件。![](/img/大数据/ch6-deepwalk-流程.png)#### Node2Vec**优化目标**:设$f(u)$是是将顶点 $u$ 映射为embedding向量的映射函数,对于图中每个顶点$u$,定义$N_{S}(u)$为通过采样策略$S$采样出的顶点$u$的近邻顶点集合。node2vec优化的目标是给定每个顶点条件下，令其近邻顶点（**如何定义近邻顶点很重要**）出现的概率最大。![](/img/大数据/ch6-Node2vec-公式.png) --><p>详见<a href="https://zhuanlan.zhihu.com/p/56380812">【GraphEmbedding】DeepWalk：算法原理，实现和应用</a></p><h4 id="node2vec">Node2vec</h4><p>详见<a href="https://zhuanlan.zhihu.com/p/56542707">【GraphEmbedding】node2vec：算法原理，实现和应用</a></p><h2 id="ch7-hadoopspark">Ch7 Hadoop/Spark</h2><h3 id="hadoop">Hadoop</h3><h4 id="what-is-hadoop">What is Hadoop</h4><p>Hadoop是一个软件框架，用于在大型计算机集群中分布式处理大型数据集。</p><h4 id="design-principles-of-hadoop">Design Principles of Hadoop</h4><ul><li>Need to process big data</li><li>Need to parallelize computation across thousands of nodes</li><li>Commodity hardware<ul><li>Large number of low-end cheap machines working in parallel to solvea computing problem</li></ul></li><li>This is in contrast to Parallel DBs<ul><li>Small number of high-end expensive machines</li></ul></li><li>Automatic parallelization &amp; distribution<ul><li>Hidden from the end-user</li></ul></li><li>Fault tolerance(容错) and automatic recovery<ul><li>Nodes/tasks will fail and will recover automatically</li></ul></li><li>Clean and simple programming abstraction.(干净而简单的编程抽象)<ul><li>Users only provide two functions “map” and “reduce”</li></ul></li></ul><h4 id="hadoop-architecture">Hadoop Architecture</h4><ul><li>Distributed file system (HDFS)</li><li>Execution engine (MapReduce)</li></ul><p><img src="/img/大数据/ch7-Hadoop-Architecture.png" /></p><h3 id="eco-system-of-hadoop">Eco-system of Hadoop</h3><ul><li>HDFS:Storing(存储)</li><li>MapReduce:computation</li><li>HBASE:NoSQL database</li><li>Hive:Data warehouse(数据仓库)</li><li>Pig:Data flow language</li><li>Zookeeper:Coordination service</li><li>Core:Filesystems and I/O</li><li>Avro:Cross-language serialization(跨语言序列化)</li></ul><h3 id="hadoop-distributed-file-systemhdfs分布式文件系统">HadoopDistributed File System(HDFS)：分布式文件系统</h3><p><strong>Main Properties of HDFS</strong>:</p><ul><li><strong>Large</strong>:一个HDFS实例可能由数以千计的服务器机器组成，每个机器都存储着文件系统的部分数据</li><li><strong>Replication</strong>:每个数据块被多次复制（默认为3）。</li><li><strong>Failure</strong>:失败是常态而不是例外</li><li><strong>FaultTolerance</strong>:检测故障和快速自动恢复故障是HDFS的一个核心架构目标</li></ul><h4 id="namenode-datanode"><strong>NameNode + DataNode</strong></h4><ul><li>NameNode(meta-information)<ul><li>Managing FsImage file and EditLog file to manager metainformation</li><li>EditLog is used to update FsImage (Checkpoint).</li></ul></li><li>DataNode(actual data)<ul><li>Store data</li><li>Block operation</li></ul></li></ul><h4 id="fault-tolerance-replication-heartbeat"><strong>FaultTolerance</strong>: Replication + HeartBeat</h4><ul><li>HeartBeat:DataNode</li><li>Replication:Steady NameNode</li></ul><h3 id="mapreduce">MapReduce</h3><p>MapReduce的思想就是“分而治之”</p><h4 id="map">Map</h4><p>Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：</p><ul><li>一是数据或计算的规模相对原任务要大大缩小;</li><li>二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算;</li><li>三是这些小任务可以并行计算，彼此间几乎没有依赖关系。</li></ul><h4 id="reduce">Reduce</h4><p>Reducer负责对map阶段的结果进行汇总。至于需要多少个Reducer，用户可以根据具体问题具体设置。</p><h3 id="spark基于内存的计算框架">Spark(基于内存的计算框架)</h3><p>MapReduce is great at one-pass computation,but inefficient formulti-pass algorithms.</p><h4 id="what-is-spark">What is Spark</h4><p><strong>Apache Spark is a fast and general-purpose cluster computingsystem.</strong>It also supports a rich set of higher-level toolsincluding <strong>Spark SQL</strong> for SQL and structured dataprocessing,<strong> MLlib</strong> for machinelearning,<strong> GraphX</strong> for graph processing,and <strong>Spark Streaming</strong> for streaming processing.</p><h4 id="memory-based-computation">Memory based computation</h4><h5 id="rdd">RDD</h5><p>Spark的主要抽象是resilient distributed dataset(RDD),它表示一个只读的对象集合，在一组机器上进行分区，如果一个分区丢失，可以重建。</p><p>An RDD can be created 2 ways:</p><ul><li>Parallelize a collection</li><li>Read data from an external source</li></ul><h5 id="operations-on-rdd">Operations on RDD</h5><ul><li>transformations：create a new dataset from an existing one</li><li>actions: return a value to the driver program after running acomputation on the dataset</li></ul><h4 id="fault-tolerance">Fault Tolerance</h4><p>暂无待续.</p><h3 id="mapreduce-vs-spark">MapReduce VS Spark</h3><p><strong>MapReduce</strong>:</p><ul><li>Great at <strong>one-pass computation</strong>, but inefficient for<strong>multi-pass algorithms</strong>.</li><li>No efficient primitives for datasharing(没有用于数据共享的有效基元)</li></ul><p><strong>Spark</strong>:</p><ul><li>Extends a programming language with a distributed collectiondata-structure（RDD）.(用分布式集合数据结构（RDD）扩展了一种编程语言)</li><li>Clean APIs in Java, Scala, Python, R.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和数组与差分数组</title>
    <link href="/2023/06/01/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2023/06/01/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和数组与差分数组">前缀和数组与差分数组</h1><h2 id="一维前缀和">一维前缀和</h2><p>对于一维数组<code>nums</code>，其前缀和数组<code>prefix</code>为<span class="math display">\[prefix[i] = \sum\limits^{i}_{1} nums[i]\]</span></p><p>实际中多在前面加一个<code>0</code>，这样<code>prefix[i]</code>就刚好是<code>nums</code>数组的前<code>i</code>项和。</p><h2 id="一维差分数组">一维差分数组</h2><p>一维数组<code>nums</code>的差分数组<code>diff</code>定义：</p><p><span class="math display">\[diff[i] = nums[i] - nums[i - 1]\]</span></p><p>二维差分、二维前缀和与一维差分一维前缀和同理。</p><p>二维前缀和、二维差分定义以及例题详见<ahref="https://juejin.cn/post/7051851325746708511">Hard题学算法(二维前缀和+二维差分）</a></p><h2id="从差分数组前缀和数组求原数组">从差分数组、前缀和数组求原数组</h2><p><strong>差分数组求原数组</strong>：差分数组的前缀和数组就是原数组</p><p><strong>前缀和数组求原数组</strong>（以二维为例,默认在前面添加了一维的<code>0</code>防止越界）：</p><p><span class="math display">\[nums[i][j] = prefix[i + 1][j + 1] -prefix[i][j + 1] - prefix[i + 1][j] + prefix[i][j]\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习期末复习</title>
    <link href="/2023/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习期末复习">机器学习期末复习</h1><h2 id="第一章-机器学习简介">第一章 机器学习简介</h2><h3 id="机器学习的概念">机器学习的概念</h3><p>是一种实现人工智能的方法</p><h3 id="机器学习的要素">机器学习的要素</h3><ul><li>模型：对于监督学习，模型就是要学习的条件概率或者决策函数</li><li>策略<ul><li>目标：选择最优的模型</li><li>损失函数，损失函数越小，模型就越好<ul><li>平方损失函数：<spanclass="math inline">\(L(Y，f(X))=(Y-f(x))^2\)</span>, 其中<spanclass="math inline">\(Y\)</span>是标签（真实值), <spanclass="math inline">\(f(X)\)</span>是预测值。</li></ul></li><li>风险函数（期望损失）：损失函数的期望</li><li>经验风险：训练集的平均损失，训练集的拟合情况 <spanclass="math display">\[结构风险  =  经验风险 + 正则化项 (系数 *模型复杂度)\]</span></li></ul></li><li>算法：用什么样的计算方法求解最优模型。归结为最优化问题</li></ul><h3 id="机器学习的类型">机器学习的类型</h3><ul><li>监督学习：监督学习是指通过让机器学习大量带有标签的样本数据，训练出一个模型，并使该模型可以根据输入预测相应输出的过程</li><li>无监督学习：训练数据不再是（input,output）对的形式，样本数据没有标签</li><li>强化学习：通过感知外界环境的变化来调整学习方式，然后通过奖惩的方式来判别学习方式是否正确，通过一步步调整学习方式，最终找到一个最优的方式。通过一个智能体在与复杂而不确定的环境交互中最大化总回报来学习的一种计算方法</li></ul><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>训练误差：训练集的平均损失</p><p>测试误差：测试集的平均损失</p><h3 id="回归和分类">回归和分类</h3><p>回归：因变量𝑦 ∈ ℝ是连续变量 分类：label是离散变量</p><h3 id="过拟合">过拟合</h3><p>欠拟合：模型在训练集上误差很大，在测试集上误差也大。由于模型能力不足（不灵活）</p><p>过拟合(Over-fitting)：模型在训练集上误差很低，但是在测试数据上误差很高。由于训练数据太少和/或模型能力太强等原因造成</p><p><img src="/img/机器学习/过拟合.jpg" /></p><p>解决过拟合的方法:</p><ul><li>扩大训练集</li><li>正则化Regularization：通过修改目标函数来惩罚模型的复杂度<ul><li>L1正则化：可以使参数稀疏化</li><li>L2正则化：可以防止过拟合</li></ul></li><li>通过验证集来选择模型</li></ul><h3 id="模型选择方法">模型选择方法</h3><p><strong>正则化</strong>:</p><p>结构风险 = 经验风险 + 正则化项</p><p><img src="/img/机器学习/期末复习/结构风险.png" /></p><p>在回归问题中，正则化项可以是L1,L2范数：</p><p><img src="/img/机器学习/期末复习/L1L2范数.png" /></p><p>其中，L1 L2范数分别为</p><p><img src="/img/机器学习/期末复习/L1L2范数定义.png" /></p><p><strong>奥卡姆剃刀原理</strong>：在已知数据的情况下，越简单的模型越好</p><p><strong>贝叶斯估计视角</strong>：正则化项为模型先验概率</p><h3 id="交叉验证">交叉验证</h3><p>数据集划分为三个部分：训练集，测试集，验证集。训练集用于模型训练，测试集用于最终对学习方法评估，验证集用于模型选择。在学习到不同复杂度的模型中，选择验证集最小预测误差的模型。</p><ul><li>简单交叉验证：划分训练集和测试集，用不同的模型对训练集进行训练，最终在测试集评价每一个模型的误差，选出误差最小的模型。</li><li>S折交叉验证：把数据集划分成s份，用其中的s-1份训练模型，用剩下的一份测试模型。其中，一共有s种组合，对s种组合重复对对模型进行训练和评测。最终，选出在这s次训练和评测中，平均误差最小的模型。</li><li>留一交叉验证：s折交叉验证的特殊情况：S=N，N为数据集的个数。即为：只留一个样本用作测试。</li></ul><h3 id="泛化能力">泛化能力</h3><p>对未知数据集的预测能力</p><h3 id="生成模型与判别模型">生成模型与判别模型</h3><ul><li>生成模型：生成方法由数据学习联合概率分布<spanclass="math inline">\(P(X,Y)\)</span>,然后求出条件概率分布 <spanclass="math inline">\(P(Y|X)\)</span>作为预测的模型：<spanclass="math inline">\(P(Y|X) = {P(X,Y)/P(X)}\)</span>。最后模型: <spanclass="math inline">\(P(Y)=P(Y|X)*P(X)\)</span>。</li><li>判别模型：直接学习决策函数或者 P(Y|X)作为预测的模型。</li></ul><h3 id="二分类评价指标">二分类评价指标</h3><p>精确率和召回率：TP, FP, TN, FN（true/false positive/negitive）</p><p>精确率: <span class="math inline">\(P = \frac{TP}{TP +FP}\)</span></p><p>召回率: <span class="math inline">\(R = \frac{TP}{TP+FN}\)</span></p><h3 id="贝叶斯定理">贝叶斯定理</h3><p><span class="math inline">\(P(A|H) =\frac{P(A)P(H|A)}{P(H)}\)</span></p><h4 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h4><p><strong>先验概率</strong>:<spanclass="math inline">\(P(Y=c_k),k=1,2,...,K\)</span></p><p><strong>条件概率（似然概率）</strong>:<spanclass="math inline">\(P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,...,K\)</span></p><p><strong>后验概率</strong>:<spanclass="math inline">\(P(Y=c_k|X=x)=\frac{P(Y=c_k)P(X=x|Y=c_k)}{\sum_{k=1}^KP(Y=c_k)P(X=x|Y=c_k)}\)</span></p><h2 id="第二章-概率论概述">第二章 概率论概述</h2><h3 id="频率论学派和贝叶斯学派">频率论学派和贝叶斯学派</h3><p><strong>频率论学派（Frequentist）</strong>：通过大量独立实验将概率解释为事件发生频率的均值（大数定律）</p><p><strong>贝叶斯学派（Bayesian）</strong>：则将概率解释为信念度（degreeofbelief）。当考虑的试验次数非常少的时候，贝叶斯方法的解释非常有用。此外，贝叶斯理论将我们对于随机过程的先验知识纳入考虑，当我们获得新数据的时候，这个先验的概率分布就会被更新到后验分布中</p><h3 id="高斯分布">高斯分布</h3><p><img src="/img/机器学习/期末复习/高斯分布.jpg" /></p><h3 id="极大似然估计和最大后验估计">极大似然估计和最大后验估计</h3><p><strong>极大似然估计（频率学派模型参数估计常用方法）</strong>：通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！即最大化<spanclass="math inline">\(P(x_0|\theta)\)</span></p><p><img src="/img/机器学习/期末复习/极大似然估计.jpg" /></p><p><strong>最大后验估计（贝叶斯派模型参数估计的常用方法）</strong>：最大化在给定数据样本的情况下模型参数的后验概率。即最大化<span class="math inline">\(P(\theta | x_0) = \frac{P(x_0 |\theta)P(\theta)}{P(x_0)}\)</span>。最大似然估计是求参数 <spanclass="math inline">\(\theta\)</span>使似然函数最大。最大后验概率估计则是想求<spanclass="math inline">\(\theta\)</span>使<spanclass="math inline">\(P(x_0|\theta)\)</span>最大 。求得的<spanclass="math inline">\(\theta\)</span>不单单让似然函数大,<spanclass="math inline">\(\theta\)</span>自己出现的先验概率也得大。</p><p><img src="/img/机器学习/期末复习/最大后验分布.png" /></p><h2 id="第三章-优化方法简介">第三章 优化方法简介</h2><h3 id="梯度下降法">梯度下降法</h3><p>一种求解的最优化算法（无约束），主要解决求最小值问题，基本思想是下山，即不断逼近最优点的思想，通过求梯度的反方向，来确定错误面中的最低点的方向（有可能是局部最低点），从而不断逼近最小值。设损失函数为：<spanclass="math inline">\(J(\theta)=\frac{1}{2}[f(x)-y]^2\)</span>,则梯度下降为：<span class="math inline">\(\theta_{n+1} = \theta_{n} - \alphaJ&#39;(\theta)\)</span> 其中<spanclass="math inline">\(\alpha\)</span>为学习率。</p><h4 id="确定学习率的方法">确定学习率的方法</h4><ul><li>线性搜索法：<span class="math inline">\(\eta_t = argminf(x - \eta\Delta f(x))\)</span>,一般来说在实际中代价太高</li><li>线性回溯搜索算法：<span class="math inline">\(f(x-\eta \Delta f(x))\le f(x) - \alpha \eta ||\Delta f(x)||^2\)</span>,在实际中work well</li></ul><h4 id="应用梯度下降的不同形式">应用梯度下降的不同形式</h4><ul><li>批量梯度下降（BGD）：更新参数时使用所有样本进行更新，梯度更新比较耗时，但是会更准确朝极值方向更新，迭代次数少</li><li>随机梯度下降(SGD)：每步仅选取一个样本求梯度，梯度更新快，但下降时候波动大，更容易从一个局部最优跳到另一个局部最优，准确度下降。迭代次数多，可能不收敛，或陷入局部极值或鞍点。</li><li>小批量梯度下降(MBGD)：上面两个的折衷，每步采用固定一部分的样本计算梯度梯度更新比BGD快，迭代次数比SGD少。学习过程仍会有振荡，为更接近最小值，需要增加学习率衰减项，避免过度振荡。</li></ul><p><strong>使用建议</strong>：当训练集比较小时，批学习，采用拟牛顿或者共轭梯度下降；当训练集大时，随机梯度下降；当训练集介于其间时，小批量学习</p><h3 id="拉格朗日乘子法和kkt条件">拉格朗日乘子法和KKT条件</h3><p>梯度下降只能求解无约束问题，对于有约束问题，使用梯度下降法，很可能最小值点根本不在约束范围内，所以用拉格朗日乘子法。</p><h4 id="拉格朗日乘子法">拉格朗日乘子法</h4><p>求解有约束最小值问题（约束为等式）：</p><p><span class="math display">\[\min{f(x)} \\s.t.g(x) = 0\]</span></p><p>即在 <span class="math inline">\(g(x)=0\)</span>的条件下，求 <spanclass="math inline">\(f(x)\)</span>的最小值，引入一个自由变量 <spanclass="math inline">\(\lambda\)</span>,构造拉格朗日函数：</p><p><span class="math display">\[L(x,\lambda)=f(x) + \lambdag(x)\]</span></p><p>则新的方程又变成了无约束问题，对其中的 <spanclass="math inline">\(x,\lambda\)</span>求偏导，联立方程组使其等于0，则所得解就是原方程的解。</p><h4 id="kkt条件">KKT条件</h4><p>用于求解约束为不等式时候的约束问题，只是判断x是否为最优解的<strong>必要条件</strong>。和拉格朗日乘子法一样，引入自由变量，构造拉格朗日函数，设约束条件：</p><p><span class="math display">\[g(x)=0 \\ t(x)≤0\]</span></p><p>求解 <span class="math inline">\(\min f(x)\)</span>.</p><p>同理构造拉格朗日函数：</p><p><span class="math display">\[L(x,\lambda,\theta)=f(x) + \lambda g(x)+ \theta t(x)\]</span></p><p>则对应kkt条件有：</p><ul><li>L对x的偏导数为0；</li><li>g(x)=0;</li><li><span class="math inline">\(\theta t(x)=0\)</span>;</li><li><span class="math inline">\(\theta \ge 0\)</span>;</li></ul><p><img src="/img/机器学习/期末复习/KKT条件.jpg" /></p><h5 id="拉格朗日乘子法求解">拉格朗日乘子法求解</h5><p><img src="/img/机器学习/期末复习/拉格朗日乘子法求解.jpg" /></p><p><strong>总结：同时包含等式和不等式约束的一般优化问题</strong></p><h3 id="对偶">对偶</h3><p>在机器学习中，对偶（duality）是指将一个优化问题转化为其对偶形式，从而更容易地解决原始问题。具体来说，对于一个原始优化问题，通过构建一个拉格朗日函数，并对其进行最大化或最小化，可以得到对偶问题。通过解决对偶问题，我们可以获得原始问题的解。这种方法在解决某些优化问题时非常有用，因为对偶问题可能比原始问题更容易求解。</p><p>用<spanclass="math inline">\(p^*\)</span>表示原问题（最小化）的最优值；<spanclass="math inline">\(d^*\)</span>表示对偶问题（最大化）的最优值。</p><p><strong>弱对偶性</strong>：<span class="math inline">\(d^* \lep^*\)</span>。即使原问题不是凸优化，不等式也成立</p><p><strong>强对偶性</strong>：<span class="math inline">\(d^* =p^*\)</span></p><h4 id="为什么要研究对偶问题">为什么要研究对偶问题</h4><ul><li>虽然对偶方法并不能保证成功，但是它对于某些类别的函数有效，在这些情况下，它总能带来更简单的优化问题，特别是当原问题中自变量的维度比约束的数量大得多的情况下,</li><li>对偶函数总是凹函数，无论原问题如何。所以对偶函数的优化是个凸优化问题</li></ul><h3 id="牛顿法">牛顿法</h3><p>用目标函数的二阶泰勒展开近似该目标函数，通过求解这个二次函数的极小值来求解凸优化的搜索方向</p><h2 id="第四章-回归的线性模型">第四章 回归的线性模型</h2><h3 id="线性回归最小二乘法">线性回归最小二乘法</h3><p>回归就是一个输入连续输出连续的模型，比如 <spanclass="math inline">\(f(x) = \lambda x + \beta\)</span>,其中： <spanclass="math inline">\(\lambda\)</span>为要学习的参数， <spanclass="math inline">\(\beta\)</span>为偏置，过于简单不多说。</p><p><strong>最小二乘法标准</strong>：平方损失函数达到最小</p><p>对于上述一元线性回归模型来说，损失函数 <spanclass="math inline">\(J(\lambda,\beta)=(f(x_i)-y_i)^2\)</span>,使损失函数最小，便是求偏导=0，所以去算损失函数关于参数和偏置的偏导为0即可求解。</p><h3 id="岭回归">岭回归</h3><p>岭回归是一种特殊的线性回归方法，它在<strong>普通线性回归的基础上增加了一个L2正则化项</strong>。</p><p>普通线性回归的损失函数为：</p><p><span class="math display">\[J(\boldsymbol{\theta}) = \frac{1}{m}\sum_{i=1}^{m}{(\boldsymbol{\theta}^{\top}\boldsymbol{x}^{(i)} -y^{(i)})^2}\]</span></p><p>岭回归损失函数为：</p><p><span class="math display">\[J(\boldsymbol{\theta}) = \frac{1}{m}\sum_{i=1}^{m}{(\boldsymbol{\theta}^{\top}\boldsymbol{x}^{(i)} -y^{(i)})^2} + \alpha \sum_{j=1}^{n}{\theta_j^2}\]</span></p><p>其中， <spanclass="math inline">\(\alpha\)</span>是正则化强度的调节参数， <spanclass="math inline">\(\boldsymbol{\theta}\)</span>是回归系数向量， <spanclass="math inline">\(\boldsymbol{x}^{(i)}\)</span>是第 <spanclass="math inline">\(i\)</span>个样本的特征向量，<spanclass="math inline">\(y^{(i)}\)</span>是第 <spanclass="math inline">\(i\)</span>个样本的目标值(标签)， <spanclass="math inline">\(n\)</span>是特征数。</p><p>岭回归通过增加正则化项，使得回归系数更加稳定，从而防止过拟合。在L2正则化下，回归系数会被压缩到接近于0的数值，但不会变成0。因此，岭回归可以保留所有的特征，而不用像特征选择那样舍弃一些特征。</p><p>岭回归的求解方法与普通线性回归类似，只是在最小化损失函数时需要加上正则化项的贡献。最常用的方法是使用解析解：</p><p><span class="math display">\[\boldsymbol{\theta} =(\boldsymbol{X}^{\top}\boldsymbol{X} +\alpha\boldsymbol{I})^{-1}\boldsymbol{X}^{\top}\boldsymbol{y}\]</span></p><p>其中， <spanclass="math inline">\(\boldsymbol{X}\)</span>是样本特征矩阵， <spanclass="math inline">\(\boldsymbol{y}\)</span>是目标值向量， <spanclass="math inline">\(\boldsymbol{I}\)</span>是单位矩阵。</p><p>岭回归的一个关键问题是如何选择正则化强度参数 <spanclass="math inline">\(\alpha\)</span>。通常可以通过交叉验证来选择最佳的<span class="math inline">\(\alpha\)</span>值。</p><h3 id="lasso回归">Lasso回归</h3><p>Lasso回归是一种用于特征选择的线性回归模型，它的<strong>损失函数是平方损失加上L1正则化</strong>。L1正则化会让一部分特征的系数变为0，从而达到特征选择的目的。</p><p>Lasso回归的损失函数为：</p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2 + \alpha \sum_{j=1}^n|\theta_j|\]</span></p><p>其中，第一项是平方损失，第二项是L1正则化项， <spanclass="math inline">\(\alpha\)</span>是正则化参数。</p><p>Lasso回归的优化算法是坐标轴下降法，也称为坐标下降法。它的基本思想是，每次只更新一个参数的值，将其他参数的值固定住。</p><p>Lasso回归有一个重要的应用场景是特征选择。如果某个特征的系数为0，说明这个特征对目标变量没有太大的影响，可以将其从模型中剔除，从而简化模型并提高泛化性能。</p><h2 id="第五章-分类的线性模型">第五章 分类的线性模型</h2><h3 id="线性分类概念">线性分类概念</h3><p>线性分类是一种常见的机器学习技术，旨在将数据分成两个或多个类别。它的基本思想是在特征空间中找到一条直线、平面或超平面，将不同类别的数据分开。线性分类可以用于二元分类（将数据分成两个类别）和多元分类（将数据分成三个或更多类别）问题。</p><p><img src="/img/机器学习/期末复习/线性分类概念.jpg" /></p><p>在二元分类中，线性分类器会将数据点分为两个类别，通常用“+1”和“-1”表示。对于一个新的数据点，分类器会计算它与这条直线、平面或超平面之间的距离，并根据其距离的符号来预测其所属的类别。如果距离为正，则预测其属于正类；如果距离为负，则预测其属于负类。</p><p>线性分类器可以用很多不同的算法来训练。其中，最常用的算法是支持向量机（SVM）。SVM算法通过寻找最大间隔超平面来分割数据。这条超平面可以最大限度地扩大不同类别数据点之间的距离，从而提高分类器的性能。</p><p>除了SVM之外，还有其他的线性分类器算法，例如感知器（perceptron）和逻辑回归（logisticregression）。这些算法也可以用来解决线性分类问题，但它们的性能和训练速度可能会有所不同。</p><h3id="判别函数概率生成模型概率判别模型">判别函数、概率生成模型、概率判别模型</h3><h4 id="判别函数模型">判别函数模型</h4><p>判别函数模型通过学习一个判别函数来直接将输入映射到输出类别，它<strong>不需要生成训练样本的概率分布</strong>。判别函数模型通常适用于高维稠密数据，并且由于它只关注分类结果，而不是关注如何生成数据，因此在训练数据不太充分或噪声较大的情况下也能够有很好的表现。常见的判别函数模型包括支持向量机（SVM）和神经网络（NeuralNetwork）。</p><h4 id="概率生成模型">概率生成模型</h4><p>概率生成模型先对样本的概率分布进行建模，然后通过贝叶斯公式计算后验概率来进行分类或预测。概率生成模型适用于多类别分类或回归问题，并且能够较好地处理缺失数据和噪声。常见的概率生成模型包括朴素贝叶斯（NaiveBayes）和高斯混合模型（Gaussian Mixture Model）。</p><p>概率生成模型先对类条件密度<spanclass="math inline">\(p(x|C_k)\)</span>和先验类概率分布<spanclass="math inline">\(p(C_k)\)</span>建模然后再使⽤贝叶斯定理计算后验类概率分布<spanclass="math inline">\(p(C_k|x)\)</span>.最后，使⽤决策论来确定每个输⼊<spanclass="math inline">\(x\)</span>的类别等价地，直接对联合概率分布建模，再归一化得到后验概率。</p><p><img src="/img/机器学习/期末复习/概率生成模型.jpg" /></p><h4 id="概率判别模型">概率判别模型</h4><p>概率判别模型是通过直接对条件概率分布进行建模来预测输出。与概率生成模型不同，它不需要显式地建模输入的概率分布，而是直接估计类别条件概率。概率判别模型适用于多分类问题，其预测性能优于概率生成模型。常见的概率判别模型包括逻辑回归（LogisticRegression）和多层感知器（Multilayer Perceptron）。</p><p>概率判别模型直接对后验概率<spanclass="math inline">\(p(C_k|x)\)</span>建模,再使⽤决策论来确定每个新的输⼊<spanclass="math inline">\(x\)</span>的类别。</p><h3 id="逻辑回归">逻辑回归</h3><p>Logistic Regression虽然被称为回归，但其实际上是分类模型，并常用于二分类</p><p>逻辑回归是一种经典的机器学习算法，用于处理分类问题。它基于线性模型，将输入特征与输出标签之间的关系建模为一个sigmoid函数，并通过最大化似然函数来学习模型参数。在预测时，逻辑回归将输入特征传入模型，并通过sigmoid函数计算输出标签的概率值，从而得到最终的分类结果。</p><p>假设我们有一个二分类问题，样本集合为</p><p><spanclass="math display">\[D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}\]</span></p><p>其中 <span class="math inline">\(x_i\in R^m\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的 <spanclass="math inline">\(m\)</span>维输入特征向量, <spanclass="math inline">\(y_i\in\{0,1\}\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的标签。</p><p>逻辑回归的目标是学习一个函数 <spanclass="math inline">\(f(x)\)</span>，将输入特征 <spanclass="math inline">\(x\)</span>映射到一个 <spanclass="math inline">\([0,1]\)</span>之间的概率值，即：</p><p><span class="math display">\[P(Y=1|X=x)=\sigma(w^Tx+b)\]</span></p><p>其中, <spanclass="math inline">\(\sigma\)</span>是sigmoid函数，定义为：</p><p><spanclass="math display">\[\sigma(z)=\frac{1}{1+e^{-z}}\]</span></p><p>逻辑回归使用极大似然估计来学习模型参数 <spanclass="math inline">\(w\)</span>和 <spanclass="math inline">\(b\)</span>。</p><p>假设每个样本独立同分布地采样，根据贝叶斯定理，我们可以将样本的似然函数写为：</p><p><spanclass="math display">\[L(w,b)=\prod_{i=1}^nP(Y=y_i|X=x_i;w,b)\]</span></p><p>对数似然函数为：</p><p><span class="math display">\[\log L(w,b)=\sum_{i=1}^n\logP(Y=y_i|X=x_i;w,b)\]</span></p><p>我们的目标是最大化对数似然函数，可以通过梯度上升法来求解。具体来说，我们可以首先计算对数似然函数关于<span class="math inline">\(w\)</span>和 <spanclass="math inline">\(b\)</span>的梯度，然后更新模型参数，重复这个过程直到收敛。</p><p>在预测时，将输入特征 <spanclass="math inline">\(x\)</span>传入训练好的模型，计算 <spanclass="math inline">\(P(Y=1|X=x)\)</span>的值，若大于0.5则预测为正类，否则预测为负类。</p><h3 id="朴素贝叶斯分类器-1">朴素贝叶斯分类器</h3><p>朴素贝叶斯分类器是一种基于贝叶斯定理和特征条件独立假设的分类算法。它通常用于文本分类、垃圾邮件过滤、情感分析等自然语言处理任务。</p><p>假设我们有一个包含 <spanclass="math inline">\(n\)</span>个训练样本的数据集 <spanclass="math inline">\(D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}\)</span>，其中<spanclass="math inline">\(x_i=(x_{i1},x_{i2},\cdots,x_{im})\)</span>表示第<span class="math inline">\(i\)</span>个样本的 <spanclass="math inline">\(m\)</span>个特征， <spanclass="math inline">\(y_i\in\{c_1,c_2,\cdots,c_k\}\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的类别。</p><p>朴素贝叶斯分类器基于贝叶斯定理计算<strong>后验概率</strong> <spanclass="math inline">\(P(y|x)\)</span></p><p>即给定特征 <span class="math inline">\(x\)</span>下类别 <spanclass="math inline">\(y\)</span>的条件概率。根据贝叶斯定理，可以将 <spanclass="math inline">\(P(y|x)\)</span>表示为：</p><p><spanclass="math display">\[P(y|x)=\frac{P(x|y)P(y)}{P(x)}\]</span></p><p>其中， <span class="math inline">\(P(y)\)</span>是类别 <spanclass="math inline">\(y\)</span>的先验概率， <spanclass="math inline">\(P(x)\)</span>是特征 <spanclass="math inline">\(x\)</span>的边缘概率， <spanclass="math inline">\(P(x|y)\)</span>是在类别 <spanclass="math inline">\(y\)</span>下特征 <spanclass="math inline">\(x\)</span>的条件概率。在朴素贝叶斯分类器中，我们假设所有特征都是相互独立的，即：</p><p><span class="math display">\[P(x|y)=\prod_{i=1}^mP(x_i|y)\]</span></p><p>根据上述假设，朴素贝叶斯分类器将 <spanclass="math inline">\(P(y|x)\)</span>简化为：</p><p><span class="math display">\[P(y|x)=\frac{P(y)\prod_{i=1}^mP(x_i|y)}{P(x)}\]</span></p><p>由于 <spanclass="math inline">\(P(x)\)</span>是与类别无关的常量，因此可以忽略掉。于是我们只需要计算先验概率<span class="math inline">\(P(y)\)</span>和条件概率 <spanclass="math inline">\(P(x_i|y)\)</span>即可。</p><p>先验概率 <spanclass="math inline">\(P(y)\)</span>可以通过样本中每个类别出现的频率来估计。对于条件概率<spanclass="math inline">\(P(x_i|y)\)</span>，我们可以根据不同类型的特征进行不同的处理。</p><ul><li>对于离散型特征，我们可以直接计算每个取值出现的频率。</li><li>对于连续型特征，通常假设其服从正态分布，然后估计每个类别下的均值和方差。</li></ul><p>在预测时，我们将测试样本的特征代入上述公式，计算每个类别的后验概率，最终预测为概率最大的类别。</p><h2 id="第六章-支持向量机">第六章 支持向量机</h2><p>简单点讲，SVM就是一种二类分类模型，他的基本模型是的定义在特征空间上的<strong>间隔最大</strong>的线性分类器，SVM的学习策略就是间隔最大化。</p><p>对于支持向量机来说，数据点若是<spanclass="math inline">\(p\)</span>维向量，我们用<spanclass="math inline">\(p-1\)</span>维的超平面来分开这些点。但是可能有许多超平面可以把数据分类。最佳超平面的一个合理选择就是以最大间隔把两个类分开的超平面。因此，SVM选择能够使离超平面最近的数据点的到超平面距离最大的超平面。</p><p>以上介绍的SVM只能解决线性可分的问题，为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型:</p><ul><li><p>线性可分SVM</p><p>当训练数据线性可分时，通过硬间隔(hardmargin，什么是硬、软间隔下面会讲)最大化可以学习得到一个线性分类器，即硬间隔SVM</p></li><li><p>线性SVM</p><p>当训练数据不能线性可分但是可以近似线性可分时，通过软间隔(softmargin)最大化也可以学习到一个线性分类器，即软间隔SVM</p></li><li><p>非线性SVM</p></li></ul><p>当训练数据线性不可分时，通过使用核技巧(kerneltrick)和软间隔最大化，可以学习到一个非线性SVM</p><h3 id="个关键想法">3个关键想法</h3><ul><li>通过优化来求解一 个超平面分类器</li><li>寻找最大间隔分类器来提高模型 的 泛化能力（结构风险最小化）</li><li>采用核技巧使得在高维特征空间的计算更有效率</li></ul><h3 id="线性可分svm硬间隔">线性可分SVM——硬间隔</h3><p>考虑如下形式的线性可分的训练数据集:</p><p><span class="math display">\[(X_1, y_1),(X_2,y_2),...,(X_n,y_n)\]</span></p><p>其中<span class="math inline">\(X_i\)</span>是一个含有<spanclass="math inline">\(d\)</span>个元素的列向量, 即<spanclass="math inline">\(X_i \in R^d\)</span>;<spanclass="math inline">\(y_i\)</span>是标量,<span class="math inline">\(y\in +1, -1\)</span>,<spanclass="math inline">\(y+i=+1\)</span>时表示<spanclass="math inline">\(X_i\)</span>属于正类别,<spanclass="math inline">\(y_i=-1\)</span>时表示<spanclass="math inline">\(X_i\)</span>属于负类别。注：这里的<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(X_i\)</span>、<spanclass="math inline">\(W\)</span>都是列向量。</p><p>回忆一下感知机的目标:找到一个超平面使其能正确地将每个样本正确分类。感知机使用误分类最小的方法求得超平面，不过此时解有无穷多个。而线性可分支持向量机利用间隔最大化求最优分离超平面,这时解是唯一的。</p><p>一个超平面由法向量<span class="math inline">\(W\)</span>和截距<spanclass="math inline">\(b\)</span>决定,其方程为<spanclass="math inline">\(X^TW+b = 0\)</span>,可以规定法向量指向的一侧为正类,另一侧为负类。下图画出了三个平行的超平面，法方向取左上方向。</p><p><img src="/img/机器学习/期末复习/SVM硬间隔.png" /></p><p>为了找到最大间隔超平面，我们可以先选择分离两类数据的两个平行超平面，使得它们之间的距离尽可能大。在这两个超平面范围内的区域称为“间隔(margin)”，最大间隔超平面是位于它们正中间的超平面。这个过程如上图所示。</p><h4 id="间隔最大化">间隔最大化</h4><p>将高数里面求两条平行直线的距离公式推广到高维可求得上图中margin的<spanclass="math inline">\(\rho\)</span>:</p><p><span class="math display">\[margin = \rho =\frac{2}{||W||}\]</span></p><p>我们的目标是使<spanclass="math inline">\(\rho\)</span>最大，等价于使<spanclass="math inline">\(p^2\)</span>最大：</p><p><span class="math display">\[\max\limits_{W,b} \rho\Longleftrightarrow \max\limits_{W,b}\rho^2 \Longleftrightarrow\min\limits{W,b}\frac{1}{2}||W||^2 \tag{1}\]</span></p><p>上式的<spanclass="math inline">\(\frac{1}{2}\)</span>是为了后续求导后刚好能消去，没有其他特殊意义。</p><p>同时也不要忘了有一些约束条件:</p><p><span class="math display">\[X_i^tW+b\ge +1,y_i=+1 \\ X_i^tW+b\le-1,y_i=-1\]</span></p><p>总结一下，间隔最大化问题的数学表达就是</p><p><span class="math display">\[\begin{equation}\min\limits_{W,b} J(W)= \min\limits_{W,b}\frac{1}{2}||W||^2 \\s.t. \quad y_i(X_i^T+b) \ge 1, i = 1,2,...,n    \tag{2}\end{equation}\]</span></p><p>通过求解上式即可得到最优超平面<spanclass="math inline">\(\hat{W}\)</span>和<spanclass="math inline">\(\hat{b}\)</span>。</p><h4 id="支持向量">支持向量</h4><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离<strong>最近</strong>的数据点称为支持向量(supportvector)，支持向量是使<spanclass="math inline">\((2)\)</span>中的约束条件取等的点，即满足</p><p><span class="math display">\[y_i(X_i^TW+b)=1\]</span></p><p>的点。也即所有在直线<spanclass="math inline">\(X_i^TW+b=1\)</span>或直线<spanclass="math inline">\(X_i^TW+b=-1\)</span>的点。如下图所示:</p><p><img src="/img/机器学习/期末复习/支持向量.jpg" /></p><p><strong>在决定最佳超平面时只有支持向量起作用，而其他数据点并不起作用</strong>。如果移动非支持向量，甚至删除非支持向量都不会对最优超平面产生任何影响。也即支持向量对模型起着决定性的作用，这也是“支持向量机”名称的由来。</p><h4 id="对偶问题">对偶问题</h4><p>如何求解式<span class="math inline">\((2)\)</span>呢？</p><p>我们称式<spanclass="math inline">\((2)\)</span>所述问题为原始问题(primal problem),可以应用拉格朗日乘子法构造拉格朗日函数(Lagrangefunction)再通过求解其对偶问题(dualproblem)得到原始问题的最优解。转换为对偶问题来求解的原因是:</p><ul><li>对偶问题更易求解，由下文知对偶问题只需优化一个变量<spanclass="math inline">\(\alpha\)</span>且约束条件更简单；</li><li>能更加自然地引入核函数，进而推广到非线性问题。</li></ul><p>首先构建拉格朗日函数。为此需要引进拉格朗日乘子(Lagrangemultiplier),<span class="math inline">\(\alpha_i \ge0,i=1,2,...,n\)</span>。则拉格朗日函数为:</p><p><span class="math display">\[L(W,b,\alpha)=\frac{1}{2}||w||^2 -\sum\limits_{n}^{i=1}\alpha_i [y_i(X_i^TW+b)-1]\]</span></p><p>因此，给定一个<span class="math inline">\(W\)</span>和<spanclass="math inline">\(b\)</span>, 若满足式<spanclass="math inline">\((1)\)</span>的约束条件，那么有</p><p><spanclass="math display">\[\max\limits_{\alpha}L(W,b,\alpha)=J(W)=\frac{1}{2}||W||^2\]</span></p><p>则由上式可知，优化问题</p><p><span class="math display">\[\min\limits_{W,b}\max\limits_{\alpha}L(W,b,\alpha)\]</span></p><p>与式<span class="math inline">\((1)\)</span>所述问题完全等价。</p><p>根据拉格朗日对偶性，式<spanclass="math inline">\((1)\)</span>所述问题即原始问题的对偶问题是:</p><p><span class="math display">\[\max\limits_{\alpha} \min\limits_{W,b}L(W,b,\alpha)\]</span></p><p>为了求得对偶问题的解，需要先求得<spanclass="math inline">\(L(W,b,\alpha)\)</span>对<spanclass="math inline">\(W\)</span>和<spanclass="math inline">\(b\)</span>的极小再求对<spanclass="math inline">\(\alpha\)</span> 的极大。</p><ol type="1"><li>求<span class="math inline">\(\min\limits_{W,b}L(W,b,\alpha)\)</span>:对拉格朗日函数求导并令导数为0，有：</li></ol><p><span class="math display">\[\begin{equation}\nabla_W L(W, b, \alpha)=W-\sum_{i=1}^n \alpha_i y_i X_i=0\Longrightarrow W=\sum_{i=1}^n \alpha_i y_i X_i \tag{3}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation*}    \nabla_b L(W, b, \alpha)=-\sum_{i=1}^n \alpha_i y_i=0\Longrightarrow \sum_{i=1}^n \alpha_i y_i=0\end{equation*}\]</span></p><p>将上面两式代入<span class="math inline">\(L(W,b,\alpha)\)</span>:</p><p><span class="math display">\[\begin{aligned}&amp; L(\mathbf{w}, b,\boldsymbol{\alpha})=\frac{1}{2}\|\mathbf{w}\|^2-\sum_{i=1}^n\alpha_i\left[y_i\left(\mathbf{x}_i^T \mathbf{w}+b\right)-1\right] \\&amp; =\frac{1}{2} \sum_{i=1}^n \alpha_i y_i \mathbf{x}_i^T \sum_{j=1}^n\alpha_j y_j \mathbf{x}_j-\sum_{i=1}^n \alpha_i y_i \mathbf{x}_i^T\sum_{j=1}^n \alpha_j y_j \mathbf{x}_j-b \sum_{i=1}^n \alpha_iy_i+\sum_{i=1}^n \alpha_i \\&amp; =\sum_{i=1}^n \alpha_i-\frac{1}{2} \sum_{i=1}^n \alpha_i y_i\mathbf{x}_i^T \sum_{j=1}^n \alpha_j y_j \mathbf{x}_j=\sum_{i=1}^n\alpha_i-\frac{1}{2} \sum_{i, j=1}^n y_i y_j \alpha_{i} \alpha_j\mathbf{x}_i^T \mathbf{x}_{i=1}\end{aligned}\]</span></p><p>所以</p><p><span class="math display">\[\begin{equation}    \min _{W, b} L(W, b, \alpha)=-\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n\alpha_i \alpha_j y_i y_j X_i^T X_j+\sum_{i=1}^n \alpha_i \tag{4}\end{equation}\]</span></p><ol start="2" type="1"><li>求<spanclass="math inline">\(\min\limits{W,b}L(W,b,\alpha)\)</span>对<spanclass="math inline">\(\alpha\)</span>的极大：</li></ol><p>等价于式<span class="math inline">\((4)\)</span>对<spanclass="math inline">\(\alpha\)</span>求极大，也等价于式<spanclass="math inline">\((4)\)</span>取负数后对<spanclass="math inline">\(\alpha\)</span>求极小，即</p><p><span class="math display">\[\min _\alpha \frac{1}{2} \sum_{i=1}^n\sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j-\sum_{i=1}^n \alpha_i\tag{5}\]</span></p><p>同时满足约束条件：</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{i=1}^n \alpha_i y_i=0 \\&amp; \alpha_i \geq 0, i=1,2, \ldots, n\end{aligned} \tag{6}\]</span></p><p>至此，我们得到了原始最优化问题<spanclass="math inline">\((2)\)</span>和对偶最优化问题<spanclass="math inline">\((5)\)</span>、<spanclass="math inline">\((6)\)</span>。</p><p>因为原始优化问题的目标函数和不等式约束条件都是凸函数，并且该不等式约束是严格可行的(因为数据是线性可分的),所以存在<spanclass="math inline">\(\hat{W},\hat{b},\hat{\alpha}\)</span>，使得<spanclass="math inline">\(\hat{W},\hat{b}\)</span>是原始问题的解，<spanclass="math inline">\(\hat{\alpha}\)</span>是对偶问题的解。这意味着求解原始最优化问题<spanclass="math inline">\((2)\)</span>可以转换为求解对偶最优化问题<spanclass="math inline">\((5),(6)\)</span>。</p><p>那么如何求解优化问题<span class="math inline">\((5)\)</span>、<spanclass="math inline">\((6)\)</span>的最优解<spanclass="math inline">\(\hat{\alpha}\)</span>呢？不难发现这是一个二次规划问题，有现成的通用的算法来求解。</p><p>假设我们现在求得了<span class="math inline">\((4)\)</span>、<spanclass="math inline">\((5)\)</span>的最优解<spanclass="math inline">\(\hat{\alpha}\)</span>，则根据式<spanclass="math inline">\((4)\)</span>可求得最优<spanclass="math inline">\(\hat{W}\)</span>：</p><p><span class="math display">\[\hat{W}=\sum\limits_{i=1}^n\hat{\alpha}_i y_i X_i \tag{5}\]</span></p><p>因为至少存在一个<span class="math inline">\(\hat{\alpha}_j &gt;0\)</span>(若不存在，即<spanclass="math inline">\(\hat{\alpha}\)</span>全为0，则<spanclass="math inline">\(\hat{W}=0\)</span>, 即<spanclass="math inline">\(margin=\frac{2}{||W||} =\infty\)</span>,显然不行), 再根据KKT条件，即</p><p><span class="math display">\[\left\{\begin{array}{l}\text { 乘子非负 }: \alpha_i \geq 0(i=1,2, \ldots n . \text { 下同 }) \\\text { 约束条件 }: y_i\left(X_i^T W+b\right)-1 \geq 0 \\\text { 互补条件 }: \alpha_i\left(y_i\left(X_i^T W+b\right)-1\right)=0\end{array}\right.\]</span></p><p>所以至少存在一个<span class="math inline">\(j\)</span>,使<spanclass="math inline">\(y_j(X_T\hat{W}+\hat{b})-1=0\)</span>,即可求得最优<spanclass="math inline">\(\hat{b}\)</span>:</p><p><span class="math display">\[\begin{aligned}\hat{b} &amp; =\frac{1}{y_j}-X_j^T \hat{W} \\&amp; =y_j-X_j^T \hat{W} \\&amp; =y_j-\sum_{i=1}^n \hat{\alpha}_i y_i X_j^T X_i\end{aligned}   \tag{7}\]</span></p><p>至此，所以我们就求得了整个线性可分SVM的解。求得的分离超平面为:</p><p><span class="math display">\[\sum_{i=1}^n \hat{\alpha}_i y_i X^T X_i+\hat{b}=0\]</span></p><p>则分类的决策函数为</p><p><span class="math display">\[f(X)=\operatorname{sign}\left(\sum_{i=1}^n \hat{\alpha}_i y_i X^TX_i+\hat{b}\right)\]</span></p><p>再来分析KKT条件里的互补条件，对于任意样本<spanclass="math inline">\((X_i,y_i)\)</span>，总会有<spanclass="math inline">\(\alpha_i=0\)</span>或者<spanclass="math inline">\(y_if(X_i)=y_i(X^T_i\hat{W}+b)=1\)</span>。则有若<spanclass="math inline">\(\alpha_i=0\)</span>，此样本点不是支持向量，对模型没有任何作用；若<spanclass="math inline">\(\alpha_i &gt;0\)</span>，此样本点位于最大间隔边界上，是一个支持向量，如下图所示:</p><p><img src="/img/机器学习/期末复习/硬间隔-1.png" /></p><p>此外，当样本点是非支持向量时，因为<spanclass="math inline">\(\alpha_i=0\)</span>，所以SVM的解中的求和项中第<spanclass="math inline">\(i\)</span>项就为0，所以SVM的解<spanclass="math inline">\((6)\)</span>、<spanclass="math inline">\((7)\)</span>可简化为如下形式:</p><p><span class="math display">\[\hat{W}=\sum\limits_{i\in S V}\hat{\alpha}_{i}y_{i}X_{i}\\\hat{b}=y_{j}-\sum\limits_{i\in S V}\hat{\alpha}_{i}y_{i}X_{j}^{T}X_{i}\]</span></p><p>类似的，判别函数也可转换成如下形式:</p><p><span class="math display">\[f(X)=s i g n(\sum\limits_{i\in SV}\hat{\alpha}_{i}y_{i}X^{T}X_{i}+\hat{b})\]</span></p><p>所以，整个SVM的解只与支持向量SV有关，与非支持向量无关。</p><h3 id="线性svm软间隔">线性SVM——软间隔</h3><p>上述<strong>硬间隔</strong>是完全分类准确，其损失函数不存在；其损失值为0；只要找出两个异类正中间的那个平面，而<strong>软间隔</strong>允许一定量的样本分类错误，即允许少量样本不满足约束</p><p><span class="math display">\[y_{i}(X_{i}^{T}W+b)\geq1\]</span></p><p>为了使不满足上述条件的样本点尽可能少，我们需要在优化的目标函数<spanclass="math inline">\((1)\)</span>里面新增一个对这些点的惩罚项。最常用的是hinge损失:</p><p><span class="math display">\[l_{h i n g e}(z)=m ax(\mathsf{0,1-z})\]</span></p><p>即若样本点满足约束条件损失就是0, 否则损失就是,则优化目标<spanclass="math inline">\(（1）\)</span>变成</p><p><span class="math display">\[\begin{equation}\min\limits_{W,b} \frac{1}{2}||W||^2 + C\sum\limits_{i=1}^n \max{(0, 1 -u_i(X_i^TW + b))}  \tag{8}\end{equation}\]</span></p><p>其中<span class="math inline">\(C&gt;0\)</span>称为惩罚参数，<spanclass="math inline">\(C\)</span>越小时对误分类惩罚越小，越大时对误分类惩罚越大，当<spanclass="math inline">\(C\)</span>取正无穷时就变成了硬间隔优化。实际应用时我们要合理选取<spanclass="math inline">\(C\)</span>,<spanclass="math inline">\(C\)</span>越小越容易欠拟合，<spanclass="math inline">\(C\)</span>越大越容易过拟合。</p><p>如果我们引入“松弛变量”<span class="math inline">\(\xi_i \ge0\)</span>, 那么式<span class="math inline">\((8)\)</span>可重写成</p><p><span class="math display">\[\min\limits_{W,b,\xi}{\frac{1}{2}||W||^{2}+C\sum\limits_{i=1}^{n}\xi_{i}} \\ s.t. \quady_i(X_i^TW+b) \ge 1 - \xi_i \\ \xi_i \ge 0, i = 1,2,...,n\]</span></p><p>上式所述问题即软间隔支持向量机。</p><p>而其对偶问题与硬间隔同理。</p><h3 id="非线性svm核技巧">非线性SVM——核技巧</h3><p>首先回顾前面的线性SVM的优化目标</p><p><span class="math display">\[\min _\alpha \frac{1}{2} \sum_{i=1}^n\sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j-\sum_{i=1}^n\alpha_i\]</span></p><p>以及约束条件</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{i=1}^n \alpha_i y_i=0 \\&amp; \alpha_i \geq 0, i=1,2, \ldots, n\end{aligned}\]</span></p><p>前面介绍的都是线性问题，但是我们经常会遇到非线性的问题(例如异或问题)，此时就需要用到核技巧(kerneltrick)将线性支持向量机推广到非线性支持向量机。如果样本在特征空间内线性不可分，则需要利用核函数将其映射到高维空间中，让其在高维空间中线性可分。根据SVM基础形式的求解，我们可能会想到下面的方式：</p><p><span class="math display">\[f(\boldsymbol X)=\sum_{i=1}^{N} w_i\phi_i(\boldsymbol X)+b\]</span></p><p>这里的<spanclass="math inline">\(\phi_i()\)</span>就是从输入的特征空间到某个更高维的特征空间的映射，这就意味着建议了非线性的学习器分为两步：</p><ul><li>使用一个变换将原空间的数据映射到新空间(例如更高维甚至无穷维的空间)；</li><li>然后在新空间里用线性方法从训练数据中学习得到模型。</li></ul><p>这种基本型的求解是非常难的，因为这个映射函数是非常难以寻找和求解的！（据说NP难），而了解了SVM的对偶形式给了另一种求解思路：</p><p><span class="math display">\[f(\boldsymbol X)=\sum_{i=1}^{l} \alpha_iy_i \left \langle \boldsymbol \phi_i(\boldsymbol X_i) \cdot \boldsymbol\phi(\boldsymbol X) \right \rangle + b\]</span></p><p>注意到，我们在求解的时候需要计算<spanclass="math inline">\(ϕi(X_i)⋅ϕ(X)\)</span>，也就是映射后的两个样本的高维特征的内积形式，如果有一种方法可以在特征空间中直接计算这个东西，是不是就很方便了？对的，核函数就是做这个的：</p><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i) =\boldsymbol \phi(\boldsymbol X) \cdot \boldsymbol \phi(\boldsymbolX_i)\]</span></p><p>那么现在的优化目标就变为</p><p><span class="math display">\[\min\limits_{\alpha}\frac{1}{2}\sum_{i=1}^{n}\sum_{j=1}^{n}\alpha_{i}\alpha_{j}y_{i}y_{j}K(X_{i},X_{j})\;-\;\sum_{i=1}^{n}\alpha_{i}\\s.t.\,\,\,\,\sum_{i=1}^{n}\alpha_{i}y_{i}=0 \\0\leq\alpha_{i}\leq C,i=1,2,\cdot\cdot,n.\]</span></p><p>上述的思想就是SVM核函数的核心思想。</p><h4 id="多项式核函数">多项式核函数</h4><p>对于一个多项式核函数</p><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i) = [(X\cdot X_i) + c]^q\]</span></p><p>可以得到q阶多项式分类器</p><h4 id="高斯径向基核rbf">高斯径向基核RBF</h4><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i)=  exp(-\frac{|X-X_i|^2}{\sigma^2})\]</span></p><p>每个基函数中心对应一个支持向量，它们及输出权值由算法自动确定。</p><h4 id="sigmod核">Sigmod核</h4><p><span class="math display">\[K(X, X_i)=tanh(\nu(X,X_)+c)\]</span></p><p>包含一个隐层的多层感知器，隐层节点数是由算法自动确定。</p><p>注：上述SVM内容转载于<ahref="https://zhuanlan.zhihu.com/p/49331510">看了这篇文章你还不懂SVM你就来打我</a></p><h2 id="第七章-混合模型与期望最大">第七章 混合模型与期望最大</h2><p><strong>聚类基本思想</strong>：将相似的实例分组在一起。聚类结果在很大程度上取决于待聚类点之间的相似性（或距离）度量</p><p><strong>聚类算法</strong></p><ul><li>原型聚类：如K均值算法、高斯混合模型</li><li>密度聚类：如DBSCAN算法、Mean-Shift 算法</li><li>层次聚类：如Agglomerative 算法、Divisive算法、BIRCH 算法</li><li>谱聚类</li></ul><h3 id="k-means-聚类">K-means 聚类</h3><p>K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p><p>如果用数据表达式表示，假设簇划分为<spanclass="math inline">\((C_1,C_2,...C_k)\)</span>，则我们的目标是最小化平方误差<spanclass="math inline">\(E\)</span>：</p><p><span class="math display">\[E = \sum\limits_{i=1}^k\sum\limits_{x\in C_i} ||x-\mu_i||_2^2\]</span></p><p>其中<span class="math inline">\(μ_i\)</span>是簇<spanclass="math inline">\(C_i\)</span>的均值向量，有时也称为质心，表达式为：</p><p><span class="math display">\[\mu_i = \frac{1}{|C_i|}\sum\limits_{x\in C_i}x\]</span></p><p>如果我们想直接求上式的最小值并不容易，这是一个NP难的问题，因此只能采用启发式的迭代方法。</p><p>K-Means采用的启发式方式很简单，用下面一组图就可以形象的描述。</p><p><img src="/img/机器学习/期末复习/kmeans过程.png" /></p><p>K-Means的算法步骤为:</p><ol type="1"><li>选择初始化的 k 个样本作为初始聚类中心<spanclass="math inline">\(a=a_1,a_2,...,a_k\)</span></li><li>针对数据集中每个样本<span class="math inline">\(x_i\)</span>计算它到<span class="math inline">\(k\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；</li><li>针对每个类别 <spanclass="math inline">\(a_j\)</span>，重新计算它的聚类中心<spanclass="math inline">\(a_{j}=\frac{1}{|c_{i}|}\sum\limits_{x\inc_{i}}x\)</span>（即属于该类的所有样本的质心）;</li><li>重复上面 2 3两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。</li></ol><h3 id="高斯混合模型gmm">高斯混合模型（GMM）</h3><p>高斯混合模型（Gaussian MixedModel）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布）。</p><!-- ![](/img/机器学习/期末复习/GMM.jpg) --><p><span class="math display">\[p(\alpha)=\sum_{k=1}^{K}\pi_{k}\mathcal{N}(x \mid\mu_{k},\Sigma_{k})\]</span></p><p>其中<span class="math inline">\(\mathcal{N}(x\mid\mu_{k},\Sigma_{k})\)</span>称为混合模型中的第<spanclass="math inline">\(k\)</span>个分量（component）。混合系数<spanclass="math inline">\(\pi_k\)</span>满足<spanclass="math inline">\(\sum\limits^{K}_{k=1}\pi_k =1 \quad0\le \pi \le1\)</span>。可以认为<spanclass="math inline">\(\pi_k\)</span>就是每个分量<spanclass="math inline">\(\mathcal{N}(x | \mu_k,\Sigma_k)\)</span>的权重。</p><h3 id="em算法">EM算法</h3><p>EM 算法，全称 Expectation MaximizationAlgorithm。期望最大算法是一种迭代算法，用于含有隐变量（HiddenVariable）的概率参数模型的最大似然估计或极大后验概率估计。</p><h4 id="em算法思想">EM算法思想</h4><p>EM 算法的核心思想非常简单，分为两步：Expection-Step 和Maximization-Step。</p><ul><li>E-Step主要通过观察数据和现有模型来估计参数，然后用这个估计的参数值来计算似然函数的期望值；</li><li>而 M-Step是寻找似然函数最大化时对应的参数。由于算法会保证在每次迭代之后似然函数都会增加，所以函数最终会收敛。</li></ul><p>EM算法例子的执行过程<ahref="https://www.jianshu.com/p/1121509ac1dc">如何感性地理解EM算法？</a></p><p>事实上隐变量估计也可以通过梯度下降等优化方法求解，但由于求和的项数将随着隐变量的数目以指数级别上升，会给梯度计算带来麻烦；而EM算法可以看作一种非梯度优化方法。</p><h2 id="第八章-高斯过程">第八章 高斯过程</h2><p>高斯过程 Gaussian Processes是概率论和数理统计中随机过程的一种，是多元高斯分布的扩展，被应用于机器学习、信号处理等领域。本文对高斯过程进行公式推导、原理阐述、可视化以及代码实现，介绍了以高斯过程为基础的高斯过程回归Gaussian Process Regression 基本原理、超参优化、高维输入等问题。</p><p><a href="https://zhuanlan.zhihu.com/p/75589452">高斯过程 GaussianProcesses 原理、可视化及代码实现</a></p><h2 id="第九章-集成学习">第九章 集成学习</h2><h3 id="bagging">Bagging</h3><p>Bagging（装袋算法）的集成学习方法非常简单，假设我们有一个数据集<spanclass="math inline">\(D\)</span>，使用Bootstrapsample（有放回的随机采样，这里说明一下，有放回抽样是抽一个就放回一个，然后再抽，而不是这个人抽<spanclass="math inline">\(10\)</span>个，再放回，下一个继续抽，它是每一个样本被抽中概率符合均匀分布）的方法取了<spanclass="math inline">\(k\)</span>个数据子集（子集样本数都相等）：<spanclass="math inline">\(D_1，D_2，…，D_k\)</span>，作为新的训练集，我们使用这<spanclass="math inline">\(k\)</span>个子集分别训练一个分类器（使用分类、回归等算法），最后会得到<spanclass="math inline">\(k\)</span>个分类模型。我们将测试数据输入到这<spanclass="math inline">\(k\)</span>个分类器，会得到<spanclass="math inline">\(k\)</span>个分类结果，比如分类结果是<spanclass="math inline">\(0\)</span>和<spanclass="math inline">\(1\)</span>，那么这<spanclass="math inline">\(k\)</span>个结果中谁占比最多，那么预测结果就是谁。</p><p><strong>算法流程</strong>：</p><ul><li>从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</li><li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知机等）</li><li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</li></ul><p><strong>特点</strong>：</p><ul><li>关于bagging所采用的抽样方式为有放回抽样，抽样的样本数量等于总体样本数量；</li><li>由于某些样本在有放回的情况下不止被抽到一次，有些样本一次也不会被抽到；</li><li>可以并行产生所需要的样本子集个数以及并行训练子模型</li><li>对于二分类问题，一般选取样本子集个数为奇数（避免出现两个类别投票数相同）</li></ul><h3 id="adaboost">AdaBoost</h3><p><strong>Boosting</strong>指的是一类集成方法，其主要思想就是将弱的基学习器提升(boost)为强学习器。具体步骤如下:</p><ol type="1"><li>先用每个样本权重相等的训练集训练一个初始的基学习器；</li><li>根据上轮得到的学习器对训练集的预测表现情况调整训练集中的样本权重(例如提高被错分类的样本的权重使之在下轮训练中得到更多的关注),然后据此训练一个新的基学习器；</li><li>重复2直到得到<spanclass="math inline">\(M\)</span>个基学习器，最终的集成结果是<spanclass="math inline">\(M\)</span>个基学习器的组合。</li></ol><p><strong>Boosting算法簇中最著名的就是AdaBoost</strong>。</p><h4 id="基本思想">基本思想</h4><p>对于上述的Boosting算法步骤，需要回答两个问题:</p><ol type="1"><li>如何调整每一轮的训练集中的样本权重？</li><li>如何将得到的[公式]个组合成最终的学习器？</li></ol><p>AdaBoost(Adaptive Boosting, 自适应增强)算法采取的方法是:</p><ol type="1"><li><strong>提高上一轮被错误分类的样本的权值，降低被正确分类的样本的权值</strong>；</li><li><strong>线性加权求和</strong>。误差率小的基学习器拥有较大的权值，误差率大的基学习器拥有较小的权值。</li></ol><p>AdaBoost算法的流程如下：</p><p>输入：训练数据集<spanclass="math inline">\(T={(x1,y1),(x2,y2),(xN,yN)}\)</span>，其中，<spanclass="math inline">\(xi∈X⊆R^n\)</span>，<spanclass="math inline">\(yi∈Y=−1,1\)</span>，迭代次数<spanclass="math inline">\(M\)</span></p><ol type="1"><li><p>初始化训练样本的权值分布: <spanclass="math display">\[D_1=(w_{1,1},w_{1,2},…,w_{1,i}),w_{1,i}=\frac{1}{N},i=1,2,…,N\]</span></p></li><li><p>对于<span class="math inline">\(m=1,2,…,M\)</span></p><ol type="1"><li><p>使用具有权值分布<spanclass="math inline">\(D_m\)</span>的训练数据集进行学习，得到弱分类器<spanclass="math inline">\(Gm(x)\)</span></p></li><li><p>计算<spanclass="math inline">\(Gm(x)\)</span>在训练数据集上的分类误差率: <spanclass="math display">\[e_m=\sum_{i=1}^Nw_{m,i}  I(G_m (x_i )≠y_i)\]</span></p></li><li><p>计算<spanclass="math inline">\(Gm(x)\)</span>在强分类器中所占的权重： <spanclass="math display">\[α_m=\frac{1}{2}log\frac{1-e_m}{e_m}\]</span></p></li><li><p>更新训练数据集的权值分布（这里，<spanclass="math inline">\(z_m\)</span>是归一化因子，为了使样本的概率分布和为<spanclass="math inline">\(1\)</span>）：</p></li></ol><p><span class="math display">\[w_{m+1,i}=\frac{w_{m,i}}{z_m}exp⁡(-α_my_i G_m (x_i ))，i=1,2,…,10\]</span></p><p><span class="math display">\[z_m=\sum_{i=1}^Nw_{m,i}exp⁡(-α_m y_i G_m(x_i ))\]</span></p></li><li><p>得到最终分类器:</p><p><span class="math display">\[F(x)=sign(\sum_{i=1}^Nα_m G_m(x))\]</span></p></li></ol><h3 id="bagging和boosting的区别">Bagging和Boosting的区别</h3><ol type="1"><li>样本选择上</li></ol><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><ol start="2" type="1"><li>样例权重</li></ol><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><ol start="3" type="1"><li>预测函数</li></ol><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><ol start="4" type="1"><li>并行计算</li></ol><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><h2 id="第十章-半监督学习">第十章 半监督学习</h2><h3 id="基于图的半监督学习">基于图的半监督学习</h3><h4 id="图的概念">图的概念</h4><p>我们首先来看看如何从训练数据中构建出图，给定半监督数据集<spanclass="math inline">\(\{(𝑥_𝑖,𝑦_𝑖 )\}_{𝑖=1}^𝑙\)</span>和<spanclass="math inline">\(\{𝑥_𝑗\}_{𝑗=𝑙+1}^{𝑙+𝑢}\)</span>，每个数据样本（有标签&amp;无标签）是图上的一个顶点，显然，图会非常大，因为无标签数据很多，一旦图构建完成，学习的过程就包括给图中的每一个定点设置标签y值。在图中可以通过边将有标签和无标签数据点相连，边通常是无向的，表示的是两个节点（样本）之间的相似性。将边权重记作<spanclass="math inline">\(w_{ij}\)</span>，<spanclass="math inline">\(w_{ij}\)</span>越大，<spanclass="math inline">\(x_i\)</span>和<spanclass="math inline">\(x_j\)</span>越相似，两者的标签越可能相同。所以边权重非常重要，人们常常将边的权值定义为如下形式：</p><ul><li>全连接图：</li></ul><p>每一对定点之间都有边相连，边的权重随欧式距离<spanclass="math inline">\(||x_i-x_j||\)</span>的增加而降低，常用的权重方程如下：</p><p><span class="math display">\[w_{ij}=\exp(-\frac{||x_i-x_j||^2}{2\sigma^2})\]</span></p><p><spanclass="math inline">\(σ\)</span>叫做带宽参数用来控制权重衰减的速度。这个权重方程和高斯方程的形式相同，也叫做高斯核或者径向基函数；</p><ul><li>KNN图：</li></ul><p>每一个定点定义它的欧式距离上的最近邻，注意，如果<spanclass="math inline">\(x_i\)</span>在<spanclass="math inline">\(x_j\)</span>的<spanclass="math inline">\(k\)</span>近邻内，<spanclass="math inline">\(x_j\)</span>不一定在<spanclass="math inline">\(x_i\)</span>的<spanclass="math inline">\(k\)</span>近邻内，如果<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_j\)</span>中有一个在对方的<spanclass="math inline">\(k\)</span>近邻内我们就用边将它们连接，这就意味着一个定点可能会有超过<spanclass="math inline">\(k\)</span>条边，如果<spanclass="math inline">\(x_i,x_j\)</span>有边相连，边的权重<spanclass="math inline">\(w_{ij}\)</span>就是<spanclass="math inline">\(1\)</span>，否则为<spanclass="math inline">\(0\)</span>。KNN图可以自适应地适应样本在特征空间的密度（密集区KNN范围的半径小）；</p><ul><li><span class="math inline">\(ε\)</span>NN图：</li></ul><p>将距离小于<span class="math inline">\(ε\)</span>的顶点连一条边。</p><h4 id="mincut">MINCUT</h4><p>我们将带有正标签的样本作为源点（就好像流从这里出发流经边），相似的，负标签样本作为终点（流消失的点），目标是找到一个最小的边集，使得删除这些边可以阻止所有从源点到终点的流，我们定义这样的一组边集叫做“cut”，割的大小用这些边的权重和来定义。一旦图被“割”开，与源点相连的点都被标记为正，反之为负。也就是说，我们想要找到这样的一个作用在顶点上的函数<spanclass="math inline">\(f(x)\in\{0,1\}\)</span>用来标记x的标签，使得对于有标签样本来说<spanclass="math inline">\(f(x_i)=y_i\)</span>，而且cut最小:</p><p><span class="math display">\[\sum_{i,j\geq f(x_{i})\neq f(x_{j})}w_{ij}\]</span></p><p>我们将最小割问题形式化为正则化风险最小化问题（合适的损失函数和正则化器）。对任何有标签的顶点<spanclass="math inline">\(x_i\)</span>，<spanclass="math inline">\(f(x_i)\)</span>就是<spanclass="math inline">\(x_i\)</span>对应的标签<spanclass="math inline">\(y_i\)</span>，可以用这样一个损失函数来表示：<spanclass="math inline">\(c(\mathbf{x},\mathbf{y},f(\mathbf{x}))=\infty\cdot(\mathbf{y}-f(\mathbf{x}))^{2}\)</span>,而正则化项则对应cut的大小，考虑到所有无标签样本的类别非负即正，cut的大小可以重写为<spanclass="math inline">\(\Omega(f)=\sum\limits_{i,\,i=1}^{i=n}w_{ij}(f(\mathbf{x}_{i})-f(\mathbf{x}_{j}))^{2}/4\)</span>。注意，当前的和是针对所有点对的，如果<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_j\)</span>不相连，<spanclass="math inline">\(w_{ij}=0\)</span>。那么最小割的正则化风险最小化问题可以写作</p><p><span class="math display">\[\min\limits_{f:f(x) \in \{-1,1\}} \infty\sum_{i=1}^{l}(y_{i}-f(\mathbf{x}_{i}))^{2}+\sum_{i,j=1}^{l+u}w_{ij}(f(\mathbf{x}_{i})-f(\mathbf{x}_{j}))^{2}\]</span></p><p>这是一个整数规划问题，因此，最小割问题可以有许多多项式时间算法可以解决。这种形式的最小割问题可能存在多个最优解，比如下图有两个带标签点一正一负，每条边有相同的权重，有6种最小割解决方案（移除任意一条边即可）。</p><h4 id="调和函数harmonic-function">调和函数（HARMONIC FUNCTION）</h4><p>对于有标签数据，调和函数的值为标签值；对于无标签数据，标签值是其邻居顶点标签值的权重平均</p><p><span class="math display">\[\begin{array}{r cl}{f(\mathbf{x}_{i})}&amp;{=}&amp;{y_{i},}&amp;{i=1,\cdot\cdot,l}\end{array}\]</span></p><p><span class="math display">\[f(x_j) = \frac{\sum\limits_{k=1}^{l+u}w_{jk}f(x_k)}{\sum\limits_{k=1}^{l+u} w_{jk}}, j =l+1,\cdots,l+u\]</span></p><p>然后把它代入上面提到过的目标函数，并松弛<spanclass="math inline">\(f\)</span>使它的值域为实数：</p><p><span class="math display">\[\min\limits_{f:f(x)\in\mathbb{R}} \infty\sum\limits_{i=1}^{l}(y_{i}-f({\bfx}_{i}))^{2}+\sum\limits_{i=1}^{l+u}w_{i j}(f({\bf x}_{i})-f({\bfx}_{j}))^{2}\]</span></p><p>相当于求解：</p><p><spanclass="math display">\[\min\limits_{f:f(x)\in\mathbb{R}}\sum\limits_{i=1}^{l+u}w_{ij}(f({\bf x}_{i})-f({\bf x}_{j}))^{2}\]</span></p><p>对<span class="math inline">\(f\)</span>进行松弛使得<spanclass="math inline">\(f\)</span>有一个闭式解，也就是说上述目标方程有全局最优解，缺点是<spanclass="math inline">\(f(x)\)</span>现在是一个<spanclass="math inline">\([0,1]\)</span>的实数，并不能直接作为一个标签。这可以通过设定阈值进行处理（如，若<spanclass="math inline">\(f(x)&gt;=0.5\)</span>，预测标签<spanclass="math inline">\(y=1\)</span>，否则为<spanclass="math inline">\(0\)</span>）.</p><p>调和函数有许多有趣的解释，比如，将图看作一张电网，每一条边的电阻为<spanclass="math inline">\(1/w_{ij}\)</span>，有标签的点连接到<spanclass="math inline">\(1v\)</span>的电池，正标签顶点连接电池正极，零标签顶点连接电池负极，每个节点两端的电压就是调和函数值，如下图所示：</p><p><img src="/img/机器学习/期末复习/调和函数电网解释.png" /></p><p>也可以解释为图上的随机游走，想象一个粒子在顶点<spanclass="math inline">\(i\)</span>上，那么这个粒子会随机走到下一个顶点<spanclass="math inline">\(j\)</span>的概率是，随机游走以这种方式继续，直到粒子到达一个有标记的顶点。那么顶点<spanclass="math inline">\(i\)</span>的调和函数值<spanclass="math inline">\(f(x_i)\)</span>就是粒子从<spanclass="math inline">\(i\)</span>顶点出发最终走到一个正标签的顶点的概率，如下图所示：</p><p><img src="/img/机器学习/期末复习/调和函数随机游走解释.png" /></p><h5 id="调和函数的求解">调和函数的求解</h5><p>求解调和函数的过程是迭代的，初始的，我们设定：对于有标签顶点，<spanclass="math inline">\(f(x_i)=y_i\)</span>，对于无标签顶点，<spanclass="math inline">\(f\)</span>为任意值。每一轮迭代都用无标签顶点邻居的权重平均更新该无标签顶点的标签值：</p><p><spanclass="math display">\[f(\mathbf{x}_{i})={\frac{\sum\limits_{j=1}^{l+u}w_{ij}f(\mathbf{x}_{j})}{\sum\limits_{j=1}^{l+u}w_{i j}}}\]</span></p><h4 id="半监督支持向量机s3vmstsvms">半监督支持向量机(S3VMs/TSVMs)</h4><p>Semi-Supervised Support VectorMachines(S3VMs)最初被称为直推式支持向量机(Transductive Support VectorMachines(TSVMs))，因为它的理论是为了给无标记样本提供性能界限(理论保证)。但是由于学习到的函数<spanclass="math inline">\(f\)</span>应用到了无标记的样本中，所以被称为半监督支持向量机S3VMs。</p><p>对于S3VMs的直观理解是使得有标记和无标记样本处于间隔边界之外。但是，对于无标记样本，我们无法得知其是否处于处于正确的分类。这里给出一种方法将无标记样本用到学习中。</p><p>对于样本<span class="math inline">\(x\)</span>,它的预测值<spanclass="math inline">\(\hat{y} =sign(f(x))\)</span>，将该预测值假定为该样本的真实标签，则<spanclass="math inline">\(x\)</span>的hinge损失函数为</p><p><span class="math display">\[\begin{align}c(x, \hat{y}, f(x)) &amp; = \max(1-\hat{y}(w^Tx+b), 0) \\&amp; = \max(1-sign(w^Tx+b)(w^Tx+b), 0) \\&amp; = \max(1- |w^Tx+b|, 0)\end{align}\]</span></p><p>该损失函数与hinge损失的不同之处在于它不需要样本真实的标签，而是由<spanclass="math inline">\(f(x)\)</span>替代。该损失函数由上图中的右图所示。基于该损失函数的图形的形状，将其命名为hatloss。</p><p>虽然假设预测的分类结果都是正确的，但是基于hatloss，有些样本还是会存在惩罚。对于<span class="math inline">\(f(x) \le-1\)</span>或<span class="math inline">\(f(x) \ge1\)</span>的样本，它们处在间隔边界之外，远离决策边界，是不存在惩罚的。但是对于<spanclass="math inline">\(-1 \le f(x) \le 1\)</span>的样本，尤其是<spanclass="math inline">\(f(x) \approx0\)</span>的样本，它们在决策边界内，对于预测值<spanclass="math inline">\(f(x)\)</span>是存在不确定性的，所以存在惩罚。</p><p>将无标记样本<spanclass="math inline">\(\{x_j\}_{j=l+1}^{l+u}\)</span>的hatloss加到SVM的损失函数中，定义S3VMs的损失函数</p><p><span class="math display">\[\min_{w,b} \sum_{i=1}^{l} \max(1 -y_i(w^Tx_i+b), 0) + \lambda_1 ||w||^2  + \lambda_2\sum_{j=l+1}^{l+u}\max(1 - |w^Tx_i+b|, 0)\]</span></p><p>由上式可以看出，S3VMs更希望无标记数据能够在决策边界的外边，也就是决策边界更希望出现在数据的低密度区域。此时，可以将hatloss看做正则化项</p><p><span class="math display">\[\Omega(f) = \lambda_1 ||w||^2  +\lambda_2\sum_{j=l+1}^{l+u} \max(1 - |w^Tx_i+b|, 0)\]</span></p><p>注意，有些时候，无标记数据的预测值只存在一个类，也就是无标记数据都被预测成了同一个类。为了纠正这种不平衡性，一种直接的想法就是限制预测值中各个类的比例。假设无标记数据的预测值中各个类的比例与有标记数据中各个类的比例相同，即</p><p><span class="math display">\[\frac{1}{u}\sum_{j=l+1}^{l+u} \hat{y}_j= \frac{1}{l}\sum_{i=1}^{l} y_i\]</span></p><p>因为<span class="math inline">\(\hat{y}_j =sign(f(x_j))\)</span>不是一个连续函数，所以很难满足上述约束条件。因此放松该约束条件为</p><p><span class="math display">\[\frac{1}{u}\sum_{j=l+1}^{l+u} f(x_j) =\frac{1}{l}\sum_{i=1}^{l} y_i\]</span></p><p>该约束被称为类别的平衡约束。</p><p>所以，带类别平衡约束的S3VMs可以表示为</p><p><span class="math display">\[\begin{align}\min_{w,b}  &amp;  \sum_{i=1}^{l} \max(1 - y_i(w^Tx_i+b), 0) + \lambda_1||w||^2  + \lambda_2\sum_{j=l+1}^{l+u} \max(1 - |w^Tx_i+b|, 0)    \\s.t. &amp; \frac{1}{u}\sum_{j=l+1}^{l+u} f(x_j) =\frac{1}{l}\sum_{i=1}^{l} y_i  \tag{4}\end{align}\]</span></p><p>S3VMs的解是很难计算的，因为它的目标函数是<strong>非凸</strong>的。</p><p>上述S3VMs部分转载自<ahref="https://blog.csdn.net/extremebingo/article/details/79020907">Semi-SupervisedSupport Vector Machines(S3VMs)</a></p><h2 id="第十二章-强化学习">第十二章 强化学习</h2><p>强化学习（Reinforcement Learning, 简称RL）是机器学习的范式和方法论之一，用于描述和解决智能体（Agent）在与环境（Environment）的交互过程中通过学习策略（Policy）以达成奖励或回报（Reward）最大化或实现特定目标的问题。</p><p>强化学习主要涉及<strong>无模型（Model-Free）</strong>和<strong>有模型（Model-based）</strong>两大类算法。Model-Free算法可分为<strong>Q-Learning</strong>和<strong>基于策略优化（PolicyOptimization）</strong>两大类。Model-based算法可分为<strong>模型学习（Learnthe Model）</strong>和<strong>给定模型（Given theModel）</strong>两大类。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2下linux header的安装</title>
    <link href="/2023/05/09/WSL2%E4%B8%8Blinux_header%E5%AE%89%E8%A3%85/"/>
    <url>/2023/05/09/WSL2%E4%B8%8Blinux_header%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl2下linux-header的安装">WSL2下linux header的安装</h1><p>正常的linux发行版执行<code>linux-headers-$(uname -r)</code>命令就能装上内核头文件，但WSL2作为一个不一般的linux发行版，并没有直接给出安装包，要手动安装才能正常使用。</p><h2 id="安装步骤">安装步骤</h2><h3 id="确认kernel版本">确认Kernel版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -r<br></code></pre></td></tr></table></figure><h3 id="安装相应依赖">安装相应依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libelf-dev build-essential pkg-config<br>sudo apt install bison build-essential flex libssl-dev libelf-dev bc<br></code></pre></td></tr></table></figure><h3 id="下载相应版本源码">下载相应版本源码</h3><p>从<ahref="https://github.com/microsoft/WSL2-Linux-Kernel/releases">https://github.com/microsoft/WSL2-Linux-Kernel/releases</a>下载刚才得到对应版本的源码。</p><h3 id="解压刚下载的包并编译">解压刚下载的包并编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zvxf linux-msft-wsl-5.15.90.1.tar.gz<br>cd WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1<br>zcat /proc/config.gz &gt; .config<br>sudo make -j $(nproc) <br>sudo make -j $(nproc) modules_install<br></code></pre></td></tr></table></figure><p>安装过程中出现一下错误：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">BTF:</span> .tmp_vmlinux.btf: pahole (pahole) <span class="hljs-built_in">is</span> <span class="hljs-built_in">not</span> available<br>Failed <span class="hljs-keyword">to</span> generate BTF <span class="hljs-keyword">for</span> vmlinux<br><span class="hljs-keyword">Try</span> <span class="hljs-keyword">to</span> disable CONFIG_DEBUG_INFO_BTF<br><span class="hljs-symbol">make:</span> *** [Makefile:<span class="hljs-number">1218</span>: vmlinux] <span class="hljs-keyword">Error</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>原因是系统缺少dwarves软件包，故我们需要安装相应的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install dwarves<br></code></pre></td></tr></table></figure><h3 id="软链接">软链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s ~/Kernel/WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1 usr/src/linux-<br>headers-5.15.90.1-microsoft-standard-WSL2<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://blog.csdn.net/qq_53928256/article/details/129737658">WSL2下kernelheader的安装</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pair tuple 作为 unordered_map unordered_set 的键值</title>
    <link href="/2023/05/06/Cpp-pair%E6%88%96tuple%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%94%AE%E5%80%BC/"/>
    <url>/2023/05/06/Cpp-pair%E6%88%96tuple%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%94%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="pair-tuple-作为-unordered_map-unordered_set-的键值">pair tuple作为 unordered_map unordered_set 的键值</h1><p>C++STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。网上的大部分实现的hash函数虽然可以用，但是其效率其实相当糟糕，他会导致碰撞严重，从而性能低下。</p><p>这里贴出一个《C++ 标准库（第二版）》中作者给出的绝佳方案，“7.9.2Creating and Controlling UnorderedContainer”，把任意结构hash化的代码搬出来，模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-comment">// from boost (functional/hash):</span><br><span class="hljs-comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span><br><span class="hljs-function"></span>&#123;<br>    seed ^= std::<span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// auxiliary generic functions to create a hash value using a seed</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;<br>    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tuple版本的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> hash_tuple &#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TT&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(TT <span class="hljs-type">const</span> &amp;tt)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;TT&gt;()(tt); &#125;<br>&#125;;<br><br><span class="hljs-comment">// from boost (functional/hash):</span><br><span class="hljs-comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, T <span class="hljs-type">const</span> &amp;v)</span> </span>&#123;<br>    seed ^= hash_tuple::<span class="hljs-built_in">hash</span>&lt;T&gt;()(v) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// Recursive template code derived from Matthieu M.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>, <span class="hljs-type">size_t</span> Index = std::tuple_size&lt;Tuple&gt;::value - <span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">struct</span> HashValueImpl &#123;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()(<span class="hljs-type">size_t</span> &amp;seed, Tuple <span class="hljs-type">const</span> &amp;tuple) <span class="hljs-type">const</span> &#123;<br>        HashValueImpl&lt;Tuple, Index - <span class="hljs-number">1</span>&gt;&#123;&#125;(seed, tuple);<br>        <span class="hljs-built_in">hash_combine</span>(seed, std::<span class="hljs-built_in">get</span>&lt;Index&gt;(tuple));<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashValueImpl</span>&lt;Tuple, <span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, Tuple <span class="hljs-type">const</span> &amp;tuple)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">hash_combine</span>(seed, std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(tuple));<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... TT&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;std::tuple&lt;TT...&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::tuple&lt;TT...&gt; <span class="hljs-type">const</span> &amp;tt)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>        HashValueImpl&lt;std::tuple&lt;TT...&gt;&gt;&#123;&#125;(seed, tt);<br>        <span class="hljs-keyword">return</span> seed;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// auxiliary generic functions to create a hash value using a seed</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);<br>    &#125;<br>&#125;;<br>&#125; <span class="hljs-comment">// namespace hash_tuple</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-comment">// std::unordered_map&lt;std::pair&lt;ll, ll&gt;, ll, hash_tuple::pair_hash&gt;</span><br>    <span class="hljs-comment">// hashmapPair; std::unordered_set&lt;std::pair&lt;ll, ll&gt;, hash_tuple::pair_hash&gt;</span><br>    <span class="hljs-comment">// hashsetPair;</span><br><br>    std::unordered_map&lt;std::pair&lt;ll, ll&gt;, ll, hash_tuple::pair_hash&gt;<br>        hashmapPair;<br>    hashmapPair[&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;] = <span class="hljs-number">10</span>;<br>    std::unordered_set&lt;std::pair&lt;ll, ll&gt;, hash_tuple::pair_hash&gt; hashsetPair;<br>    hashsetPair.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-keyword">using</span> TI = std::tuple&lt;ll, ll, ll, ll&gt;;<br>    std::unordered_map&lt;TI, ll, hash_tuple::hash&lt;TI&gt;&gt; hashmapTuple;<br>    hashmapTuple[&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;] = <span class="hljs-number">10</span>;<br>    std::unordered_set&lt;TI, hash_tuple::hash&lt;TI&gt;&gt; hashsetTuple;<br>    hashsetTuple.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bellman-Ford单源最短路径算法</title>
    <link href="/2023/04/22/Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/22/Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="bellman-ford单源最短路径算法">Bellman-Ford单源最短路径算法</h1><p>Bellman-Ford算法是一种用于计算带权有向图中单源最短路径（SSSP：Single-Source ShortestPath）的算法。该算法由 Richard Bellman 和 Lester Ford 分别发表于 1958年和 1956 年，而实际上 Edward F. Moore 也在 1957年发布了相同的算法，因此，此算法也常被称为 Bellman-Ford-Moore 算法。</p><p>Bellman-Ford 算法和 Dijkstra算法同为解决单源最短路径的算法。对于带权有向图 <spanclass="math inline">\(G = (V, E)\)</span>，Dijkstra 算法要求图 G中边的权值均为非负，而 Bellman-Ford算法能适应一般的情况（即存在负权边的情况）。一个实现的很好的 Dijkstra算法比 Bellman-Ford 算法的运行时间要低。</p><p>Bellman-Ford 算法采用动态规划（DynamicProgramming）进行设计，实现的时间复杂度为<spanclass="math inline">\(O(V*E)\)</span>，其中 <spanclass="math inline">\(V\)</span> 为顶点数量，<spanclass="math inline">\(E\)</span> 为边的数量。Dijkstra算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为<span class="math inline">\(O(V^2)\)</span>，若基于 Fibonacci heap的最小优先队列实现版本则时间复杂度为 <span class="math inline">\(O(E +VlogV)\)</span>。</p><p>Bellman-Ford 算法描述：</p><ol type="1"><li>创建源顶点 v 到图中所有顶点的距离的集合distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为0；</li><li>计算最短路径，执行 V - 1 次遍历；<ul><li>对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v的距离 d，则更新终点 v 的距离值 d；</li></ul></li><li>检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v的距离，如果对于 v 存在更小的距离，则说明存在环；</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><span class="hljs-comment">//用来存边</span><br>&#123;<br>    <span class="hljs-type">int</span> from;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;Edge[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">(<span class="hljs-type">int</span> src, <span class="hljs-type">int</span> destination)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// n是节点个数</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>        dist[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i++)          <span class="hljs-comment">// 查找从源点开始，经过k个节点可以</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++)      <span class="hljs-comment">// m 条边</span><br>        &#123;<br>            <span class="hljs-type">int</span> from = Edge[j].from, to = Edge[j].to, cost = Edge[j].cost;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[i][to], dist[i - <span class="hljs-number">1</span>][from]);<br>        &#125;                          <br>    &#125;<br>    <span class="hljs-comment">// dist[k][n]是刚好经过k步到达节点n的最短路径，若为INT_MAX则表示不能到达</span><br>    <span class="hljs-type">int</span> res = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; ++i)<br>    &#123;<br>        res = <span class="hljs-built_in">min</span>(res, dist[k][destination]);       <span class="hljs-comment">// 查找k步内到达destination的最短路径</span><br>    &#125;<br>    <span class="hljs-comment">// 未考虑负环的存在</span><br>    <span class="hljs-keyword">return</span> res == INT_MAX ? <span class="hljs-number">-1</span> : res;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveCpp-41：了解隐式接口和编译期多态</title>
    <link href="/2023/04/20/EffectiveCpp-41/"/>
    <url>/2023/04/20/EffectiveCpp-41/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-item-41-了解隐式接口和编译期多态">Effective C++ Item41 了解隐式接口和编译期多态</h1><h2 id="显式接口和运行时多态">显式接口和运行时多态</h2><p>面向对象编程的世界围绕着显式接口和运行时多态。举个例子，考虑下面的类（无意义的类）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;                          <span class="hljs-comment">// Item 25</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>考虑下面的函数（同样没有意义）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    &#123;<br>        <span class="hljs-function">Widget <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>        temp.<span class="hljs-built_in">normalize</span>();<br>        temp.<span class="hljs-built_in">swap</span>(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>doProcessing</code>中的<code>w</code>，我们可以这样说：</p><ul><li>因为w被声明为<code>Widget</code>类型，<code>w</code>必须支持<code>Widget</code>接口。我们可以在源码中搜寻这个接口（例如，在<code>Widget</code>的头文件中），以便能够确切的知道它长成什么样子，所以我将其叫做一个显式的接口（explicitinterface）——可以显式的在源码中看到的接口。</li><li>因为<code>Widget</code>中的一些成员函数是虚的，<code>w</code>对这些函数的调用会展示出运行时多态：<code>w</code>具体调用哪个函数会根据运行时<code>w</code>的动态类型来决定。</li></ul><h2 id="隐式接口和编译期多态">隐式接口和编译期多态</h2><p>模板（template）和泛型编程（genericprogramming）的世界从根本上发生了变化。在这个世界中，显式接口和运行时多态继续存在，但是它们不再像以前那么重要。相反，隐式接口和编译时多态被挪到了前台。为了了解这是什么样子的，我们将<code>doProcessing</code>从函数转换为一个函数模板，看看会发生什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    &#123;<br>        <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>        temp.<span class="hljs-built_in">normalize</span>();<br>        temp.<span class="hljs-built_in">swap</span>(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们能对<code>doProcessing</code>中的<code>w</code>说些什么呢？</p><ul><li><code>w</code>必须支持的接口由模板中w需要执行的操作所决定。例如，<code>w</code>的类型<code>T</code>必须支持<code>size</code>，<code>normalize</code>和<code>swap</code>成员函数；拷贝构造函数（来创建<code>temp</code>）；和不等比较（同<code>someNastyWidget</code>进行比较）。我们很快就能发现这也不是很精确的，但是对于现在来说足够了。重要的是，这些表达式必须是<code>T</code>所支持的隐式接口，它们对于模板来说必须是有效的以便能够通过编译。</li><li>对于涉及到<code>w</code>的像<code>operator&gt;</code>和<code>operator!=</code>这样的函数调用，可能涉及到模板的实例化来让这些调用成功。这些实例化在编译期发生。因为用不同的模板参数实例化出来的函数模板会导致不同的函数被调用，这叫做“编译期多态”。</li></ul><h2 id="显示接口和隐式接口的区别">显示接口和隐式接口的区别</h2><h3 id="显示接口的特点">显示接口的特点</h3><p>即使你永远不使用模板，你也应该熟悉运行时多态和编译期多态的区别，因为这同编译期决定调用哪个重载函数以及运行期决定绑定哪个虚函数是类似的。隐式和显式接口的区别对于模板来说是新的概念，然而，一个显式的接口由函数签名组成，也即是函数名字，参数类型，返回值类型等等。<code>Widget</code>类的公共接口，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由一个构造函数，一个析构函数，和函数<code>size</code>，<code>normalize</code>和<code>swap</code>以及参数类型，返回值类型和这些函数的常量性组成。（同样包含编译器生成的拷贝构造函数和拷贝赋值运算符——看Item5）。它同样可以包含<code>typedef</code>和数据成员，如果你够大胆违反Item22的建议的话（将数据成员声明为<code>private</code>）。虽然在这个例子中没有这么做。</p><h3 id="隐式接口的特点">隐式接口的特点</h3><p>一个隐式的接口会有很大的不同。它不是基于函数签名。而是由有效表达式组成。再看一下<code>doProcessing</code>模板开始部分的条件表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T &amp;w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget)<br>    &#123;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>T（<code>w</code>的类型）的隐式接口看上去会有如下限制：</p><ul><li>它必须提供一个名字为<code>size</code>的成员函数并且返回一个整型值。</li><li>它必须支持<code>!=</code>操作符函数，能够对两个<code>T</code>类型的对象进行比较。（这里，我们假设<code>someNastWidget</code>的类型为<code>T</code>。）</li></ul><p>多亏了操作符重载，上面的两个限制都不需要满足。<code>T</code>必须支持一个<code>size</code>成员函数，值得提及的是这个函数可能继承自一个基类。但是这个成员函数没有必要返回一个整型值。甚至不需要返回一个数字类型值。如果这么说的话，它甚至不需要返回<code>operator&gt;</code>定义中所需要的值。他需要的是返回一个类型<code>X</code>的对象，于是可以在一个类型<code>X</code>对象和<code>int</code>（因为<code>10</code>是<code>int</code>型的）型对象上调用<code>operator&gt;</code>。但是<code>Operator&gt;</code>没有必要带一个类型<code>X</code>的参数，因为它也可以带一个类型<code>Y</code>的参数，只要<code>Y</code>可以隐式的转成<code>X</code>就可以了。</p><p>类似的，<code>T</code>也没有必要支持<code>operator!=</code>，因为<code>operator!=</code>带一个类型<code>X</code>的参数和一个类型<code>Y</code>的参数也能接受。只要<code>T</code>能转成<code>X</code>并且<code>someNastyWidget</code>的类型可以转换成<code>Y</code>，那么函数调用就是有效的。</p><p>大多数人当第一次开始考虑这种隐式转换就头疼，你不需要吃阿司匹林。隐式接口只是简单的由一些有效表达式组成。表达式本身看起来复杂，但是加在上面的限制一般来说是简单直接的。例如，考虑下面的条件表达式，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    ...<br></code></pre></td></tr></table></figure><p>很难说要对函数<code>size</code>，<code>operator&gt;</code>,<code>operator&amp;&amp;</code>或者<code>operator!=</code>做什么限制，但是很容易辨认出需要对整个表达式做出的限制。If声明的条件部分必须是一个boolean表达式，所以不管涉及到什么类型，也不管<code>w.size() &gt; 10 &amp;&amp; w != someNastyWidget</code>产生什么，它必须同<code>bool</code>是兼容的。这是模板<code>doProcessing</code>强加在类型参数<code>T</code>上的隐式接口的一部分。剩下的<code>doProcessing</code>所需要的接口就是对拷贝构造函数的调用，还有<code>swap</code>对于类型T来说必须是有效的。</p><p>强加在模板参数上的隐式接口同强加在类对象上的显示接口一样真实，两者都是在编译阶段检查。你不能同一个类提供的显示接口相矛盾的方式使用一个类对象（不会编译通过），你也不能随便在一个模板中尝试使用一个对象，除非这个对象支持模板需要的隐式转换（否则也不能通过编译）</p><h2 id="总结">总结</h2><ul><li>类和模板都支持接口和多态。</li><li>对于类来说，接口是显式的，以函数签名为中心。多态发生在运行时，通过虚函数来实现。</li><li>对于模板参数来说，接口是隐式的，基于有效表达式。模板多态通过模板实例化和函数重载来实现，它发生在编译期。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveCpp-21：必须返回对象时，不要返回reference</title>
    <link href="/2023/04/20/EffectiveCpp-21/"/>
    <url>/2023/04/20/EffectiveCpp-21/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-item-21必须返回对象时不要返回reference">EffectiveC++ Item 21：必须返回对象时，不要返回reference</h1><p>众所周知，C++中函数传参<em>pass-by-value</em>的效率是要低于<em>pass-by-reference</em>的，所以函数传参尽量以<strong><em>pass-by-reference-to-const</em>替换<em>pass-by-value</em></strong>,但是在函数返回的时候，返回一个<em>reference</em>并不一定是一件好事，因为这可能会导致我们<strong>传递一些<em>reference</em>并不存在的对象</strong>。</p><p>考虑一个用于表现有理数的class,内含一个函数用来计算两个有理数的乘积：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n, d;   <span class="hljs-comment">// 分子numerator 和 分母denominator</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类的<code>operator*</code>是以<em>by-value</em>返回其计算结果。如果现在你想节省掉该对象的构造和析构函数成本，而改用传递reference，那么请先回想一下，<strong>所谓reference只是一个名称，代表某个既有对象。任何时候看到一个reference对象声明式，都要立刻提醒自己，它的另一个名称是什么？因为它一定是某物的另一个名称</strong>。如果上面<code>operator*</code>返回reference，那么它一定指向一个既有的<code>Rational</code>对象,内含两个<code>Rational</code>对象的乘积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;   <span class="hljs-comment">// a = 1/2</span><br><span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;   <span class="hljs-comment">// b = 3/5</span><br>Rational c = a * b; <span class="hljs-comment">// c 应该是 3/10</span><br></code></pre></td></tr></table></figure><p>以上面的代码为例，期望一个值为<code>3/10</code>的Rational对象已经存在并不合理，如果<code>operator*</code>返回一个reference指向如此数值，它必须自己创建那个Rational对象。</p><p>创建新对象的方式有两种：在stack空间或者在heap空间创建。如果要定义一个local变量，就是在stack空间上创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这样做有一个很明显的漏洞：函数返回一个reference指向result，但result是一个local对象，而local对象在函数退出之前就已经销毁了。因此这个版本的<code>operator*</code>并未返回reference指向某个Rational，它返回的额reference指向一个已经被销毁的“从前的”Rational。而任何使用到这个返回值的操作都会引发“无定义行为”的报错。所以，<strong>任何函数都不要返回reference指向一个local对象</strong>。</p><p>那么考虑在heap内构建对象，并返回reference指向它，Heap-based对象由new创建，所以写一个heap-based<code>operator*</code>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational* <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>即便如此，我们还是要付出一个“构造函数”的代价，因为分配所得的内存将以一个适当的构造函数并完成初始化操作。但此外你又有了另一个问题：谁该对着这个new出来的对象实施delete？</p><p>即便调用者诚实诚谨，并出于良好意识，他们还是不太能在这样合情合理的用法下阻止内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Rational w, x, y, z;<br>w = x * y * z;      <span class="hljs-comment">// 与 operator* (operator* (x, y), z)相同</span><br></code></pre></td></tr></table></figure><p>这里同一个语句调用了两次<code>operator*</code>，也就需要使用两次new，对应的就需要两次delete。但是却没有合理的方法让<code>operator*</code>的使用者进行那些delete调用，因为没有合理的方法让他们取得<code>operator*</code>返回的reference背后隐藏的那个指针。这一定会导致内存泄露。</p><p>所以不管是on-the-stack或者是on-the-heap的做法，都会因为<code>operator*</code>的返回结果调用构造函数而出错或付出代价。而我们想返回引用的最初目的是<strong>避免构造函数的调用</strong>。</p><p>或许还有一种避免任何构造函数被调用的方法，那就是“让<code>operator*</code>返回的reference指向一个被定义于函数内部的staticRational对象”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-type">static</span> Rational result;<br><br>    result = ...;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这也是一个非常糟糕的设计，看下面这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs);<br><br>Rational a, b, c, d;<br><br><span class="hljs-keyword">if</span>((a * b) == (c * d))      <span class="hljs-comment">// 这个表达式一定为true</span><br>    ...<br><span class="hljs-keyword">else</span><br>    ...<br></code></pre></td></tr></table></figure><p>不管<code>a</code>,<code>b</code>,<code>c</code>,<code>d</code>的值是什么，表达式<code>(a * b) == (c * d)</code>一定为<code>true</code>。上述的<code>if</code>判别式可以写为下面的等价形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">operator</span>* (a, b), <span class="hljs-keyword">operator</span>* (c, d)))<br></code></pre></td></tr></table></figure><p>在<code>operator==</code>被调用之前，两个<code>operator*</code>已经被调用，每个都返回reference指向<code>operator*</code>内部定义的static对象。因此<code>operator==</code>比较的两个对象都是<code>operator*</code>内定义的static对象，所以判别式一定是<code>true</code>。</p><h2 id="总结">总结</h2><p>绝不要返回pointer或reference指向一个localstack对象，或返回有一个reference指向一个heap-allocated对象，或返回pointer或reference指向一个loaclstaic对象而又可能同时需要多个这样的对象。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划的几种实现方式</title>
    <link href="/2023/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划的几种实现方式">动态规划的几种实现方式</h1><p>动态规划又几种不同的实现方式，以leetcode第<ahref="https://leetcode.cn/problems/longest-common-subsequence/description/">1143</a>题为例：</p><p><img src="/img/算法/动态规划实现方式/leetcode1143.png" /></p><p>很明显这是一道动态规划的题，而动态规划有多种不同的实现方式，比如最常见的两种方式是迭代递推法和记忆化搜索法，这两种方法的主要区别在于，迭代递推法是自底向上递推，而记忆化搜索是自顶向下搜索，在搜索过程中保存计算结果，避免重复计算。</p><h2 id="递归搜索-保存计算结果-记忆化搜索">递归搜索 + 保存计算结果 =记忆化搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(text1, len1 - <span class="hljs-number">1</span>, text2, len2 - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;text1, <span class="hljs-type">int</span> end1, <span class="hljs-type">const</span> string &amp;text2, <span class="hljs-type">int</span> end2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(end1 == <span class="hljs-number">-1</span> || end2 == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(memo[end1][end2] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> memo[end1][end2];<br><br>        <span class="hljs-keyword">if</span>(text1[end1] == text2[end2])<br>            memo[end1][end2] = <span class="hljs-built_in">dp</span>(text1, end1 - <span class="hljs-number">1</span>, text2, end2 - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            memo[end1][end2] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dp</span>(text1, end1 - <span class="hljs-number">1</span>, text2, end2), <span class="hljs-built_in">dp</span>(text1, end1, text2, end2 - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> memo[end1][end2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代递推">迭代递推</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        memo[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = memo[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = memo[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = memo[i][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span>    <br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(memo[i][j + <span class="hljs-number">1</span>], memo[i + <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len1][len2];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="空间优化一个数组">空间优化（一个数组）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; ++i)<br>        &#123;   <br>            pre = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 每次++i之后j又从0开始，pre = memo[j] = 二维memo[i][0] = 0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; ++j)<br>            &#123;   <br>                <span class="hljs-type">int</span> tmp = memo[j + <span class="hljs-number">1</span>];      <span class="hljs-comment">// temp == 二维memo[i][j + 1]</span><br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    memo[j + <span class="hljs-number">1</span>] = pre + <span class="hljs-number">1</span>;   <span class="hljs-comment">// memo[j + 1] == 二维memo[i + 1][j + 1]</span><br>                <span class="hljs-keyword">else</span>    <br>                    memo[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(tmp, memo[j]);     <span class="hljs-comment">// memo[j + 1] == 二维memo[i + 1][j + 1]</span><br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len2];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树</title>
    <link href="/2023/04/08/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2023/04/08/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树">前缀树</h1><p>前缀树（又称为字典树或者称为字典映射树、查找树），是一种树形结构。前缀树的作用是：对于一组字符串，找到这组字符串的公共前缀，或者判断一个字符串是否是这组字符串中的某一个串的前缀。</p><p>前缀树的主要性质是：根节点不包含字符,每一个节点的所有子节点包含的字符都不相同。另外，从根节点到某一个节点，路径上经过的字符连接起来，即为该节点对应的字符串。</p><p>以下是前缀树的时间复杂度描述：</p><table><thead><tr class="header"><th>空间复杂度</th><th>时间复杂度</th><th>空间复杂度描述</th><th>时间复杂度描述</th></tr></thead><tbody><tr class="odd"><td>O(字符串总长度)</td><td>O(字符串总长度)</td><td>各字符串的字符数之和</td><td>查找、插入、删除的时间复杂度均为O(字符串长度)</td></tr></tbody></table><p>字典树的应用场景非常广泛，比如字符串的匹配 (Trie),排序、树形统计和信息检索 (eg. 索引, 关键词检索, 模糊查询) 等等。</p><p>前缀树的实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> is_end_;<br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>),  <span class="hljs-built_in">is_end_</span>(<span class="hljs-literal">false</span>)<br>    &#123;   <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span>    <span class="hljs-comment">// 输入字符串</span></span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<br>                node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br><br>            node = node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node -&gt; is_end_ = <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span>    <span class="hljs-comment">// 查找word是否在前缀树中插入过</span></span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-built_in">searchPrefix</span>(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nullptr</span> &amp;&amp; node -&gt; is_end_ == <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span>  <span class="hljs-comment">// 判断是否以word为前缀</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchPrefix</span>(prefix);<br>    &#125;<br><br>    <span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            node = node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈">单调栈</h1><p>单调栈是一种运用栈数据结构来解决一些特定问题的解题技巧。它主要用于解决需要快速寻找<strong>一个元素左(或右)边第一个比它大(或小)的元素</strong>的问题。</p><p>使用单调栈的基本思路是保持栈内的元素单调递增或单调递减，栈顶元素是当前栈内最大或最小的元素，同时记录下每个元素的相关信息，如坐标、面积、数量等，根据这些信息计算出所需的结果。</p><p>单调栈的实现主要有两种，第一种是从前往后遍历数组，第二种是从后往前遍历数组。</p><p>以寻找数组中当前元素右侧第一个比它大的数为例,第一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它大的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 当前元素大于栈顶元素时，当前元素就是栈顶元素右侧第一个大于栈顶的元素，并将栈顶出栈</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[s.<span class="hljs-built_in">top</span>()] &lt; nums[i])    <br>        &#123;<br>            res[s.<span class="hljs-built_in">top</span>()] = nums[i];<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它大的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)     <br>    &#123;<br>        <span class="hljs-comment">// 栈顶元素在当前元素右侧，当栈顶元素小于或等于当前元素的时候，将其出栈，继续寻找当前元素右侧第一个比它大的元素</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>() &lt;= nums[i])  <br>            s.<span class="hljs-built_in">pop</span>();<br>        res[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/04/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/04/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快排算法">快排算法</h1><p>快速排序是一种常见的排序算法，其核心思想是分治法。下面是快速排序的步骤：</p><ol type="1"><li>选取一个基准数（pivot）</li><li>将序列中比基准数大的元素放在基准数的右边，比基准数小的元素放在基准数的左边。</li><li>递归地对基准数左右两边的序列进行排序，直到序列长度为1或0。</li></ol><p>快速排序中最重要的就是第2步，也就是<code>partation</code>阶段。快速排序有很多不同的实现方式，每次选择最右侧的数作为<code>pivot</code>进行<code>partation</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> pvoit = nums[right];     <span class="hljs-comment">// 选择最右侧的数作为pivot</span><br>   <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>   &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过上面的代码我们可以看出，每次<code>partation</code>必然会将一个数放到最终的位置，然后再递归处理<code>pivot</code>左右两侧的区间，那么最好的情况就是每次<code>partation</code>都将数组两等分，而最坏的情况是每次<code>partation</code>划分出的区间都在<code>pivot</code>的一侧。</p><p>那么如何避免最坏情况的发生呢？这里可以每次选择一个随机数作为<code>pivot</code>然后进行划分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>   <span class="hljs-built_in">swap</span>(nums[p], nums[right]);      <span class="hljs-comment">// 将随机选出的数与最右侧数交换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">partation</span>(nums, left, right); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pvoit = nums[right];<br>  <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>  &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 快速排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomQuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(left &gt;= right)<br>      <span class="hljs-keyword">return</span> ;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">randomPartation</span>(nums, left, right);<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, left, p - <span class="hljs-number">1</span>);<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, p + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>   <span class="hljs-built_in">swap</span>(nums[p], nums[right]);      <span class="hljs-comment">// 将随机选出的数与最右侧数交换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">partation</span>(nums, left, right); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pvoit = nums[right];<br>  <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>  &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2023/04/04/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2023/04/04/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法">二分法</h1><p>二分法作为一种常见的查找算法，其实不单单可以只寻找某一个数。</p><h2 id="最基本的二分查找">最基本的二分查找</h2><p>搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索一个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 定义target在左闭右开的区间里，即：[left, right)</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;   <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>            right = mid;    <span class="hljs-comment">// target 在左区间，在[left, mid)中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在[mid + 1, right)中</span><br>        <span class="hljs-keyword">else</span>                <span class="hljs-comment">// nums[mid] == target</span><br>            <span class="hljs-keyword">return</span> mid;     <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;              <span class="hljs-comment">// 未找到目标值</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="搜索左侧边界">搜索左侧边界</h2><p><img src="/img/算法/二分法/二分法拓展.png" /></p><p>如上图所示，查找数组中最左侧大于或等于3的数也可以使用二分法。首先对整个数组二分，看中间的数是否满足大于或等于3，若满足继续在左侧二分，否则在右半侧二分，一直到结束，得到的所有满足条件的最小下标就是求得的结果。</p><p><strong>这个问题与普通二分法查找的区别在于</strong>：二分法是使用二分找个一个满足条件的数之后就结果查找，但是这里需要一直二分到最后，然后在所有满足条件的数中比较。</p><p><strong>搜索左侧边界</strong>的二分搜索算法的具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索左侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <br>            right = mid;    <span class="hljs-comment">// 当找到 target 时，收缩右侧边界</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) <br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>            right = mid;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == nums.<span class="hljs-built_in">size</span>())     <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;    <span class="hljs-comment">// nums[left] != target说明没有搜索到，返回-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意在搜索左侧边界的时候并不是一旦发现<code>nums[mid] == target</code>就直接返回，因为要寻找最左侧满足条件的下标。</p><p>简化后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 优化版搜索左侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) <br>            right = mid;  <br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == nums.<span class="hljs-built_in">size</span>())     <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;    <span class="hljs-comment">// nums[left] != target说明没有搜索到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索右侧边界">搜索右侧边界</h2><p>搜索右侧边界其实和搜索左侧边界同理，不同的地方在于，搜索左侧边界时出现<code>nums[mid] == target</code>时<code>right</code>需要向左收缩，而在搜索右侧边界的时候出现<code>nums[mid] == target</code>时是<code>left</code>需要向右收缩。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索右侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            left = mid + <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>; <span class="hljs-comment">// nums[left - 1] != target说明没有搜索到，返回-1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>nums[mid] == target</code>和<code>nums[mid] &lt; target</code>的情况合并之后的简化版为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索右侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;&gt;= target)<br>            left = mid + <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">else</span><br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>; <span class="hljs-comment">// nums[left - 1] != target说明没有搜索到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：不管是搜索单个值还是左右侧边界，此模板中<code>left</code>和<code>right</code>收缩的模式是一样的，即<code>left</code>向右收缩时总是<code>left = mid + 1</code>,而<code>right</code>收缩时总是<code>right = mid</code>。为什么<code>left</code> 的更新必须是 <code>left = mid + 1</code>，当然是为了把<code>nums[mid]</code>排除出搜索区间。记住这一点便很容易记下三种不同的模板。</p><p>另外，搜索左右侧边界时的返回也不一样，搜索左侧边界的时候返回是<code>left</code>，而在搜索右侧边界的时候返回是<code>left - 1</code>，因为我们对<code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code>了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p><h2 id="寻找局部最小值">寻找局部最小值</h2><p>在一个无序数组arr中，相邻的数都不相同，那么如何在这个数组arr中找到一个局部最小值？这里的极小值定义是比左右两侧都小的数，在数组最左侧则只需要满足比它右侧的数小，在数组最右侧的数只需要满足比它左侧的数小即可。</p><p>首先判断<code>arr[0]</code>和<code>arr[n - 1]</code>是否是极小值，若右极小值则直接返回。若都不是极小值那么取最中间的数<code>arr[m]</code>,判断<code>arr[m]</code>是否为局部最小值，若为局部最小值则直接返回。</p><p><img src="/img/算法/二分法/局部最小值-2.png" /></p><p>若不为极小值那么它要么比它左侧的数大，要么比它右侧的数大。假设它比左侧的数大，那么就在左半边进行二分，如此一来，就存在了二分的点，直至找到一个局部最小值为止。</p><p><img src="/img/算法/二分法/局部最小值-1.png" /></p><p><strong>这里可以看出来二分法不只是能用在有序数组，在无序的情况下满足特定条件也可以用二分。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集union-find">并查集（UNION-FIND）</h1><p>并查集（Union-FindSet）是一种用来管理和解决集合分组问题的数据结构，它支持两个操作：</p><ul><li><strong>查找（Find）</strong>：查找一个元素属于哪个集合，即找出其所在的连通块。</li><li><strong>合并（Union）</strong>：将两个不相交的集合合并成一个新的集合。</li></ul><h2 id="并查集模板">并查集模板</h2><p><strong>查找（Find）</strong>：这里用树来表示是否属于同一个数组，使用<strong>查找（Find）</strong>操作返回的是该节点所在树的根节点，如果一个节点<code>x</code>所在树的根节点就是<code>x</code>自己，那么<code>findParent(x)</code>返回的结果就是<code>x</code>。</p><p><strong>合并（Union）</strong>：合并两个节点<code>x</code>和<code>y</code>之前需要先判断<code>x</code>和<code>y</code>是否属于一个集合，如果已经在一个集合里，那么直接返回，否则将<code>x</code>和<code>y</code>的集合合并（在此实现为将<code>x</code>和<code>y</code>的树合并为一个树）。</p><p>合并两个集合最原始的方式就是将一个节点的根节点接到另一个节点的根节点上：</p><p><img src="/img/算法/并查集/原始合并.jpg" /></p><p>其实就是一个树结构，每个节点的祖先节点是其所在的集合，那么就会有一个问题，在最坏的情况下，树会退化为一个链表，这时候的<strong>查找</strong>时间复杂度为<code>O(N)</code>，上面的<code>findParent</code>函数可以在查找过程中将树结构进行压缩，压缩之后的结构如下图所示，每个节点的父亲节点为所在树的根节点：</p><p><img src="/img/算法/并查集/路径压缩.jpg" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x != parent[x])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(parent[x]);<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>其查找过程便是压缩过程，见下面的动图：</p><p><img src="/img/算法/并查集/路径压缩动图.gif" /></p><p>并查集的模板如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UF</span>(<span class="hljs-type">int</span> n)   <span class="hljs-comment">// 构造函数，输入n为节点个数</span><br>    &#123;<br>        parent = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);    <span class="hljs-comment">// n + 1是可以parent[i]为第i个节点的祖先，视情况而定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;      <span class="hljs-comment">// 初始时每个节点都是单独的结合</span><br>        count = n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x != parent[x])      <span class="hljs-comment">// 路径压缩</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(parent[x]);<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> parent_x = <span class="hljs-built_in">findParent</span>(x);<br>        <span class="hljs-type">int</span> parent_y = <span class="hljs-built_in">findParent</span>(y);<br><br>        <span class="hljs-keyword">if</span>(parent_x == parent_y)  <span class="hljs-comment">// x，y已经属于同一个集合，直接返回     </span><br>            <span class="hljs-keyword">return</span> ;<br>        --count;<br>        parent[parent_y] = parent_x;   <span class="hljs-comment">// 将两个集合合并</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>  <span class="hljs-comment">// 判断两个节点是否属于一个集合</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(x) == <span class="hljs-built_in">findParent</span>(y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;     <span class="hljs-comment">// parent[i]为第i个节点的祖先</span><br>    <span class="hljs-type">int</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考：本文中的图引用自<ahref="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/bing-cha-j-323f3/">labuladong的算法小抄</a>,模板实现是根据其模板修改而来。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法</title>
    <link href="/2023/04/03/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/03/Dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图算法">图算法</h1><h2 id="dijkstra算法">Dijkstra算法</h2><p>输入是一个图<code>graph</code>,返回是一个最短路径权重的数组。</p><p>思路：将<code>dis</code>的初始值出<code>start</code>之外设置为<code>INT_MAX</code>，<code>start</code>设置为<code>0</code>，然后将<code>start</code>加入到优先级队列中，依次将优先级队列中到<code>start</code>距离最小的节点<code>cur</code>弹出，看是否可以更新<code>cur</code>相邻节点<code>next_node</code>的dis值，如果出现下面<code>next_cost &lt; dis[edge.first]</code>的情况，那么就表示<code>next_node</code>的值可以被更新，且新的最短距离是经过<code>cur</code>的，同时将<code>next_node</code>加入到优先级队列中。重复这个过程，最终得到的<code>dis</code>数组就是<code>start</code>到其他节点的距离。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph为输入的图，graph[i]为节点i的邻接表，pair.first为相邻的节点编号,pair.second为该边的权重</span><br><span class="hljs-comment">// start为起点</span><br><span class="hljs-comment">// n为图的节点个数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; &amp;graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;   <span class="hljs-comment">// 距离起点的距离数组,初始设置为INT_MAX,方便以后遍历到之后更新</span><br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p2) &#123;<span class="hljs-keyword">return</span> p1.second &lt; p2.second;&#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);  <span class="hljs-comment">// 使用优先级队列，pair.first为节点编号,pair.second到该节点的最小距离</span><br>    dis[start] = <span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(start, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [id, cost] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cost &gt; dis[id])  <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : graph[id])<br>        &#123;<br>            <span class="hljs-type">int</span> next_cost = edge.second + dis[id];<br>            <span class="hljs-keyword">if</span>(next_cost &lt; dis[edge.first])     <span class="hljs-comment">// 如果下一个节点cost小于dis存储的值，更新dis并将其加入到优先级队列中</span><br>            &#123;<br>                dis[edge.first] = next_cost;<br>                pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, next_cost));   <span class="hljs-comment">// 该节点的cost更新之后，其相邻节点的cost可能也会因此更新</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dis;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="kruskal-最小生成树算法">Kruskal 最小生成树算法</h2><p>思想：从图<code>graph</code>中每次选择一条最短的边<code>e</code>，若加入<code>e</code>之后不构成环，将<code>e</code>加入到最小生成树的结果中；重复上述步骤，一直到有<code>n - 1</code>条边为止（<code>n</code>为图的节点个数，因为<code>n</code>个节点不存在环的连通图中必定有<code>n - 1</code>条边）。</p><p><strong>Kruskal算法步骤</strong>：</p><ol type="1"><li>将所有边按照权重从小到大排序</li><li>初始化一个集合，并且把所有节点分别加入集合，每个节点都是单独一个集合。</li><li>遍历排序后的边，将它们加入树中(如果边的两个节点不在同一个集合中)。</li><li>最后得到的tree就是最小生成树。</li></ol><p>这里实现KRUSKAL使用了并查集，并查集的概念与代码见<ahref="https://gstarmin.github.io/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph[i] = [x, y, cost]，表示节点x和y之间有一条权值为cost的边</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(graph.<span class="hljs-built_in">begin</span>(), graph.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; v2) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> v1[<span class="hljs-number">2</span>] &lt; v2[<span class="hljs-number">2</span>];&#125;);<br>    <span class="hljs-function">UF <span class="hljs-title">my_uf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;      <span class="hljs-comment">// 定义并查集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : graph)<br>    &#123;<br>        <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], cost = edge[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(my_uf.<span class="hljs-built_in">isConnected</span>(x, y))    <span class="hljs-comment">// 若x，y已经连通那么不能把这条边加入到结果中</span><br>            <span class="hljs-keyword">continue</span>;<br>        ++count;<br>        my_uf.<span class="hljs-built_in">unionNode</span>(x, y);<br>        res.<span class="hljs-built_in">emplace_back</span>(edge);     <span class="hljs-comment">// 将这条边添加到结果中，可以根据实际情况执行不同操作</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> count == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="prim-最下生成树算法">Prim 最下生成树算法</h2><p><code>Prim</code>算法与<code>Kruskal</code>的区别在于，<code>Kruskal</code>算法是每次选择一条最短的且不构成环的边，而<code>Prim</code>算法是使用<code>BFS</code>算法思想和<code>visited</code>数组避免成环，保证选出来的边一定是一棵树。</p><p><code>Prim</code>算法步骤：</p><ol type="1"><li>从任意一个节点开始，将该节点加入到已访问节点集合中。</li><li>在未访问节点中找到与已访问节点集合中节点权值最小的边（也就是跨越已访问节点集合和未访问节点中某个节点的边），将该边和对应的节点加入到已访问节点集合中。</li><li>重复第二步操作，直到所有节点都被加入到已访问节点集合中为止。</li></ol><p><code>Prim</code>算法也是一种贪心算法,它的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>，其中<code>n</code>为节点个数。在实际应用中，<code>Prim</code>算法通常用于处理<strong>稠密图</strong>中的最小生成树问题。</p><p>这里<code>Prim</code>算法的实现使用了优先级队列<code>priority_queue</code>,实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph为邻接表graph[i] = [node, cost]，start为Prim算法起始节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(graph[start].<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    visited[start] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p2) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> p1.second &gt; p2.second;&#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);      <span class="hljs-comment">// visited数组判断当前节点是否访问过</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;edge : graph[start])<br>    &#123;<br>        pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, edge.second));<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> cur = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(visited[cur.first])<br>            <span class="hljs-keyword">continue</span>;<br>        visited[cur.first] = <span class="hljs-literal">true</span>;<br>        res += cur.second;      <span class="hljs-comment">// 这里是计算最小生成树边的权值之和，可以根据实际情况调整</span><br>        ++count;<br>        <span class="hljs-keyword">if</span>(count == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;edge : graph[cur.first])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[edge.first])        <span class="hljs-comment">// 将当前节点的邻接节点加入优先级队列</span><br>                pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, edge.second));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓扑排序算法">拓扑排序算法</h2><p>Leetcode上的 <ahref="https://leetcode.cn/problems/course-schedule-ii/description/">210.课程表 II</a> 便是一道典型的拓扑排序题，问题如下：</p><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code>到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code>，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程<code>ai</code> 前 必须 先选修 <code>bi</code> 。</p><p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code>，我们用一个匹配来表示：<code>[0,1]</code> 。返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回<strong>任意一种</strong>就可以了。如果不可能完成所有课程，返回<strong>一个空数组</strong>。</p><p>拓扑排序分为<code>DFS</code>版本和<code>BFS</code>版本。</p><h3 id="dfs版本">DFS版本</h3><p><strong>步骤</strong>：</p><ol type="1"><li>首先，需要先建立一个 DAG（有向无环图），包含顶点和边。</li><li>初始化入度为 0 的顶点队列，将初始顶点加入队列中。</li><li>从队列头部开始处理。</li><li>遍历该顶点的出边，将出边对应的顶点的入度减 1。</li><li>如果入度为 0，则将该顶点加入队列末尾。</li><li>重复步骤 <code>3-5</code> 直到队列为空。</li></ol><p><code>DFS</code>版本实现类似二叉树的前序遍历或者树的<code>DFS</code>遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; visited;    <span class="hljs-comment">// 用于判断节点是否已经访问</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inedges;    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// DFS</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        inedges = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">buildGraph</span>(numCourses, prerequisites, graph, inedges);  <span class="hljs-comment">// 建图</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i)     <span class="hljs-comment">// 确保在图不是连通的情况下也能正确得到拓扑排序</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(graph, path, i, numCourses);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses ? path : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> numCourses)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[s])<br>            <span class="hljs-keyword">return</span> ;<br>        <br>        visited[s] = <span class="hljs-number">1</span>;<br>        path.<span class="hljs-built_in">emplace_back</span>(s);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses)<br>        &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;i : graph[s])<br>        &#123;<br>            --inedges[i];<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(graph, path, i, numCourses);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;prerequisites, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inedges)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : prerequisites)<br>        &#123;<br>            <span class="hljs-type">int</span> from = p[<span class="hljs-number">1</span>], to = p[<span class="hljs-number">0</span>];<br>            graph[from].<span class="hljs-built_in">emplace_back</span>(to);<br>            ++inedges[to];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="bfs版本">BFS版本</h3><p><code>BFS</code>版本和<code>DFS</code>版本的思路其实是一样的，<code>BFS</code>和<code>DFS</code>的区别类似树的遍历，无非是在遍历节点的时候以不同的顺序访问其邻接节点。<code>DFS</code>的实现用到了递归而<code>BFS</code>的实现用到了队列，类似二叉树的层序遍历或树的<code>BFS</code>遍历。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// BFS</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 判断节点是否已经访问</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inedges</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 入度数组</span><br>        <span class="hljs-built_in">buildGraph</span>(numCourses, prerequisites, graph, inedges);      <span class="hljs-comment">// 建图</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">emplace</span>(i);<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            visited[cur] = <span class="hljs-number">1</span>;<br>            path.<span class="hljs-built_in">emplace_back</span>(cur);     <span class="hljs-comment">// 将当前节点加入到拓扑排序结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[cur])<br>            &#123;<br>                --inedges[i];<br>                <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)     <span class="hljs-comment">// 若相邻节点的入度为0，加入到队列中</span><br>                    q.<span class="hljs-built_in">emplace</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses? path : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;prerequisites, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inedges)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : prerequisites)<br>        &#123;<br>            <span class="hljs-type">int</span> from = p[<span class="hljs-number">1</span>], to = p[<span class="hljs-number">0</span>];<br>            graph[from].<span class="hljs-built_in">emplace_back</span>(to);<br>            ++inedges[to];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 右值引用</title>
    <link href="/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="c-右值引用">C++ 右值引用</h1><p>C++11中一个最主要的特性是可以移动而非拷贝对象的能力。我们很多情况下都会发生对象拷贝，而在其中某些情况下，对象拷贝之后就立即背销毁了。这种情况下，移动而非拷贝对象会大幅度提升性能。</p><p>在C++11之前，没有直接的方法移动对象。因此，计时不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如string），进行不必要的拷贝代价非常高。</p><p>为了支持移动操作，C++11中引入了一种新的引用类型————<strong>右值引用(rvaluereference)</strong>。所谓右值引用是就是必须绑定到右值的引用。<strong>我们通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用</strong>。比如我们将要看到的，右值引用有一个重要的性质————<strong>只能绑定到一个将要销毁的对象上</strong>。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。</p><p>如我们所知，对于常规引用（为了与右值引用区分开，我们可以称之为<strong>左值引用</strong>），我们不能将其绑定到要求转换的表达式、字面常量、或者是返回右值的表达式。右值引用有完全相反的特性：我们可以将一个右值绑定到一个左值上，但不能将一个右值引用直接绑定到一个左值上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;         <span class="hljs-comment">// 正确：r引用i</span><br><span class="hljs-type">int</span> &amp;&amp;rr = i;       <span class="hljs-comment">// 错误:不能将一个右值引用绑定到一个左值上</span><br><span class="hljs-type">int</span> &amp;r2 = i * <span class="hljs-number">42</span>;   <span class="hljs-comment">// 错误：i * 42是一个右值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i * <span class="hljs-number">42</span>;     <span class="hljs-comment">// 正确:我们可以将一个const的引用绑定到一个右值上</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = i * <span class="hljs-number">42</span>;         <span class="hljs-comment">// 正确:将rr2绑定到乘法结果上</span><br></code></pre></td></tr></table></figure><p>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。</p><p>返回非引用类型的函数，连同算数、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个右值引用绑定到这类表达式上，但我们可以将一个const的左值引用或一个右值引用绑定到这类表达式上。</p><h2 id="左值持久右值短暂">左值持久；右值短暂</h2><p>考察左值和右值表达式的列表，两者相互区别之处就很明显了：<strong>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong>。</p><p>由于右值引用只能绑定到临时对象，我们得知</p><ul><li>所引用的对象将要别销毁</li><li>该对象没有其他用户</li></ul><p>这两个特性意味着：使用右值引用的diamagnetic可以自由地接管所引用对象的资源.</p><h2 id="变量是左值">变量是左值</h2><p>变量可以看作只有一个变量没有运算符的表达式,虽然我们很少这样看待变量.类似其他任何表达式,变量表达式也有左值/右值属性.变量表达式都是左值,带来的结果就是,<strong>我们不能将一个右值引用绑定一个右值引用类型的变量上</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 正确:字面常量是右值</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = rr1;    <span class="hljs-comment">// 错误:表达式rr1是左值!</span><br></code></pre></td></tr></table></figure><p>其实有了右值表示临时对象这一观察结果,变量是左值这一特性并不令人惊讶.毕竟,变量是持久的,直至离开作用域的时候才被销毁.</p><h2 id="stdmove函数">std::move函数</h2><p>虽然不能将一个右值引用直接绑定到一个左值上,但是我们可以显式地将一个左值转换为对应的右值引用.我们还可以通过调用一个名为<code>move</code>的函数来获得绑定到左值上的右值引用.<strong><code>move</code>函数可以返回给定对象的右值引用</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1);     <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p><code>move</code>调用告诉编译器:我们有一个左值,但我们希望像一个右值一样处理它.调用<code>move</code>就意味着承诺:除了对<code>rr1</code>赋值或销毁它外,我们将不再使用它.在调用<code>move</code>之后,我们不能对移后源对象的值做任何假设.(我们可以销毁一个移后源对象,也可以赋予它新值,但不能使用一个移后源对象的值)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ explicit用法</title>
    <link href="/2023/03/13/Cpp-explicit%E7%94%A8%E6%B3%95/"/>
    <url>/2023/03/13/Cpp-explicit%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="explicit关键字">explicit关键字</h1><h2 id="explicit-作用">explicit 作用</h2><p>在 C++中, explicit 关键字用来修饰类的构造函数, 被修饰的构造函数的类,不能发生相应的隐式类型转换, 只能以显式的方式进行类型转换.</p><p>explicit 使用注意事项:</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上；</li><li>explicit 关键字作用于单个参数的构造函数 (多个参数也适用,但必须只有一个参数需要赋值, 其他的参数要有默认值).</li><li>在 C++ 中, explicit 关键字用来修饰类的构造函数,被修饰的构造函数的类, 不能发生相应的隐式类型转换.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();    <span class="hljs-comment">// default构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>)</span></span>;   <span class="hljs-comment">// default构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;  <span class="hljs-comment">// 不是default构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述的classesB和C的构造函数都被声明为explicit，这可以组织它们被用来执行隐式类型转换，但它们仍然可以被用来进行显式类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(B bObject)</span></span>;    <span class="hljs-comment">// 函数，接受一个为B的对象</span><br><br>B bObj1；         <span class="hljs-comment">//一个类型为B的对象</span><br><span class="hljs-built_in">doSomething</span>(bObj1);     <span class="hljs-comment">// 没问题，传递一个B给doSomething对象</span><br><span class="hljs-function">B <span class="hljs-title">bOBj2</span><span class="hljs-params">(<span class="hljs-number">28</span>)</span></span>;            <span class="hljs-comment">// 没问题，根据int 28建立一个B</span><br><br><span class="hljs-built_in">doSomething</span>(<span class="hljs-number">28</span>);        <span class="hljs-comment">// 错误！doSomething应该接受一个B，不是一个int，而int至B没有隐式转化</span><br><br><span class="hljs-built_in">doSomething</span>(<span class="hljs-built_in">B</span>(<span class="hljs-number">28</span>));     <span class="hljs-comment">// 没问题，使用B构造函数将int显式转换为一个B以促成此调用</span><br></code></pre></td></tr></table></figure><p>被声明为explicit二点构造函数通常比其non-explicit兄弟更受欢迎，因为它们禁止编译器执行非预期（往往不被预期）的类型转换。除非我有一个好的理由允许构造函数被用于隐式转换，否则我会把它声明为explicit。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL优先级队列</title>
    <link href="/2023/03/09/CppSTL%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/09/CppSTL%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="cstl优先级队列">C++STL优先级队列</h1><p>优先级队列是特殊的队列，它与queue的区别在于它可以定义队列中数据的优先级，让优先级高的排在队列前面，可以优先出队，它本质上是由堆实现的。</p><h2 id="定义">定义</h2><p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><ul><li>Type:数据类型</li><li>Container：容器类型(Container必须是用数组实现的容器，比如vector,deque等等，但不能用list。STL里面默认用的是vector)</li><li>Functional:比较的方式，当需要用自定义的数据类型时才需要传入第三个参数，使用基本数据类型时，只需要传入数据类型，其默认是<strong>大根堆</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//升序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<br></code></pre></td></tr></table></figure><p><code>greater</code>和<code>less</code>是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）。</p><h2 id="基本操作">基本操作</h2><p><code>priority_queue</code>的基本操作：</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// pair 先比较first，first相等然后再比较second</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; a;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)</span></span>;<br>    a.<span class="hljs-built_in">push</span>(d);<br>    a.<span class="hljs-built_in">push</span>(c);<br>    a.<span class="hljs-built_in">push</span>(b);<br>    <span class="hljs-keyword">while</span> (!a.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; a.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        a.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="自定义类型">自定义类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp1</span> <span class="hljs-comment">//运算符重载&lt;</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">tmp1</span>(<span class="hljs-type">int</span> a) &#123;x = a;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> tmp1&amp; a) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x &lt; a.x;     <span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-comment">// return x &gt; a.x   // 小根堆</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp2</span> <span class="hljs-comment">//重写仿函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(tmp1 a, tmp1 b)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.x &lt; b.x;    <span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-comment">// return a.x &gt; b.x  // 小根堆</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    priority_queue&lt;tmp1&gt; d;<br>    d.<span class="hljs-built_in">push</span>(b);<br>    d.<span class="hljs-built_in">push</span>(c);<br>    d.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span> (!d.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; d.<span class="hljs-built_in">top</span>().x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        d.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span>&lt;&lt; endl;<br>    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;<br>    f.<span class="hljs-built_in">push</span>(c);<br>    f.<span class="hljs-built_in">push</span>(b);<br>    f.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span> (!f.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; f.<span class="hljs-built_in">top</span>().x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        f.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">3<br>2<br><span class="hljs-section">1</span><br><span class="hljs-section">----</span><br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p>参考:<ahref="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列(priority_queue)用法详解</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算的妙用</title>
    <link href="/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算的妙用">位运算的妙用</h1><h2 id="异或运算实现变量交换">异或运算实现变量交换</h2><p>异或运算可以理解为<strong>无进位相加</strong>，异或运算的性质如下：</p><ul><li>0 ^ N = N</li><li>N ^ N = N</li><li>a ^ b = b ^ a (交换律)</li><li>a ^ b ^ c = a ^ (b ^ c) （结合律）</li></ul><p>异或运算的妙用：交换两个数的值不使用额外变量： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">17</span>, b = <span class="hljs-number">23</span>;<br><span class="hljs-comment">// 交换a，b的值</span><br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure></p><p>但是<strong>需要注意的是，可以这样使用的前提是a和b指向的内存是不同的，但是两个数的值可以相同。</strong>比如在一个数组中对nums[i]和nums[j]进行交换，要使用这种方法，必须要保证i和j相同，否则nums[i]位置上的数会被抹成0。所以一般情况下不推荐这种用法。</p><h2 id="异或运算查找出现奇数次的数">异或运算查找出现奇数次的数</h2><h3 id="只有一种数出现奇数次">只有一种数出现奇数次</h3><p>一个数组中只有一种数出现奇数次，其余的数都出现偶数次，那么如果寻找这个出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>就是出现奇数次的数。因为异或运算满足交换律，出现偶数次的数相互异或的结果为<spanclass="math inline">\(0\)</span>，出现奇数次的数相互异或的结果为这个数的值，所以总的结果就是这个出现奇数次的数。</p><h3 id="有两种数出现奇数次">有两种数出现奇数次</h3><p>一个数组中有两种数出现奇数次，其余的数都出现偶数次，那么如果寻找出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>为a ^b。因为a和b是不同的数，所以必然有a ^ b <spanclass="math inline">\(\ne\)</span> 0,也就是a ^b的二进制至少有一位是1，那么假设a ^ b的二进制第8位为1，让<spanclass="math inline">\(eor\)</span>与数组中第8位为1的数异或，得到的<spanclass="math inline">\(eor^{&#39;}\)</span>就是a或b，再用<spanclass="math inline">\(eor^{&#39;}\)</span>与<spanclass="math inline">\(eor\)</span>异或得到的就是另外一个数。</p><p><img src="/img/算法/异或/查找数组中出现奇数次个数的数图解.png" /></p><p>因为a和b在第8为上的值一定是不一样的，所以肯定在不同的区域里，这样去用<spanclass="math inline">\(eor\)</span>异或第8位为1的数得到的就是a，b其中之一，出现偶数次的数不影响异或的结果。</p><p>那么就有一个问题，<strong>选哪一位的1？如何提取出这一位上的1？</strong>这里选择提取出a^ b最右边一位的1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>) <span class="hljs-comment">// 提取出eor最右侧的1</span><br></code></pre></td></tr></table></figure><p>将<spanclass="math inline">\(eor\)</span>用二进制表示就可以更直观的看出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">             eor = <span class="hljs-number">11001110</span>    <br>        ~eor + <span class="hljs-number">1</span> = <span class="hljs-number">00110010</span><br>eor &amp; (~eor + <span class="hljs-number">1</span>) = <span class="hljs-number">00000010</span> <span class="hljs-comment">// 提取出来最右侧的1</span><br></code></pre></td></tr></table></figure><h2 id="运算消去二进制最低位的1">&amp;运算消去二进制最低位的1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &amp; (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>因为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">    n = <span class="hljs-number">11001110</span><br>n - <span class="hljs-number">1</span> = <span class="hljs-number">11001101</span><br></code></pre></td></tr></table></figure><p>可以看到<code>n</code>的二进制中的高位的<spanclass="math inline">\(1\)</span>其实是不受<strong>减一</strong>操作的影响的，所以<code>n &amp; (n - 1)</code>就可以在不影响其他二进制位的情况下消去其最低位的<spanclass="math inline">\(1\)</span>。</p><p>那么就可以根据这个特性<strong>计算k的二进制1的个数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br>    n &amp;= n - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 每次消去二进制中最低位的1</span><br>    count++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求两个数的均值">求两个数的均值</h2><p>一般的写法是 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>但是这样并不是无懈可击的，可能会出现一个问题，当<code>low</code>和<code>high</code>都很大的时候<code>low + high</code>可能会溢出，这样结果就变成一个负数。更加好的写法是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><code>low</code>和<code>high</code>都没有溢出，那么<code>high - low</code>也不会溢出，这样结果就不会溢出。</p><p>更加简化的写法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++deque和queue</title>
    <link href="/2023/03/07/Cpp-deque%E5%92%8Cqueue/"/>
    <url>/2023/03/07/Cpp-deque%E5%92%8Cqueue/</url>
    
    <content type="html"><![CDATA[<h1 id="c-deque和queue">C++ deque和queue</h1><p>deque是双端队列，queue可以访问两端但是只能修改队头，而deque可以访问两端并且可以在队首和队尾删除和插入元素。</p><p>queue操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q； <span class="hljs-comment">//创建一个int型空队列q</span><br><br>q.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 将变量s从队尾入队</span><br>q.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">// 将队头元素弹出</span><br>q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 只返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();   <span class="hljs-comment">// 只返回队尾元素</span><br>q.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 返回队列中元素个数</span><br></code></pre></td></tr></table></figure><p>deque操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; dq； <span class="hljs-comment">// 创建一个数双端队列dq</span><br><br>dq.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>dq.<span class="hljs-built_in">push_front</span>(s); <span class="hljs-comment">//  将s从队头入队</span><br>dq.<span class="hljs-built_in">push_back</span>(s);    <span class="hljs-comment">// 将s从队尾入队，和普通队列方式一样</span><br>dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 只返回队头元素</span><br>dq.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 只返回队尾元素</span><br>dq.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 将队头元素弹出</span><br>dq.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 将队尾元素弹出</span><br>dq.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 将队列清空</span><br></code></pre></td></tr></table></figure><p>由于deque两端都可以压入，只用个push的话到底是用哪端压入呢？所以有了<code>push_back()</code>和<code>push_front()</code>,同样，<code>pop()</code>是弹出，所以有<code>pop_back()</code>和<code>pop_front()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++函数后冒号的含义</title>
    <link href="/2023/03/06/Cpp-%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2023/03/06/Cpp-%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="c函数后冒号的含义">C++函数后冒号的含义</h1><h2 id="c-函数后面加一个冒号的含义">c++ 函数后面加一个冒号的含义</h2><p>冒号后面跟的是赋值，这种写法是C++的特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb ):<span class="hljs-built_in">a</span>(aa),<span class="hljs-built_in">b</span>(bb)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb )<br>&#123;<br>    a=aa;<br>    b=bb;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c构造函数后面的冒号">C++构造函数后面的冒号</h2><p>在C++类的构造函数中经常会看到如下格式的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><p>上述语句中单冒号(:)的作用是表示后面是初始化列表，一般有三种使用场景。</p><h3 id="对父类进行初始化">对父类进行初始化</h3><p>调用格式为“子类构造函数 :父类构造函数”，如下，其中QMainWindow是MyWindow的父类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><h3 id="对类成员进行初始化">对类成员进行初始化</h3><p>调用格式为“构造函数 :A(初始值),B(初始值),C(初始值)……”，如下，其中A、B、C分别是类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">rectangle</span> <span class="hljs-comment">//头文件中类定义</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">rectangle</span>( <span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length);<br><span class="hljs-keyword">private</span>:<br>    CPoint m_point;<br>    <span class="hljs-type">int</span> m_Width;<br>    <span class="hljs-type">int</span> m_Length;<br>&#125;;<br> <br>rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length) : <span class="hljs-built_in">m_point</span>(pointX,pointY),<span class="hljs-built_in">m_Width</span>(Width),<span class="hljs-built_in">m_Length</span>(Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，上面构造函数的实现与下面的写法等价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    m_point.X = pointX;<br>    m_point.Y = pointY;<br>    m_Width   = Width;<br>    m_Length  = Length;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><h3id="对类的const成员变量进行初始化">对类的const成员变量进行初始化</h3><p>由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值。</p><h3 id="总结">总结</h3><p>对于第2、3种方式的应用场景，有以下两点说明：</p><ol type="1"><li><p>构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关。</p></li><li><p>相对于在构造函数中赋值，初始化列表执行效率更高。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常量、#define、const和constexpr</title>
    <link href="/2023/03/06/Cpp%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/"/>
    <url>/2023/03/06/Cpp%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/</url>
    
    <content type="html"><![CDATA[<h1id="c常量defineconst和constexpr">C++常量、#define、const和constexpr</h1><h2 id="常量">常量</h2><p>常量是固定值，在程序执行期间不会改变，可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值，常量的值在定义后不能进行修改；</p><p>可以使用枚举、#define、const和constexpr等方法定义常量.</p><h2 id="define">#define</h2><p>#define是预处理阶段进行处理，是一种宏定义，所以定义常量的宏是没有类型的，是在编译前即预编译阶段进行字符替换，并且由于是在预处理阶段替换所以不会有类型安全检查，系统也不会为它分配内存，存储在程序的代码段空间，实际就是给出了立即数，在运行过程中，常量在内存中会有若干个拷贝；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br></code></pre></td></tr></table></figure><p>如果只想常量宏只在某段代码起作用，则使用#undef这个常量宏，如果再用到了这个常量宏，编译器就会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r; <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span></span><br><br>S = Pi + <span class="hljs-number">1</span>; <span class="hljs-comment">//编译器报错</span><br></code></pre></td></tr></table></figure><h2 id="const">const</h2><p>const是一种Runtime，const常量会在内存中分配，可以是堆中也可以是栈中。以后在定义的常量调用时，只是使用对应的内存地址，不再开辟新的空间，在内存中只有一个拷贝，因此const相比#define，可以避免反复分配内存，节省空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> doulbe Pi=<span class="hljs-number">3.14159</span>;<br>S = Pi * r * r;<br></code></pre></td></tr></table></figure><h3 id="const修饰指针">const修饰指针</h3><p>const位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* test_ptr = &amp;test;<span class="hljs-comment">//禁止修改test_ptr指向的值, 可以修改test_ptr的值</span><br><span class="hljs-type">int</span> test2 = <span class="hljs-number">2</span>;<br>test_ptr = &amp;test2;<span class="hljs-comment">//指向另一个变量</span><br></code></pre></td></tr></table></figure><p>const位于<code>*</code>的右侧，const就是修饰指针本身，即指针本身是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> test_ptr = &amp;test;<br><br>*test_ptr = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 可以修改test_ptr指向的值, 禁止修改test_ptr的值</span><br></code></pre></td></tr></table></figure><h3 id="const修饰函数">const修饰函数</h3><p>在类中将成员函数修饰为const表明在该函数体内，不能修改对象的数据成员而且不能调用非const函数，由于非const函数可能修改数据成员，const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//fun1函数需要设置i的值，所以不能声明为const</span></span><br><span class="hljs-function">    </span>&#123;<br>i = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-comment">//fun2函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。</span></span><br><span class="hljs-function">    </span>&#123; <br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数参数">const修饰函数参数</h3><p>const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用;const指针可以接收非const和const指针，而非const指针只能接收非const指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> param)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数返回值">const修饰函数返回值</h3><p>const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员变量">const修饰成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> Test:: <span class="hljs-built_in">fun1</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">//i++; i不能修改</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="constexpr">constexpr</h2><p>constexpr与const一样，它可以应用于变量，不同的是可以应用于函数和类构造函数,constexpr指示值或返回值是常量，并且在可能的情况下，在编译时计算</p><h3 id="修饰变量">修饰变量</h3><p>const和constexpr之间的主要区别在于，const的初始化可以在到运行时，而constexpr编译时必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> :<br>        n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-built_in">exp</span>(x * x, n / <span class="hljs-number">2</span>) :<br>        <span class="hljs-built_in">exp</span>(x * x, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰构造函数">修饰构造函数</h3><p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy,<span class="hljs-type">int</span> zz)</span></span><br><span class="hljs-function">        :x(xx),y(yy),z(zz)&#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        :Base(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">constexpr</span> Base pt = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure><p>转载自<a href="https://zhuanlan.zhihu.com/p/473260243">C/C++常量、#define、const和constexpr</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛法:埃氏筛和欧拉筛</title>
    <link href="/2023/03/06/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
    <url>/2023/03/06/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="质数数筛法">质数数筛法</h1><p>本文主要介绍埃氏筛法和欧拉筛法。</p><h2 id="判断单个数是不是质数">判断单个数是不是质数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(num==<span class="hljs-number">2</span> || num==<span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(num%<span class="hljs-number">6</span> != <span class="hljs-number">1</span> &amp;&amp; num%<span class="hljs-number">6</span> != <span class="hljs-number">5</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp = <span class="hljs-built_in">sqrt</span>(num);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">5</span>; i &lt;= tmp; i+=<span class="hljs-number">6</span>)<br><span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span> || num%(i+<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是当有很多个数需要判断的时候，每次都输入num判断是否是质数就很耗时了，这样提前将一个范围的质数算出来可以更节省时间，所以就用到了质数筛法。</p><h2 id="暴力筛法">暴力筛法</h2><p>学习埃氏筛之前，我们先看一下暴力筛法，即对每个数都用试除法判断其是不是质数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">// 初始化为0， 0表示质数，1表示合数</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i / j; j++)&#123;<span class="hljs-comment">//试除法</span><br><span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<br>st[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 合数，标记为1 </span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="埃式筛">埃式筛</h2><p>暴力筛法无疑是最慢的，我们看一下如何加快，换一种思路：一个质数的倍数一定是合数，所以，假设<spanclass="math inline">\(P\)</span>是质数，我们可以筛掉区间<spanclass="math inline">\([1,1e7]\)</span>中所有<spanclass="math inline">\(P\)</span>的倍数。 先看个例子，对于数列1~11：</p><p><img src="/img/算法/素数筛法/数1-11.png" /></p><p>先筛去2的倍数：</p><p><img src="/img/算法/素数筛法/筛去2倍数.png" /></p><p>再筛去3倍数：</p><p><img src="/img/算法/素数筛法/筛去3倍数.png" /></p><p>再筛去5倍数：</p><p><img src="/img/算法/素数筛法/筛去5倍数.png" /></p><p>至此，1~11内的所有合数都被筛完了， 2 3 5 7 11是数列中的质数。</p><p>为什么这样能筛去所有的合数呢，因为<strong>一个合数一定能被分解为几个质数的幂的乘积</strong>，并且这个数的质因子一定是小于它本身的，所以当我们从小到大将每个质数的倍数都筛去的话，当遍历到一个合数时，它一定已经被它的质因子给筛去了。</p><p>埃氏筛代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的时间复杂度为<span class="math inline">\(O(n\log{\log_2 n})\)</span></p><p>我们还可以对其进行优化：</p><ul><li>我们会先筛<spanclass="math inline">\(2\)</span>的所有倍数，然后筛<spanclass="math inline">\(3\)</span>的所有倍数，但筛除<spanclass="math inline">\(3\)</span>的倍数时，我们还是从<spanclass="math inline">\(3\)</span>的<spanclass="math inline">\(2\)</span>倍开始筛，其实<spanclass="math inline">\(3 * 2\)</span> ，已经被<spanclass="math inline">\(2 * 3\)</span>时筛过了。又比如说筛5的倍数时，我们从5的2倍开始筛，但是<spanclass="math inline">\(5 * 2\)</span>会先被<span class="math inline">\(2* 5\)</span>筛去， <span class="math inline">\(5 * 3\)</span>会先被<spanclass="math inline">\(3 * 5\)</span>会筛去，<spanclass="math inline">\(5 * 4\)</span>会先被<span class="math inline">\(2* 10\)</span>筛去，所以我们每一次只需要从<spanclass="math inline">\(i*i\)</span>开始筛，因为<spanclass="math inline">\((2，3,…,i - 1)\)</span>倍已经被筛过了。</li><li>另外，判断一个数 <spanclass="math inline">\(n\)</span>是不是质数，我们只判断<spanclass="math inline">\([2, \sqrt{n}]\)</span>内有没有它的因子。在筛合数的时候，我们也可以这样做，因为一个合数的最小质因子一定小于等于<span class="math inline">\(\sqrt{n}\)</span>。所以对于区间<spanclass="math inline">\([1, 1e7]\)</span>，最大的合数是 <spanclass="math inline">\(1e7\)</span>, 它的最小质因子一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>，区间内其他的合数的最小质因子也一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>的，所以只需要用<spanclass="math inline">\([1, \sqrt{1e7}]\)</span>中的质数就可以筛去 <spanclass="math inline">\([1, 1e7]\)</span>中所有的合数。</li></ul><p>优化后的埃式筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意循环条件i &lt;= n / i，为什么不直接成sqrt(n)?</span><br>    <span class="hljs-comment">// 写成这样的形式当i &gt;= sqrt(n) 时候依然可以停止循环，而且加减法需要几个时钟周期，乘法需要10几个时钟周期，除法需要2、3十个时钟周期，开根号需要8000个时钟周期，这样可以节省时间</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的时间复杂度可以近似看成<spanclass="math inline">\(O(n)\)</span>了。</p><h2 id="欧拉筛">欧拉筛</h2><p>优化后的埃式筛时间复杂度可以<strong>近似</strong>看成<spanclass="math inline">\(O(n)\)</span>，但是欧拉筛可以比它更快，欧拉筛的时间复杂度是<spanclass="math inline">\(O(n)\)</span>，又被称为线性筛。</p><p>埃氏筛是筛去每个质数的倍数，但难免，会有合数会被其不同的质因子多次重复筛去。这就造成了时间浪费。</p><p>比如说： <span class="math inline">\(120 = 2^3 * 3 * 5\)</span>,<spanclass="math inline">\(120\)</span> 会被<spanclass="math inline">\(2\)</span>筛去一次， <spanclass="math inline">\(3\)</span>筛去一次， <spanclass="math inline">\(5\)</span>筛去一次。 多做了两次不必要的操作。</p><p>那么我们如何确保120只被2筛掉呢？在埃氏筛中我们用了一个循环来筛除一个质数的所有倍数，即对于p来说，筛除数列：<span class="math inline">\(2 * p , 3 * p, ... ,k*p\)</span>。另外，我们是从小到大枚举区间中的每个数的，数列是：<spanclass="math inline">\(2,3,4,...,n\)</span>。</p><p>对比两个数列：</p><p><span class="math display">\[\begin{align}    &amp;2 * p , 3 * p, ... , k*p \\    &amp;2,3,4,...,n\end{align}\]</span></p><p>会发现，第二个数列是第一个数列的系数,所以，我们不需要用一个for循环去筛除一个质数的所有倍数，我们将所有质数存储到<code>primes[]</code>中，然后枚举到第i个数时，就筛去所有的<code>primes[j] * i</code>。这样就在每一次遍历中，正好筛除了所有已知素数的<code>i</code>倍。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-comment">//isPrime[i] == 1表示：i是素数</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-comment">//Prime存质数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛到n</span></span><br><span class="hljs-function"></span>&#123;<br>    Prime.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    isPrime.<span class="hljs-built_in">resize</span>(N, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//以“每个数都是素数”为初始状态，逐个删去</span><br>    isPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//1不是素数</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(isPrime[i])<span class="hljs-comment">//没筛掉 </span><br>        &#123;<br>            Prime.<span class="hljs-built_in">push_back</span>(i);<br>            ++cnt;<br>        &#125;<br>            <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n<span class="hljs-comment">/*不超上限*/</span>; j++) <br>        &#123;<br>            <span class="hljs-comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span><br>            <span class="hljs-comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span><br>            isPrime[i * Prime[j]] = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">if</span>(i % Prime[j] == <span class="hljs-number">0</span>)<span class="hljs-comment">//i中也含有Prime[j]这个因子</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//重要步骤。见原理</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意内层循环有一个<code>break</code>的条件<code>i % primes[j] == 0</code>,为什么呢？</p><p><strong>因为</strong>:</p><p>由</p><p><span class="math display">\[i \quad \% \quad primes[j] ==0\]</span></p><p>可得</p><p><span class="math display">\[primes[j] * k = i \tag{1}\]</span></p><p>设</p><p><span class="math display">\[primes[j] * k = X\tag{2}\]</span></p><p>将<span class="math inline">\((1)\)</span>代入到<spanclass="math inline">\((2)\)</span>中可得</p><p><span class="math display">\[primes[j+1] * primes[j] * k =X\]</span></p><p>因为<span class="math inline">\(primes[j+1] &gt;primes[j]\)</span>,所以<span class="math inline">\(primes[j+1] * k &gt;i\)</span>。</p><p>设</p><p><span class="math display">\[primes[j] * k = i^\prime\]</span></p><p>则</p><p><span class="math display">\[primes[j] * i^\prime =X\tag{3}\]</span></p><p>所以如果用<span class="math inline">\((2)\)</span>式筛去<spanclass="math inline">\(X\)</span>的话，当<spanclass="math inline">\(i\)</span>等于<spanclass="math inline">\(i&#39;\)</span>时，<spanclass="math inline">\(X\)</span>又会被<spanclass="math inline">\((3)\)</span>式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的<spanclass="math inline">\(i\)</span>, 所以不能提前筛。</p><p>比如说 <span class="math inline">\(1，2，3，4，5，6，7，8，9，10，11， 12\)</span>,当<code>i == 4</code> 时,<code>primes = &#123;2, 3&#125;</code>,此时 <code>i % 2 == 0</code>,如果不结束内层循环的话， <spanclass="math inline">\(12\)</span>会被<spanclass="math inline">\(3*4\)</span>筛掉， 当<code>i == 6</code>时，<spanclass="math inline">\(12\)</span>又会被<spanclass="math inline">\(2*6\)</span>筛掉。</p><p><strong>欧拉筛的核心思想就是确保每个合数只被最小质因数筛掉。或者说是被合数的最大因子筛掉。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++左值和右值</title>
    <link href="/2023/03/04/Cpp-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2023/03/04/Cpp-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="理解-cc-中的左值和右值">理解 C/C++ 中的左值和右值</h1><p>我们在 C/C++ 编程中并不会经常用到 <em>左值 (lvalue)</em> 和 <em>右值(rvalue)</em>两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用<code>gcc</code> 编译以下代码时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会得到：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">test</span>.c: <span class="hljs-keyword">In</span> function &#x27;main&#x27;:<br><span class="hljs-keyword">test</span>.c:8:5: <span class="hljs-keyword">error</span>: lvalue required <span class="hljs-keyword">as</span> left operand of assignment<br></code></pre></td></tr></table></figure><p>没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值(lvalue)。另一个例子是当你用 <code>g++</code> 编译以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在错误信息是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">testcpp.cpp: <span class="hljs-keyword">In</span> <span class="hljs-keyword">function</span> &#x27;<span class="hljs-title function_">int</span>&amp; <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#x27;:<br>testcpp.cpp:<span class="hljs-number">5</span>:<span class="hljs-number">12</span>: error: invalid initialization <span class="hljs-keyword">of</span> non-<span class="hljs-keyword">const</span> <span class="hljs-keyword">reference</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&amp;&#x27;</span> <span class="hljs-keyword">from</span> an rvalue <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，左值和 右值 到底是什么意思呢？我这篇文章将会详细解释。</p><h2 id="简单的定义">简单的定义</h2><p>这里我故意给出了一个 <strong>左值</strong> 和 <strong>右值</strong>的简化版定义。文章剩下的部分还会进行详细解释。</p><p><strong>左值 (lvalue, locator value)</strong>表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是左值 就是 右值 。那么，右值是一个<strong>不</strong>表示内存中某个可识别位置的对象的表达式。</p><h2 id="举例">举例</h2><p>上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var;<br>var = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。<code>var</code>是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">4</span> = var;       <span class="hljs-comment">// 错误！</span><br>(var + <span class="hljs-number">1</span>) = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误！</span><br></code></pre></td></tr></table></figure><p>常量 <code>4</code> 和表达式 <code>var + 1</code>都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p><p>那么，我们就能理解第一个代码片段中的错误信息的含义了。<code>foo</code>返回的是一个临时的值。它是一个右值，赋值给它是错误的。因此当编译器看到<code>foo() = 2</code> 时，会报错——赋值语句的左边应当是一个左值。</p><p>然而，给函数返回的结果赋值，不一定总是错误的操作。例如，C++的引用让我们可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> globalvar = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> globalvar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>foo</code>返回一个引用。<strong>引用一个左值</strong>，因此可以赋值给它。实际上，C++中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符<code>[]</code>，来实现一些查找访问的操作，如 <code>std::map</code>中的方括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; mymap;<br>mymap[<span class="hljs-number">10</span>] = <span class="hljs-number">5.6</span>;<br></code></pre></td></tr></table></figure><p>之所以能赋值给 <code>mymap[10]</code>，是因为<code>std::map::operator[]</code> 的重载返回的是一个可赋值的引用。</p><h2 id="可修改的左值">可修改的左值</h2><p>左值一开始在 C 中定义为“可以出现在赋值操作左边的值”。然而，当 ISO C加入 <code>const</code> 关键字后，这个定义便不再成立。毕竟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// &#x27;a&#x27; 是左值</span><br>a = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 但不可以赋值给它！</span><br></code></pre></td></tr></table></figure><p>于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为<strong>可修改左值 (modifiable lvalues)</strong>。C99标准定义可修改左值为：</p><blockquote><p>可修改左值是特殊的左值，不含有数组类型、不完整类型、const修饰的类型。如果它是 <code>struct</code> 或<code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p></blockquote><h2 id="左值与右值间的转换">左值与右值间的转换</h2><p>通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符<code>'+'</code> 就需要两个右值参数，并返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;     <span class="hljs-comment">// a 是左值</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;     <span class="hljs-comment">// b 是左值</span><br><span class="hljs-type">int</span> c = a + b; <span class="hljs-comment">// + 需要右值，所以 a 和 b 被转换成右值</span><br>               <span class="hljs-comment">// + 返回右值</span><br></code></pre></td></tr></table></figure><p>在例子中，<code>a</code> 和 <code>b</code>都是左值。因此，在第三行中，它们经历了隐式的<strong>左值到右值转换</strong>。除了数组、函数、不完整类型的所有左值都可以转换为右值。</p><p>那右值能否转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注1：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】</p><p>不过，右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符<code>'*'</code>需要一个右值参数，但返回一个左值结果。考虑这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;arr[<span class="hljs-number">0</span>];<br>*(p + <span class="hljs-number">1</span>) = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span><br></code></pre></td></tr></table></figure><p>相反地，一元取地址操作符 <code>'&amp;'</code>需要一个左值参数，返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* bad_addr = &amp;(var + <span class="hljs-number">1</span>); <span class="hljs-comment">// 错误: 一元 &#x27;&amp;&#x27; 操作符需要左值参数</span><br><span class="hljs-type">int</span>* addr = &amp;var;           <span class="hljs-comment">// 正确: var 是左值</span><br>&amp;var = <span class="hljs-number">40</span>;                  <span class="hljs-comment">// 错误: 赋值操作的左操作数需要是左值</span><br></code></pre></td></tr></table></figure><p>在 C++ 中 <code>'&amp;'</code>符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string&amp; sref = std::<span class="hljs-built_in">string</span>();  <span class="hljs-comment">// 错误: 非常量的引用 &#x27;std::string&amp;&#x27; 错误地使用右值 &#x27;std::string` 初始化</span><br></code></pre></td></tr></table></figure><p><strong>常量的</strong>左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得C++中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p><h2 id="cv-限定的右值">CV 限定的右值</h2><p>如果我们仔细阅读 C++ 标准中关于左值到右值的转换的部分【注2：在新的C++11 标准草稿的第 4.1 节】，我们会发现：</p><blockquote><p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T不是类类型【译注：类类型即 C++中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定CV 的版本 (cv-unqualified version ofT)。其他情况下，转换后的右值类型就是 T 本身。</p></blockquote><p>什么叫做 “未限定 CV” (cv-unqualified) 呢？ <strong>CV 限定符</strong>这个术语指的是 <em>const</em> 和 <em>volatile</em> 两个类型限定符。C++标准的 3.9.3 节写到：</p><blockquote><p>每个类型都有三个对应的 CV-限定类型版本： <em>const 限定</em> 、<em>volatile 限定</em> 和 <em>const-volatile 限定</em> 版本。有或无 CV限定的不同版本的类型是不同的类型，但写法和赋值需求都是相同的。</p></blockquote><p>那么，这些又和右值有什么关系呢？在 C 中，只有左值有 CV限定的类型，而右值从来没有。而在 C++ 中，类右值可以有 CV限定的类型，但内置类型 (如 <code>int</code>)则没有。考虑下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo() const\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">cbar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bar</span>().<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// calls foo</span><br>    <span class="hljs-built_in">cbar</span>().<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// calls foo const</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code>中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是<code>const A</code>，这和 <code>A</code>是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code>的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p><h2 id="c11-的右值引用">C++11 的右值引用</h2><p>C++11 标准中引入的最强有力的特性就是右值引用，以及相关的 <em>移动语义(move semantics)</em>概念。这篇简短的文章没法完全讨论这个特性【注3：搜索 “rvalue references”可以找到很多相关的资料，几个个人认为有用的资料：<ahref="http://www.artima.com/cppsource/rvalue.html">这一篇</a>， <ahref="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x">这一篇</a>，特别是<ahref="http://thbecker.net/articles/rvalue_references/section_01.html">这一篇</a>】，但我想给出一个简单的例子。实际上，对左值和右值的理解可以帮助我们理解一些非平凡的语言概念。</p><p>这篇文章的大部分内容都在解释：左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p><p>假设我们要实现一个“整数的vector”，一些相关的函数可能是这样定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Intvec</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Intvec</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        : m_size(num), m_data(new int[m_size])</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;constructor&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Intvec</span>()<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;destructor&quot;</span>);<br>        <span class="hljs-keyword">if</span> (m_data) &#123;<br>            <span class="hljs-keyword">delete</span>[] m_data;<br>            m_data = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">Intvec</span>(<span class="hljs-type">const</span> Intvec&amp; other)<br>        : <span class="hljs-built_in">m_size</span>(other.m_size), <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size])<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy constructor&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_size; ++i)<br>            m_data[i] = other.m_data[i];<br>    &#125;<br><br>    Intvec&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Intvec&amp; other)<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy assignment operator&quot;</span>);<br>        <span class="hljs-function">Intvec <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>        std::<span class="hljs-built_in">swap</span>(m_size, tmp.m_size);<br>        std::<span class="hljs-built_in">swap</span>(m_data, tmp.m_data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> m_size;<br>    <span class="hljs-type">int</span>* m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样，我们定义了基本的构造器、析构器、拷贝构造器 (copy constructor)和拷贝赋值操作符 (copy assignment operator)【注4：拷贝赋值操作符的实现是在考虑异常安全角度的规范写法。结合使用拷贝构造器和不会抛出异常的<code>std::swap</code>，可以保证在异常发生时不会出现未初始化的内存】。它们都有一个logging 函数，让我们能知道是否调用了它们。</p><p>运行一个将 <code>v1</code> 的内容拷贝到 <code>v2</code> 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Intvec <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>Intvec v2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;assigning lvalue...\n&quot;</span>;<br>v2 = v1;<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning lvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>运行输出的结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">assigning lvalue...<br>[<span class="hljs-number">0</span>x28fef8] <span class="hljs-keyword">copy</span> assignment <span class="hljs-keyword">operator</span><br>[<span class="hljs-number">0</span>x28fec8] <span class="hljs-keyword">copy</span> <span class="hljs-keyword">constructor</span><br>[0<span class="hljs-title function_">x28fec8</span>] <span class="hljs-title function_">destructor</span><br><span class="hljs-title function_">ended</span> <span class="hljs-title function_">assigning</span> <span class="hljs-title function_">lvalue</span>...<br></code></pre></td></tr></table></figure><p>这是正常的结果，准确展示了 <code>operator=</code>的内部过程。但假设我们要将一个右值赋值给 <code>v2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;assigning rvalue...\n&quot;</span>;<br>v2 = <span class="hljs-built_in">Intvec</span>(<span class="hljs-number">33</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning rvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>虽然这里的例子中是赋值一个新创建的vector，但它可以代表更一般的情况——创建了一个临时的右值，然后赋值给<code>v2</code> （例如当一个函数返回 vector的情况）。我们会得到这样的输入：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>这看起来就要很多步骤了。特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。然而，在拷贝赋值操作符中，也创建和销毁了<em>另一个</em> 临时的对象。这完全是多余的没有意义的工作。</p><p>不过现在你不需要多一个临时对象了。C++11引入了右值引用，让我们可以实现“移动语义” (movesemantics)，特别是可以实现“移动赋值操作符” (move assignment operator)【注5：文章中一直将 <code>operator=</code> 叫做 “拷贝赋值操作符” (copyassignment operator)。在 C++11中，区分这两个概念是很重要的】。我们可以为 <code>Intvec</code>加上另一个 <code>operator=</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">Intvec&amp; <span class="hljs-keyword">operator</span>=(Intvec&amp;&amp; other)<br>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;move assignment operator&quot;</span>);<br>    std::<span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>    std::<span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>符号 <code>&amp;&amp;</code> 代表了新的 <strong>右值引用 (rvaluereference)</strong>。顾名思义，右值引用可以让我们创建对右值的引用。而且在调用结束后，右值引用就会被销毁。我们可以利用这个特性将右值的内部内容“偷”过来——因为我们不再需要使用这个右值对象了！这样得到的输出是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">move</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>由于将一个右值赋值给了 <code>v2</code>，移动赋值操作符被调用。虽然<code>Intvec(33)</code>仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。优雅。</p><p>再提醒一遍，这个例子只展示了移动语义和右值引用的冰山一角。你可以猜到，这实际上是一个复杂的话题，要考虑很多特殊情况和陷阱。我是想展示一个C++中左值右值区别的一个很有趣的应用。编译器显然知道哪里是个右值，会在编译时选择调用合适的构造器。</p><h2 id="总结">总结</h2><p>即使不考虑左值和右值的问题，你也可以写很多 C++代码，然后把这些问题看作编译器某些错误警告中奇怪的行话。然而，这篇文章想表明，对这个问题有一些领悟的话，会使你能更深入地理解一些C++ 代码，也更能弄懂一些 C++ 规范和语言专家的讨论。</p><p>另外，在新的 C++ 规范中，因为 C++11引入了右值引用和移动语义，这个话题变得更重要了。要想真正理解这个语言的一些新特性，透彻地理解左值和右值就变得重要了。</p><p>转载自<ahref="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C">理解C/C++ 中的左值和右值</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ auto与decltype:类型推导</title>
    <link href="/2023/03/04/Cpp-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/03/04/Cpp-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="modern-c-之-auto-与-decltype-类型推导">Modern C++ 之 auto 与decltype : 类型推导</h1><h2 id="auto-与-decltype-类型推导"><code>auto</code> 与<code>decltype</code> : 类型推导</h2><p>变量类型推导其实在 C++ 中一直存在,例如我们在使用泛型函数时编译器将帮助我们隐式地推导参数类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(_Type value)</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">114514</span>);  <span class="hljs-comment">// func&lt;int&gt;(114514);</span><br></code></pre></td></tr></table></figure><p>但直到 C++11 起才允许用户主动要求编译器进行类型推导. 现代 C++中提供的主动类型推导功能主要是通过 <code>auto</code> 的<code>decltype</code> 两个关键字实现.</p><h2 id="使用-auto-进行变量类型推导">使用 <code>auto</code>进行变量类型推导</h2><p>当你声明一个变量为 <code>auto</code> 类型时,编译器将自动帮助你推导出合适的数据类型. 这个变量可以是 :</p><ol type="1"><li>声明后立即赋值的普通变量;</li><li>函数的返回值;</li><li>函数的形参 (C++14 起)</li></ol><p>需要注意的是, 使用 <code>auto</code> 进行类型推导时, 将忽略顶层的<code>const</code> , <code>&amp;</code> , <code>*</code> 等修饰符,以便用户更细化的控制推导, 示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">auto</span> var_1 = number;       <span class="hljs-comment">// int var_1 = number;</span><br><span class="hljs-keyword">auto</span> var_2 = <span class="hljs-number">8.0f</span>;         <span class="hljs-comment">// float var_2 = 8.0f;</span><br><span class="hljs-keyword">auto</span> var_3 = var_1;        <span class="hljs-comment">// int var_3 = var_1;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> var_4 = var_2;  <span class="hljs-comment">// const float var_4 = var_2;</span><br><span class="hljs-keyword">auto</span>&amp; var_5 = number;      <span class="hljs-comment">// int&amp; var_5 = number;</span><br></code></pre></td></tr></table></figure><p>这种基础的用法主要是用于省略一些很长的类型名,一定程度上增加代码可读性. 一种经典用法是简写迭代器类型以遍历容器, 传统C++ 中, 我们需要完整写出迭代器的类型或是使用局部的 <code>typedef</code>进行简写, 如下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::unordered_map&lt;std::string, std::string&gt; key_value_map;<br><span class="hljs-comment">// C++98/03, 迭代器遍历容器完整写法</span><br><span class="hljs-keyword">for</span> (std::unordered_map&lt;std::string, std::string&gt;::const_iterator itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++98/03, 使用迭代器别名进行缩写</span><br><span class="hljs-keyword">typedef</span> std::unordered_map&lt;std::string, std::string&gt;::const_iterator unordered_map_const_itor;<br><span class="hljs-keyword">for</span> (unordered_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>而现代 C++ 中, 一方面我们通常使用 <code>using</code> 代替<code>typedef</code>, 但更方便的方式是使用 <code>auto</code>简写迭代器类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, 使用 using 代替 typedef</span><br><span class="hljs-keyword">using</span> hash_map_const_itor = std::unordered_map&lt;std::string, std::string&gt;::const_iterator;<br><span class="hljs-keyword">for</span> (hash_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++11 起, 使用 auto 自动推导迭代器类型</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们稍微引申一下, 在现代 C++ 中迭代一个容器的方式还有很多,具体可见下面的例子 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, auto + 范围 for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++17 起, auto + 范围 for 循环 + 结构化绑定</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++20 起, auto + 范围 for 循环 + 结构化绑定 + range 机制, 细化控制方式 (MSVC /std:c++laest)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::all) <span class="hljs-comment">// 全部遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::reverse) <span class="hljs-comment">// 全部倒序遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::<span class="hljs-built_in">drop</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 顺序遍历忽略前两个</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了普通的变量外, 我们还可以使用 <code>auto</code> 设置函数的返回值,此时需要我们在参数列表后使用 <code>-&gt;</code>符号标注具体的返回值类型. 这种写法被称作"返回类型后置语法",在一些脚本语言中比较常见 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>-&gt;<span class="hljs-type">int</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br><br><span class="hljs-comment">// 引申 : lambda 表达式的书写格式借鉴了返回值后置语法</span><br><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>到了 C++14, 我们甚至可以使用 <code>auto</code> 进行参数类型推导,在传统 C++ 中我们想进行参数类型的推导需要用到泛型机制, 但有了<code>auto</code> 进行推导参数类型后, 我们可以简化一些工作 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(_Type value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br><span class="hljs-comment">// C++20</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p><code>auto</code> 关键字在单独使用时, 大部分是用于简化书写当它与其它机制结合使用时可以衍生出更多的功能, 同样在下文里细说.</p><h2 id="使用-decltype-进行表达式类型推导">使用 <code>decltype</code>进行表达式类型推导</h2><p><code>auto</code> 关键字用于推导变量类型, 与之相对的<code>decltype</code> 则是用来推导表达式结果的类型. 熟悉 GCC的用户可能对这个关键字不陌生, <code>decltype</code> 的标准化提案就是源自GCC 的扩展关键字 <code>__decltype</code>, 而后者又是源自于 GCC一个很古老的扩展关键字 <code>__typeof__</code> .例如你可能需要推导某两个变量相加的结果类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> number_a = <span class="hljs-number">16LL</span>;                                          <span class="hljs-comment">// long long number_a = 16LL;</span><br><span class="hljs-keyword">auto</span> number_b = <span class="hljs-number">16.0F</span>;                                         <span class="hljs-comment">// float number_b = 16.0F;</span><br><span class="hljs-keyword">decltype</span>(number_a + number_b) number_c = number_a + number_b;  <span class="hljs-comment">// float number_c = number_a + number_b;</span><br></code></pre></td></tr></table></figure><p><code>decltype</code> 的推导规则遵循如下几点 :</p><ol type="1"><li>若表达式是一个 <strong>不带括号的标记符表达式</strong> 或<strong>类/结构体成员访问表达式</strong>,那么推导的结果是所代表实体的类型;</li><li>若表达式是一个<strong>函数调用(包括操作符重载)</strong>,那么推导的结果是函数的返回类型, 若返回值是基础类型则抛弃<code>const</code> 限定符;</li><li>若表达式是一个<strong>字符串字面量</strong>, 则推到为<code>const</code> 左值引用;</li><li>上述情况以外, 若表达式结果为左值则推导为左值引用,否则推导为本类型;</li></ol><p>示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> const_number = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> number_array[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span>* number_array_ptr = number_array;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123; <span class="hljs-type">double</span> member; &#125; my_struct;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">bool</span> <span class="hljs-title">func_1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;;<br><span class="hljs-function"><span class="hljs-type">const</span> MyStruct <span class="hljs-title">func_2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyStruct</span>(); &#125;;<br><br><span class="hljs-comment">// 规则 1 : 不带括号的标记符表达式 或 类/结构体成员访问表达式</span><br><span class="hljs-keyword">decltype</span>(number_array) var_1;      <span class="hljs-comment">// int[2] var_1; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number_array_ptr) var_2;  <span class="hljs-comment">// int*   var_2; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(my_struct.member) var_3;  <span class="hljs-comment">// double var_3; 成员访问表达式 =&gt; 本类型</span><br><br><span class="hljs-comment">// 规则 2 : 函数调用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_1</span>(<span class="hljs-number">1</span>)) var_5 = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// bool var_5; 基础类型返回值, 丢弃 const 限定符</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>)) var_7 = <span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// const MyStruct var_7; 类类型返回值, 保留 const 限定符</span><br><br><span class="hljs-comment">// 规则 3 : 字符串字面量</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-string">&quot;hello&quot;</span>) var_8 = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">//const char&amp; var_8[6]; const 左值引用</span><br><br><span class="hljs-comment">// 规则 4 : 其他情况下表达式结果</span><br><span class="hljs-keyword">decltype</span>((number)) var_9 = number;                 <span class="hljs-comment">// int&amp; var_9; 带括号的标记符表达式 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? number : number) var_10 = number;  <span class="hljs-comment">// int&amp; var_10; 条件表达式返回左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(++number) var_11 = number;                <span class="hljs-comment">// int&amp; var_11; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(number_array[<span class="hljs-number">5</span>]) var_12 = number;         <span class="hljs-comment">// int&amp; var_12; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(*number_array_ptr) var_13 = number;       <span class="hljs-comment">// int&amp; var_13; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>) var_14 = <span class="hljs-number">10</span>;                           <span class="hljs-comment">// int var_14; 纯右值字面量 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number++) var_15 = number;                <span class="hljs-comment">// int var_15; 表达式结果为右值 =&gt; 本类型</span><br></code></pre></td></tr></table></figure><p>你可能在部分平台上使用过关键字 <code>typeof</code> ,<code>__typeof__</code> 或 <code>__decltype</code> ,它们同样可用于推导表达式结果类型, 并且可以视作 <code>decltype</code>功能的子集. 但这些关键字从来都不是标准 C++ 的一部分,只是部分编译器支持的功能, 并且它们的推导规则也有很强的平台差异性.相比之下 <code>decltype</code> 的标准化程度和适用面更广. 除此之外<code>typeof</code> 进行类型推导时 <code>&amp;</code>引用符号很可能将不做保留, 至少 GCC 上是这样的, 参考以下示例 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>           var = <span class="hljs-number">1</span>; <br><span class="hljs-type">int</span>&amp;          ref = var; <br><span class="hljs-built_in">typeof</span>(var)   var_1 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-built_in">typeof</span>(ref)   var_2 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-keyword">decltype</span>(var) var_3;      <span class="hljs-comment">// int </span><br><span class="hljs-keyword">decltype</span>(ref) var_4 = a;  <span class="hljs-comment">// int&amp; </span><br></code></pre></td></tr></table></figure><p>总之, 当你的工程所使用的 C++ 版本若是等于或高于 C++11 ,我推荐全盘使用 <code>decltype</code> 代替 <code>typeof</code> .</p><h2 id="结合-auto-与-decltype-进行自动推导返回值类型">结合<code>auto</code> 与 <code>decltype</code> 进行自动推导返回值类型</h2><p><code>auto</code> 与 <code>decltype</code> 单独使用的时候,在功能上的突破本质还是向用户开放了主动要求类型推导的权限.但如果二者结合使用的话, 就可以突破传统 C++ 中一些限制了.在这里我们思考一个问题 : <strong>如何实现一个满足所有类型之间进行<code>+</code> 运算的函数?</strong></p><p>在传统 C++ 中的最优解是这样的 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function">_TypeResult <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法的确可以满足所有类型的 <code>+</code> 运算,但很明显使用上有着很大的局限性. 因为我们必须预知返回值的类型,而题目的隐藏含义是一定要做到通用性的. 那么我们现在已经知道如何使用<code>decltype</code> 可以进行表达式结果的类型推导,那何不直接用其直接推导函数体的结果呢 ?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> <span class="hljs-comment">// 未定义的标识符</span></span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>很遗憾这种行为是无效的, 因为形式参的定义在参数列表里,而处于参数列表左侧的返回值类型是无法获取形参名的.除非我们能将返回值类型放在参数列表的右侧, 实现这个目标的方式就是使用<code>auto</code> 书写返回类型后置语法 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// auto 返回类型后置语法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;_TypeResult </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br><span class="hljs-comment">// auto 返回类型后置语法 结合 decltype 表达式结果类型推导</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>若只是单纯的只用 <code>auto</code> 进行返回类型后置,则只是换了种语法. 但如果将 <code>auto</code> 与 <code>decltype</code>相结合, 就可以突破传统 C++ 的限制了. 到此,我们已经完全实现了题目里的需求. 但还有继续优化的空间,首先是上文中提到的, 自 C++14 起, 我们可以利用 <code>auto</code>进行参数类型的推导 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>其次是由于这种二者结合的模式被大量的使用, 自 C++14 起, 我们在使用<code>auto</code> 描述返回类型时无需在参数列表后写上返回类型,编译器将自动通过函数体进行推导, 因此这个方法最终将演化成这种形式 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p><strong>引申 : 上例中的 "最终版本" 真的完美吗?</strong></p><blockquote><p>返回类型后置这种语法看似只是语法上的一些取巧手法,但实则通过这种方式可以突破编译器的桎梏,因为编译器始终是由上至下由左至右理解代码的.</p></blockquote><p>正如上文中所说, <code>auto</code> 与 <code>decltype</code>的功能并不是现代 C++ 才出现的,而且在它们单独使用时更多的时候是一种简化代码书写的方式.但当二者结合起来时, 将可以做出一些语言功能上的突破.</p><h2 id="auto-与-decltype-的演化"><code>auto</code> 与<code>decltype</code> 的演化</h2><p>传统 C++ 里, 类型推导一般是在模板传参时进行隐式类型推导, 而<code>auto</code> 的出现是将类型推导的控制权开放给用户进行显示类型推导;而传统 C++ 里表达式结果类型的推导通常由不同平台上各种<code>typeof</code> 非标准扩展关键字实现, 而 <code>decltype</code>的出现则是这个功能的标准化. 当 <code>auto</code> 与<code>decltype</code> 相结合后, 由衍生出许多新的功能, 它们二者构成了现代C++ 类型推导功能的核心. 以下的 <code>auto</code> 与<code>decltype</code> 的发展历程简述 :</p><ol type="1"><li>C++11 :<ul><li>允许使用 <code>auto</code> 进行普通变量的主动类型推导;</li><li>允许使用 <code>auto</code> 书写返回值后置语法;</li><li>使用标准 <code>decltype</code> 进行表达式结果类型推导以替代各平台的<code>typeof</code> 扩展关键字;</li></ul></li><li>C++14 :<ul><li>允许使用 <code>auto</code> 进行形参类型推导;</li><li>允许使用 <code>auto</code> 进行返回值类型推导(书写返回值后置语法时不适用类型标识符表面返回类型);</li></ul></li></ol><p>内容转载自 <ahref="http://brabbit.xyz/blog/NoteModernCpp/p3_auto_deltype.html">ModernC++ 之 auto 与 decltype : 类型推导</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="详解-c-11-中的智能指针">详解 C++ 11 中的智能指针</h2><p>C/C++语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在C/C++语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如boost，智能指针技术应运而生。</p><h4 id="c-9803-的尝试stdauto_ptr">C++ 98/03 的尝试——std::auto_ptr</h4><p>在 2022 年讨论 <strong>std::auto_ptr</strong>不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11标准的出现（最新标准是 C++20），<strong>std::auto_ptr</strong>已经被彻底废弃了，取而代之是<strong>std::unique_ptr</strong>。然而，我之所以还向你介绍一下<strong>std::auto_ptr</strong> 的用法以及它的设计不足之处是想让你了解C++语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它，不是吗？</p><p><strong>std::auto_ptr</strong> 的基本用法如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化方式1</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-comment">//初始化方式2</span><br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">8</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针对象 <strong>sp1</strong> 和 <strong>sp2</strong>均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在<strong>sp1</strong> 和 <strong>sp2</strong> 释放时得到释放。这是<strong>std::auto_ptr</strong> 的基本用法。</p><blockquote><p>sp 是 smart pointer（智能指针）的简写。</p></blockquote><p><strong>std::auto_ptr</strong>真正让人容易误用的地方是其不常用的复制语义，即当复制一个<strong>std::auto_ptr</strong> 对象时（拷贝复制或 operator =复制），原对象所持有的堆内存对象也会转移给复制出来的对象。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试拷贝构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    <span class="hljs-keyword">if</span> (sp1.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp2.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">//测试赋值构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp4;<br>    sp4 = sp3;<br>    <span class="hljs-keyword">if</span> (sp3.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp4.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中分别利用拷贝构造（sp1 =&gt; sp2）和 赋值构造（sp3 =&gt;sp4）来创建新的 std::auto_ptr 对象，因此 sp1 持有的堆对象被转移给sp2，sp3 持有的堆对象被转移给 sp4。我们得到程序执行结果如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[root@iZ238vnojlyZ testx]<span class="hljs-comment"># g++ -g -o test_auto_ptr test_auto_ptr.cpp</span><br>[root@iZ238vnojlyZ testx]<span class="hljs-comment"># ./test_auto_ptr </span><br>sp1 <span class="hljs-keyword">is</span> empty.<br>sp2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br>sp3 <span class="hljs-keyword">is</span> empty.<br>sp4 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br></code></pre></td></tr></table></figure><p>由于 <strong>std::auto_ptr</strong>这种不常用的复制语义，我们应该避免在 stl 容器中使用<strong>std::auto_ptr</strong>，例如我们绝不应该写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; myvectors;<br></code></pre></td></tr></table></figure><p>当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误。</p><p>以史为鉴，作为 <strong>std::auto_ptr</strong> 的替代者<strong>std::unique_ptr</strong>吸取了这个经验教训。下文会来详细介绍。</p><p>正因为 <strong>std::auto_ptr</strong> 的设计存在如此重大缺陷，C++11标准在充分借鉴和吸收了 boost库中智能指针的设计思想，引入了三种类型的智能指针，即<strong>std::unique_ptr</strong>、<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong>。</p><blockquote><p>boost 还有 scoped_ptr，C++11并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。</p></blockquote><p>所有的智能指针类（包括 std::unique_ptr）均包含于头文件 **** 中。</p><blockquote><p>正因为存在上述设计上的缺陷，在 C++11及后续语言规范中 std::auto_ptr已经被废弃，你的代码不应该再使用它。</p></blockquote><h4 id="stdunique_ptr">std::unique_ptr</h4><p><strong>std::unique_ptr</strong>对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是1，<strong>std::unique_ptr</strong>对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个<strong>std::unique_ptr</strong> 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>你应该尽量使用初始化方式 3 的方式去创建一个<strong>std::unique_ptr</strong> 而不是方式 1 和 2，因为形式 3更安全，原因 Scott Meyers 在其《Effective ModernC++》中已经解释过了，有兴趣的读者可以阅读此书相关章节。</p><blockquote><p>令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared()方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique()方法创建一个 std::unique_ptr 对象，这个方法直到 C++14才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp; ...params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></td></tr></table></figure><p>鉴于 <strong>std::auto_ptr</strong>的前车之鉴，<strong>std::unique_ptr</strong>禁止复制语义，为了达到这个效果，<strong>std::unique_ptr</strong>类的拷贝构造函数和赋值运算符（operator =）被标记为<strong>delete</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//省略其他代码...</span><br><br>    <span class="hljs-comment">//拷贝构造函数和赋值运算符被标记为delete</span><br>    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，下列代码是无法通过编译的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;;<br><br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//std::unique_ptr&lt;int&gt; sp2(sp1);</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//sp3 = sp1;</span><br></code></pre></td></tr></table></figure><p>禁止复制语义也存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(val))</span></span>;<br>    <span class="hljs-keyword">return</span> up;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp1 = <span class="hljs-built_in">func</span>(<span class="hljs-number">123</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码从 func 函数中得到一个 <strong>std::unique_ptr</strong>对象，然后返回给 sp1。</p><p>既然 <strong>std::unique_ptr</strong> 不能复制，那么如何将一个<strong>std::unique_ptr</strong>对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;<br><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(std::move(sp1))</span></span>;<br><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>    sp3 = std::<span class="hljs-built_in">move</span>(sp2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2不再持有堆内存的引用，变成一个空的智能指针对象。并不是所有的对象的std::move 操作都有意义，只有实现了移动构造函数（MoveConstructor）或移动赋值运算符（operator =）的类才行，而<strong>std::unique_ptr</strong> 正好实现了这二者，以下是实现伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Deletor&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//其他函数省略...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T*    m_pT;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是 <strong>std::unique_ptr</strong>具有移动语义的原因，希望读者可以理解之。关于移动构造和<strong>std::move</strong>，我们将在后面章节详细介绍。</p><p><strong>std::unique_ptr</strong>不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建10个int类型的堆对象</span><br>    <span class="hljs-comment">//形式1</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br>    <span class="hljs-comment">//形式2</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]);<br>    <span class="hljs-comment">//形式3</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">10</span>))</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        sp1[i] = i;<br>        sp2[i] = i;<br>        sp3[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        std::cout &lt;&lt; sp1[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp2[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp3[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># g++ -g -o test_unique_ptr_with_array test_unique_ptr_with_array.cpp -std=c++17</span><br>[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># ./test_unique_ptr_with_array </span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span><br><span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br><span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span><br><span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span><br><span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span><br><span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span><br><span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>也可以持有一组堆对象，用法与 <strong>std::unique_ptr</strong>相同，下文不再赘述。</p><p><strong>自定义智能指针对象持有的资源的释放函数</strong></p><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete或者delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个Socket类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以<strong>std::unique_ptr</strong> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    ~<span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//关闭资源句柄</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> deletor = [](Socket* pSocket) &#123;<br>        <span class="hljs-comment">//关闭句柄</span><br>        pSocket-&gt;<span class="hljs-built_in">close</span>();<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span><br>        <span class="hljs-keyword">delete</span> pSocket;<br>    &#125;;<br><br>    <span class="hljs-function">std::unique_ptr&lt;Socket, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(Socket * pSocket)</span>&gt; <span class="hljs-title">spSocket</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Socket(), deletor)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义 <strong>std::unique_ptr</strong> 的资源释放函数其规则是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;T, DeletorFuncPtr&gt;<br></code></pre></td></tr></table></figure><p>其中 T 是你要释放的对象类型，DeletorPtr是一个自定义函数指针。上述代码 <strong>33</strong> 行表示 DeletorPtr有点复杂，我们可以使用 <strong>decltype(deletor)</strong>让编译器自己推导 deletor 的类型，因此可以将 <strong>33</strong>行代码修改为：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">std</span>::unique_ptr&lt;<span class="hljs-type">Socket</span>, decl<span class="hljs-keyword">type</span>(deletor)&gt; spSocket(new <span class="hljs-type">Socket</span>(), deletor);<br></code></pre></td></tr></table></figure><h4 id="stdshared_ptr">std::shared_ptr</h4><p><strong>std::unique_ptr</strong> 对其持有的资源具有独占性，而<strong>std::shared_ptr</strong> 持有的资源可以在多个<strong>std::shared_ptr</strong> 之间共享，每多一个<strong>std::shared_ptr</strong> 对资源的引用，资源引用计数将增加1，每一个指向该资源的 <strong>std::shared_ptr</strong>对象析构时，资源引用计数减 1，最后一个 <strong>std::shared_ptr</strong>对象析构时，发现资源计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作<strong>std::shared_ptr</strong>引用的对象是安全的）。<strong>std::shared_ptr</strong> 提供了一个<strong>use_count()</strong>方法来获取当前持有资源的引用计数。除了上面描述的，<strong>std::shared_ptr</strong>用法和 <strong>std::unique_ptr</strong> 基本相同。</p><p>下面是一个初始化 <strong>std::shared_ptr</strong> 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>sp3 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>和 <strong>std::unique_ptr</strong> 一样，你应该优先使用<strong>std::make_shared</strong> 去初始化一个<strong>std::shared_ptr</strong> 对象。</p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//初始化方式1</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//初始化方式2</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        sp2.<span class="hljs-built_in">reset</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        &#123;<br>            std::shared_ptr&lt;A&gt; sp3 = sp1;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码 <strong>22</strong> 行 sp1 构造时，同时触发对象 A的构造，因此 A 的构造函数会执行；</li><li>此时只有一个 sp1 对象引用 <strong>22</strong> 行 new 出来的 A对象（为了叙述方便，下文统一称之为<strong>资源对象A</strong>），因此代码 <strong>24</strong> 行打印出来的引用计数值为<strong>1</strong>；</li><li>代码 <strong>27</strong> 行，利用 sp1 拷贝一份 sp2，导致代码<strong>28</strong> 行打印出来的引用计数为 <strong>2</strong>；</li><li>代码 <strong>30</strong> 行调用 sp2 的 reset() 方法，sp2释放对资源对象 A 的引用，因此代码 <strong>31</strong>行打印的引用计数值再次变为 <strong>1</strong>；</li><li>代码 <strong>34</strong> 行 利用 sp1 再次 创建 sp3，因此代码<strong>35</strong> 行打印的引用计数变为 <strong>2</strong>；</li><li>程序执行到 <strong>36</strong> 行以后，sp3 出了其作用域被析构，资源A 的引用计数递减 1，因此 代码 <strong>38</strong> 行打印的引用计数为<strong>1</strong>；</li><li>程序执行到 <strong>39</strong> 行以后，sp1出了其作用域被析构，在其析构时递减资源 A 的引用计数至<strong>0</strong>，并析构资源 A 对象，因此类 A 的析构函数被调用。</li></ul><p>所以整个程序的执行结果如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# ./test_shared_ptr_use_count <br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">use</span> <span class="hljs-title">count</span>:</span> <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>A <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure><p><strong>std::enable_shared_from_this</strong></p><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个<strong>std::shared_ptr</strong> 对象给外部使用，C++新标准也为我们考虑到了这一点，有如此需求的类只要继承自<strong>std::enable_shared_from_this</strong>模板对象即可。用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">getSelf</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，类 A 的继承 <strong>std::enable_shared_from_this</strong>并提供一个 <strong>getSelf()</strong> 方法返回自身的<strong>std::shared_ptr</strong> 对象，在 <strong>getSelf()</strong>中调用 <strong>shared_from_this()</strong> 即可。</p><p><strong>std::enable_shared_from_this</strong>用起来比较方便，但是也存在很多不易察觉的陷阱。</p><p><strong>陷阱一：不应该共享栈对象的 this 给智能指针对象</strong></p><p>假设我们将上面代码 main 函数 <strong>25</strong> 行生成 A对象的方式改成一个栈变量，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//其他相同代码省略...</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br><br>    std::shared_ptr&lt;A&gt; sp2 = a.<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行修改后的代码会发现程序在<code>std::shared_ptr sp2 = a.getSelf();</code>产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过<strong>shared_from_this()</strong>将该对象交由智能指针对象管理。切记：<strong>智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</strong>。</p><p><strong>陷阱二：避免 std::enable_shared_from_this的循环引用问题</strong></p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// test_std_enable_shared_from_this.cpp : This file contains the &#x27;main&#x27; function. Program execution begins and ends there.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">9</span>;<br>        <span class="hljs-comment">//注意:</span><br>        <span class="hljs-comment">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span><br>        <span class="hljs-comment">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">0</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_SelfPtr = <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>                 m_i;<br>    std::shared_ptr&lt;A&gt;  m_SelfPtr;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">spa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        spa-&gt;<span class="hljs-built_in">func</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# g++ -g -o test_std_enable_shared_from_this_problem test_std_enable_shared_from_this_problem.cpp<br>[root@myaliyun testmybook]# ./test_std_enable_shared_from_this_problem<br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br></code></pre></td></tr></table></figure><p>我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏了！</p><p>我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到<strong>42</strong> 行后，spa出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁A。这就是所谓的 std::enable_shared_from_this的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。也就是说一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理。</p><h4 id="stdweak_ptr">std::weak_ptr</h4><p><strong>std::weak_ptr</strong>是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助<strong>std::shared_ptr</strong> 工作。</p><p><strong>std::weak_ptr</strong> 可以从一个<strong>std::shared_ptr</strong> 或另一个 <strong>std::weak_ptr</strong>对象构造，<strong>std::shared_ptr</strong> 可以直接赋值给<strong>std::weak_ptr</strong> ，也可以通过<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 函数来获得<strong>std::shared_ptr</strong>。它的构造和析构不会引起引用计数的增加或减少。<strong>std::weak_ptr</strong>可用来解决 <strong>std::shared_ptr</strong>相互引用时的死锁问题（即两个<strong>std::shared_ptr</strong>相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放）。</p><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个std::shared_ptr对象</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过构造函数得到一个std::weak_ptr对象</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过赋值运算符得到一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = sp1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp4 = sp2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># g++ -g -o test_weak_ptr test_weak_ptr.cpp </span><br>[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># ./test_weak_ptr</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>无论通过何种方式创建 <strong>std::weak_ptr</strong>都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。</p><p>既然，<strong>std::weak_ptr</strong>不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？<strong>std::weak_ptr</strong>提供了一个 <strong>expired()</strong> 方法来做这一项检测，返回true，说明其引用的资源已经不存在了；返回false，说明该资源仍然存在，这个时候可以使用<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 方法得到一个<strong>std::shared_ptr</strong>对象然后继续操作资源，以下代码演示了该用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span><br><span class="hljs-comment">//tmpConn_引用的TcpConnection已经销毁，直接返回</span><br><span class="hljs-keyword">if</span> (tmpConn_.<span class="hljs-built_in">expired</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (conn)<br>&#123;<br>    <span class="hljs-comment">//对conn进行操作，省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有读者可能对上述代码产生疑问，既然使用了<strong>std::weak_ptr</strong> 的 <strong>expired()</strong>方法判断了对象是否存在，为什么不直接使用 <strong>std::weak_ptr</strong>对象对引用资源进行操作呢？实际上这是行不通的，<strong>std::weak_ptr</strong>类没有重写 <strong>operator-&gt;</strong> 和 <strong>operator</strong>*方法，因此不能像 <strong>std::shared_ptr</strong> 或<strong>std::unique_ptr</strong> 一样直接操作对象，同时<strong>std::weak_ptr</strong> 类也没有重写 <strong>operator!</strong>操作，因此也不能通过 <strong>std::weak_ptr</strong>对象直接判断其引用的资源是否存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    <span class="hljs-function">std::weak_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (sp1)<br>    &#123;<br>        <span class="hljs-comment">//正确代码</span><br>        sp1 -&gt; <span class="hljs-built_in">doSomething</span>();<br>        (*sp1).<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (!sp1)<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    //错误代码，无法编译通过</span><br>    <span class="hljs-comment">//    sp2-&gt;doSomething();</span><br>    <span class="hljs-comment">//    (*sp2).doSomething();</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (!sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以 <strong>std::weak_ptr</strong>不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦。</p><p>因此，<strong>std::weak_ptr</strong>的正确使用场景是那些资源如果可用就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时Session 对象如果强行持有 Connection 对象与事实矛盾。</p><p><strong>std::weak_ptr</strong>的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeManager</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publish</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; iter : m_subscribers)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!iter.<span class="hljs-built_in">expired</span>())<br>            &#123;<br>                <span class="hljs-comment">//TODO：给订阅者发送消息</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt;   m_subscribers;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="智能指针对象的大小">智能指针对象的大小</h4><p>一个 <strong>std::unique_ptr</strong> 对象大小与裸指针大小相同（即sizeof(std::unique_ptr<T>) == sizeof(void*)），而<strong>std::shared_ptr</strong> 的大小是<strong>std::unique_ptr</strong> 的两倍。以下是我分别在 Visual Studio2019 和 gcc/g++ 4.8 上（二者都编译成 x64 程序）的测试结果：</p><p><strong>测试代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp0;<br>    std::shared_ptr&lt;std::string&gt; sp1;<br>    sp1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>());<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp0 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp0) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp1) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp3) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Visual Studio 2019 运行结果：</p><p><img src="/img/C++/智能指针/sp1.webp" /></p><p>gcc/g++ 运行结果：</p><p><img src="/img/C++/智能指针/sp2.webp" /></p><p>在 32 位机器上，<strong>std_unique_ptr</strong> 占 4字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 8 字节；在 64 位机器上，<strong>std_unique_ptr</strong> 占 8字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 16 字节。也就是说，<strong>std_unique_ptr</strong>的大小总是和原始指针大小一样，<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong> 大小是原始指针的两倍。</p><h4 id="智能指针使用注意事项">智能指针使用注意事项</h4><p>C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++新标准中的各种智能指针是如此的实用与强大，在现代 C++项目开发中，读者应该尽量去使用它们。智能指针虽然好用，但稍不注意，也可能存在许多难以发现的bug，这里我根据经验总结了几条：</p><ul><li><p>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</p><p>看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-keyword">delete</span> pSubscriber;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针spSubscriber去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象<strong>spSubscriber</strong> 情何以堪啊？</p><p>记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。当然，除了<strong>std::weak_ptr</strong>，<strong>std::unique_ptr</strong> 和<strong>std::shared_ptr</strong>都提供了获取原始指针的方法——<strong>get()</strong> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span><br>  Subscriber* pTheSameSubscriber= spSubscriber.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分清楚场合应该使用哪种类型的智能指针；</p><p>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用<strong>std::unique_ptr</strong>，反之使用<strong>std::shared_ptr</strong>，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用<strong>std::weak_ptr</strong>。</p></li><li><p>认真考虑，避免操作某个引用资源已经释放的智能指针；</p><p>前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;T do something...&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> m_i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; sp2 = sp1;<br><br>  sp1.<span class="hljs-built_in">reset</span>();<br><br>  <span class="hljs-comment">//由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为</span><br>  sp2-&gt;<span class="hljs-built_in">doSomething</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即<strong>operator-&gt;</strong>）在内部会调用 <strong>get()</strong>方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用doSomething() 导致程序崩溃。</p><p>你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//连接断开</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MonitorServer::OnClose</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;TcpConnection&gt;&amp; conn)</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(m_sessionMutex)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = m_sessions.<span class="hljs-built_in">begin</span>(); iter != m_sessions.<span class="hljs-built_in">end</span>(); ++iter)<br>  &#123;<br>      <span class="hljs-comment">//通过比对connection对象找到对应的session</span><br>      <span class="hljs-keyword">if</span> ((*iter)-&gt;<span class="hljs-built_in">GetConnectionPtr</span>() == conn)<br>      &#123;<br>          m_sessions.<span class="hljs-built_in">erase</span>(iter);<br>          <span class="hljs-comment">//注意这里：程序在此处崩溃</span><br>          <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;monitor client disconnected: %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码不是我杜撰的，而是来自于我实际的一个商业项目中。注意代码中我提醒注意的地方，该段程序会在代码<strong>12</strong> 行处崩溃，崩溃原因是调用了<code>conn-&gt;peerAddress()</code>方法。为什么这个方法的调用可能会引起崩溃？现在可以一目了然地看出了吗？</p><p>崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个<strong>std::shared_ptr</strong> 的引用，当连接断开时，对应的TcpConnection 对象可能早已被销毁，而 conn引用就会变成空指针（严格来说是不再拥有一个 TcpConnection对象），此时调用 TcpConnection 的 peerAddress()方法就会产生和上一个示例一样的错误。</p></li><li><p>作为类成员变量时，应该优先使用前置声明（forwarddeclarations）</p><p>我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++项目中一般在 *.h文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:<br>  A*      m_pA;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:  <br>  std::unique_ptr&lt;A&gt;  m_spA;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>C++ 新标准中的智能指针我想介绍的就这么多了，Modern C/C++ 已经变为C/C++开发的趋势，希望读者能善用和熟练使用本节介绍的后三种智能指针对象。</p><p>转载自 <ahref="https://github.com/balloonwj/CppGuide/blob/master/articles/C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AF%A6%E8%A7%A3C++11%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md">详解C++11中的智能指针</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL 容器以及常用操作</title>
    <link href="/2023/03/02/CppSTL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/03/02/CppSTL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="vector容器">vector容器</h2><p>C++ STL vector是一个动态数组容器，它可以在运行时调整大小，并且支持随机访问。以下是vector 常用的基本操作：</p><h3 id="创建vector">创建vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;             <span class="hljs-comment">// 创建一个空 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size)</span></span>;       <span class="hljs-comment">// 创建一个大小为 size 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size, value)</span></span>;<span class="hljs-comment">// 创建一个大小为 size，并且所有元素都初始化为 value 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;        <span class="hljs-comment">// 创建一个副本 vector，v2 和 v1 中的元素相同</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v3 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 创建一个初始元素分别为1 2 3的vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3.begin() + <span class="hljs-number">1</span>, ilist.end() - <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 用v3的某个范围元素初始化v4</span><br></code></pre></td></tr></table></figure><h3 id="访问-vector-元素">访问 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index];                 <span class="hljs-comment">// 访问第 index 个元素</span><br>v.<span class="hljs-built_in">at</span>(index);              <span class="hljs-comment">// 访问第 index 个元素，并且进行边界检查</span><br>v.<span class="hljs-built_in">front</span>();                <span class="hljs-comment">// 访问第一个元素</span><br>v.<span class="hljs-built_in">back</span>();                 <span class="hljs-comment">// 访问最后一个元素</span><br>v.<span class="hljs-built_in">data</span>();                 <span class="hljs-comment">// 返回指向 vector 数据的指针</span><br></code></pre></td></tr></table></figure><h3 id="修改-vector-元素">修改 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index] = value;         <span class="hljs-comment">// 修改第 index 个元素为 value</span><br>v.<span class="hljs-built_in">at</span>(index) = value;      <span class="hljs-comment">// 修改第 index 个元素为 value，并且进行边界检查</span><br>v.<span class="hljs-built_in">emplace_back</span>(value);       <span class="hljs-comment">// 在 vector 的末尾插入一个元素</span><br>v.<span class="hljs-built_in">pop_back</span>();             <span class="hljs-comment">// 删除 vector 的末尾元素</span><br>v.<span class="hljs-built_in">insert</span>(iterator, value);<span class="hljs-comment">// 在 iterator 指定的位置插入 value</span><br>v.<span class="hljs-built_in">erase</span>(iterator);        <span class="hljs-comment">// 删除 iterator 指定的元素</span><br>v.<span class="hljs-built_in">clear</span>();                <span class="hljs-comment">// 删除 vector 中所有的元素</span><br>v.<span class="hljs-built_in">resize</span>(size);           <span class="hljs-comment">// 修改 vector 的大小为 size，如果原来的大小比 size 大，则删除后面的元素，否则增加默认值的元素</span><br>v.<span class="hljs-built_in">resize</span>(size, value);    <span class="hljs-comment">// 修改 vector 的大小为 size，并且用 value 进行初始化，如果原来的大小比 size 大，则删除后面的元素，否则增加 value 的元素</span><br></code></pre></td></tr></table></figure><h3 id="vector-容量操作">vector 容量操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v.<span class="hljs-built_in">size</span>();                 <span class="hljs-comment">// 返回 vector 中元素的个数</span><br>v.<span class="hljs-built_in">capacity</span>();             <span class="hljs-comment">// 返回 vector 可以存储的元素的数量，也就是预留的空间</span><br>v.<span class="hljs-built_in">empty</span>();                <span class="hljs-comment">// 如果 vector 为空，返回 true，否则返回 false</span><br>v.<span class="hljs-built_in">reserve</span>(capacity);      <span class="hljs-comment">// 预留 capacity 的存储空间</span><br>v.<span class="hljs-built_in">shrink_to_fit</span>();        <span class="hljs-comment">// 释放 vector 多余的存储空间</span><br></code></pre></td></tr></table></figure><h3 id="vector-遍历操作">vector 遍历操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="两个元素之间的范围">两个元素之间的范围</h3><p>我们知道，作用于同一容器的 2个同类型迭代器可以有效指定一个区间范围。在此基础上，如果想获取该指定范围内包含元素的个数，就可以借助distance() 函数。</p><p>distance()函数用于计算两个迭代器表示的范围内包含元素的个数，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>&gt;<br>  <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="hljs-function">difference_type <span class="hljs-title">distance</span> <span class="hljs-params">(InputIterator first, InputIterator last)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，first 和 last都为<strong>迭代器</strong>，其类型可以是输入迭代器、前向迭代器、双向迭代器以及随机访问迭代器；该函数会返回[first,last)范围内包含的元素的个数。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// distance</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span>         <span class="hljs-comment">// list</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">//创建一个空 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist;<br><span class="hljs-comment">//向空 list 容器中添加元素 0~9</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>mylist.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//指定 2 个双向迭代器，用于执行某个区间</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator first = mylist.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//指向元素 0</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator last = mylist.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//指向元素 9 之后的位置</span><br><span class="hljs-comment">//获取 [first,last) 范围内包含元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;distance() = &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(first, last);<br></code></pre></td></tr></table></figure><h3 id="查找某个值所在位置">查找某个值所在位置</h3><p>使用 std::find()方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-type">int</span> key = <span class="hljs-number">6</span>;<br> <br>    std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = std::<span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), key);<br> <br>    <span class="hljs-keyword">if</span> (itr != v.<span class="hljs-built_in">cend</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element present at index &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(v.<span class="hljs-built_in">begin</span>(), itr);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找最大元素和最小元素">查找最大元素和最小元素</h3><p><code>max_element()</code>函数是算法标头的库函数，用于查找范围中的最大元素，它接受容器范围[start，end]，并返回一个迭代器，该迭代器指向给定范围中具有最大值的元素。</p><p><strong>参数</strong>：</p><ul><li>iterator start, iterator end,容器开始和结束位置;</li><li>[compare comp]，可选参数，可以与给定范围内的元素进行比较。</li></ul><p><strong>返回值</strong>:</p><p>iterator -返回一个迭代器，该迭代器指向给定范围内具有最大值的元素。</p><p><code>min_element()</code>同理，参数用法也相同，不同的是它返回的是最小元素的迭代器。</p><h2 id="stack容器">stack容器</h2><p>C++ STL 标准库中的 stack是一个后进先出（LIFO）的容器适配器，它可以使用不同的底层容器（默认使用deque）实现。以下是 stack 常用的基本操作：</p><h3 id="创建-stack">创建 stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>std::stack&lt;<span class="hljs-type">int</span>&gt; s;       <span class="hljs-comment">// 创建一个空 stack</span><br><span class="hljs-function">std::stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;   <span class="hljs-comment">// 创建一个副本 stack，s1 和 s 中的元素相同</span><br>std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; s2; <span class="hljs-comment">// 创建一个底层容器为 vector 的 stack</span><br></code></pre></td></tr></table></figure><h3 id="stack-元素操作">stack 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">emplace</span>(value);       <span class="hljs-comment">// 将 value 压入 stack 顶部</span><br>s.<span class="hljs-built_in">pop</span>();                <span class="hljs-comment">// 弹出 stack 顶部的元素</span><br>s.<span class="hljs-built_in">top</span>();                <span class="hljs-comment">// 返回 stack 顶部的元素</span><br>s.<span class="hljs-built_in">empty</span>();              <span class="hljs-comment">// 如果 stack 为空，返回 true，否则返回 false</span><br>s.<span class="hljs-built_in">size</span>();               <span class="hljs-comment">// 返回 stack 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-stack">遍历 stack</h3><p>stack 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历stack。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = s.<span class="hljs-built_in">top</span>();<br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 stack 时，一定要判断 stack 是否为空，否则会发生undefined behavior。</p><h2 id="queue容器">queue容器</h2><p>C++ STL 标准库中的 queue是一个先进先出（FIFO）的容器适配器，它也可以使用不同的底层容器（默认使用deque）实现。以下是 queue 常用的基本操作：</p><h3 id="创建-queue">创建 queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;           <span class="hljs-comment">// 创建一个空 queue</span><br><span class="hljs-function">std::queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q1</span><span class="hljs-params">(q)</span></span>;       <span class="hljs-comment">// 创建一个副本 queue，q1 和 q 中的元素相同</span><br>std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q2;  <span class="hljs-comment">// 创建一个底层容器为 list 的 queue</span><br></code></pre></td></tr></table></figure><h3 id="queue-元素操作">queue 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">q.<span class="hljs-built_in">emplace</span>(value);           <span class="hljs-comment">// 将 value 插入 queue 尾部</span><br>q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-comment">// 弹出 queue 头部的元素</span><br>q.<span class="hljs-built_in">front</span>();                  <span class="hljs-comment">// 返回 queue 头部的元素</span><br>q.<span class="hljs-built_in">back</span>();                   <span class="hljs-comment">// 返回 queue 尾部的元素</span><br>q.<span class="hljs-built_in">empty</span>();                  <span class="hljs-comment">// 如果 queue 为空，返回 true，否则返回 false</span><br>q.<span class="hljs-built_in">size</span>();                   <span class="hljs-comment">// 返回 queue 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-queue">遍历 queue</h3><p>queue 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历queue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 queue 时，一定要判断 queue 是否为空，否则会发生undefined behavior。</p><h2 id="unordered_map容器">unordered_map容器</h2><p>unordered_map定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = std::hash&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Pred = std::equal_to&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, Ty&gt; &gt; &gt;<br>    <span class="hljs-keyword">class</span> unordered_map;<br>    &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">unordered_map</span><br></code></pre></td></tr></table></figure><ul><li><strong>第1个参数</strong>:存储key值。</li><li><strong>第2个参数</strong>:存储mapped value。</li><li><strong>第3个参数</strong>:为哈希函数的函数对象。它将key作为参数，并利用函数对象中的哈希函数返回类型为size_t的唯一哈希值。默认值为std::hash&lt;key &gt;。</li><li><strong>第4个参数</strong>:为等比函数的函数对象。它内部通过等比操作符’=='来判断两个key是否相等，返回值为bool类型。默认值是std::equal_to&lt;key &gt;。</li></ul><p>基本操作</p><h3 id="插入元素">插入元素</h3><p>一种插入的特殊情况是，unordered_map插入的<strong>值</strong>是int类型(key的类型无所谓)，这时候可以用第二种方式插入:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="删除元素">删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-comment">// 删除</span><br>    mymap.<span class="hljs-built_in">erase</span>(mymap.<span class="hljs-built_in">begin</span>());    <br>    mymap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>    mymap.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找元素">查找元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">if</span>(hash_map.<span class="hljs-built_in">find</span>(key) != hash_map.<span class="hljs-built_in">end</span>())       <span class="hljs-comment">// 查找</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;True&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;False&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="unordered_set容器">unordered_set容器</h2><p>C++ STL 中的 unordered_set是一个关联容器，它提供了一种存储唯一元素的无序集合。与 set不同，unordered_set内部的元素是无序的，因此在插入和查找时，它的性能通常比有序的关联容器 set更快。</p><p>以下是一些 unordered_set 的基本用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个 unordered_set 对象</span><br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 使用 find() 方法查找元素</span><br>    <span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (it != mySet.<span class="hljs-built_in">end</span>())<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 count() 方法检查元素是否在 unordered_set 中</span><br>    <span class="hljs-keyword">if</span> (mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">4</span>) &gt; <span class="hljs-number">0</span>) <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;4 is in the set&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历 unordered_set 中的所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; element : mySet)<br>        std::cout &lt;&lt; element &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Found <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the <span class="hljs-built_in">set</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在 unordered_set中，元素的顺序是不确定的，因此输出的结果可能与上面的示例不完全一致。</p><h2 id="stl中emplace和push的区别">STL中emplace和push的区别</h2><p>在 C++ STL 标准库中，容器中的 <code>emplace()</code> 和<code>push()</code>都可以用来向容器中添加新元素。但是它们的底层实现和作用不同。</p><h3 id="push">push()</h3><p><code>push()</code>是一个成员函数，用于将一个已经构造好的元素加入到容器的尾部，即将元素的副本或引用添加到容器中。因此，需要将元素先构造出来，再将其加入容器中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这里的 <code>push_back()</code> 函数首先构造了一个 int类型的元素，然后将其加入到了 vector 的尾部。</p><h3 id="emplace">emplace()</h3><p><code>emplace()</code>是一个可变参数模板函数，它在容器的尾部直接构造一个新的元素，而不需要将元素构造出来再加入容器。因此，它比<code>push()</code> 更加高效。</p><p>例如，对于 vector 容器来说，下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt; v;<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure><p>将直接在 vector 的尾部构造一个 <code>pair&lt;int, double&gt;</code>类型的元素，而不需要先构造一个 <code>pair&lt;int, double&gt;</code>对象，然后再将其加入到 vector 中。</p><h3 id="总结">总结</h3><ul><li><code>emplace()</code> 可以直接在容器中构造新的元素，而<code>push()</code> 需要先将元素构造出来，再加入到容器中。</li><li><code>emplace()</code> 更加高效，因为它省去了元素构造的过程，而<code>push()</code> 则需要先构造元素，再将其加入容器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉树">什么是二叉树</h2><p>二叉树是一种常见的数据结构，它是每个节点至多有两棵子树的树。</p><p>二叉树有两种特殊的形式，满二叉树和完全二叉树。</p><p><strong>满⼆叉树</strong>：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆叉树为满⼆叉树。一棵深度为k的满二叉树节点个数为<spanclass="math inline">\(2^k -1\)</span>。</p><p><strong>完全⼆叉树</strong>：至多只有最下面的两层结点的度数可以小于2,并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。</p><p><img src="/img/算法/二叉树/完全二叉树和满二叉树.png" /></p><p>我们可以看出满二叉树是完全二叉树， 但完全二叉树不一定是满二叉树。</p><h2 id="二叉搜索树二叉排序树">二叉搜索树（二叉排序树）</h2><p>二叉排序树虽然名叫排序树，但是它其实是用来搜索的，是一种有序的二叉树。它遵循着左小右大的规则：</p><ul><li>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；</li><li>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；</li><li>它的左、右⼦树也分别为⼆叉搜索树。</li></ul><p><img src="/img/算法/二叉树/二叉排序树.jpg" /></p><h2 id="平衡二叉树">平衡二叉树</h2><p>二叉搜索树有一个缺点，在插入数据是有序的序列（包括升序和降序），会导致二叉树退化成链表，从而导致在查找，删除，添加时的性能均从O（logN）降低为O（N），这是不能接受的。</p><p>究其原因，是因为二叉搜索树退化成链表的时候，树的高度与节点的个数相等，也就是成正比，所以为了优化这种情况，就出现了具有平衡能力的二叉搜索树，其中AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O（logN）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G.M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm forthe organization of information》中公开了这一数据结构。</p><p><strong>平衡二叉树的性质</strong></p><p>平衡二叉树本质上是特殊的二叉搜索树（二叉排序树），它具有二叉搜索树所有的特点，此外它有自己的特别的性质，如下：</p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>平衡二叉树的左右两个子树都是一棵平衡二叉树。</li></ul><p>平衡因子指的是，平衡二叉树在保持平衡的时候，是通过平衡因子来判断的</p><p><span class="math display">\[节点的平衡因子 = 该节点的左子树的高度 -该节点右子树的高度\]</span></p><p>只有当值等于-1（右子树的高度大），0（左右子树的高度相等），1（左子树的高度大）的时候，能够代表该子树是平衡的除此之外，就认为该节点已经失衡了，需要旋转来维持平衡。</p><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的遍历是对于理解二叉树以及应对二叉树问题必不可少的因素，甚至有很多算法问题都是基于二叉树的不同遍历算法来做的。</p><p>二叉树的遍历有多种实现方式，不同的方式这里都要熟练掌握，只有熟练掌握不同的遍历方式才能以不变应万变来应对不同的问题。</p><h3 id="递归法">递归法</h3><p>很简单，不需要多说，二叉树的前序、中序、后序遍历其实都是一个模板，区别在于它们将当前节点值添加到结果数组<code>res</code>的时间不一样，而这种区别是由不同遍历方式下父节点与子节点的遍历次序导致的。</p><h4 id="前序遍历">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">oreOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    res.<span class="hljs-built_in">emplace_back</span>(res -&gt; val, res);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; left);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">inOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; left, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历">后序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">postOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; left, res);<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; right, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="迭代法">迭代法</h3><h4 id="前序遍历-1">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历-1">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历-1">后序遍历</h4><p>迭代法的后序遍历相比较前序遍历和中序遍历是要麻烦一些的。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// stk.emplace(cur);</span><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; cur -&gt; right != pre)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);   <span class="hljs-comment">// 若右孩子存在且没有遍历过那么将cur重新压栈，访问右子树</span><br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            pre = cur;<br>            cur = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="morris法">Morris法</h3><p>Morris法只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979年的论文「Traversing Binary Trees Simply andCheaply」中首次提出，因此被称为 Morris 遍历。</p><h4 id="前序遍历-2">前序遍历</h4><p>Morris遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下（假设当前遍历到的节点为<code>cur</code>）:</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>,然后将<code>cur</code>加入答案。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树。<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>这样我们利用 Morris遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)      <span class="hljs-comment">// 左子节点为空直接将val加入res中</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;  <br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h4 id="中序遍历-2">中序遍历</h4><p>Morris法的中序遍历与前序遍历的思想是相同的，不同的是在当前节点的左孩子存在时的处理方式不同，思路如下（假设当前遍历到的节点为<code>cur</code>）：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空，然后将当<code>cur</code>加入答案。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root,* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左子节点为空直接遍历右子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            pre = cur -&gt; left;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>其中 <span class="math inline">\(n\)</span>为二叉搜索树的节点个数。Morris遍历中每个节点会被访问两次，因此总时间复杂度为 <spanclass="math inline">\(O(2n)=O(n)\)</span>。</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>。</li></ul><h4 id="后序遍历-2">后序遍历</h4><p>后续遍历思路依然同上，不同的仍然是把<code>cur</code>加入答案的时机，思路如下：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>        root = root -&gt; right;<br>        count++;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">end</span>() - count, res.<span class="hljs-built_in">end</span>());<br> &#125;<br><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br><br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左孩子不空寻找cur左子树的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">// 为空说明左子树尚未遍历，将pre的右孩子更新为cur</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明左子树已经遍历，将pre右孩子重新置空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-built_in">addPath</span>(res, cur -&gt; left);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左孩子为空直接访问右子树</span><br>            cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-built_in">addPath</span>(res, root); <span class="hljs-comment">// root节点没有parent，所以root需要单独addPath</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，所以由于root节点没有parent，最后要再单独对root节点调用<code>addPath</code>。</strong></p><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><p>上面这种解法是leetcode的官方解法，这里我还有另外一种思路，如上面所说，<strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，那么是否可以采用Morris的方法将输出顺序改为<code>cur</code>、<code>cur</code>的右孩子、<code>cur</code>的左孩子，在输出完之后再统一对<code>res</code>进行翻转？</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) <br>    &#123;<br>        <br>        pre = cur -&gt; right;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// cur右孩子为空，直接将cur加入答案并访问左子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则寻找 `父右左` 遍历模式下的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; left != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; left != cur)<br>                pre = pre -&gt; left;<br>            <span class="hljs-keyword">if</span>(pre -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 为空说明右子树尚未遍历</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; left = cur;<br>                cur = cur -&gt; right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;       <br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明右子树已经遍历</span><br>            &#123;<br>                pre -&gt; left = <span class="hljs-literal">nullptr</span>;<br>                cur = cur -&gt; left;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 翻转数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有右子树的节点只被访问一次，有右子树的节点被访问两次，最后翻转数组。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h2 id="二叉树问题的小trick">二叉树问题的小trick</h2><p>二叉树中有一类问题其实套路是固定的，虽然不同问题要求的东西不一样，但是仔细分析会发现，其实它们用到的套路是一样的。<strong>当一个问题的结果需要树的左右子树也满足条件，且每层子树需要返回的参数一样时，便可以用到递归套路。</strong></p><h3id="一棵子树上的点在深度优先搜索序列即先序遍历中是连续的">一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的</h3><p>可以采用这个套路来求解一个树是否是另一个树的子树，但是但从一个树<code>s</code>的dfs遍历是否是另一个树<code>t</code>的dfs遍历的字串并不能判断出是否是子树，所以想要通过dfs的序列判断s是否是t的子树，还需要做一些额外的处理。</p><p>可以通过引入两个空值 <code>lNull</code> 和<code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<code>s</code>的深度优先搜索序列包含<code>t</code>的深度优先搜索序列」来判断<code>s</code>是否是<code>t</code>的子树。</p><p>这里判断<code>s</code>的遍历序列是否是<code>t</code>遍历序列的子串可以用KMP算法或Rabin-Karp算法</p><h3 id="后序遍历迭代法">后序遍历迭代法</h3><p>采用迭代法的后序遍历，即上边用栈的方法，当遍历到节点 <spanclass="math inline">\(p\)</span> 时，栈中的节点刚好是 <spanclass="math inline">\(p\)</span>的祖先节点，所以此时将栈中节点依次弹出便得到 <spanclass="math inline">\(p\)</span> 的祖先节点的倒序。</p><h3 id="验证二叉搜索树">验证二叉搜索树</h3><p><strong>问题</strong>：给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>分析</strong>：如何判断一个二叉树是否是二叉搜索树？它需要满足两个条件：</p><ol type="1"><li>它的左子树和右子树都是二叉搜索树；</li><li>它的节点值大于左子树的最大值且小于右子树的最小值。</li></ol><p>那么从以上两点出发，就可以构造一个递归套路，每层需要向上层返回自己这颗树是否是二叉搜索树，如果不是那么整个树一定不是二叉搜索树；同时还要向上层返回自己这颗子树的最大值和最小值。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root, LONG_MIN, LONG_MAX);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBST</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= upper || root -&gt; val &lt;= lower)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root -&gt; left, lower, root -&gt; val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root -&gt; right, root -&gt; val, upper);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是反向思维，若<code>cur</code>的值需要大于左子树最大值并且小于右子树最小值，那么就等价于让它的左子树判断其最大值是否小于<code>cur</code>值以及<code>cur</code>右子树判断其最小值是否大于<code>cur</code>值.</p><h3 id="验证平衡二叉树">验证平衡二叉树</h3><p><strong>问题</strong>:给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p><strong>分析</strong>:一个二叉树是平衡二叉树,那么它必然满足它的左右子树都是平衡二叉树,且左右子树的高度差的绝对值不大于1.那么就又可以以相似的方式构造递归,每次需要向上层返回的参数有:</p><ul><li>当前子树是否是平衡二叉树</li><li>当前子树的深度</li></ul><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> is_balance;<br>    <span class="hljs-built_in">isBalancedTree</span>(root, is_balance, height);<br>    <span class="hljs-keyword">return</span> is_balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isBalancedTree</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">bool</span> &amp;is_balance, <span class="hljs-type">int</span> &amp;height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        is_balance = <span class="hljs-literal">true</span>;<br>        height = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">bool</span> left_balance, right_balance;<br>    <span class="hljs-type">int</span> left_height, right_height;<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; left, left_balance, left_height);<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; right, right_balance, right_height);<br>    <span class="hljs-keyword">if</span>(!left_balance || !right_balance || <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)<br>        is_balance = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        is_balance = <span class="hljs-literal">true</span>;<br>    height = <span class="hljs-built_in">max</span>(left_height, right_height) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全二叉树的第k个节点">完全二叉树的第k个节点</h3><p>规定根节点位于第 <span class="math inline">\(0\)</span>层，完全二叉树的最大层数为 <spanclass="math inline">\(h\)</span>。根据完全二叉树的特性可知，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数<span class="math inline">\(h\)</span>。</p><p>当 <span class="math inline">\(0 \le i &lt; h\)</span> 时，第 <spanclass="math inline">\(i\)</span> 层包含 <spanclass="math inline">\(2^i\)</span> 个节点，最底层包含的节点数最少为<span class="math inline">\(1\)</span>，最多为 <spanclass="math inline">\(2^h\)</span>。</p><p>因此对于最大层数为 hhh 的完全二叉树，节点个数一定在 <spanclass="math inline">\([2^h,2^{h+1}-1]\)</span>的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。</p><p>如何判断第 <span class="math inline">\(k\)</span>个节点是否存在呢？如果第 <span class="math inline">\(k\)</span>个节点位于第 <span class="math inline">\(h\)</span> 层，则 <spanclass="math inline">\(k\)</span> 的二进制表示包含 <spanclass="math inline">\(h+1\)</span> 位，其中最高位是 <spanclass="math inline">\(1\)</span>，其余各位从高到低表示从根节点到第 <spanclass="math inline">\(k\)</span> 个节点的路径，<spanclass="math inline">\(0\)</span> 表示移动到左子节点，<spanclass="math inline">\(1\)</span> 表示移动到右子节点。通过位运算得到第<span class="math inline">\(k\)</span>个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 <spanclass="math inline">\(k\)</span> 个节点是否存在。</p><p><img src="/img/算法/二叉树/完全二叉树第k个节点.png" /></p><p>那么如何依次判断k的各个二进制位是否为1呢？这里需要一个<spanclass="math inline">\(bits = 2^{h-1}\)</span>，<spanclass="math inline">\(h\)</span>为要查找节点所在层数(注意根节点是0层),比如现在要查找<spanclass="math inline">\(8\)</span>这个节点，那么<spanclass="math inline">\(bits = 2^{3 - 1} = 0100\)</span>,而<spanclass="math inline">\(8\)</span>的二进制表示是<spanclass="math inline">\(1000\)</span>,用<spanclass="math inline">\(bits\)</span> &amp; <spanclass="math inline">\(1000 = 0\)</span>，所以向左子树走，然后将<spanclass="math inline">\(bits\)</span>左移一位，再与<spanclass="math inline">\(8\)</span>（也就是<spanclass="math inline">\(1000\)</span>）相与得到<spanclass="math inline">\(0010 \&amp; 1000 =0\)</span>,继续向左子树移动，重复上面操作，一直到<spanclass="math inline">\(bits\)</span>为<spanclass="math inline">\(0\)</span>为止，此时节点若不为空，那么就是第<spanclass="math inline">\(8\)</span>个节点。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL-unordered_map中自定义哈希函数</title>
    <link href="/2023/02/24/Cpp-STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2023/02/24/Cpp-STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2id="unordered_map中自定义哈希函数">unordered_map中自定义哈希函数</h2><p>内容转载自<ahref="https://blog.csdn.net/qq_34525916/article/details/115896842">c++unordered_set，unordered_map中自定义哈希函数</a></p><p>如果想用哈希的时候，但是哈希的目标又不再STL标准的类型内，比如一个自定义的class，就不太方便使用STL默认的哈希函数，比较函数，那么就需要重写了。</p><p><strong>将自定义类型作为unordered_map的键值，需如下两个步骤</strong>：</p><ol type="1"><li>定义自定义key的哈希函数的函数对象，告知此容器如何生成hash的值；</li><li>定义等比函数的函数对象或者在自定义类里重载operator==()，告知容器当出现hash冲突的时候，如何区分hash值相同的不同对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">Line</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2)&#123;<br>       k = d1;<br>       b = d2;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Line&amp; other)<span class="hljs-type">const</span>&#123;<span class="hljs-comment">//重载operator==(),若没有重载==则定义 unordered_map 时需要isEqual</span><br>        <span class="hljs-keyword">return</span> other.k ==k &amp;&amp; other.b == b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">createhash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span>  Line l)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// size_t</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//return size_t(l.k ^ l.b);//自定义哈希</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.k) ^  <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.b);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">isEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span> Line l1, <span class="hljs-type">const</span> Line l2)</span> <span class="hljs-type">const</span><span class="hljs-comment">//最后的const不能少</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//unordered_map&lt;Line ,int , createhash, isEqual&gt; mm;//若使用这种方式,Line类中不需要重载==</span><br>    unordered_map&lt;Line ,<span class="hljs-type">int</span> , createhash&gt; mm; <br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">1</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">auto</span> success = mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">if</span>(success.second == <span class="hljs-literal">false</span>)<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;mm insert failed &quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : mm)<br>    &#123;<br>        std::cout&lt;&lt; ele.first.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.first.b&lt;&lt;std::endl; <br><br>    &#125;<br><br>    <span class="hljs-comment">//unordered_set&lt;Line, createhash&gt; ms;</span><br>    unordered_set&lt;Line, createhash, isEqual&gt; ms;<span class="hljs-comment">//若使用这种方式,Line类中不需要重载==</span><br>    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">auto</span> it = ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">if</span>(it.second == <span class="hljs-literal">false</span>)<br>       std::cout&lt;&lt;<span class="hljs-string">&quot;ms insert failed &quot;</span>&lt;&lt;std::endl; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : ms)<br>    &#123;<br>        std::cout&lt;&lt; ele.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.b&lt;&lt;std::endl; <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表内部传递方式和内存占用">哈希表内部传递方式和内存占用</h3><ol type="1"><li>放入哈希表的key，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。</li><li>放入哈希表的key，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ lambda函数用法</title>
    <link href="/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Lambda表达式（也叫lambda函数，或简称lambda），是从C++11开始引入并不断完善的，是能够捕获作用域中变量的匿名函数对象。因为C++是不能嵌套定义函数的，所以lambda就成了我们构造闭包的主要手段，不过在对象的生命周期上还是有点不同。</p><h2 id="lambda基本语法">Lambda基本语法</h2><figure><img src="/img/C++/lambda/lambda基本语法.png" alt="lambda基本语法" /><figcaption aria-hidden="true">lambda基本语法</figcaption></figure><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。下面对重要的组成部分进行说明：</p><h3 id="捕获列表">捕获列表</h3><p><strong>值捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=100,因为i是创建时拷贝的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [&amp;i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=0, 因为传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（隐式捕获），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p><p><strong>lambda捕获列表：</strong></p><ul><li>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</li><li>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>[this]。函数体内可以使用Lambda所在类中的成员变量。</li><li>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>[&amp;a]。将a按引用进行传递。</li><li>[=，&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>悬垂引用：</strong></p><p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p><h3 id="形参列表">形参列表</h3><p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C++14前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C++14起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> &amp;b) &#123;<br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//输出：10  20</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(i,j);<br><span class="hljs-comment">//输出：1 20</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>) &#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">f</span>(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明符">说明符</h3><ul><li>mutable：允许函数体修改各个复制捕获的对象，以及调用其非 const成员函数;</li><li>constexpr：显式指定函数调用运算符为 constexpr函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr函数的所有要求，则它也会是 constexpr； (C++17 起)</li><li>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和constexpr。(C++20 起)</li></ul><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span><br><span class="hljs-keyword">auto</span> f = [i, &amp;j]() <span class="hljs-keyword">mutable</span> &#123;<br>i = <span class="hljs-number">100</span>, j = <span class="hljs-number">100</span>;<br>&#125;;<br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//输出:0 100</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回类型--">返回类型 -&gt;</h3><p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的return语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = []() -&gt; <span class="hljs-type">double</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p><h3 id="函数体">函数体 <span class="math inline">\(\{ \}\)</span></h3><p>略，同普通函数的函数体。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::accumulate函数用法</title>
    <link href="/2023/02/24/Cpp-accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/Cpp-accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>accumulate定义在#include<numeric>中，有两种用法，一个是累加求和，另一个是自定义类型数据的处理</p><h2 id="默认累加求和">默认累加求和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="自定义对数据的处理">自定义对数据的处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> BinaryOperation &gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init,</span></span><br><span class="hljs-params"><span class="hljs-function">                        BinaryOperation op )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><p><strong>first, last</strong>: 要求和的元素范围</p><p><strong>init</strong>：和的初值</p><p><strong>op</strong>:被使用的二元函数对象。接收当前积累值 a （初始化为init ）和当前元素 b 的二元运算符。</p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// accumulate example</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">// std::minus</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>      <span class="hljs-comment">// std::accumulate</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">2</span>*y;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myclass</span> &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>*y;&#125;<br>&#125; myobject;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> init = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> numbers[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using default accumulate: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers,numbers+<span class="hljs-number">3</span>,init);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using functional minus: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom function: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers, numbers + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, [](<span class="hljs-type">int</span> a, Grade b)&#123;<span class="hljs-keyword">return</span> a + b * <span class="hljs-number">2</span>; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom object: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, myobject);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">using</span> <span class="hljs-keyword">default</span> accumulate: <span class="hljs-number">160</span><br><span class="hljs-keyword">using</span> functional minus: <span class="hljs-number">40</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-keyword">function</span>: <span class="hljs-number">120</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-type">object</span>: <span class="hljs-number">280</span><br></code></pre></td></tr></table></figure><p>转载自<ahref="https://blog.csdn.net/gongjianbo1992/article/details/105128849">C++Lambda表达式的基本使用</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中数学公式换行问题</title>
    <link href="/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-书写-latex-公式时的一些问题及解决方法">Hexo 书写 LaTeX公式时的一些问题及解决方法</h2><p>使用hexo撰写博客的时候难免会用到数学公式，，如果公式过长，我们通常希望把方程分成多行显示，这时候就需要用到换行符号<code>\\</code>，但是写出来的Markdown 经过 Hexo 的处理以后显示不正确，这与 Hexo的渲染引擎有关系。</p><p>Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax支持，因此首先要启用 MathJax 才能渲染 LaTeX公式.但是它并不支持MathJax换行，这是因为我们的markdown文件首先会被hexo-theme-marked的marked.js解析，这就会使得使用Latex语法所写的MathJax公式中的_和，最后轮到MathJax来对公式进行解析就出错了。</p><h3 id="安装hexo-renderer-pandoc">安装hexo-renderer-pandoc</h3><p>为了使用pandoc作为Hexo的渲染引擎，我们需要安装插件hexo-renderer-pandoc，步骤如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载默认渲染插件</span><br><span class="hljs-built_in">npm</span> install hexo-renderer-pandoc --svae <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p>但是在安装pandoc之后发现，公式中使用<code>\\</code>仍然不能换行，经过一番折腾之后发现了一个曲线救国的方法：在需要换行的公式加上align对齐：</p><p>例如</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>在显示的时候会发现并没有换行</p><p><img src="/img/latex/错误用法.png" /></p><p>而加上aligin之后就可以正常换行</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br><span class="hljs-built_in">&amp;</span>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> <span class="hljs-built_in">&amp;</span>B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]  <br><span class="hljs-keyword">\end</span>&#123;align&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p><img src="/img/latex/正确用法.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的随机过程</title>
    <link href="/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="正态过程">正态过程</h2><h3id="多维正态分布的概率密度和特征函数">多维正态分布的概率密度和特征函数</h3><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数.png" /></p><p>记 <imgsrc="/img/随机过程/常见随机过程/正态概率密度符号替换.png" /></p><p>则<span class="math inline">\((X,Y)\)</span>的联合概率密度为</p><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-新.png" /><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-注.png" /></p><h3 id="证明随机过程xt是正态过程">证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程</h3><p>要证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程，即证对<spanclass="math inline">\(\forall t_1,t_2,\dots\)</span> , <spanclass="math inline">\(t_n，(X(t_1),X(t_2),\dots,X(t_n))\)</span>是<spanclass="math inline">\(n\)</span>维正态分布。</p><h4 id="方法1用特征函数">方法1：用特征函数</h4><h4 id="方法2正态分布的线性不变性">方法2：正态分布的线性不变性</h4><p><strong>正态分布的线性不变性</strong>:</p><p><img src="/img/随机过程/常见随机过程/正态分布线性不变性.png" /></p><p><strong>正态分布的线性变换不变性</strong>:</p><p><imgsrc="/img/随机过程/常见随机过程/正态分布的线性变换不变性.png" /></p><h2 id="维纳过程">维纳过程</h2><p><img src="/img/随机过程/常见随机过程/维纳过程条件.png" /> <imgsrc="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><h3 id="维纳过程的分布">维纳过程的分布</h3><p><img src="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><p>设<span class="math inline">\(t&gt;s\)</span>，因<spanclass="math inline">\(W(0)=0\)</span>,且<spanclass="math inline">\(W(t)\)</span>是平稳独立增量过程，故</p><p><span class="math display">\[W(t) - W(s) = W(t-s+s)-W(s)\]</span></p><p>与</p><p><span class="math display">\[W(t-s) - W(0) = W(t-s)\]</span>有相同分布<span class="math inline">\(N(0,\sigma^2 (t-s))\)</span>。</p><p><strong>维纳过程是正态过程</strong>。</p><h3 id="维纳过程的数字特征">维纳过程的数字特征</h3><p><strong>维纳过程是平稳独立增量过程</strong>，其数字特征如下。</p><p><img src="/img/随机过程/常见随机过程/维纳过程的数字特征.png" /></p><h2 id="计数过程和泊松过程">计数过程和泊松过程</h2><h3 id="定义">定义</h3><p><strong>计数过程</strong>：</p><p><img src="/img/随机过程/常见随机过程/计数过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/计数过程定义2.png" /></p><p><strong>Poisson过程是一类很重要的计数过程</strong>。</p><p><strong>Poisson过程数学模型</strong>：</p><p><img src="/img/随机过程/常见随机过程/泊松过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程定义2.png" /></p><h3 id="齐次泊松过程">齐次泊松过程</h3><p><img src="/img/随机过程/常见随机过程/齐次泊松过程定义.png" /></p><h3 id="泊松过程的等价定义">泊松过程的等价定义</h3><p><img src="/img/随机过程/常见随机过程/泊松过程等价定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程等价定义2.png" /></p><h3 id="齐次泊松过程的有关结论">齐次泊松过程的有关结论</h3><h4 id="数字特征">数字特征</h4><p><strong>均值函数</strong>： <spanclass="math inline">\(m(t)=E\{N(t)\}=\lambda t\)</span></p><p><strong>方差函数</strong>: <span class="math inline">\(D(t)=\lambdat\)</span></p><p><strong>协方差函数</strong>: <spanclass="math inline">\(C(s,t)=\lambda min(s,t)\)</span></p><p><strong>相关函数</strong>： <spanclass="math inline">\(R(s,t)=\lambda min(s,t)+\lambda^2 st\)</span></p><p>故有<spanclass="math inline">\(\lambda=\frac{E\{N(t)\}}{t}\)</span>,称<spanclass="math inline">\(\lambda\)</span>为<strong>事件的到达率</strong>或<strong>单位时间内事件出现的平均次数</strong>。</p><h3 id="时间间隔与等待时间的分布">时间间隔与等待时间的分布</h3><p>如下图所示，<spanclass="math inline">\(N(t)\)</span>是轨道是跃度为<spanclass="math inline">\(1\)</span>的阶梯函数。</p><p><img src="/img/随机过程/常见随机过程/N（t）的分布函数.png" /></p><p>用<span class="math inline">\(T_n\)</span>表示事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n-1\)</span>次出现与第<spanclass="math inline">\(n\)</span>次出现的时间间隔。<spanclass="math inline">\(W_n\)</span>为事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n\)</span>次出现的<strong>等待时间(到达时间)</strong>，则有：</p><p><span class="math display">\[W_n=\sum\limits_{i=1}^nT_i\]</span></p><p>和</p><p><span class="math display">\[T_n=W_n - W_{n-1}\]</span></p><p><img src="/img/随机过程/常见随机过程/时间间隔序列分布定理.png" /></p><h3 id="到达时间的条件分布">到达时间的条件分布</h3><p><img src="/img/随机过程/常见随机过程/引理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理2.png" /> <imgsrc="/img/随机过程/常见随机过程/注1.png" /> <imgsrc="/img/随机过程/常见随机过程/注2.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性空间</title>
    <link href="/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="线性空间">线性空间</h2><p><strong>线性空间定义</strong>： <imgsrc="/img/矩阵论/线性空间/线性空间定义.jpg" /></p><p><strong>线性子空间定义</strong>：</p><p><img src="/img/矩阵论/线性空间/线性子空间定义.png" /></p><p><strong>平凡子空间</strong>：<spanclass="math inline">\(V\)</span>空间的平凡子空间指<spanclass="math inline">\(0\)</span>空间和<spanclass="math inline">\(V\)</span>空间本身，其他维数的空间都是非平凡子空间。</p><p><strong>线性空间的和</strong>：</p><p><img src="/img/矩阵论/线性空间/线性空间的和.jpg" /></p><h3 id="维数定理">维数定理</h3><p><img src="/img/矩阵论/线性空间/维数定理.png" /></p><h3 id="直和">直和</h3><p><img src="/img/矩阵论/线性空间/直和定义.png" /></p><h4id="判断线性空间v的两个子空间v_1和v_2是否是直和的方法">判断线性空间V的两个子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>是否是直和的方法</h4><p>判断<span class="math inline">\(V_1 \cap V_2 =\{0\}\)</span>是否成立，若成立，就是直和；否则不是直和。</p><p>将子空间的概念推广到多个子空间，于是在多个子空间中就可以定义这样的直和关系：</p><p><img src="/img/矩阵论/线性空间/多个子空间的直和.jpg" /></p><h3 id="酉空间">酉空间</h3><p>欧几里得空间：定义了内积的实线性空间。</p><p>欧几里得空间的定义推广到复线性空间就是酉空间。</p><h3 id="正交补子空间">正交补子空间</h3><p><img src="/img/矩阵论/线性空间/正交补子空间定义.png" /></p><p>这里的<spanclass="math inline">\(V_n(C)\)</span>指的是酉空间。这里的<spanclass="math inline">\(n\)</span>表示维数，<spanclass="math inline">\(C\)</span>表示复数空间。这个定义指的是复数域内的<spanclass="math inline">\(n\)</span>维空间，即是酉空间。</p><p>也就是说，一个空间V的子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>不仅要满足直和的关系，还要相互正交。<strong>这样的空间我们称<spanclass="math inline">\(V_2\)</span>为<spanclass="math inline">\(V_1\)</span>的正交补子空间（或简称正交补）</strong>。显然，二者是互为正交补的。<strong>正交补分解实际上就是在分正交基。直和分解实际上就是在分解基向量</strong>。</p><p><strong>定理</strong>：<spanclass="math inline">\(V_n(C)\)</span>的任意子空间<spanclass="math inline">\(V_1\)</span>都有唯一的正交补。</p><h3 id="kronecker积">Kronecker积</h3><h4 id="kronecker积-1">Kronecker积</h4><p><img src="/img/矩阵论/线性空间/Kronecker积.png" /></p><p>其中<span class="math inline">\(a_{ij}\)</span>为矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列的元素，对于<spanclass="math inline">\(A \in \mathbb{R^{m × n}}\)</span> 和 <spanclass="math inline">\(B \in \mathbb{R^{p × q}}\)</span>,<spanclass="math inline">\(A \otimes B \in \mathbb{R^{(mp) ×(nq)}}\)</span>。</p><p><strong>Kronecker积的性质如下</strong>：</p><p><img src="/img/矩阵论/线性空间/Kronecker积性质1.png" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质2.jpg" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质3.png" /></p><p>这些性质中前4条与矩阵运算完全相同，从第5条开始是Kronecker积独有的性质。</p><p>给出一些定义和定理：</p><p><img src="/img/矩阵论/线性空间/Kronecker积定理.jpg" /></p><p>Kronecker积的特征值：</p><p><img src="/img/矩阵论/线性空间/Kronecker积的特征值.jpg" /></p><h4 id="kronecker和">Kronecker和</h4><p><img src="/img/矩阵论/线性空间/Kronecker和.jpg" /></p><p>由定义2我们可以看到，对于Kronecker积而言，m阶矩阵和n阶矩阵之间是无法直接求和的，所以，我们通过对单位阵的Kronecker积运算，同时把他们化为<spanclass="math inline">\((m ×n)\)</span>阶方阵，这样就可以对矩阵进行求和运算了。</p><h4 id="向量化算符">向量化算符</h4><p><img src="/img/矩阵论/线性空间/向量化算符.png" /></p><p>性质：</p><p><img src="/img/矩阵论/线性空间/向量化算符性质.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题的一些心得</title>
    <link href="/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>记录一下在刷题的时候的一些小trick以及踩的一些坑。</p><!-- ### string.size()`string.size()`返回的是一个无符号数，所以在循环中如果需要对使用`s.size()`的话，需要使用`(int)s.size()`。 --><h2 id="滑动窗口">滑动窗口</h2><p>滑动窗口就是<strong>不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。它通常用于字符串或者数组特定长度下内容是否相同，也可以查找在内容相同情况下的最短长度(一般来说需要查找的数组或者字符串是连续的)。</p><h2 id="时间复杂度master公式">时间复杂度（Master公式）</h2><p>若有<span class="math inline">\(T(N)=a * T(\frac{N}{b})+O(N^d)\)</span>，则说明这个算法满足<strong>Master公式</strong>。也就是说只要是<strong>满足子问题等规模的递归都可以用Master公式</strong>。a，b，d的值可能会有三种情况。</p><ol type="1"><li><span class="math inline">\(\log_b a &lt;d\)</span>,则算法时间复杂度为<spanclass="math inline">\(O(N^d)\)</span>。</li><li><span class="math inline">\(\log_b a &gt;d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^{\log_ba})\)</span>。</li><li><span class="math inline">\(\log_b a =d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^d * \logn)\)</span>。</li></ol><h2 id="链表">链表</h2><h3 id="重要技巧">重要技巧</h3><h4 id="额外数据结构记录哈希表等">额外数据结构记录（哈希表等）</h4><p>此技巧一般只适用于笔试做题，面试一般不适用。</p><p>设置额外的数据结构，比如数组、哈希表或者栈等来辅助做题。</p><h4 id="快慢指针">快慢指针</h4><p>有一些问题诸如寻找链表的中点，最简单暴力的方法是遍历一遍链表然后得到链表长度，然后根据长度得到其最中间的节点。这样做有一个问题，就是需要遍历一遍半的链表。而使用快慢指针就可以少遍历一遍链表。</p><p>它的思想是设置一个<code>fast</code>节点和一个<code>slow</code>节点，每次<code>fast</code>节点往后走两步，而<code>slow</code>节点往后走一步。这样当<code>fast</code>节点走完整个链表的时候，<code>slow</code>节点就在链表的中间。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点。偶数长度返回上中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">nullptr</span>)<br>            fast = fast -&gt; next;<br>      <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>&#125;<br></code></pre></td></tr></table></figure><p>需要特别注意的是，<strong>不要死记这代码，实际上在做题或者应用中的不同情况是是有很多细微的差别的，比如若链表长度是偶数，有的时候需要中间靠前的节点，有的时候需要中间靠后的节点，还有的时候需要中间靠前节点的前驱节点，不同情况要做对应的调整，同时还要注意边界条件，比如节点为空或者只有一个节点的情况。</strong></p><p>链表长度为偶数情况下，寻找中间靠后的那个节点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点，偶数长度返回下中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>      fast = fast -&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><!-- - 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点后一个 --><h3 id="面试时链表解题方法论">面试时链表解题方法论</h3><ol type="1"><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。比如可以直接把链表copy到数组。</li><li>对于面试，时间复杂度仍然放在第一位，但是要找到空间复杂度最省的方法。</li></ol><h2 id="打表法">打表法</h2><p>在刷题过程中经常会遇到一类题，这类题的特点是：<strong>输入简单，可能是一个或几个数或数组，输出也简单，可能只让你返回一个整形的结果。</strong>当然，一般的方法是根据题目的要求编写对应的算法求解。但是有时候这种方法并不那么容易实现或者并不那么容易想，这个时候可以考虑一种比较取巧的方法：打表法。</p><p>打表法就是用暴力方法先求出前面几十个或一百个解，从中找出其规律，然后根据规律直接编写对应方法求解。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平稳过程</title>
    <link href="/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="严平稳过程">严平稳过程</h2><p><img src="/img/随机过程/平稳过程/严平稳过程定义.png" /> <imgsrc="/img/随机过程/平稳过程/严平稳过程定义-2.png"alt="严平稳过程定义" /></p><p>严平稳过程有限维分布不随时间的推移而改变，，它的当前变化情况与过去的情况有不可忽视的联系。</p><p>严平稳过程的一维分布与时间无关，而二维分布仅与<spanclass="math inline">\(t_1\)</span>和<spanclass="math inline">\(t_2\)</span>的时间间隔有关，与时间起点无关。</p><h2 id="宽平稳过程">宽平稳过程</h2><p>由于</p><ul><li>工程中确定一个过程的有限维分布函数族,进而判定过程的严平稳性十分困难；</li><li>部分随机过程(如正态过程)的概率特征主要由一阶和二阶矩函数确定；</li><li>工程实际中,通常仅需在相关理论范畴内考虑平稳过程,即只限于研究一、二阶矩（均值、相关函数等）理论.</li></ul><p>所以有了宽平稳过程。</p><p>定义： <img src="/img/随机过程/平稳过程/宽平稳过程定义.png"alt="宽平稳过程定义" /></p><p>其中<span class="math inline">\(R_x(\tau)\)</span>为<spanclass="math inline">\(\{X(t),t \inT\}\)</span>的自相关函数。其协方差函数为 <spanclass="math display">\[C_X(s,t)=R_X(s,t)-|m_X|^2=R_X(\tau)-|m_X|^2\]</span></p><p>自协方差函数与自相关函数都仅依赖于<spanclass="math inline">\(t－s\)</span></p><p><strong>维纳过程不是宽平稳过程，但是维纳过程是增量宽平稳过程，即</strong><span class="math display">\[X(t)=W(t+a)-W(t), t \ge 0, \quad(a&gt;0)\]</span></p><p>是宽平稳过程</p><h2 id="两种平稳性的关系">两种平稳性的关系</h2><ul><li>严平稳过程不一定是宽平稳的;</li></ul><p>因宽平稳过程一定是二阶矩过程, 而严平稳过程未必是二阶矩过程.</p><ul><li>宽平稳不一定 严平稳;</li><li>严平稳过程是宽平稳过程的充要条件是其二阶矩存在.</li><li>对于正态过程, 宽平稳性与严平稳性等价.</li></ul><h2 id="平稳过程的自相关函数">平稳过程的自相关函数</h2><p><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-1.png" /><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-2.png" /></p><p>证明:</p><ol type="1"><li><img src="/img/随机过程/平稳过程/自相关证明1.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明2.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明3.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明4.png" /></li></ol><p>推论： <img src="/img/随机过程/平稳过程/自相关函数推论.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.2.png" /></p><p>证明： <img src="/img/随机过程/平稳过程/5.2.2证明.png" /></p><p>定理: <img src="/img/随机过程/平稳过程/定理5.2.3.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.4.png" /></p><p>推论： <img src="/img/随机过程/平稳过程/定理5.2.4推论1.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广义逆矩阵</title>
    <link href="/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="单边逆">单边逆</h2><p>所谓矩阵的单边逆就是指矩阵的左逆和右逆。</p><figure><img src="/img/矩阵论/单边逆定义.png" alt="矩阵的单边逆" /><figcaption aria-hidden="true">矩阵的单边逆</figcaption></figure><p><strong>定理1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(A\)</span>为列满秩矩阵</li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(A\)</span>为行满秩矩阵</li></ul><p><strong>推论1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(N(A)=\{0\}\)</span></li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(R(A)=\mathbb{C}^m\)</span></li></ul><h3 id="单边逆的求法">单边逆的求法</h3><p><strong>例1</strong>: <img src="/img/矩阵论/例1-1.png" /> <imgsrc="/img/矩阵论/例1-2.png" /></p><p><strong>例2</strong>: <img src="/img/矩阵论/例2-1.png" /> <imgsrc="/img/矩阵论/例2-2.png" /></p><p>需要注意的是例1求左逆矩阵进行的是初等行变换,例2求右逆矩阵是进行的初等列变换，初等行变换我们在线性代数中常用，比较熟悉，但是要求右逆矩阵一定要进行初等列变换。</p><h2 id="广义逆矩阵">广义逆矩阵</h2><p><strong>定义</strong>: <img src="/img/矩阵论/广义逆定义.png" /></p><p><strong>性质</strong>: <img src="/img/矩阵论/广义逆定理1.png" /></p><p>推论: <img src="/img/矩阵论/广义逆推论1.png" /></p><p>需要注意的是，同线性代数中的矩阵的逆不同的是，这里求的广义逆一般不唯一。既然不唯一，有许多解的话，我们就考虑是否有一个通解可以将所有的广义逆全部表示呢？的确有，下面我们就介绍定理2，该定理表示的就是全部的广义逆：</p><p><img src="/img/矩阵论/全部广义逆集合定义.png" /></p><p><strong>定理2</strong>(不常考): <imgsrc="/img/矩阵论/广义逆定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆定理2-2.png" /></p><p><strong>定理3</strong>: <img src="/img/矩阵论/广义逆定理3-1.png" /><img src="/img/矩阵论/广义逆定理3-2.png" /></p><ul><li>(i)是逆矩阵性质在广义逆的推广</li><li>(ii)说的是一个矩阵乘以他的广义矩阵是幂等矩阵，且他们矩阵的秩相等</li><li>(iii)可以看出0矩阵的广义逆矩阵可以是任何矩阵（包括0矩阵）</li><li>(v)说的是<span class="math inline">\(AA^{-1}\)</span>与<spanclass="math inline">\(A\)</span>的值域相同,<spanclass="math inline">\(A^{-1}A\)</span>与<spanclass="math inline">\(A\)</span>的零空间相同,证明如下:</li></ul><p><img src="/img/矩阵论/定理3(v)证明.png" /></p><h2 id="自反广义逆矩阵">自反广义逆矩阵</h2><p>自反广义逆矩阵是广义逆矩阵里的一类特殊矩阵,其定义如下: <imgsrc="/img/矩阵论/自反广义逆矩阵定义.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/自反广义逆矩阵定理1.png" /></p><p>需要注意的是，自反广义逆矩阵并不唯一。事实上，对于 <imgsrc="/img/矩阵论/广义逆矩阵/图1.png" /></p><p>构造这样的矩阵 <img src="/img/矩阵论/广义逆矩阵/图2.png" /></p><p>所有满足这样条件的矩阵G，就是A的自反广义逆。所以自反广义逆并不唯一.</p><p><strong>定理2</strong>(考试不要求): <imgsrc="/img/矩阵论/广义逆矩阵/定理2.png" /></p><p>定理2给出了自反广义逆矩阵的一种具体的构造方法,</p><p><strong>定理3</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/定理3.png" /></p><p>定理3给出了在广义逆矩阵中，区分自反广义逆的一种有效方法。当广义逆矩阵的秩等于矩阵A的秩的时候是自反广义逆。当广义逆的秩大于矩阵A的秩的时候是广义逆矩阵而不是自反广义逆矩阵。</p><h2 id="m-p广义逆矩阵">M-P广义逆矩阵</h2><p>M-P广义逆矩阵（Moore-Penrose）矩阵是在自反广义逆矩阵之上又加了两个条件形成的矩阵，要求更加苛刻。我们一般用<span class="math inline">\(A^+\)</span> 来表示M-P广义逆矩阵。 <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定义.png" /></p><p>这四个条件，共同保证了 <span class="math inline">\(A^+\)</span>的<strong>唯一性</strong>。</p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理1.png" /></p><p>该定理给出了<span class="math inline">\(A^+\)</span>的具体计算方法。定理的证明直接用该式子验证定义中的四个式子即可.</p><p><strong>定理2</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则 <spanclass="math inline">\(A^+\)</span>是唯一的.</p><p>这一点已经在上面提到过了,定义中的四个式子保证了<spanclass="math inline">\(A^+\)</span>的唯一.</p><h3 id="m-p广义逆的性质">M-P广义逆的性质</h3><p><img src="/img/矩阵论/广义逆矩阵/M-P广义逆定理3.png" /></p><p><strong>定理5</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理5.png" /></p><h3 id="m-p广义逆的计算">M-P广义逆的计算</h3><h4 id="最大秩分解">最大秩分解</h4><p><img src="/img/矩阵论/广义逆矩阵/引理1.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆的计算定理1.png" /></p><p><strong>例1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-2.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-3.png" /></p><h4 id="奇异值分解法">奇异值分解法</h4><p><strong>定理2</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-2.png" /></p><h3 id="m-p广义逆的应用">M-P广义逆的应用</h3><h4 id="判断方程有没有解">判断方程有没有解</h4><p>求出<span class="math inline">\(A^+\)</span>,判断<spanclass="math inline">\(AA^+b\)</span>是否等于<spanclass="math inline">\(b\)</span>,若不等于则没有解，否则有解。</p><h4id="求方程的最佳逼近解最小范数解最小二乘解">求方程的最佳逼近解/最小范数解/最小二乘解</h4><p>当方程有解的时候，可以求得最小范数解为<spanclass="math inline">\(A^+b\)</span>；当方程没有解的时候，可以求出最佳逼近解为<spanclass="math inline">\(A^+b\)</span>，最小二乘通解为<spanclass="math inline">\(A^+ b+(I-A^+ A)u, \forall u \in\mathbb{C}^n\)</span>,其中<span class="math inline">\(A\)</span>为<spanclass="math inline">\(n\)</span>阶矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    <url>/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"> --><h2id="三角分解qr分解需要是非奇异矩阵">三角分解(QR分解)(需要是非奇异矩阵)</h2><h3id="正交三角分解通过schmidt正交化">正交三角分解(通过Schmidt正交化)</h3><p>若 <span class="math inline">\(n\)</span> 阶实矩阵 <spanclass="math inline">\(A\in \mathbb {C}^{n\times n}\)</span> 满秩，且<span class="math display">\[A = [\alpha_1,...,\alpha_n]\]</span></p><p>其中 <span class="math inline">\(\alpha_1,...,\alpha_n\)</span> 是<span class="math inline">\(\mathbb {C}^{n\times n}\)</span>中线性无关向量组</p><p><strong>正交化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned} \beta_1&amp;=\alpha_1\\\beta_2&amp;=\alpha_2 -\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1\\ \vdots \\ \beta_n &amp;= \alpha_n -\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}\end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \alpha_1 &amp;=\beta_1\\ \alpha_2 &amp;=\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1+ \beta_2\\ \vdots \\ \alpha_n &amp;=\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}+ \beta_n \end{aligned} \]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\alpha_1,\alpha_2,...,\alpha_n\end{bmatrix} &amp;=\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;\triangleqB\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix} \end{aligned}\]</span></p><p><strong>单位化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned}q_1=&amp;\frac{\beta_1}{||\beta_1||} \\ &amp;\vdots \\ q_n =&amp; \frac{\beta_n}{||\beta_n||} \end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \beta_1 =&amp;q_1||\beta_1|| \\ &amp;\vdots \\ \beta_n =&amp; q_n ||\beta_n||\end{aligned}\]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix} &amp;=\begin{bmatrix}q_1,q_2,...,q_n\end{bmatrix}\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\end{aligned} \]</span></p><p>综上，结合正交化和单位化可得</p><p><span class="math display">\[ \begin{aligned} A &amp;=B\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp;||\beta_n||\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;||\beta_2||&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq QR \end{aligned} \]</span></p><p><strong>QR 分解定理</strong> : <span class="math inline">\(A\in\mathbb {C}^{n\times n}\)</span> ,则存在酉矩阵 <spanclass="math inline">\(Q\)</span> 和正线上三角阵 <spanclass="math inline">\(R\)</span> ，使 <spanclass="math display">\[A=QR\]</span></p><p>且分解唯一</p><p><strong>正交三角分解的求法</strong> 1. 取矩阵 <spanclass="math inline">\(A=(A_1,A_2,...,A_n)\)</span> 的列向量，进行<strong>Schmidt 标准正交化</strong>,得 <spanclass="math inline">\(v_1,v_2,...,v_n\)</span> ，有 <spanclass="math display">\[Q=(v_1,v_2,...,v_n)\]</span> 2. 再由 <spanclass="math inline">\(R=Q^HA\)</span> 得到 <spanclass="math inline">\(R\)</span> , 于是 <spanclass="math inline">\(A=QR\)</span></p><h3 id="householder变换分解">HouseHolder变换分解</h3><p>将矩阵A按列划分为 <spanclass="math inline">\((\alpha_1,\alpha_2,\dots,\alpha_n)\)</span>,以4阶方阵为例，</p><p>第一步 令 <spanclass="math display">\[\omega_1=\frac{\alpha_1-a_1*e_1}{||\alpha_1-a_1*e_1||_2}，a_1=||\alpha_1||_2\]</span></p><p>于是 <spanclass="math display">\[H_1A=(H_1\alpha_1,H_1\alpha_2，...，H_1\alpha_n)=\left\{\begin{matrix} a_1 &amp; * &amp; \cdots &amp; * \\                   0      &amp; \\                   \vdots &amp; &amp;B_1 \\0\end{matrix}\right\}\]</span></p><p>第二步</p><p>从第一步中得到 <spanclass="math inline">\(B_1=(\beta_2,\beta_2,\cdots,\beta_n)\inR^{n-1}\)</span></p><p>取 <spanclass="math display">\[\omega_2=\frac{\beta_2-b_2*e_1}{||\beta_2-b_2*e_1||_2}，b_1=||\beta_2||_2\]</span></p><p>则 <spanclass="math display">\[\widehat{H_2}=I-2*\omega_2*\omega_2^T,H_2=\left\{\begin{matrix}1 &amp; 0^T \\                                                              0 &amp;\widehat{H_2}，                                              \end{matrix}\right\}\]</span></p><p>得到 <span class="math display">\[H_2(H_1*A) = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp;* \\                                       0 &amp; a_2 &amp; * &amp; \cdots&amp;* \\                                       0 &amp; 0 &amp;  &amp;\\                                       \vdots &amp; \vdots&amp;  &amp;C_2&amp; \\                                       0 &amp; 0\end{bmatrix} , C_2\in R^{n-2}\]</span></p><p>依次类推，进行第n步时，得到第n-1个 <spanclass="math inline">\(H_{n-1}\)</span>阵,使得 <spanclass="math display">\[H_{n-1} \cdots H_2H_1*A = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp; * \\                                                   0 &amp; a_2 &amp; *&amp; \cdots &amp; * \\                                                   0 &amp; 0 &amp; a_3&amp; \cdots &amp; *\\                                                  \vdots &amp; \vdots&amp; &amp;\ddots \\                                                    0 &amp; 0 &amp; 0&amp; \cdots &amp;a_n\end{bmatrix}=R\]</span></p><p>其中 <span class="math inline">\(H_{n-1} \cdotsH_2H_1*A=H\)</span>也称为HouseHolder矩阵，也为自逆矩阵 <spanclass="math inline">\(H=H^{-1}\)</span></p><p><span class="math display">\[H_{n-1} \cdots H_2H_1*A=R\]</span> <spanclass="math display">\[\Rightarrow (H_{n-1} \cdots H_2*H_1)^{-1}*H_{n-1}\cdots H_2H_1*A=(H_{n-1} \cdots H_2*H_1)^{-1}*R\]</span> <spanclass="math display">\[\Rightarrow A=H_1^{-1} \cdotsH_{n-1}^{-1}*R\]</span> <span class="math display">\[\RightarrowA=H_1\cdots H_{n-1}*R\]</span></p><p>得到 <span class="math inline">\(A=QR\)</span>,其中 <spanclass="math inline">\(Q\)</span>为正交矩阵， <spanclass="math inline">\(R\)</span>为上三角矩阵 <spanclass="math display">\[\begin{cases}Q = H_1\cdots H_{n-1}\\R = Q^{-1}A=QA\end{cases}\]</span></p><h3 id="三角分解的性质">三角分解的性质</h3><p><strong>定理1</strong>:设 <span class="math inline">\(A\in \mathbb{C}_r^{m\times n}\)</span>，则 <span class="math inline">\(A\)</span>可以唯一地分解为 <span class="math display">\[A=U_1 R\]</span></p><p>其中 <span class="math inline">\(U_1\)</span>是酉矩阵， <spanclass="math inline">\(R\)</span> 是正线上三角复矩阵，或 <spanclass="math inline">\(A\)</span> 可以唯一地分解为 <spanclass="math display">\[A=L U_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角复矩阵， <spanclass="math inline">\(U_2\)</span>是酉矩阵</p><p><strong>推论1</strong>：设 <span class="math inline">\(A \in \mathbb{R}^{n × n}_n\)</span>,则 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=Q_1 R\]</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是则正交矩阵，<spanclass="math inline">\(R\)</span>是正线上三角实矩阵，或 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=L Q_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角实矩阵， <spanclass="math inline">\(Q_2\)</span>是正交矩阵。</p><p><strong>推论2</strong>：设A是实对称正定矩阵，则存在唯一正线上三角实矩阵<span class="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^T R\]</span></p><p><strong>推论3</strong>：设 <spanclass="math inline">\(A\)</span>是正定Hermite矩阵，则存在唯一正线上三角复矩阵<spanclass="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^H R\]</span></p><h2 id="矩阵的满秩分解">矩阵的满秩分解</h2><p>设 <span class="math inline">\(A\in \mathbb {C}_r^{m\timesn}\)</span>，则存在 <span class="math inline">\(B\in \mathbb{C}_r^{m\times r}, C\in \mathbb {C}_r^{r\times n}\)</span>，满足 <spanclass="math display">\[ A = BC \]</span></p><p><span class="math inline">\(\mathbb {C}_r\)</span> 表示矩阵的秩为<span class="math inline">\(r\)</span></p><p>实际上上述定理用文字描述就是，一个亏秩的矩阵可以分解成一个列满秩与行满秩矩阵的乘积</p><p>证明：因为 <span class="math inline">\(rank(A)=r\)</span>，所以一定可以找到与 <spanclass="math inline">\(A\)</span> 相似的一个矩阵</p><p><span class="math display">\[ A \simeq\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\\0_{(m-r)\timesr}&amp;0_{(m-r)\times(n-r)}\end{bmatrix}=\begin{bmatrix}E_r\\0_{(m-r)\timesr}\end{bmatrix}\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\end{bmatrix}\]</span></p><p>因此存在两个可逆矩阵 <span class="math inline">\(P,Q\)</span>，使<span class="math inline">\(PAQ=\begin {bmatrix} E_r&amp;0\\0&amp;0\end{bmatrix}\)</span>，则</p><p><span class="math display">\[ \begin{aligned} A &amp;=P^{-1}\begin{bmatrix}E_r\\0\end{bmatrix}\begin{bmatrix}E_r&amp;0\end{bmatrix}Q^{-1}\\&amp;\triangleq BC \end{aligned} \]</span></p><p>因为 <span class="math inline">\(P^{-1}\)</span> 是可逆矩阵，<spanclass="math inline">\(\begin {bmatrix} E_r\\0\end {bmatrix}\)</span>是一个列满秩矩阵，所以 <span class="math inline">\(B=P^{-1}\begin{bmatrix} E_r\\0\end {bmatrix}\)</span> 仍是一个列满秩矩阵；同理，<spanclass="math inline">\(C=\begin {bmatrix} E_r&amp;0\end {bmatrix}Q^{-1}\)</span> 是一个行满秩矩阵</p><h3 id="矩阵满秩分解的计算">矩阵满秩分解的计算</h3><p>如何在给定矩阵 <span class="math inline">\(A\)</span>的情况下，求出矩阵 <span class="math inline">\(B,C\)</span> 呢？</p><p>设</p><p><span class="math display">\[\begin{align}&amp;A = [\alpha_1,\alpha_2,...,\alpha_n]\\ &amp;B =[\beta_1,\beta_2,...,\beta_r]  \end{align}\]</span></p><p>其中 <span class="math inline">\(\beta_1,...,\beta_r\)</span>线性无关</p><p>所以 <span class="math display">\[ \begin{aligned} &amp;A=BC\\&amp;\Rightarrow[\alpha_1,\alpha_2,...,\alpha_n]=[\beta_1,...,\beta_r]\begin{bmatrix}c_{11}&amp;\cdots&amp;c_{1n}\\\vdots &amp;\ddots&amp;\vdots\\c_{r1}&amp;\cdots&amp;c_{rn}\end{bmatrix} \end{aligned} \]</span></p><p>实际上我们可以取 <spanclass="math inline">\(\beta_1,...,\beta_r\)</span> 为 <spanclass="math inline">\(\alpha_1,...,\alpha_n\)</span>的一个极大线性无关组，因此 <span class="math inline">\(B\)</span>就是矩阵 <span class="math inline">\(A\)</span>列向量组的一个极大线性无关组，<span class="math inline">\(C\)</span>就是用该线性无关组去表示 <span class="math inline">\(A\)</span>时的系数</p><h4 id="例-1">例 1</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换 <span class="math display">\[A=\begin{bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\\0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}1&amp;4&amp;-1\\2&amp;0&amp;0\\-1&amp;2&amp;-4\\2&amp;6&amp;-5\end{bmatrix}，C=\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\end{bmatrix}\]</span></p><h4 id="例-2">例 2</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换</p><p><span class="math display">\[A=\begin{bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}2&amp;1&amp;-2\\2&amp;5&amp;-1\\1&amp;3&amp;-1\end{bmatrix},C=\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><h2 id="矩阵的lu分解">矩阵的LU分解</h2><p>LU 分解（LUDecomposition）是矩阵分解的一种，可以将一个矩阵分解为一个单位下三角矩阵和一个上三角矩阵的乘积，以四阶矩阵为例<span class="math display">\[ L = \begin{bmatrix}1&amp;0&amp;0&amp;0 \\*&amp;1&amp;0&amp;0\\ *&amp;*&amp;1&amp;0\\*&amp;*&amp;*&amp;1\end{bmatrix},U=\begin{bmatrix}*&amp;*&amp;*&amp;*\\0&amp;*&amp;*&amp;*\\0&amp;0&amp;*&amp;*\\0&amp;0&amp;0&amp;*\end{bmatrix}\]</span></p><p>LU 矩阵是否一定存在？答案是否，具体看下面的例子</p><p>设 <span class="math inline">\(\begin {bmatrix} 0&amp;1 \\1&amp;0\end{bmatrix}=\begin {bmatrix} a&amp;0\\b&amp;c\end {bmatrix}\begin{bmatrix} l&amp;m\\0&amp;n\end {bmatrix}\)</span>，则应该满足如下 4个式子</p><p><span class="math display">\[ \begin{cases} al=0\\ am=1\\ bl=1\\bm+cn=0 \end{cases} \]</span></p><p>由 <span class="math inline">\(al=0\)</span> 得 <spanclass="math inline">\(a=0\)</span> 或 <spanclass="math inline">\(l=0\)</span>，但实际上这两种情况带入上面的式子都会推出矛盾，因此不是所有情况LU 分解都存在</p><p><strong>LU 分解定理</strong> ：设 <span class="math inline">\(A\in\mathbb {C}_n^{n\times n}\)</span>，<spanclass="math inline">\(A\)</span> 有唯一的 LU 分解 <spanclass="math inline">\(\Leftrightarrow A\)</span> 的各阶顺序主子式 <spanclass="math inline">\(\Delta k \neq 0,\ k=1,2...,n\)</span></p><p><span class="math inline">\(k\)</span> 阶顺序主子式指的是矩阵左上角<span class="math inline">\(k\times k\)</span> 个元素组成的行列式</p><p>将矩阵 <span class="math inline">\(A\)</span> 分解为 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span> 之后，解方程组 <spanclass="math inline">\(Ax=b\)</span> 就变得简单了，因为 <spanclass="math inline">\(A=LU\)</span>，所以 <spanclass="math inline">\((LU) x=b\Rightarrow L (Ux)=b\Rightarrow \begin{cases} Ly=b\\Ux=y\end {cases}\)</span></p><p>所以 <span class="math inline">\(x=U^{-1} y=U^{-1} L^{-1}b\)</span></p><h3 id="lu-矩阵的求法">LU 矩阵的求法</h3><p>实际上 LU 矩阵有非常多的求法，这里列举一种比较简单的待定系数法</p><p>设 <span class="math inline">\(A = \begin {bmatrix}2&amp;3&amp;4\\1&amp;1&amp;9\\1&amp;2&amp;-6\end{bmatrix}\)</span>，求矩阵 <span class="math inline">\(A\)</span> 的 LU分解矩阵 <span class="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span></p><p><strong>解</strong>：令 <span class="math display">\[L=\begin{bmatrix}1&amp;0&amp;0\\l_1&amp;1&amp;0\\l_2&amp;l_3&amp;1\end{bmatrix},U=\begin{bmatrix}u_1&amp;u_2&amp;u_3\\0&amp;u_4&amp;u_5\\0&amp;0&amp;u_6\end{bmatrix}\]</span></p><p>由于 <span class="math inline">\(A=LU\)</span>，所以有</p><p><span class="math display">\[ \begin{cases} u_1=2\\ u_2=3\\ u_3=4\\l_1u_1=1\\ l_1u_2+u_4=1\\ l_1u_3+u_5=9\\ l_2u_1=1\\ l_2u_2+l_3u_4=2\\l_2u_3+l_3u_5+u_6=-6 \end{cases} \]</span></p><p>上面的方程组非常容易解，最后求出</p><p><span class="math display">\[ L =\begin{bmatrix}1&amp;0&amp;0\\\frac{1}{2}&amp;1&amp;0\\\frac{1}{2}&amp;-1&amp;1\end{bmatrix},U=\begin{bmatrix}2&amp;3&amp;4\\0&amp;-\frac{1}{2}&amp;7\\0&amp;0&amp;-1\end{bmatrix}\]</span></p><h2 id="奇异值分解">奇异值分解</h2><p><strong>奇异值</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{m × n}_r,AA^H\)</span> 的特征值为 <spanclass="math display">\[\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_n =0\]</span></p><p>则称 <span class="math inline">\(\sigma_i=\sqrt{\lambda_i}\)</span>为矩阵A的正奇异值。<strong><span class="math inline">\(A\)</span>和<span class="math inline">\(A^H\)</span>相同的奇异值</strong>。</p><p><strong>奇异值分解</strong>：当给定一个大小为<spanclass="math inline">\(m × n\)</span>的矩阵<spanclass="math inline">\(A\)</span>,虽然矩阵<spanclass="math inline">\(A\)</span>不一定是方阵，但大小为<spanclass="math inline">\(m × m\)</span>的<spanclass="math inline">\(AA^T\)</span>和<span class="math inline">\(n ×n\)</span>的<span class="math inline">\(AA^T\)</span>是对称矩阵,若<spanclass="math inline">\(AA^T=P \Lambda_1 Q^T\)</span>,<spanclass="math inline">\(A^T A=Q\Lambda_2Q^T\)</span>,则矩阵A的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T\]</span></p><p>其中，矩阵<span class="math inline">\(P=(\overrightarrow{p_1},\overrightarrow{p_2}, \dots, \overrightarrow{p_m})\)</span>的大小为<span class="math inline">\(m × m\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{p_1}, \overrightarrow{p_2}, \dots,\overrightarrow{p_m}\)</span>是 <spanclass="math inline">\(AA^T\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的左奇异向量（left singularvector）；矩阵<span class="math inline">\(Q=(\overrightarrow{q_1},\overrightarrow{q_2}, \dots, \overrightarrow{q_m})\)</span>的大小为<span class="math inline">\(n × n\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{q_1}, \overrightarrow{q_2}, \dots,\overrightarrow{q_m}\)</span>是 <spanclass="math inline">\(A^TA\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的右奇异向量（left singularvector）；矩阵<spanclass="math inline">\(\Lambda_1\)</span>的大小为<spanclass="math inline">\(m × m\)</span>，矩阵<spanclass="math inline">\(\Lambda_2\)</span>的大小为<spanclass="math inline">\(n ×n\)</span>，两个矩阵对角线上的非零元素相同（即矩阵<spanclass="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的非零特征值相同）；矩阵<spanclass="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(m ×n\)</span>，位于对角线上的元素被称为<strong>奇异值</strong>（singularvalue）。</p><p>设<span class="math inline">\(A\)</span>的秩为r，当 <spanclass="math inline">\(m \ne n\)</span>时，矩阵<spanclass="math inline">\(\Lambda_1\)</span>和<spanclass="math inline">\(\Lambda_2\)</span>的大小显然是不同的，但是他们对角线上的非零元素是相同的，记矩阵<spanclass="math inline">\(\Lambda_1\)</span>(或<spanclass="math inline">\(\Lambda_2\)</span>)对角线上的非零元素为<spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_r\)</span>，这些数皆为非负数，又记矩阵<spanclass="math inline">\(\Sigma\)</span>对角线上的非零元素分别为<spanclass="math inline">\(\sigma_1,\sigma_2,\dots,\sigma_r\)</span>，则<spanclass="math display">\[\sigma_1=\sqrt{\lambda_1},\sigma_2=\sqrt{\lambda_2},\dots,\sigma_r=\sqrt{\lambda_r}\]</span></p><p>即非零奇异值的平方对应着矩阵<spanclass="math inline">\(\Lambda_1\)</span>（或矩阵<spanclass="math inline">\(\Lambda_2\)</span>）的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。</p><p><strong>例1</strong>：一个<spanclass="math inline">\(3×2\)</span>的矩阵<spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\)</span>，求其奇异值分解。</p><p>由 <span class="math display">\[AA^T=\begin{bmatrix}    5&amp;0&amp;0 \\ 0&amp;0&amp;0 \\ 0&amp;0&amp;0\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=\lambda_3=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{p_1}=(1,0,0)^T,\overrightarrow{p_2}=(0,1,0)^T,\overrightarrow{p_3}=(0,0,1)^T\)</span></p><p>由 <span class="math display">\[A^TA=\begin{bmatrix}    1&amp;2 \\ 2&amp;4\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{q_1}=(\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T,\overrightarrow{q_2}=(-\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T\)</span></p><p>令 <span class="math display">\[\Sigma=\begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p>注意矩阵<span class="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(3 × 2\)</span>，此时，矩阵<spanclass="math inline">\(A\)</span>的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T=(\overrightarrow{p_1},\overrightarrow{p_2}, \overrightarrow{p_3})\Sigma (\overrightarrow{q_1},\overrightarrow{q_2})^T \\ =\begin{bmatrix}    1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix} \begin{bmatrix}    \frac{\sqrt{5}}{5}&amp;\frac{2\sqrt{5}}{5} \\\frac{-2\sqrt{5}}{5}&amp;\frac{\sqrt{5}}{5}\end{bmatrix} = \begin{bmatrix}    1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p><strong>例2</strong>：求对称矩阵<spanclass="math inline">\(A=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}\)</span>的奇异值分解。</p><p>经计算可以发现<spanclass="math inline">\(A^TA=AA^T=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix} \begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}=\begin{bmatrix}  5&amp;4 \\ 4&amp;5\end{bmatrix}\)</span>，左奇异向量和右奇异向量构成的矩阵也是相等的，即<span class="math display">\[P=Q=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p>则其奇异值分解为 <span class="math display">\[A=P\SigmaQ^T=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2}&amp; \frac{\sqrt{2}}{2}\end{bmatrix}\begin{bmatrix}    3&amp;0 \\ 0&amp;1\end{bmatrix}\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p><strong>注</strong>：这是由于当矩阵<spanclass="math inline">\(A\)</span>为对称矩阵时，其可以被正交对角化，这时奇异值分解等于正交对角化分解。</p><h2 id="谱分解">谱分解</h2><p><strong>谱分解</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{n × n}\)</span>是单纯矩阵，则 <spanclass="math inline">\(A\)</span>可以分解为一系列幂等矩阵 <spanclass="math inline">\(A_i(i=1,2, \dots,n)\)</span>的加权和 <spanclass="math display">\[A=\sum_{i=1}^n \lambda_i A_i\]</span></p><p>其中 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span>是A的特征值。</p><p><strong>单纯矩阵</strong>：若矩阵 <spanclass="math inline">\(A\)</span>的<strong>代数重数</strong>等于<strong>几何重数</strong>，则称<spanclass="math inline">\(A\)</span>为单纯矩阵。<strong>代数重数</strong>为矩阵<spanclass="math inline">\(A\)</span>特征值的重数，<strong>几何重数</strong>为齐次方程组<spanclass="math inline">\(Ax=\lambda_ix(i=1,2,\dots,k)\)</span>的解空间<spanclass="math inline">\(V_{\lambda_i}\)</span>的维数，也即特征值对应的最多无关特征向量数。</p><p><strong>幂等矩阵</strong>：若 <spanclass="math inline">\(A\)</span>为方阵，且 <spanclass="math inline">\(A^2=A\)</span>，则称<spanclass="math inline">\(A\)</span>为幂等矩阵。所有幂等矩阵都相似与对角元全为0或1的对角阵。</p><p><strong>更一般的单纯矩阵谱分解定理</strong>：设 <spanclass="math inline">\(A \in \mathbb{C}^{n × n}\)</span>，他有 <spanclass="math inline">\(k\)</span>个相异特征值 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,k)\)</span>，则 <spanclass="math inline">\(A\)</span>是单纯矩阵的充要条件是存在<spanclass="math inline">\(k\)</span>个矩阵<spanclass="math inline">\(A_i(i=1,2,\dots,k)\)</span>满足</p><ol type="1"><li><span class="math inline">\(A_i A_j = \begin{cases}  A_i, i=j \\ 0,i\ne j \end{cases}\)</span></li><li><span class="math inline">\(\sum_{i=1}^k A_i = E_n\)</span></li><li><span class="math inline">\(A=\sum_{i=1}^k \lambda_iA_i\)</span></li></ol><p>该定理比定理3要求放宽了，不再要求必须要有n个特征值了，这里的k可以小于等于n。</p><p><strong>例1</strong>：求正规矩阵 <span class="math inline">\(A =\begin{bmatrix}  0&amp;1&amp;1&amp;1 \\ 1&amp;0&amp;-1&amp;1 \\1&amp;-1&amp;0&amp;1 \\ -1&amp;1&amp;1&amp;0\end{bmatrix}\)</span>的谱分解表达式。</p><p><strong>解</strong>：首先计算 <spanclass="math inline">\(A\)</span>的特征值和特征向量 <spanclass="math display">\[|\lambda_ I - A |=(\lambda - 1)^3 (\lambda +3)\]</span></p><p>从而 <span class="math inline">\(A\)</span>的特征值为 <spanclass="math display">\[\lambda_1=\lambda_2=\lambda_3=1,\lambda_4=-3\]</span></p><p>当<spanclass="math inline">\(\lambda=1\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_1=(1,1,0,0)^T \\ \alpha_2=(1,0,1,0)^T \\\alpha_3=(-1,0,0,1)^T\]</span></p><p>当<spanclass="math inline">\(\lambda=-3\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_4=(1,-1,-1,1)^T\]</span></p><p>将 <spanclass="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交化并单位化得<spanclass="math display">\[\eta_1=(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0,0)^T\\\eta_2=(\frac{1}{\sqrt{6}},\frac{1}{\sqrt{6}},\frac{2}{\sqrt{6}},0)^T \\\eta_3=(-\frac{1}{2\sqrt{3}},\frac{1}{2\sqrt{3}},\frac{1}{\sqrt{3}},\frac{3}{2\sqrt{3}})^T\]</span></p><p>将<span class="math inline">\(\alpha_4\)</span>单位话得 <spanclass="math display">\[\eta_4=(\frac{1}{2},-\frac{1}{2},-\frac{1}{2},\frac{1}{2})\]</span></p><p>故有 <span class="math display">\[G_1=\eta_1 \eta_1^H+\eta_2 \eta_2^H+\eta_3 \eta_3^H \\= \begin{bmatrix}    \frac{3}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;\frac{3}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{3}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{3}{4}    \end{bmatrix}\]</span></p><p><span class="math display">\[G_2=\eta_4 \eta_4^H \\=\begin{bmatrix}    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4}\end{bmatrix}\]</span></p><p>这样其谱分解表达式为 <span class="math display">\[A=G_1 -3G_2\]</span></p><p>注意<span class="math inline">\(G_1\)</span>和<spanclass="math inline">\(G_2\)</span>的系数<spanclass="math inline">\(\lambda_i\)</span>为其对应的特征值。<!-- https://www.cnblogs.com/blairgrowing/p/15800825.html --></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>范数</title>
    <link href="/2022/12/05/%E8%8C%83%E6%95%B0/"/>
    <url>/2022/12/05/%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>不管向量范数、矩阵范数还是算子范数，都需要满足三个特性:</p><ul><li>正定性</li><li>齐次性</li><li>三角不等式</li></ul><h2 id="向量范数">向量范数</h2><p><strong>1 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_1=\sum\limits_{i=1}^N|x_i|\)</span>，即向量元素绝对值之和</p><p><strong>2 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_2=(\sum\limits_{i=1}^N (x_i)^2)^{\frac{1}{2}}\)</span>，也叫欧几里得范数，常用于计算向量长度，即向量元素的平方和再开方</p><p><strong><span class="math inline">\(\infty\)</span>-范数</strong>:<span class="math inline">\(\Vert \boldsymbol{x}\Vert_{\infty}=\max\limits_{i}|x_i|\)</span>，即所有向量元素中绝对值的最大值</p><!-- **-$\infty$- 范数**:$\Vert \boldsymbol {x}\Vert_{-\infty}=\min\limits_{i} |x_i|$，即所有向量元素绝对值中的最小值 --><p><strong>P - 范数</strong>:<span class="math inline">\(\Vert\boldsymbol {x}\Vert_p=(\sum\limits_{i=1}^N (x_i)^p)^{\frac{1}{p}}\)</span>，即向量元素的 p 次方和再开 p 次方</p><h2 id="矩阵范数">矩阵范数</h2><p>设<span class="math inline">\(A \in \mathbb{C}^{m ×n}\)</span>，则</p><p><span class="math inline">\({||A||}_{m_1} = \sum\limits^{n}_{j=1}\sum\limits^{m}_{i=1} |a_{ij}|\)</span></p><p><span class="math inline">\(||A||_{m_2} = {||A||}_{F}=\sqrt{\sum\limits^{n}_{j=1} \sum\limits^{m}_{i=1} |a_{ij}^2|} =\sqrt{tr(A^HA)} = \sqrt{tr(AA^H)}\)</span></p><p><spanclass="math inline">\(||A||_{m_\infty}=\max\limits_{i,j}\{|a_{ij}|\},1\le i \le m, 1 \le j \le n\)</span></p><h3 id="矩阵范数的性质">矩阵范数的性质</h3><p><img src="/img/矩阵论/矩阵范数性质-定理1.png" /> <imgsrc="/img/矩阵论/矩阵范数性质-定理1-2.png" /></p><ul><li><span class="math inline">\({||A||}_{m_1}\)</span>范数与向量范数<span class="math inline">\(||x||_1\)</span>相容</li><li><span class="math inline">\({||A||}_{m_2}\)</span>范数与向量范数<span class="math inline">\(||x||_2\)</span>相容</li><li><spanclass="math inline">\({||A||}_{m_{\infty}}\)</span>范数与向量范数 <spanclass="math inline">\(||x||_\infty\)</span> 不相容</li></ul><h3 id="证明一个范数是矩阵范数流程">证明一个范数是矩阵范数流程</h3><ul><li>证明非负性、齐次性、三角不等式</li><li>看他定义是哪种类型的范数，若是相容的需要证明相容性</li></ul><h2 id="算子范数">算子范数</h2><p>算子范数定义1： <img src="/img/矩阵论/算子范数定义1.png" /></p><p>注意：并不是所以的矩阵范数都与向量范数相容。只有满足该条件的矩阵范数才与向量范数是相容的。</p><p>算子范数定义2： <img src="/img/矩阵论/算子范数定义2.png" /></p><p><strong>则称此矩阵范数为从属于向量范数 <spanclass="math inline">\(||x||\)</span>的算子范数</strong>。这里的x可是n维空间的任意取向。</p><p><strong>算子范数表示</strong>：</p><p><span class="math inline">\({||A||}_1=\max\limits_{1 \le j \len}\{\sum\limits^{s}_{j=1}|a_{ij}|\}\)</span>,列模和范数，即所有矩阵列向量绝对值之和的最大值</p><p><span class="math inline">\(||A||_2=\sqrt{\rho(A^HA)}\)</span>，谱范数</p><p><span class="math inline">\(||A||_\infty=\max\limits_{1 \le i \les}\{\sum^n_{j=1}|a_{ij}|\}\)</span>,行模和范数,即所有矩阵行向量绝对值之和的最大值</p><h3 id="算子范数性质">算子范数性质</h3><ul><li><span class="math inline">\({||A||}_{1}\)</span> 范数与向量范数<span class="math inline">\(||x||_1\)</span> 相容</li><li><span class="math inline">\({||A||}_{2}\)</span> 范数与向量范数<span class="math inline">\(||x||_2\)</span> 相容</li><li><span class="math inline">\(||·||_a\)</span>是算子范数 <spanclass="math inline">\(\Rightarrow ||E||_a = 1\)</span></li><li>设<span class="math inline">\(A \in \mathbb{C}^{n × n}，||A||_a\)</span>是从属向量范数<spanclass="math inline">\(||x||\)</span>的算子范数，若<spanclass="math inline">\(||A||_a &lt; 1\)</span>,则 <spanclass="math inline">\(E \pm A\)</span> 可逆，且<spanclass="math inline">\(||(E \pm A)^{-1}||_a \le (1 -||A||_a)^{-1}\)</span></li></ul><p><img src="/img/矩阵论/算子范数性质-定理3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jordan标准型</title>
    <link href="/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <url>/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="jordan标准型">Jordan标准型</h2><figure><img src="/img/矩阵论/Jordan标准型定义.png" alt="Jordan标准型定义" /><figcaption aria-hidden="true">Jordan标准型定义</figcaption></figure><p>其中 <spanclass="math inline">\(J_1(\lambda_1),J_2(\lambda_2)\)</span>分别构成Jardon块。</p><p>即对任意矩阵 <spanclass="math inline">\(A\)</span>，比存在n阶可逆矩阵<spanclass="math inline">\(P\)</span>，使 <spanclass="math display">\[P^{-1}AP=\begin{bmatrix}    J_1 &amp; &amp; &amp; \\ &amp; J_2 &amp; &amp; \\ &amp; &amp; \ddots&amp; \\ &amp; &amp; &amp; J_n\end{bmatrix} = J\]</span></p><p>每一个 <span class="math inline">\(J\)</span> 都是Jardon块 <spanclass="math display">\[J_i=\begin{bmatrix}    \lambda_i &amp; 1 &amp; &amp; \\ &amp; \lambda_i &amp; \ddots &amp;&amp; \\ &amp; &amp; \ddots &amp;1 \\ &amp; &amp; &amp; \lambda_i\end{bmatrix}\]</span></p><h3 id="jordan标准型的结构与结论">Jordan标准型的结构与结论</h3><ul><li>Jordan标准型的个数<spanclass="math inline">\(k\)</span>是线性无关特征向量的个数</li><li>矩阵可对角化当且仅当<span class="math inline">\(k=n\)</span></li><li>相应于一个已知特征值的Jordan块的个数是该特征值的几何重数，它是相应的特征子空间的维数，相应于一个已知特征值的所有Jordan的阶数之和，是该特征值的代数重数</li><li>特征值的几何重数 &lt; 代数重数</li><li>矩阵不同特征值对应的特征向量线性无关</li></ul><figure><img src="/img/矩阵论/Jordan标准型定理2.png" alt="定理2" /><figcaption aria-hidden="true">定理2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征值估计</title>
    <link href="/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>shur不等式</strong> <imgsrc="/img/矩阵论/特征值估计-shur不等式.png" /></p><p>证明如下： <img src="/img/矩阵论/shur不等式证明.png" /></p><p><strong>行盖尔圆盘和列盖尔圆盘</strong>： <imgsrc="/img/矩阵论/盖尔圆盘.png" /></p><p><strong>圆盘定理</strong>： <img src="/img/矩阵论/圆盘定理1.png" /><img src="/img/矩阵论/圆盘定理2.png" /></p><p>推论1：设<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>相似于对角阵.</p><p>推论2： 设<span class="math inline">\(n\)</span>阶实阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>特征值全为实数.</p><p><strong>对角占优矩阵</strong>：</p><p><img src="/img/矩阵论/对角占优矩阵.png" /></p><p><strong>Rayleigh商</strong>：设<span class="math inline">\(A \in\mathbb{C}^{n \times n}\)</span>为Hermite矩阵，<spanclass="math inline">\(x \in \mathbb{C}\)</span>，称 <spanclass="math display">\[R(x)=\frac{x^HAx}{x^Hx}, x \ne 0\]</span></p><p>为<span class="math inline">\(A\)</span>的Rayleigh商。</p><p><strong>定理（Rayleigh-Ritz）</strong>: <imgsrc="/img/矩阵论/Rayleigh-Ritz定理.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵函数</title>
    <link href="/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数">矩阵函数</h2><p><strong>定义</strong>： 设幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty} c_kz^k\)</span>收敛半径为<span class="math inline">\(r\)</span>，且当<spanclass="math inline">\(|z|&lt;r\)</span>的时候，幂级数收敛于<spanclass="math inline">\(f(z)\)</span>，即</p><p><span class="math display">\[f(z)=\sum\limits_{k=0}^{\infty} c_kz^k,|z|&lt;r\]</span></p><p>如果<span class="math inline">\(A \in\mathbb{C}^{n×n}\)</span>满足<spanclass="math inline">\(r(A)&lt;r\)</span>,则收敛的矩阵幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty}a_kA^k\)</span>的和为矩阵函数，记为<spanclass="math inline">\(f(A)\)</span>，即</p><p><span class="math display">\[f(A)=\sum\limits_{k=0}^{\infty} c_kA^k\]</span></p><p>把<span class="math inline">\(f(A)\)</span>的方阵换为<spanclass="math inline">\(At\)</span>,<spanclass="math inline">\(t\)</span>为参数，得到</p><p><span class="math display">\[f(At)=\sum\limits_{k=0}^{\infty}c_k(At)^k\]</span></p><p>常见的矩阵级数有：</p><p><img src="/img/矩阵论/矩阵函数/常见矩阵函数1.png" /> <imgsrc="/img/矩阵论/矩阵函数/常见矩阵函数2.png" alt="常见矩阵函数" /></p><h3 id="矩阵函数的计算方法">矩阵函数的计算方法</h3><h4 id="利用相似对角化">利用相似对角化</h4><p>设<span class="math inline">\(P^{-1}AP= diag(\lambda_1,\lambda_2,\dots, \lambda_3) = D\)</span></p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算2.png" /></p><p><strong>例1</strong>：</p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-3.png" /></p><h4 id="jordan标准型法">Jordan标准型法</h4><p><img src="/img/矩阵论/矩阵函数/Jordan法-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-4.png" /></p><p><strong>例2</strong>：</p><p><img src="/img/矩阵论/矩阵函数/Jordan法-例2-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例2-2.png" /></p><h4 id="数项级数求和法">数项级数求和法</h4><p><img src="/img/矩阵论/矩阵函数/数项级数求和法.png" /></p><p>由哈密尔顿-凯莱定理于是我们有：</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-2.png" /></p><p>由该定理，我们可以实现降次的目的。</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/数项级数求和法-4.png" /></p><h3 id="矩阵函数的性质">矩阵函数的性质</h3><p><img src="/img/矩阵论/矩阵函数/矩阵函数性质.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近似算法</title>
    <link href="/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="近似算法">近似算法</h2><p>假设现在需要解决一个NP-Hard问题，但是又不太可能在多项式时间内求解，但是我们可以退而求其次，那么就必须要牺牲下面的其中一项：</p><ul><li>求得最优解</li><li>在多项式时间内完成</li><li>覆盖问题的所有例子</li></ul><p>而牺牲第二条是不能接受的，当我们选择满足后两者（也就是牺牲第一项），即对解的优越性放宽要求时，设计出的算法被称为<strong>近似算法</strong>。</p><h2 id="load-balancing问题">Load Balancing问题</h2><p>给定<span class="math inline">\(m\)</span>台相同的机器，<spanclass="math inline">\(n\)</span>个任务，任务<spanclass="math inline">\(j\)</span>需要的处理时间为<spanclass="math inline">\(t_j\)</span>,且每个任务<spanclass="math inline">\(j\)</span>必须在一台机器上连续完成。</p><p>令<span class="math inline">\(J(i)\)</span>为分配给机器<spanclass="math inline">\(i\)</span>的任务子集，机器<spanclass="math inline">\(i\)</span>的负载为<spanclass="math inline">\(L_i=\sum\limits_{j \inJ(i)}t_j\)</span>,该问题的时间跨度(makespan)为所有机器上的结束时间最大值<spanclass="math inline">\(L=\max\limits_i L_i\)</span>。</p><p><strong>LoadBalancing</strong>：求上述问题中的任务分配使得时间跨度最小。</p><h3 id="贪心算法">贪心算法</h3><p>每次将任务<spanclass="math inline">\(j\)</span>分配在当前负载最小的机器上： <imgsrc="/img/近似算法/LoadBalancing贪心算法.png" /></p><p><strong>引理1</strong>：最优解makespan<span class="math inline">\(L^*\ge \max\limits_j t_j\)</span>。</p><p>用时最长的这个任务总需要分配到一个机器上完成.</p><p><strong>引理2</strong>:最优解makespan <span class="math inline">\(L^*\ge \frac{1}{m} \sum\limits_j t_j\)</span></p><p>所有任务的总运行时间为<span class="math inline">\(\sum\limits_jt_j\)</span>,那么<spanclass="math inline">\(L^*\)</span>的时间跨度必然选自<spanclass="math inline">\(m\)</span>个机器中最大的一个,而<spanclass="math inline">\(m\)</span>个机器中的最大时间跨度一定不小于<spanclass="math inline">\(\frac{1}{m}\)</span>的总运行时间.</p><p><strong>定理:贪心算法是LoadBalancing问题的二倍近似算法。</strong></p><p>证明:</p><p>假设负载<span class="math inline">\(L_i\)</span>为问题的平静,令<spanclass="math inline">\(j\)</span>为最后一个分配到该机器的任务,由贪心算法,在任务<spanclass="math inline">\(j\)</span>分配之前,机器<spanclass="math inline">\(i\)</span>的负载是最小的.<spanclass="math inline">\(j\)</span>分配之前机器<spanclass="math inline">\(i\)</span>的负载为<span class="math inline">\(L_i- t_j\)</span>,也就是说在准备分配<spanclass="math inline">\(j\)</span>的时候有<span class="math inline">\(L_i- t_j\)</span>小于或等于所有机器上的负载<span class="math inline">\(L_k,1 \le k \le m\)</span></p><p><img src="/img/近似算法/LoadBalancing贪心算法证明-1.png" /></p><p>分配任务<span class="math inline">\(j\)</span>之前,由引理1: <spanclass="math display">\[  \begin{aligned}    L_i - t_j &amp;\le \frac{1}{m}\sum\limits_k L_k \\        &amp;=  \frac{1}{m} \sum\limits_k t_k \\        &amp;\le L^*    \end{aligned}\]</span></p><p>分配任务<span class="math inline">\(j\)</span>后,由上式以及引理2:<span class="math display">\[L_i = (L_i -t_i) + t_j \le L^* +\max\limits_j t_j \le L^* + L^* = 2L^*\]</span></p><p>那么贪心算法是Load Balancing的紧2倍近似算法吗?判断<spanclass="math inline">\(\rho\)</span>-近似算法是否紧的要看该算法相比于最优解有比<spanclass="math inline">\(\rho\)</span>更低的近似率吗?若有则说明其并不是紧的。</p><p>答:大致是的,考虑下面的一个Load Balancing的实例,有<spanclass="math inline">\(m\)</span>个机器,<spanclass="math inline">\(m^2\)</span>个任务,其中有<spanclass="math inline">\(m(m-1)\)</span>个任务运行时间为1,一个任务的运行时间为<spanclass="math inline">\(m\)</span>.贪心算法的结果如下图所示:</p><p><img src="/img/近似算法/LoadBalancing实例-贪心算法.png" /></p><p>而最优解的结果为:</p><p><img src="/img/近似算法/LoadBalancing实例-最优解.png" /></p><p>这个实例里贪心算法的时间跨度为19,而最优解的时间跨度为10.</p><h3 id="lptlongest-processing-time算法">LPT(longest ProcessingTime)算法</h3><p>LPT算法是在上面的贪心算法基础之上,先对<spanclass="math inline">\(n\)</span>个任务按时间降序排序,然后再按照上面的贪心算法执行.</p><p><img src="/img/近似算法/LoadBalancingLPT算法.png" /></p><p>通过观察可以得出,当任务数小于或等于机器数的时候,LRT算法就是最优解.这时候只需要把任务<spanclass="math inline">\(i\)</span>分配给机器<spanclass="math inline">\(i\)</span>.</p><p><strong>引理3</strong>:如果任务数多于机器数<spanclass="math inline">\(m\)</span>,有<span class="math inline">\(L^* \ge2t_{m+1}\)</span>.</p><p>设前<spanclass="math inline">\(m+1\)</span>个任务的运行时间分别为<spanclass="math inline">\(t_1,\dots,t_{m+1}\)</span>,由于运行时间<spanclass="math inline">\(t_i\)</span>是按照降序排列,所以前<spanclass="math inline">\(m+1\)</span>个任务的运行时间都不小于<spanclass="math inline">\(t_{m+1}\)</span>,且由于鸽笼原则,至少有一个机器会被分配两个任务.</p><p><strong>定理:LPT算法是Load Balancing的一个<spanclass="math inline">\(\frac{3}{2}\)</span>近似算法.</strong></p><p>证明:与证明贪心算法相同的方法 <span class="math display">\[L_i=(L_i -t_j) + t_j \le L^* + \frac{1}{2}L^* = \frac{3}{2}L\]</span></p><p>那么LPT算法是Load Balancing的紧<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似算法吗?不是;LPT算法是LoadBalancing的紧<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似算法吗?很可能是.</p><h2 id="centrer-selection-problem中心选址问题">Centrer SelectionProblem(中心选址问题)</h2><p>定义:给定一个大小为<spanclass="math inline">\(n\)</span>个地址集合<spanclass="math inline">\(s_1,s_2,\dots,s_n\)</span>以及一个整数<spanclass="math inline">\(k&gt;0\)</span>,选择<spanclass="math inline">\(k\)</span>个中心使所有地址到离它最近的中心距离的最大值最短.</p><p><img src="/img/近似算法/CentrerSelectionProblem.png" /></p><p>几个概念:</p><ul><li><span class="math inline">\(dist(x, y)\)</span>:<spanclass="math inline">\(x,y\)</span>的距离.</li><li><span class="math inline">\(dist(s_i, C)=\min\limits_{c \inC}\)</span>:<spanclass="math inline">\(s_i\)</span>到离它最近的中心的距离,这里采用欧式距离.</li><li><span class="math inline">\(r(C)=\max\limits_{i}dist(s_i,C)\)</span>:最小的覆盖半径.</li></ul><p>中心选址问题的目标便是找到一个中心集合<spanclass="math inline">\(C\)</span>使覆盖半径<spanclass="math inline">\(r(C)\)</span>最小,其中中心的数量等于<spanclass="math inline">\(k\)</span>.</p><p>距离的一些性质: <span class="math display">\[dist(x,x)=0\tag{同一性}\]</span> <span class="math display">\[dist(x,y)=dist(y,x)\tag{对称性}\]</span> <span class="math display">\[dist(x,y) \ledist(x,z) + dist(z,y) \tag{三角不等式}\]</span></p><h3 id="贪心算法-1">贪心算法</h3><p>开始时我们任意选取一个地址作为中心，接着选择离第一个中心最远的那个地址作为第二个中心，如此的重复进行,直到选了<spanclass="math inline">\(k\)</span>个中心为止。</p><p><img src="/img/近似算法/CentrerSelectionProblem贪心算法.png" /></p><p><strong>定理：贪心算法是中心选址问题的2倍近似解</strong></p><p>证明(反证法)：</p><p>假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span></p><ul><li>对近似解集合<span class="math inline">\(C\)</span>的中心<spanclass="math inline">\(c_i\)</span>，总有一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>在<spanclass="math inline">\(c_i\)</span>的圆中(任意一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>的圆里最少有一个地址<spanclass="math inline">\(s\)</span>,而贪心算法选址都是在地址集合中选的，并且<spanclass="math inline">\(c_i\)</span>的半径 <spanclass="math inline">\(&gt;\)</span> <spanclass="math inline">\(c_i^*\)</span>的半径，所以<spanclass="math inline">\(c_i^*\)</span>必然在某一个中心<spanclass="math inline">\(c_i\)</span>的圆里)</li><li>令<span class="math inline">\(c_i\)</span>是与<spanclass="math inline">\(c_i^*\)</span>对应的中心</li><li>对于任意一个离最优解<spanclass="math inline">\(c_i^*\)</span>最近的地址<spanclass="math inline">\(s\)</span>,有</li></ul><p><span class="math display">\[dist(s,C) \le dist(s, c_i) \le dist(s,c_i^*) + dist(c_i^*, c_i) \le r(C^*) + r(C^*) = 2r(C^*)\]</span></p><p>上式与假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span>相违背，故有<spanclass="math inline">\(r(C^*) \ge\frac{1}{2}r(C)\)</span>,即贪心算法是中心选址问题的2倍近似解。</p><p>中心选址问题有没有<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似解或者<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似解？</p><p>答：没有，除非P＝NP，否则中心选址问题没有倍率比2小的近似算法。</p><h2 id="weighted-vertex-cover">Weighted Vertex Cover</h2><p>带权值的顶点覆盖：对于给出的一个顶点带权值的图<spanclass="math inline">\(G\)</span>，找到一个顶点覆盖，使它们的权值之和最小。（这里我们主要解决的是：求图<spanclass="math inline">\(G=(V,E)\)</span>的顶点覆盖<spanclass="math inline">\(S\)</span>，要使顶点集合<spanclass="math inline">\(S\)</span>中所有顶点的权值之和最小。</p><p><img src="/img/近似算法/WeightedVertexCover.png" /></p><h3 id="pricing-method">Pricing Method</h3><p><strong>定价法</strong>：因为顶点覆盖要求每条边至少有一个顶点在集合<spanclass="math inline">\(S\)</span>里,每条边必须被一些顶点所覆盖，根据顶点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>，给边<span class="math inline">\(e =(i, j)\)</span> 标上价格<span class="math inline">\(P_e\)</span>。</p><p>公平性：与顶点<spanclass="math inline">\(i\)</span>所连接的所有边的价格（权值）之和必须小于顶点<spanclass="math inline">\(i\)</span>的权值。</p><p>引理：：图<spanclass="math inline">\(G\)</span>的所有边的价格（权值）之和 <spanclass="math inline">\(\le\)</span> 顶点覆盖<spanclass="math inline">\(S\)</span>中所有顶点的权值之和（两个简单的缩放）。</p><p><img src="/img/近似算法/WeightedVertexCover-不等式放缩.png" /></p><p>上面第一个<spanclass="math inline">\(\le\)</span>不能写成等号，等号只在每条边都恰好只有一个顶点在<spanclass="math inline">\(S\)</span>中时才成立，若有边的两个顶点都在<spanclass="math inline">\(S\)</span>中，那么这条边就会被计算两次。</p><p>求解过程：边的价格设置与找寻顶点覆盖同时进行</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-求解过程.png" /></p><p>例子：</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-例子.png" /></p><p><strong>Pricing Method是Weighted VertexCover</strong>的一个2倍近似算法。</p><p>证明：</p><p>首先证明<span class="math inline">\(S\)</span>是一个点覆盖：</p><p>算法结束条件：在while循环的每次迭代结束之后，至少有一个顶点会是紧致的（除非图没有边），所以在算法结束的时候每条边的两个顶点中至少有一个是紧的，即每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，而VertexCover要求每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，所以<spanclass="math inline">\(S\)</span>必然是一个点覆盖，否则循环就不会停止。</p><p>然后再证明<spanclass="math inline">\(S\)</span>是最优解的一个2倍近似解：</p><p><img src="/img/近似算法/证明PricingMethod2倍近似解.png" /></p><p>第一处放缩很容易得出，<spanclass="math inline">\(S\)</span>肯定为顶点集<spanclass="math inline">\(V\)</span>的一个子集；<spanclass="math inline">\(\sum\limits_{i \in V} \sum\limits_{e=(i,j)} p_e =2 \sum\limits_{e \in E} p_e\)</span>是因为计算与<spanclass="math inline">\(V\)</span>中所有顶点相连的边时，每条边会被计算两次；最右边一个放缩为引理的结论。</p><h2id="线性规划解决最小带权点覆盖问题">线性规划解决最小带权点覆盖问题</h2><h3 id="整数规划">整数规划</h3><p>对于图<spanclass="math inline">\(G=(V,E)\)</span>,对图中的每个点<spanclass="math inline">\(v \in V\)</span>，定义函数<spanclass="math inline">\(x(v) \in {0, 1}\)</span>,且 <spanclass="math inline">\(x(v)=0\)</span>，表示顶点 <spanclass="math inline">\(v\)</span>不在点覆盖集合里。</p><p>对图中任意一条边 <span class="math inline">\((u,v) \inE\)</span>,由点覆盖定义，顶点<spanclass="math inline">\(u\)</span>、顶点<spanclass="math inline">\(v\)</span> 至少有一个必须在点覆盖中 ，因此：<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>.</p><p>因而得到最小权值点覆盖的规划模型：其中<spanclass="math inline">\(w(v)\)</span> 表示顶点<spanclass="math inline">\(v\)</span>的权值。</p><p><img src="/img/近似算法/整数规划.png" /></p><h3 id="线性规划">线性规划</h3><p>线性规划在整数规划的基础之上不再限定<spanclass="math inline">\(x(v)\)</span>只为0或1，而是有一个范围 <spanclass="math inline">\(x(v) \in [0, 1]\)</span> 这样在整数规划中的<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>仍然成立.这是可以的。因为：前者是后者的一个特例。前者称为0-1整数规划，后者为普通的线性规划。因此，线性规划中的最优解是0-1整数规划最优解的一个下界（因为线性规划最优解包含了0-1整数规划最优解）。</p><p><img src="/img/近似算法/点覆盖-LP规划.png" /></p><p><strong>用线性规划的解来构造最小权值点覆盖问题的近似解算法</strong>:</p><p>对于每一个顶点<spanclass="math inline">\(v\)</span>，都会求得一个<spanclass="math inline">\(x(v)\)</span>的值。若，<spanclass="math inline">\(x(v) \ge 1/2\)</span>,则将该顶点加入到点覆盖集合中，否则舍去顶点<spanclass="math inline">\(v\)</span>，直至图G中所有的顶点都处理完毕。此时得到的顶点集合<spanclass="math inline">\(C\)</span>即为最小权值点覆盖问题的近似解的点覆盖集合。</p><p><strong>线性规划求得的顶点集合C是最小权值点覆盖问题的二倍近似解</strong>:</p><p>设 <span class="math inline">\(C^*\)</span>是最小权值点覆盖问题的一个最优解，<span class="math inline">\(Z\)</span>是线性规划的一个最优解， <spanclass="math inline">\(C\)</span>是最小权值点覆盖问题的近似解.</p><ol type="1"><li>由于最小权值点覆盖问题的一个最优解是线性规划的一个可行解，故：<spanclass="math inline">\(Z \le W(C^*)\)</span>(<spanclass="math inline">\(W\)</span>为求权值的函数)</li><li>为什么求得的集合<spanclass="math inline">\(C\)</span>就是一个点覆盖呢？因为对任意边<spanclass="math inline">\((u,v) \in E\)</span>,有<spanclass="math inline">\(x(u)+x(v)\ge 1\)</span>，即在<spanclass="math inline">\(x(u)\)</span>和<spanclass="math inline">\(x(v)\)</span>中至少有一个的值大于1/2。因此，顶点<spanclass="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>至少有一个会被加入到集合<spanclass="math inline">\(C\)</span>中，从而使得图<spanclass="math inline">\(G\)</span>中的每一条边都会被覆盖。</li><li>由下式</li></ol><p><img src="/img/近似算法/证明线性规划是2倍近似解.png" /></p><p>以及<span class="math inline">\(Z \le W(C^*)\)</span>,知:<spanclass="math inline">\(W(C) \le 2Z &lt;=2W(C^*)\)</span>,即近似解<spanclass="math inline">\(C\)</span>的权值<span class="math inline">\(W(C)\le\)</span> 二倍最优解<spanclass="math inline">\(C^*\)</span>的权值.</p><p>那么是否有比2倍近似解更小的近似解?最小的近似解倍率是多少?</p><p>答:有.</p><p><strong>定理</strong>: 若 P <span class="math inline">\(\ne\)</span>NP,那么没有比<span class="math inline">\(\rho = 1.3607(10\sqrt{5} -21)\)</span>更小的<span class="math inline">\(\rho\)</span>-近似解.</p><h2id="多项式时间逼近算法polynomial-time-approximation-scheme">多项式时间逼近算法(PolynomialTime Approximation Scheme)</h2><p>上面的<spanclass="math inline">\(\rho\)</span>-近似算法是通过牺牲最优解来换取时间和例子,多项式时间逼近算法可以产生任意高质量的解决方案，但以精度换取时间。</p><p>以背包问题为例:物品<spanclass="math inline">\(i\)</span>的价值为<spanclass="math inline">\(v_i\)</span> ,重量为<spanclass="math inline">\(w_i\)</span>;背包最多可以拿的物品重量为<spanclass="math inline">\(W\)</span>.现在求最大可以拿取的物品价值。</p><p><img src="/img/近似算法/背包问题-例子.png" /></p><h3 id="方法1动态规划-1">方法1：动态规划-1</h3><p>定义<spanclass="math inline">\(OPT(i,w)=\)</span>所有物品中可以拿到的<strong>最大价值</strong>。</p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>新的容量为<span class="math inline">\(w-w_i\)</span></li><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w-w_i\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划1.png" /></p><p>运行时间：<span class="math inline">\(O(n W)\)</span></p><ul><li><span class="math inline">\(W=\)</span>重量限制</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="方法2动态规划2">方法2：动态规划2</h3><p>定义<span class="math inline">\(OPT(i,v)=\)</span>物品<spanclass="math inline">\(1,2,\dots,i\)</span>中拿取且得到的物品价值为<spanclass="math inline">\(v\)</span>所消耗的<strong>最小重量</strong></p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>消耗重量<span class="math inline">\(w_i\)</span>,且新的价值为<spanclass="math inline">\(v-v_i\)</span></li><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划2.png" /></p><p>运行时间：<span class="math inline">\(O(n V^*)=O(n^2v_{max})\)</span></p><ul><li><span class="math inline">\(V^*\)</span>为在<spanclass="math inline">\(OPT(n, v) \leW\)</span>的情况下可以选取的最大价值</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="多项式时间逼近算法">多项式时间逼近算法</h3><p>以上的动态规划都可以得到最优解，但是考虑一个问题：若所有物品的价值远大于重量的时候，上面的动态规划还可行吗？</p><p>这时候问题的输入不是多项式的（物品的价值，因为在计算机内数据都要转化为2进制再处理），这时候为了使求解时间更快，引入了新的算法<strong>多项式时间逼近算法（PolynomialTime Approximation Scheme）</strong>。它的大致思想是：</p><ul><li>将所有的价值向上舍入到一个较小的范围里</li><li>在向上舍入后的实力上运行动态规划算法</li><li>得到向上舍入实例的最优解</li></ul><p>注：这里一定要是向上舍入而不能是四舍五入，虽然全部向上舍入可能会在原来的问题中丢失一些较为优质的解，但是若四舍五入的时候，若有向下舍去的价值，可能在新的实例中找到的解在原问题中是不可行解。</p><p><img src="/img/近似算法/背包问题-四舍五入.png" /></p><p>首先对所有价值向上舍入：</p><p><img src="/img/近似算法/向上舍入.png" /></p><ul><li><spanclass="math inline">\(v_{max}\)</span>为原始例子里的最大价值</li><li><span class="math inline">\(\varepsilon\)</span>为精确参数</li><li><span class="math inline">\(\theta\)</span>为放缩因子</li></ul><p>对于放缩之后的例子，复杂度<span class="math inline">\(O(n^3 /\varepsilon)\)</span>,使用上面的动态规划-2方法的运行时间为<spanclass="math inline">\(0(n^2 \hat{v}_{max})\)</span>.</p><p>其中</p><p><img src="/img/近似算法/公式1.png" /></p><p><strong>定理</strong>：若<spanclass="math inline">\(S\)</span>为多项式时间逼近算法找到的一个解，同时<spanclass="math inline">\(S^*\)</span>为另一个可行解，那么有 <spanclass="math inline">\((1+\varepsilon) \sum\limits_{i \in S}v_i \ge\sum\limits_{i \in S^*}v_i\)</span></p><p>证明：</p><p><img src="/img/近似算法/多项式时间逼近算法-证明.png" /></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NP问题以及常见多项式规约</title>
    <link href="/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="pnpnpcnph问题">P、NP、NPC、NPH问题</h2><p><strong>P问题</strong>：存在多项式时间算法的决策问题。</p><p><strong>NP问题</strong>：能在多项式时间内验证某个猜想答案的正确性，但问题求解可能在无法在多项式时间内完成。比如Composite问题、3-Satisfiability、HamiltonianCycle，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。</p><p><strong>结论1</strong>：P <spanclass="math inline">\(\subseteq\)</span> NP</p><p><strong>结论2</strong>：NP <spanclass="math inline">\(\subseteq\)</span> EXP</p><p><strong>EXP问题</strong>：存在指数时间算法的决策问题。</p><p><strong>NPC问题</strong>: 需要满足两个条件</p><ul><li>它是一个NP问题</li><li>所有的NP问题都可以规约到NP-complete</li></ul><p><strong>定理</strong>：若Y是一个NPC问题，那么Y可以在多项式时间内求解<strong>当且仅当</strong>P<spanclass="math inline">\(=\)</span>NP</p><p>证明：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若P <span class="math inline">\(=\)</span>NP，那么Y可以在多项式时间求解，因为Y是NP（NPC的第一个条件：它要先是一个NP）</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若Y可以在多项式时间求解： - 令X为任意一个NP问题，因为X <spanclass="math inline">\(\le_p\)</span>Y，而Y可以在多项式时间求解，故X也可以在多项式时间求解。NP <spanclass="math inline">\(\subseteq\)</span> P - 又已知P <spanclass="math inline">\(\subseteq\)</span> NP,所以 P <spanclass="math inline">\(=\)</span> NP</p><p><strong>如果</strong>我们给NPC问题找到了一个多项式时间复杂度的算法，那么也就意味着我们给所有的NP问题找到了多项式时间复杂度的算法，从而NP=P，因为P=NP，所以“P对NP问题”就可以被解决。但给NPC问题找一个多项式时间复杂度的算法太难了，所以现在人们普遍相信P≠NP。</p><p><strong>NPH问题</strong>：满足上面NPC问题的第二个条件，但不一定要满足第一个条件，所以NPH的范围比HPC更大。</p><h3 id="证明一个问题是npc问题的步骤">证明一个问题是NPC问题的步骤</h3><ul><li>证明这个问题Y属于NP</li><li>选择一个NPC问题X</li><li>证明X可以多项式规约到Y</li></ul><h3 id="证明一个问题是nph问题的步骤">证明一个问题是NPH问题的步骤</h3><p>要证明一个问题是NP-hard，通常是找到一个已被证明了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC<span class="math inline">\(\le\)</span> NP-hard）,简单来说就是：</p><ul><li>对问题A给定限制条件得到一个特例B问题</li><li>证明问题B是NPC问题</li></ul><h2 id="npc之间规约的例子">NPC之间规约的例子</h2><h3 id="sat-le_p-independent-set">3-SAT <spanclass="math inline">\(\le_p\)</span> Independent Set</h3><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造:</p><ul><li>3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点</li><li>连接句子里的点连接形成三角形</li><li>连接不同Clause里每个Literal和它对应的非</li></ul><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h3 id="hamiltonian-cycle-problem">Hamiltonian Cycle problem</h3><p><strong>Hamiltonian Cycle</strong>:给定一个无向图 <spanclass="math inline">\(G=(V,E)\)</span>，是否存在一个简单的环 <spanclass="math inline">\(\Gamma\)</span> 包含 <spanclass="math inline">\(V\)</span> 中所有的点。</p><figure><img src="/img/多项式规约/HamiltonianCycle定义.png"alt="有奇数个节点的Hamiltonian Cycle" /><figcaption aria-hidden="true">有奇数个节点的HamiltonianCycle</figcaption></figure><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p><strong>DIR-HAM-CYCL <span class="math inline">\(\le_p\)</span>Ham-Cycle</strong>: 证明：给定一个有向图<spanclass="math inline">\(G=(V,E)\)</span>,构造一个有<spanclass="math inline">\(3n\)</span>个节点的无向图<spanclass="math inline">\(G&#39;\)</span>，则<spanclass="math inline">\(G\)</span>有Hamiltonian Cycle当且仅当<spanclass="math inline">\(G&#39;\)</span>有Hamiltonian Cycle。</p><p><img src="/img/多项式规约/DIR-HAM-CYC2Ham-Cycle.png" /></p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若<span class="math inline">\(G\)</span>中有一个有向的HamiltonianCycle，则<spanclass="math inline">\(G&#39;\)</span>中肯定也有一个HamiltonianCycle，且顺序与有向图的节点顺序相同。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若<spanclass="math inline">\(G&#39;\)</span>中有一个无向的HamiltonianCycle，则从蓝色节点出发，节点的颜色出现顺序必然是两种中的一种 -B,G,R,B,G,R,<span class="math inline">\(\dots\)</span> -B,R,G,B,R,G,<span class="math inline">\(\dots\)</span></p><p>若<span class="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第一种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相同；若<spanclass="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第二种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相反。</p><h3 id="sat-le_p-hamiltonian-cycle-problem">3SAT <spanclass="math inline">\(\le_p\)</span> Hamiltonian Cycle problem</h3><!-- **Vertex Cover**：一组顶点的集合，使得图的每条边至少与集合中的一个顶点相连接。在这里Vertex Cover问题是给定图$G$和点集的个数$k$，要找到图$G$的一个大小为$k$的点覆盖。（也就是常说的最小点覆盖） --><p><strong>构造思路:有<spanclass="math inline">\(n\)</span>个变量的3-SAT有<spanclass="math inline">\(2^n\)</span>种可能的分配，要将其规约到HamiltonianCycle，其对应的Hamiltonian Cycle应该也有<spanclass="math inline">\(2^n\)</span>种可能的分配方式。</strong></p><p>构造方法：对一个有<span class="math inline">\(n\)</span>个变量和<spanclass="math inline">\(k\)</span>个句子的3-SAT,构造<spanclass="math inline">\(3k+3\)</span>个节点的HamiltonianCycle，其中每个变量<span class="math inline">\(x_i\)</span>对应<spanclass="math inline">\(3k+3\)</span>个节点，令外再增加一个源点<spanclass="math inline">\(s\)</span>、一个汇点<spanclass="math inline">\(t\)</span>。</p><p><img src="/img/多项式规约/3-SAT2Ham-Cycle构造.png" /></p><p>如果 <spanclass="math inline">\(x_i=1\)</span>，则形成从左向右的一个路径；如果<spanclass="math inline">\(x_i=0\)</span>，则形成从右向左的一个路径。</p><p>对于每一个clause <span class="math inline">\(c_j=z_1 z_2z_3\)</span>，若<span class="math inline">\(z=x_i\)</span>,则添加有向边<spanclass="math inline">\((v_{i,3j},c_j)和(c_j,v_{i,3j+1})\)</span>;若<spanclass="math inline">\(z=\bar{x}_i\)</span>,则添加有向边<spanclass="math inline">\((c_j,v_{i,3j})和(v_{i,3j+1},c_j)\)</span>，这里<spanclass="math inline">\(1\le j\le m, 1\le i\len\)</span>。如上图所示（即若<spanclass="math inline">\(z=x_i\)</span>,该节点与<spanclass="math inline">\(c\)</span>节点的连接顺序是从左边进入<spanclass="math inline">\(c\)</span>节点，然后从右边出<spanclass="math inline">\(c\)</span>节点；反之顺序相反）。</p><p>如果选择子句<span class="math inline">\(C_1\)</span>中<spanclass="math inline">\(x_1=1\)</span>,则<spanclass="math inline">\(x_1\)</span>对应的路径为从左向右;同理<spanclass="math inline">\(x_2=0\)</span>,则<spanclass="math inline">\(x_2\)</span>对应的路径为从右向左；<spanclass="math inline">\(x_3=1\)</span>,则<spanclass="math inline">\(x_3\)</span>对应的路径为从左向右。其余句子同理，这样就得到了最终的图<spanclass="math inline">\(G\)</span>。</p><p><strong>证明</strong>:</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>假设3-SAT有一个可满足的分配<spanclass="math inline">\(x^*\)</span>：</p><ul><li>对于<span class="math inline">\(x_i\)</span>,若其为1，则第<spanclass="math inline">\(i\)</span>行从左往右遍历；反之，若其为0，则第<spanclass="math inline">\(i\)</span>行从右往左遍历</li><li>且对于每个句子节点<spanclass="math inline">\(c_i\)</span>，至少会有一行便利的时候会经过<spanclass="math inline">\(c_i\)</span>，否则便不满足每个句子都为真的条件，也就是该分配并不是可满足的。</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>假设构造的图<spanclass="math inline">\(G\)</span>有一个Ham-Cycle，那么</p><ul><li>若Ham-Cycle进入句子节点<spanclass="math inline">\(c_i\)</span>，那么它一定会返回相同的行，否则便不存在简单环。</li><li>这样Ham-Cycle里的句子节点<spanclass="math inline">\(c_i\)</span>与同一行的两个相邻节点相连，记这两个相邻节点之间的边为<spanclass="math inline">\(e_i\)</span></li><li>去掉句子节点<span class="math inline">\(c_i\)</span>，同时用<spanclass="math inline">\(e_i\)</span>替换与<spanclass="math inline">\(c_i\)</span>相连的两条边。</li><li>按上面的方法去掉所有的句子节点得到图也必然存在Ham-Cycle，且节点的顺序是相同的。</li><li>若Ham-Cycle的第<spanclass="math inline">\(i\)</span>行是从左往右遍历的，便令<spanclass="math inline">\(x_i=1\)</span>;反之则令<spanclass="math inline">\(x_i=0\)</span>，这样便得到一个分配方案，且其是可满足的。</li></ul><p>这样便得到一个分配方式，且每个句子都是可满足的。</p><h3 id="ham-cycle-le_p-tsptraveling-saleperson-problem">HAM-CYCLE <spanclass="math inline">\(\le_p\)</span> TSP(Traveling SalepersonProblem)</h3><p><strong>TSP(Traveling Saleperson Problem)</strong>：给定一个<spanclass="math inline">\(n\)</span>个城市的集合以及城市之间的距离<spanclass="math inline">\(d(u,v)\)</span>,是否存在一个旅行的路线使行走的距离<spanclass="math inline">\(\le n\)</span>?</p><p>旅行者问题与HAM-CYCLE的区别在于：旅行者问题并不限定简单路径，也就是说一个节点可以通过多次，只需要考虑最后的路径长度。</p><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p>$HAM-CYCLE <span class="math inline">\(\le_p\)</span> TSP(TravelingSaleperson Problem)$</p><p><strong>构造</strong>：给定一个HAM-CYCLE的实例<spanclass="math inline">\(G=(V,E)\)</span>,<spanclass="math inline">\(V\)</span>中的每个节点构造一个城市节点，城市之间的距离根据<spanclass="math inline">\(E\)</span>进行赋值: <spanclass="math display">\[d(u,v)= \begin{cases}    1, (u,v) \in E  \\    2, (u,v) \notin E\end{cases}\]</span></p><p>则TSP中有一个旅行路径<span class="math inline">\(\len\)</span>当且仅当<spanclass="math inline">\(G\)</span>中存在HAM-CYCLE</p><h3 id="sat-le_p-3-colorable">3-SAT <spanclass="math inline">\(\le_p\)</span> 3-Colorable</h3><p><strong>3-Colorable</strong>:给定一个无向图<spanclass="math inline">\(G\)</span>，并给图中的每个节点染上红、蓝、绿的其中一种颜色，那么是否存在一种染色方式使相邻的节点都有不同的颜色？</p><p>3-SAT <span class="math inline">\(\le_p\)</span> 3-Colorable</p><p><strong>构造</strong>：</p><ul><li>对每个Literal，构造一个节点</li><li>同时添加三个节点<spanclass="math inline">\(T、F、B\)</span>，连接这三个节点形成一个三角形</li><li>对每个literal节点，创建一个它的"非"并与它相连</li><li>所有的Literal节点都与<span class="math inline">\(B\)</span>相连</li></ul><p>如下图所示： <imgsrc="/img/多项式规约/3-SAT23-COLOLABLE-1.png" /></p><p>这样构造保证了下面的每个Literal节点都是绿色或红色，且它的“非”与它的颜色刚好相反。</p><p>继续接上面：</p><ul><li>对每个Clause，假设<span class="math inline">\(C_i=x_1 \vee\overline{x_2} \vee x_3\)</span>,则对<span class="math inline">\(x_1 ,\overline{x_2} , x_3\)</span>添加6个节点以及13条边</li></ul><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-2.png" /></p><p>即<span class="math inline">\(x_1 , \overline{x_2} ,x_3\)</span>下方的两行一共6个节点，并将左下角的节点、第一行的节点与之前构造的<spanclass="math inline">\(T\)</span>节点相连，右下角的节点与之前的<spanclass="math inline">\(F\)</span>节点相连。</p><p>这样构造是为了保证当三个Literal节点全为红色的时候，是不满足三着色的，如下图所示：当三个Literal节点全为红色的时候，他们下面那行节点必须为蓝色，这样最后一行从左到右着色，最后一个节点冲突。</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-3.png" /></p><p><strong>3-SAT <span class="math inline">\(\le_p\)</span>3-Colorable</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若图3-Colorable：</p><ul><li>将所有为绿色的Literal节点设为真</li><li>由上面可知，当图3-Colorable的时候三个Literal节点至少有一个是绿色的，那么该句子的输出为真</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>若3-SAT是可满足的：则 - 三个Literal节点至少有一个为真 -将为真的Literal节点染为绿色，然后将该节点下面的节点染为红色（否则会冲突），再继续将下面的节点染为蓝色-对中间一行没有染红的节点染为蓝色，然后它们下面一行没有染色的节点可唯一确定颜色</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-4.png" /></p><p>上面没有染色的Literal节点绿色、红色皆可。</p><h3 id="color搜索问题-le_p-3-color判断问题自规约">3-COLOR搜索问题 <spanclass="math inline">\(\le_p\)</span> 3-COLOR判断问题（自规约）</h3><p><strong>方法1</strong>：</p><p>将3-COLOR图中不相邻的点合并，合并后的点表示之前所有合并过来点的集合，如下图所示：</p><p><img src="/img/多项式规约/3-color自规约.png" /></p><p>然后一直重复上述步骤，若图可以进行3着色，那么到最后图必然会合并为一个三角形。染色是对最后的三角形三个点所代表的点的集合染成不同的颜色，便为最后的3着色。</p><p><strong>方法2</strong>：</p><p>设判定算法为<span class="math inline">\(D\)</span></p><ol type="1"><li>调用算法<spanclass="math inline">\(D\)</span>判断原图是否有解，若无解，则返回NO。</li><li>任意选择一对边<span class="math inline">\((u,v)\)</span>，满足<spanclass="math inline">\((u,v) \notin E\)</span><ol type="1"><li>考虑图<span class="math inline">\(G&#39; = G +(u,v)\)</span>，调用<spanclass="math inline">\(D\)</span>判断是否有解。</li><li>若<span class="math inline">\(G&#39;\)</span>无解，标记点对<spanclass="math inline">\((u,v)\)</span>；若有解，添加边<spanclass="math inline">\((u,v)\)</span>到<spanclass="math inline">\(G\)</span>中。</li></ol></li><li>返回步骤2，继续选择一对未标记点对。</li><li>若图<spanclass="math inline">\(G\)</span>构成一个三部完全图，每一部选择一个颜色，输出颜色方案。### 点覆盖搜索问题 <span class="math inline">\(\le_p\)</span>点覆盖判断问题</li></ol><ul><li>从1开始，依次查找该图有没有<spanclass="math inline">\(k^*\)</span>个顶点的顶点覆盖(这样得到的第一次满足的<spanclass="math inline">\(k^*\)</span> 的值就是该图最小顶点覆盖的数目)</li><li>从图中选出一个点<span class="math inline">\(v\)</span>，若去除该点后图的顶点覆盖数目变为<span class="math inline">\(k^* −1\)</span>，则<spanclass="math inline">\(v\)</span>是原图顶点覆盖中的一员，反之则不是</li><li>在<span class="math inline">\(G −v\)</span>中递归执行上述两步。</li></ul><h3 id="ham-cycle搜索问题-le_p-ham-cycle判断问题">Ham-Cycle搜索问题<span class="math inline">\(\le_p\)</span> Ham-Cycle判断问题</h3><p>证明：若可以在多项式时间内给出判定一个图是否存在哈密尔顿圈，则可以在多项式时间内找到一个图的哈密尔顿圈（如果存在的话）</p><p>首先判断<spanclass="math inline">\(G\)</span>中是否存在Ham-Cycle,若不存在则算法结束，如果存在则继续寻找Ham-Cycle:<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">对G中的每条边e<br>&#123;<br>    若G-e不存在Ham-<span class="hljs-keyword">Cycle</span>，将e加入S中；<br>    否则令G=G-e<br>&#125;<br>最后所得的集合便是一个Ham-<span class="hljs-keyword">Cycle</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式规约</title>
    <link href="/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="多项式规约">多项式规约</h2><p>定义：若问题X 的任意实例可以由下面两条之和解决</p><ul><li>问题X可以通过多项式时间的基本运算步骤转换为问题Y；</li><li>问题X多项式次调用求解问题Y的算法，且问题Y可以在多项式时间内被求解。</li></ul><p>那么称问题X可以多项式规约到问题Y，记为 $ X _{p} Y$。需要注意的是，问题X转换为问题Y之后，问题Y的运行时间是建立在问题Y的输入上。</p><p>多项式规约的几个性质：</p><ul><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若Y能在多项式时间内求解，那么X也能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若X不能在多项式时间内求解，那么Y也不能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p} Y\)</span> 且 <spanclass="math inline">\(Y \le_{p} X\)</span>，那么X和Y是等价的。</li></ul><h3 id="基本的规约方法">基本的规约方法</h3><ul><li>简单的恒等归约：比如最大独立集和最小点覆盖。</li><li>从特殊例子到一般例子：比如 <span class="math inline">\(点覆盖\le_{p} 集合覆盖\)</span>。<br /></li><li>通过一些小技巧规约。比如 <span class="math inline">\(3-SAT \le_{p}独立集\)</span></li></ul><h3 id="简单的恒等规约">简单的恒等规约</h3><h4 id="独立集问题independent-set">独立集问题（Independent Set）</h4><p><strong>定义</strong>：给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k(V为顶点集，E为边集)，是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \gek\)</span>并且图中每条边至多有一个顶点在S中？</p><figure><img src="/img/多项式规约/独立集.png" alt="独立集" /><figcaption aria-hidden="true">独立集</figcaption></figure><h4 id="点覆盖问题vertex-cover">点覆盖问题（Vertex Cover）</h4><p><strong>定义</strong>:给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k,是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \lek\)</span>并且图中的每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中？</p><figure><img src="/img/多项式规约/点覆盖.png" alt="点覆盖" /><figcaption aria-hidden="true">点覆盖</figcaption></figure><h4 id="vertex-cover和independent-set的关系">Vertex Cover和IndependentSet的关系</h4><p><strong>定理： <span class="math inline">\(点覆盖 \equiv_p独立集\)</span></strong></p><p>证明如下：</p><p><span class="math inline">\(\Rightarrow\)</span></p><ul><li>令<span class="math inline">\(S\)</span>为任意独立集</li><li>对任意的边 <span class="math inline">\((u,v)\)</span></li><li><span class="math inline">\(S\)</span>是独立集 <spanclass="math inline">\(\Rightarrow\)</span> <span class="math inline">\(u\notin S\)</span> 或 <span class="math inline">\(v \notin S \Rightarrowu \in V - S\)</span> 或 <span class="math inline">\(v \in V -S\)</span></li><li>所以 <span class="math inline">\(V-S\)</span> 是一个点覆盖</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><ul><li>令 <span class="math inline">\(V-S\)</span>是一个点覆盖</li><li>对两个顶点 <span class="math inline">\(u \in S\)</span> 及 <spanclass="math inline">\(v \in S\)</span></li><li>若 <span class="math inline">\(V-S\)</span> 是一个点覆盖,那么 <spanclass="math inline">\((u, v) \notin E\)</span></li><li>因此，没有相邻的顶点在 <span class="math inline">\(S\)</span> 中<span class="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(S\)</span>是独立集</li></ul><h3 id="从特殊例子到一般例子">从特殊例子到一般例子</h3><h4 id="集合覆盖set-cover">集合覆盖（Set Cover）</h4><p><strong>定义</strong>：给定一个集合<spanclass="math inline">\(U\)</span>，以及<spanclass="math inline">\(U\)</span>的子集<spanclass="math inline">\(S_1,S_2,\dots,S_m\)</span>以及一个整数<spanclass="math inline">\(k\)</span>，是否存在小于或等于<spanclass="math inline">\(k\)</span>个子集<spanclass="math inline">\(S_i\)</span>的并等于<spanclass="math inline">\(U\)</span>?</p><p><strong>例子</strong>:</p><figure><img src="/img/多项式规约/集合覆盖例子.png" alt="几何覆盖例子" /><figcaption aria-hidden="true">几何覆盖例子</figcaption></figure><h4 id="vertex-cover归约到set-cover">Vertex Cover归约到Set Cover</h4><p><strong>证明：给定一个Vertex-Cover的实例<spanclass="math inline">\(G=(V,E),k\)</span>,可以构造一个与VertexCover大小相等的Set Cover的实例。（从特殊例子到一般例子）</strong></p><ul><li>创建一个Set Cover的实例<span class="math inline">\(k = k,U=E,S_v=\{e\in E: 与V相连的边\}\)</span></li><li>可以看到Set Cover的<span class="math inline">\(size \lek\)</span>当且仅当Vertex Cover的<span class="math inline">\(size \lek\)</span></li></ul><p><strong>例子</strong>：有如下点覆盖</p><p><img src="/img/多项式规约/VertexCover归约到SetCover例子.png" /></p><p>构造Set Cover的<span class="math inline">\(U\)</span>为VertexCover的边集，即<span class="math inline">\(U=(1,2,3,4,5,6)\)</span>，SetCover的每个子集<span class="math inline">\(S_i\)</span>为VertexCover中对应顶点所连的边,故有 <span class="math display">\[    S_a=\{3,7\}， \\    S_b=\{2,4\}， \\    S_c=\{3,4,5,6\}， \\    S_d=\{5\}，  \\    S_e=\{1\}， \\    S_f=\{1,2,6,7\}    \]</span></p><p>可以看到<span class="math inline">\(S_c\)</span>和<spanclass="math inline">\(S_f\)</span>构成一个SetCover的实例，而这两个子集对应的顶点恰好组成一个Vertex Cover的实例。</p><h3 id="通过小技巧规约">通过"小技巧"规约</h3><h4 id="sat问题">3-SAT问题</h4><p><strong>Literal（字）</strong>：一个布尔变量或者它的非<spanclass="math inline">\(x_i \quad or \quad \overline{x_i}\)</span></p><p><strong>Clause（句子）</strong>：Literal的析取 <spanclass="math inline">\(C_j = x_1 \vee \overline{x_2} \veex_3\)</span></p><p><strong>Formula（式子）</strong>：Clause的合取 <spanclass="math inline">\(\Phi=C_1 \wedge C_2 \wedge C_3 \wedgeC_4\)</span></p><p><strong>SAT</strong>:给定CNF式子<spanclass="math inline">\(\Phi\)</span>，是否存在一个满足结果是True的分配<spanclass="math inline">\(x_1,\dots,x_n\)</span>？若有则称式子<spanclass="math inline">\(\Phi\)</span>是<strong>可满足</strong>的。</p><p><strong>3-SAT</strong>:每个Clause只有三个Literals。</p><p><strong>例子</strong>：</p><p><img src="/img/多项式规约/3-SAT例子.png" /></p><h4id="satisfiability3-sat归约到independent-set">3-Satisfiability（3-SAT）归约到IndependentSet</h4><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造: -3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点 -连接句子里的点连接形成三角形 -连接不同Clause里每个Literal和它对应的非</p><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h2 id="自规约重要">自规约（重要）</h2><p><strong>决策问题（Decision Problem）</strong>：诸如"是否存在一个<spanclass="math inline">\(size \ge k\)</span>的点覆盖"</p><p><strong>求解问题（SearchProblem）</strong>：诸如"寻找一个最小的点覆盖"</p><p><strong>自规约（Self-Reducibility）</strong>：Search Problem <spanclass="math inline">\(\le_p\)</span> Decision Problem</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大流最小割</title>
    <link href="/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <url>/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小割">最小割</h2><p>在图论中，去掉其中所有边能使一张网络流图不再连通（即分成两个子图）的边集称为图的割。一个$st-cut $即去掉的边把源点s和汇点t划分在两个不同的部分。</p><figure><img src="/img/最大流最小割/最小割定义.png" alt="最小割定义" /><figcaption aria-hidden="true">最小割定义</figcaption></figure><p>一般来说，一张图中有多个不同的<spanclass="math inline">\(st-cut\)</span>，如下图便为其中一个 <spanclass="math inline">\(st-cut\)</span> 。</p><figure><img src="/img/最大流最小割/一个割例子.png" alt="一个割例子" /><figcaption aria-hidden="true">一个割例子</figcaption></figure><p>但是在实际应用中，我们去掉每条边往往都是有代价的，以边的容量作为权值，一个割中去掉的边的权值之和为这个割的值，那么最小割就是这张图上最小的割。</p><h2 id="最大流">最大流</h2><p>为了求解最小割，需要引入最大流的概念。用边的权值表示边的最大流量，一个<span class="math inline">\(st-flow\)</span>是从源点s到汇点t的流量。通俗的讲，最大流就是从源点s到汇点t的最大流量。</p><figure><img src="/img/最大流最小割/最大流.png" alt="最大流" /><figcaption aria-hidden="true">最大流</figcaption></figure><h2 id="求解最大流">求解最大流</h2><h3 id="贪心算法">贪心算法</h3><ul><li>开始时对每条边e令<span class="math inline">\(f(e)=0\)</span></li><li>找到一条从源点s到汇点t的路径 <span class="math inline">\(s\rightarrow t\)</span> 使路径上的每条边e满足 <spanclass="math inline">\(f(e)&lt;c(e)\)</span> ,其中 <spanclass="math inline">\(c(e)\)</span> 为边e的权值</li><li><span class="math inline">\(flow = flow + 路径上的流量\)</span></li><li>重复上述步骤直至找不到新的路径</li></ul><h3 id="ford-fulkerson算法">Ford-Fulkerson算法</h3><h4 id="残留图residual-graph">残留图(Residual Graph)</h4><p>在另一个图中，额外构造一个反向边，权值是实际流过该边的流量 <spanclass="math inline">\(f(e)\)</span> 。</p><figure><img src="/img/最大流最小割/残余图.png" alt="残余图" /><figcaption aria-hidden="true">残余图</figcaption></figure><p>剩余图有以下性质： - <strong>增广路径(AugmentingPath)</strong>:一个增广路径P是从残余图中的一条简单路径 <spanclass="math inline">\(s \rightarrow t\)</span> -增广路径的容量是该条路径所有边中的最小权值</p><h4 id="算法说明">算法说明</h4><ul><li>每次找到一条从s到t的增广路径，并调整flow和残留图，不断调整直到没有增广路径</li><li>当残留图中不存在从s到t的增广路径时，该图已经达到最大流</li></ul><h4 id="例子">例子</h4><p>初始时没有反向边,此时残留图等于原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子1.png" /></p><p>从中选取一条增广路径,并更新残留图和原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子2.png" /></p><p>重复上面的步骤,注意<strong>增广路径一定要从残留图中找</strong>,且可以使用残留图中的反向边.</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子3.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子4.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子5.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子6.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>此时,没有新的增广路径,则最大流的值等于流进s的流量,即 <spanclass="math inline">\(flow = s_{in}\)</span></p><h2 id="最大流与最小割的关系">最大流与最小割的关系</h2><p><strong>最大流最小割定理：最大流=最小割。</strong>最大流-最小割定理用来证明Ford-Fulkson方法的确达到了最大流.</p><figure><img src="/img/最大流最小割/最大流最小割定理.png"alt="最大流最小割定理" /><figcaption aria-hidden="true">最大流最小割定理</figcaption></figure><p>证明:</p><ul><li><span class="math inline">\((i) \Rightarrow (ii)\)</span>:弱对偶性法则的推论</li><li><span class="math inline">\((ii) \Rightarrow (iii)\)</span>:反证法<br />若f是一个最大流,且仍存在增广路径,那么可以让f加上增广路径的流量,与f是一个最大流相悖.故<spanclass="math inline">\((ii) \Rightarrow (iii)\)</span>成立</li><li><span class="math inline">\((iii) \Rightarrow (i)\)</span></li></ul><p>设f是一个流,且没有增广路径,令A等于s的可达顶点集,则</p><p><img src="/img/最大流最小割/iii到i.png" /></p><h2 id="求出最大流之后如何求最小割">求出最大流之后如何求最小割</h2><p>求完最大流之后，在残留图中用BFS遍历，结束后可得到一个从<spanclass="math inline">\(s\)</span>出发可达的集合，将原图分为两个子集合，<spanclass="math inline">\(s\)</span>可达的集合<spanclass="math inline">\(X\)</span>以及<spanclass="math inline">\(s\)</span>不可达的集合<spanclass="math inline">\(Y\)</span>,其中<spanclass="math inline">\(Y\)</span>中必然包含汇点<spanclass="math inline">\(t\)</span>。</p><p>连接两个集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的边有两种情况</p><ul><li>已被占满的前向边</li><li>没有流量的反向边(即从<span class="math inline">\(Y\)</span>到<spanclass="math inline">\(X\)</span>的边)</li></ul><p>其中被占满的前向边集合就是所求的最小割</p><p>还是用上面的例子 <imgsrc="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>在<span class="math inline">\(G_f\)</span>中,用BFS遍历可得<spanclass="math inline">\(s\)</span>可达的顶点集合为<spanclass="math inline">\(\{s, 3\}\)</span>，在<spanclass="math inline">\(G\)</span>中查看<span class="math inline">\(\{s,3\}\)</span>与图中剩余顶点集合的关系。</p><ul><li>已被占满的前向边:<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span></li><li>没有流量的反向边:<span class="math inline">\(2 \rightarrow3\)</span></li></ul><p>所以图中的一个最小割为<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git撤销commit命令">Git撤销commit命令</h2><p>当要撤销的提交不是最开始的提交时 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD~<br></code></pre></td></tr></table></figure>当要撤销的提交时最开始的提交时 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">update</span> <span class="hljs-operator">-</span><span class="hljs-keyword">ref</span> <span class="hljs-operator">-</span>d HEAD<br></code></pre></td></tr></table></figure> ## Git连接远程仓库<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>url<br></code></pre></td></tr></table></figure> 注：url为github仓库链接 ## Git删除已经add的文件1.要删除的文件少时 一种是 <code>git rm --cached</code>"文件路径"，不删除物理文件，仅将该文件从缓存中删除； 一种是<code>git rm --f</code>"文件路径"，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。</p><p>2.要删除的文件多时 <code>git rm -r --cached</code> . 清空缓存区然后将本地文件删除，再次<code>add</code></p><h2 id="git创建远程新分支">Git创建远程新分支</h2><p>git无法直接通过命令方式创建远程新分支，需要间接来创建,这里我创建的远程新分支名叫vedio</p><p>首先</p><p><code>git checkout --orphan 分支名</code> <imgsrc="https://img-blog.csdnimg.cn/20210403164118752.png" /> <strong>gitrm -rf .</strong> （这一步很关键）然后创建一个文件readme.md（其实任何文件都可以），add并commit，然后</p><p><code>git push origin 分支名</code></p><p>就可以啦~如下图红框圈注的命令 <imgsrc="https://img-blog.csdnimg.cn/20210403164816128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTQyMQ==,size_16,color_FFFFFF,t_70" /></p><h2id="git强制提交本地分支覆盖远程分支">git强制提交本地分支覆盖远程分支</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> localBranchName:remoteBranchName --force<br></code></pre></td></tr></table></figure><h2 id="git从远程仓库拉取">Git从远程仓库拉取</h2><p><code>git pull origin main</code></p><h2 id="git创建与切换分支">Git创建与切换分支</h2><p>创建分支 <code>git branch branch_name</code> 切换分支<code>git checkout branch_name</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Latex常用表示</title>
    <link href="/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th>小写字母</th><th>语法</th><th>大写字母</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(A\)</span></td><td><code>A</code></td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td><td><span class="math inline">\(B\)</span></td><td><code>B</code></td></tr><tr class="odd"><td><span class="math inline">\(\gamma\)</span></td><td><code>\gamma</code></td><td><span class="math inline">\(\Gamma\)</span></td><td><code>\Gamma</code></td></tr><tr class="even"><td><span class="math inline">\(\delta\)</span></td><td><code>\delta</code></td><td><span class="math inline">\(\Delta\)</span></td><td><code>\Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td><td><span class="math inline">\(E\)</span></td><td><code>E</code></td></tr><tr class="even"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(Z\)</span></td><td><code>Z</code></td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td><td><span class="math inline">\(H\)</span></td><td><code>H</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span></td><td><code>\theta</code></td><td><span class="math inline">\(\Theta\)</span></td><td><code>\Theta</code></td></tr><tr class="even"><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(I\)</span></td><td><code>I</code></td></tr><tr class="even"><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td><td><span class="math inline">\(K\)</span></td><td><code>K</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span></td><td><code>\lambda</code></td><td><span class="math inline">\(\Lambda\)</span></td><td><code>\Lambda</code></td></tr><tr class="even"><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td><td><span class="math inline">\(M\)</span></td><td><code>M</code></td></tr><tr class="odd"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(N\)</span></td><td><code>N</code></td></tr><tr class="even"><td><span class="math inline">\(\xi\)</span></td><td><code>\xi</code></td><td><span class="math inline">\(\Xi\)</span></td><td><code>\Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(O\)</span></td><td><code>O</code></td></tr><tr class="even"><td><span class="math inline">\(\pi\)</span></td><td><code>\pi</code></td><td><span class="math inline">\(\Pi\)</span></td><td><code>\Pi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td><td><span class="math inline">\(R\)</span></td><td><code>R</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\sigma\)</span></td><td><code>\sigma</code></td><td><span class="math inline">\(\Sigma\)</span></td><td><code>\Sigma</code></td></tr><tr class="odd"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td><td><span class="math inline">\(T\)</span></td><td><code>T</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td><code>\upsilon</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span></td><td><code>\phi</code></td><td><span class="math inline">\(\Phi\)</span></td><td><code>\Phi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td><td><span class="math inline">\(X\)</span></td><td><code>X</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span></td><td><code>\psi</code></td><td><span class="math inline">\(\Psi\)</span></td><td><code>\Psi</code></td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span></td><td><code>\omega</code></td><td><span class="math inline">\(\Omega\)</span></td><td><code>\Omega</code></td></tr></tbody></table><p>var开头的只有小写希腊字母，没有大写。</p><h2 id="运算符符号">运算符符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td></tr><tr class="even"><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="odd"><td><span class="math inline">\(\int\)</span></td><td><code>\int</code></td></tr><tr class="even"><td><span class="math inline">\(\oplus\)</span></td><td><code>\oplus</code></td></tr><tr class="odd"><td><span class="math inline">\(\otimes\)</span></td><td><code>\otimes</code></td></tr><tr class="even"><td><span class="math inline">\(\times\)</span></td><td><code>\times</code></td></tr><tr class="odd"><td><span class="math inline">\(\cdot\)</span></td><td><code>\codt</code></td></tr><tr class="even"><td><span class="math inline">\(\cap\)</span></td><td><code>\cap</code></td></tr><tr class="odd"><td><span class="math inline">\(\cup\)</span></td><td><code>\cup</code></td></tr></tbody></table><h2 id="关系符号">关系符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\le\)</span></td><td><code>\le</code></td></tr><tr class="even"><td><span class="math inline">\(\ge\)</span></td><td><code>\ge</code></td></tr><tr class="odd"><td><span class="math inline">\(\ll\)</span></td><td><code>\ll</code></td></tr><tr class="even"><td><span class="math inline">\(\gg\)</span></td><td><code>\gg</code></td></tr><tr class="odd"><td><span class="math inline">\(\equiv\)</span></td><td><code>\equiv</code></td></tr><tr class="even"><td><span class="math inline">\(\subseteq\)</span></td><td><code>\subseteq</code></td></tr><tr class="odd"><td><span class="math inline">\(\supseteq\)</span></td><td><code>\supseteq</code></td></tr><tr class="even"><td><span class="math inline">\(\subset\)</span></td><td><code>\subset</code></td></tr><tr class="odd"><td><span class="math inline">\(\supset\)</span></td><td><code>\supset</code></td></tr></tbody></table><h2 id="箭头符号">箭头符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Leftarrow\)</span></td><td><code>\Leftarrow</code></td></tr><tr class="even"><td><span class="math inline">\(\Rightarrow\)</span></td><td><code>\Rightarrow</code></td></tr><tr class="odd"><td><span class="math inline">\(\Longleftrightarrow\)</span></td><td><code>\Longleftrightarrow</code></td></tr></tbody></table><h2 id="其他符号">其他符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\infty\)</span></td><td><code>\infty</code></td><td>无穷</td></tr><tr class="even"><td><span class="math inline">\(\exists\)</span></td><td><code>\exists</code></td><td>存在</td></tr><tr class="odd"><td><span class="math inline">\(\forall\)</span></td><td><code>\forall</code></td><td>任取</td></tr><tr class="even"><td><span class="math inline">\(\ldots\)</span></td><td><code>\ldots</code></td><td>下三连点</td></tr><tr class="odd"><td><span class="math inline">\(\cdots\)</span></td><td><code>\cdots</code></td><td>中三连点</td></tr><tr class="even"><td><span class="math inline">\(\vdots\)</span></td><td><code>\vdots</code></td><td>竖三连点</td></tr><tr class="odd"><td><span class="math inline">\(\ddots\)</span></td><td><code>\ddots</code></td><td>斜三连点</td></tr><tr class="even"><td><span class="math inline">\(\overline{x}\)</span></td><td><code>\overline&#123;x&#125;</code></td><td>平均</td></tr><tr class="odd"><td><span class="math inline">\(\quad\)</span></td><td><code>\quad</code></td><td>空格</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>本文大部分转载自知乎<ahref="https://www.zhihu.com/people/ruan-xing-zhi"><span class="citation"data-cites="阮行止">@阮行止</span></a>，后添加了自己的一些思考。</p><h2 id="从一个生活问题谈起">1. 从一个生活问题谈起</h2><p>先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，<strong>需要用到尽量少的钞票</strong>。</p><p>依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。</p><p>这种策略称为“<strong>贪心</strong>”：假设我们面对的局面是“需要凑出w”，贪心策略会<strong>尽快</strong>让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。</p><p>但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：<br />　　15=1×11+4×1 （贪心策略使用了5张钞票）<br />　　15=3×5 （正确的策略，只用3张钞票）<br />　　为什么会这样呢？贪心策略错在了哪里？</p><p><strong>鼠目寸光</strong>。</p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。</p><p>在这里我们发现，贪心是一种<strong>只考虑眼前情况</strong>的策略。</p><p>那么，现在我们怎样才能避免鼠目寸光呢？</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。</p><p>重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。</p><p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？</p><p>明显<strong>cost=f(4)+1=4+1=5</strong>，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。</p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1=2+1=3</strong>。</p><p>那么，现在w=15的时候，我们该取那种钞票呢？<strong>当然是各种方案中，cost值最低的那一个！</strong></p><ul><li>取11：cost=f(4)+1=4+1=5</li><li>取5:cost=f(10)+1=2+1=3</li><li>取1:cost=f(14)+1=4+1=5</li></ul><p>显而易见，cost值最低的是取5的方案。<strong>我们通过上面三个式子，做出了正确的决策！</strong></p><p>这给了我们一个<strong>至关重要</strong>的启示——f(n)只与f(n-1),f(n-5),f(n-11) 相关；更确切地说：</p><blockquote><p>f(n)=min{f(n-1),f(n-5),f(n-11)}+1</p></blockquote><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><figure><img src="/img/动态规划/解决方案.jpg" alt="pic1" /><figcaption aria-hidden="true">pic1</figcaption></figure><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：</p><ul><li>f(n)只与f(n-1),f(n-5),f(n-11)的值有关。</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。<strong>其他信息并不需要</strong>。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。<strong>我们将求解f(c)称作求解f(n)的“子问题”</strong>。</p><p><strong>这就是DP（动态规划，dynamic programming）</strong>.</p><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</strong></p><h2 id="几个简单的概念">2. 几个简单的概念</h2><ul><li><strong>无后效性</strong><br />一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</li></ul><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p><p>“<strong>未来与过去无关</strong>”，这就是<strong>无后效性</strong>。</p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><ul><li>最优子结构</li></ul><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).</p><p>f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的最优解，我们即可算出w=15的最优解。</p><p>大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“最优子结构性质”。</p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="dp的典型应用dag最短路">3. DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><figure><img src="/img/动态规划/最短路径.png" alt="最短路径" /><figcaption aria-hidden="true">最短路径</figcaption></figure><p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).</p><p>想要到T，要么经过C，要么经过D。从而<spanclass="math inline">\(f(T)=min\{f(C)+20,f(D)+10\}\)</span>.</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是<spanclass="math inline">\(S \rightarrow P\rightarrow Q \rightarrowT\)</span>,那肯定S走到Q的最优路径是<span class="math inline">\(S\rightarrow P\rightarrowQ\)</span>。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><blockquote><p>f(P)=min{f(R)+W<sub><span class="math inline">\(R \rightarrowP\)</span></sub>}</p></blockquote><p>其中R为有路通到P的所有的点， [公式] 为R到P的过路费。</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="对dp原理的一点讨论">4. 对DP原理的一点讨论</h2><ul><li>DP的核心思想</li></ul><p>DP为什么会快？</p><p>无论是DP还是暴力，我们的算法都是在<strong>可能解空间</strong>内，寻找<strong>最优解</strong>。</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。</p><p>DP是枚举<strong>有希望成为答案的解</strong>。这个空间比暴力的小得多。</p><p>也就是说：<strong>DP自带剪枝</strong>。</p><p>DP舍弃了一大堆不可能成为最优解的答案。譬如：<br />　　15 = 5+5+5 被考虑了。<br />　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。</p><p>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><ul><li>DP的操作过程</li></ul><p>一言以蔽之：<strong>大事化小，小事化了</strong>。</p><p>将一个大问题转化成几个小问题；<br />　　求解小问题；<br />　　推出大问题的解。</p><ul><li>如何设计DP算法</li></ul><p>下面介绍比较通用的设计DP算法的步骤。</p><p>首先，把我们面对的局面表示为x。这一步称为设计状态。</p><p>对于状态x，记我们要求出的答案(e.g.最小费用)为f(x).我们的目标是求出f(T).<strong>找出f(x)与哪些局面有关（记为p）</strong>，写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><ul><li>DP三连</li></ul><p>设计DP算法，往往可以遵循DP三连：</p><p>我是谁？ ——设计状态，表示局面</p><p>我从哪里来？</p><p>我要到哪里去？ ——设计转移</p><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，<strong>更新能从x走到的一些解</strong>。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><blockquote><p>思考题：如何把钞票问题的代码改写成“我到哪里去”的形式？<br />提示：求出f(x)之后，更新f(x+1),f(x+5),f(x+11).</p></blockquote><h2 id="例题最长上升子序列">5. 例题：最长上升子序列</h2><p>扯了这么多形而上的内容，还是做一道例题吧。</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。<br />　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p><p>如何设计状态（我是谁）？</p><p>我们记<spanclass="math inline">\(f(x)\)</span>为以a<sub>x</sub>结尾的LIS长度，那么答案就是<span class="math inline">\(max\{f(x)\}\)</span></p><p>状态x从哪里推过来（我从哪里来）？</p><p>考虑比x小的每一个p：如果 a<sub>x</sub> &gt; a<sub>p</sub>，那么<spanclass="math inline">\(f(x)\)</span>可以取<spanclass="math inline">\(f(p)+1\)</span>.</p><p>解释：我们把 a<sub>x</sub> 接在 a<sub>p</sub>的后面，肯定能构造一个以 a<sub>x</sub> 结尾的上升子序列，长度比以a<sub>p</sub> 结尾的LIS大1.那么，我们可以写出状态转移方程了：</p><figure><img src="/img/动态规划/状态转移方程.svg" alt="状态转移方程" /><figcaption aria-hidden="true">状态转移方程</figcaption></figure><p>至此解决问题。两层for循环，复杂度O(n<sup>2</sup>) 。</p><figure><img src="/img/动态规划/最长上升子序列代码.jpg"alt="最长上升子序列代码" /><figcaption aria-hidden="true">最长上升子序列代码</figcaption></figure><p>从这三个例题中可以看出，DP是一种思想，一种“大事化小，小事化了”的思想。带着这种思想，DP将会成为我们解决问题的利器。</p><h2 id="习题">6. 习题</h2><p>如果读者有兴趣，可以试着完成下面几个习题：</p><ol type="1"><li>请采取一些优化手段，以 O(n log<sub>2</sub> n)的复杂度解决LIS问题。</li></ol><p>提示：可以参考这篇博客 <ahref="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">JuniorDynamic Programming--动态规划初步·各种子序列问题</a></p><ol start="2" type="1"><li>“按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成<ahref="https://www.luogu.com.cn/problem/P1541">P1541 乌龟棋 - 洛谷</a>。</li><li>01背包问题是一种常见的DP模型。请完成<ahref="https://www.luogu.com.cn/problem/P1048">P1048 采药 -洛谷</a>。</li></ol><h2 id="读后思考动态规划和分治法的区别与共同点">7.读后思考：动态规划和分治法的区别与共同点？</h2><h3 id="分治法">1. 分治法</h3><p>分治法(Divide-and-Conquer) :将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治模式在每一层递归上都有三个步骤：</p><ul><li>分解(Divide)：将原问题分解成一系列子问题；</li><li>解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。</li><li>合并(Combine)：将子问题的结果合并成原问题的解。</li></ul><p>合并排序(MergeSort)是一个典型分治法的例子。其对应的直观的操作如下:</p><p>分解： 将n个元素分成各含n/2个元素的子序列；</p><p>解决：用合并排序法对两个子序列递归地排序；</p><p>合并：合并两个已排序的子序列以得到排序结果。</p><h3 id="动态规划法">2. 动态规划法</h3><p>动态规划算法的设计可以分为如下4个步骤：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><p><strong>分治法是指将问题划分成一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。</strong></p><p>适合采用动态规划方法的最优化问题中的两个要素：<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p><p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p><p>In a word, <strong>分治法 —— 各子问题独立；动态规划 ——各子问题重叠</strong>。</p><p>算法导论：<strong>动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><h2 id="红黑树的性质">红黑树的性质</h2><ol type="1"><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</li></ol><p>由性质5我们可以推出：<br />性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</p><h2 id="红黑树和avl的区别">红黑树和AVL的区别</h2><ol type="1"><li><p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p></li><li><p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p></li><li><p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胜者树与败者树</title>
    <link href="/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    <url>/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>胜者树与败者树是完全二叉树。就像是参加比赛一样，每个选手有不同的实力，两个选手PK,实力决定胜负，晋级下一轮，经过几轮之后，就能得到冠军。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。在k路归并排序中经常用到。</p><h2 id="胜者树">胜者树</h2><p>胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p><figure><img src="/img/胜者树败者树/fig1.jpg" alt="fig1" /><figcaption aria-hidden="true">fig1</figcaption></figure><p>上图是一个胜者树的示例。规定数值小者胜。 1. b3 PKb4，b3胜b4负，内部结点ls[4]的值为3； 2. b3 PKb0，b3胜b0负，内部结点ls[2]的值为3； 3. b1 PKb2，b1胜b2负，内部结点ls[3]的值为1； 4. b3 PKb1，b3胜b1负，内部结点ls[1]的值为3。</p><p>取出胜者b3之后，叶子结点b3的值变为11时，重构的胜者树如下:</p><figure><img src="/img/胜者树败者树/fig2.jpg" alt="fig2" /><figcaption aria-hidden="true">fig2</figcaption></figure><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。</li></ol><p>用胜者树对n个节点实现排序操作，构建胜者树和构建堆比较相似，区别在于胜者树只有叶子节点存放了数据，中间节点记录的是叶子节点间的关系。</p><p>胜者树在每次重构时只需与其兄弟结点比较，一直到根节点选出胜者为止。</p><h2 id="败者树">败者树</h2><p>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p><figure><img src="/img/胜者树败者树/fig3.jpg" alt="fig3" /><figcaption aria-hidden="true">fig3</figcaption></figure><p>上图是一棵败者树。规定数大者败。</p><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；</li></ol><p>败者树重构过程如下： -将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。-比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。</p><figure><img src="/img/胜者树败者树/fig4.jpg" alt="fig4" /><figcaption aria-hidden="true">fig4</figcaption></figure><h2 id="胜者树败者树堆比较">胜者树、败者树、堆比较</h2><h3 id="相同点">相同点</h3><p>这三者空间和时间复杂度都是一样的。调整一次的时间复杂度都是O(logN)的。</p><h3 id="不同点">不同点</h3><p>一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，<strong>调整堆的时候，每次都要选出父结点的两个孩子节点的最小值，然后再用孩子结点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了胜者树。这样<strong>每次比较只用跟自己的兄弟结点进行比较就好</strong>，所以用胜者树可以比堆少一半的比较次数。</p><p>而<strong>胜者树想要比较兄弟结点首先要获得其父结点，也就是说需要访存两次</strong>，这时人们又想能否再次减少比较次数，于是就有了败者树。败者树每个新元素上升时，<strong>只需要获得父节点并比较即可</strong>。</p><p>总的来说，败者树与胜者树相比减少了访存时间。<strong>现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了</strong>。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html#:~:text=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91%E9%83%BD%E6%98%AF%E5%AE%8C%E5%85%A8,%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BE%E5%88%B0%E6%9C%80%E5%80%BC%E3%80%82">胜者树和败者树</a></li><li><ahref="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
