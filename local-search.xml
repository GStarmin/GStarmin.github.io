<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络IO模型</title>
    <link href="/2023/09/13/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/09/13/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络io模型">网络IO模型</h1><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><h2 id="阻塞io">阻塞IO</h2><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="/img/网络IO模型/应用程序读取数据图.png" /></p><p><strong>具体流程如下图</strong>：</p><p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO。</p><p><strong>阶段一</strong>：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>此时用户进程也处于阻塞状态</li></ul><p><strong>阶段二</strong>：</p><ul><li>数据到达并拷贝到内核缓冲区，代表已就绪</li><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p><p><img src="/img/网络IO模型/应用程序读取数据流程图.png" /></p><p><strong>缺点</strong>：</p><p>当有client与服务器连接之后，服务器端就会调用read()函数等待client发送数据，如果client没有发送数据，那么服务器端就会一直阻塞等待，直到client发送数据。</p><p>若服务器端采用单线程处理用户请求，如果有client连接到服务器，在这个client与服务器断开连接之前，服务器端是无法处理其他client的请求的，这样就会导致服务器端的性能下降；如果服务器端是多线程的，即每当有一个client连接时，在新建一个线程去处理这个client的请求，那么当client连接数过多时，服务器端的线程数也会过多，这样会导致服务器端的性能下降，而且线程也是OS非常宝贵的资源，线程之间的切换也是需要消耗CPU资源的。</p><p>上述在多线程情况下的缺点有两种<strong>解决方案</strong>：</p><ul><li>采用线程池，即预先创建一定数量的线程，当有client连接时，从线程池中取出一个线程去处理client的请求，当client断开连接时，该线程回到线程池中，等待下一个client的连接。</li><li>NIO(非阻塞IO):</li></ul><h2 id="非阻塞io">非阻塞IO</h2><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p><p><img src="/img/网络IO模型/非阻塞IO流程图.png" /></p><p>NIO实质上是使用轮询来替代异步阻塞，即讲所有连接存在一个队列中，然后不断轮询这个队列，看看是否有连接有数据可读，如果有，就读取数据，如果没有，就继续轮询。</p><p>缺点：</p><ul><li>如果连接数量过大，轮询的效率会很低，因为大部分连接都是没有数据可读的，但是仍然需要轮询每个连接。</li><li>轮询遍历的过程是出于用户态的，而判断连接是否有数据可读是出于内核态的，这样就需要用户态和内核态之间的切换，这样会导致CPU资源的浪费。</li></ul><p><strong>解决方案</strong>：IO多路复用</p><h2 id="io多路复用">IO多路复用</h2><h3 id="select">select</h3><p>select是Linux最早是由的I/O多路复用技术。</p><p>前面有说到，采用NIO（非阻塞）的方式在高并发的情况下，会导致CPU空转，CPU使用率暴增，而且轮询的效率也会很低，因为大部分连接都是没有数据可读的，但是仍然需要轮询每个连接，而且需要频繁的用户态和内核态之间的切换，这样会导致CPU资源的浪费。</p><p>基于以上问题，select就应运而生了。它的思想是把需要轮询的fd集合复制到内核空间，然后由内核来负责轮询，这样就避免了用户态和内核态之间的切换，也避免了轮询的效率低下的问题。</p><p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据。</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情，比如说频繁的传递fd集合，频繁的去遍历FD等问题。</p><p><img src="/img/网络IO模型/select定义以及流程.png" /></p><p><strong>select的缺点</strong>：</p><ul><li>select中存放文件描述符(fd)的数组大小FD_SETSIZE为1024,进程的文件描述符上限默认是1024，正是因为这个原因，select设计时才把数组大小设计为1024，所以一个进程最多只能处理1024个客户端</li><li>fd数组拷贝到了内核态仍然有开销(只是相对于之前要从用户态切换到内核态少了系统调用切换上下文的开销。（内核层可以优化为异步事件通知）)。</li><li>select并没有通知用户态哪一个socket有数据，仍然需要用户态自己去做一次<spanclass="math inline">\(O(n)\)</span>的遍历。（可优化为只返回给用户就绪的文件描述符，无序用户做多余遍历）</li></ul><h3 id="poll">poll</h3><p>poll是select的改进版，但是性能提升不明显，部分流程如下：</p><ul><li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li></ul><p>与select对比：</p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用<strong>链表</strong>，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><p><img src="/img/网络IO模型/poll定义.png" /></p><p><strong>缺点</strong>：</p><ul><li>pollfd数组拷贝到了内核态仍然有开销，poll在每次调用的时候都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，</li><li>poll并没有通知用户态哪一个socket有数据，仍然需要用户态自己去做一次<spanclass="math inline">\(O(n)\)</span>的遍历。</li></ul><h3 id="epoll">epoll</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>；<span class="hljs-comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>；</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br><br><span class="hljs-number">1.</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</span><br><span class="hljs-comment">// 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</span><br><br><span class="hljs-number">2.</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>；</span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function">函数是对指定描述符fd执行op操作。</span></span><br><span class="hljs-comment"><span class="hljs-function">- epfd：是epoll_create()的返回值。</span></span><br><span class="hljs-comment"><span class="hljs-function">- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="hljs-comment"><span class="hljs-function">- fd：是需要监听的fd（文件描述符）</span></span><br><span class="hljs-comment"><span class="hljs-function">- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> epoll_event </span>&#123;<br>  <span class="hljs-type">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-type">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><br><span class="hljs-comment">//events可以是以下几个宏的集合：</span><br><span class="hljs-comment">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="hljs-comment">// EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="hljs-comment">// EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="hljs-comment">// EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="hljs-comment">// EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="hljs-comment">// EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="hljs-comment">// EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="hljs-number">3.</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br><span class="hljs-comment">// 等待epfd上的io事件，最多返回maxevents个事件。</span><br><span class="hljs-comment">// 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</span><br></code></pre></td></tr></table></figure><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><ul><li>epoll_create:创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li><li>epoll_ctl: 函数是对指定描述符fd执行op操作。见上面注释。</li><li>epoll_wait:等待epfd上的io事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大。</li></ul><p>epoll和poll的一个很大的区别在于，poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而epoll内核中维护了一个<strong>内核事件表</strong>，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。</p><p>那么如何在内核中维护这个内核事件表呢？内核事件表时常要有插入、查找和删除的操作，而这些操作会对内核的效率产生不小的影响，因此需要一种插入、查找和删除效率都很高的数据结构，<strong>红黑树</strong>就是一个不错的选择。</p><p>epoll的优点：</p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数，即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li>与poll不同，epoll每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li></ul><h3 id="小总结">小总结</h3><p><strong>select模式存在的三个问题</strong>：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p><strong>poll模式的问题</strong>：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p><strong>epoll模式中如何解决这些问题的？</strong></p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li></ul><p><img src="/img/网络IO模型/IO多路复用对比.png" /></p><h3 id="epoll中的et和lt">epoll中的ET和LT</h3><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>举个栗子：</p><ul><li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li><li>客户端socket发送了2kb的数据</li><li>服务端调用epoll_wait，得到通知说FD就绪</li><li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li></ul><p>两种不同通知方式的结果：</p><ul><li>如果我们采用LT模式，因为FD中仍有1kb数据，则第 3步依然会返回结果，并且得到通知</li><li>如果我们采用ET模式，因为第 3步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</li></ul><h3 id="基于epoll的服务器端流程">基于epoll的服务器端流程</h3><p><img src="/img/网络IO模型/IO复用模型流程.png" /></p><ol type="1"><li>服务器启动以后，服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据<ul><li>红黑树（初始为空）：rb_root 用来去记录需要被监听的FD</li><li>链表（初始为空）：list_head，用来存放已经就绪的FD</li></ul></li><li>创建好了之后，会去调用epoll_ctl函数，此函数会会将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去(但是此时并没有完成)</li><li>当第二步完成后，就会调用epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），在等待了一段时间后(可以进行配置)，如果等够了超时时间，则返回没有数据，如果有，则进一步判断当前是什么事件，如果是建立连接时间，则调用accept()接受客户端socket，拿到建立连接的socket，然后建立起来连接，如果是其他事件，则把数据进行写出</li></ol><p><img src="/img/网络IO模型/基于epoll的服务器端流程.png" /></p><h2 id="信号驱动io">信号驱动IO</h2><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：</p><ul><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li></ul><p>阶段二：</p><ul><li>收到SIGIO回调信号</li><li>调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><img src="/img/网络IO模型/信号驱动IO流程.png" /></p><p><strong>缺点</strong>：当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h3 id="异步io">异步IO</h3><p>上面的信号驱动方式用户调用recvfrom读取数据之后，需要等待内核将数据从内核空间拷贝到用户空间，而这个过程中用户是阻塞等待的，而异步IO则是用户调用recvfrom读取数据之后，内核会将数据从内核空间拷贝到用户空间，然后内核会给用户发送一个信号，告诉用户数据已经拷贝完成，此时用户就可以去处理数据了，这个过程用户不会阻塞。</p><p><img src="/img/网络IO模型/异步IO流程.png" /></p><h2 id="五个io模型对比">五个I/O模型对比</h2><p><img src="/img/网络IO模型/五个IO模型对比.png" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-高级篇-skiplist</title>
    <link href="/2023/09/11/Redis-%E9%AB%98%E7%BA%A7%E7%AF%87-skiplist/"/>
    <url>/2023/09/11/Redis-%E9%AB%98%E7%BA%A7%E7%AF%87-skiplist/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-skiplist">redis-skiplist</h1><h2 id="为什么引出跳表">为什么引出跳表</h2><ul><li><p>先从一个单链表来说对于一个单链表来讲，<font color = 'blue'>即便链表中存储的数据是有序的</font>，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高O(N)</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/55.单链表.png" /></p></li><li><p>痛点</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/56.单链表.png" /></p><p>解决方法：升维，也即空间换时间</p></li><li><p>优化</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/57.索引优化.png" /></p></li><li><p>案例：画一个包含64个节点的链表，按前面思路，建立五级索引</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/58.索引案例.png" /></p></li></ul><h2 id="是什么">是什么</h2><p>跳表是可以实现二分查找的有序链表</p><p><font color = 'red'>skiplist是一种以空间换取时间的结构</font>。由于链表，无法进行二分查找，因此借鉴数据库索引的思想，提取出链表中关键节点(索引)，先在关键节点上查找，再进入下层链表查找，提取多层关键节点，就形成了跳跃表。</p><p>但是，<font color = 'red'>由于索引也要占据一定空间的，所以，索引添加的越多，空间占用的越多</font></p><p>总结来说，跳表=链表+多级索引</p><h2id="跳表时间和空间复杂度介绍"><font color = 'red'>跳表时间和空间复杂度介绍</font></h2><ol type="1"><li><p>跳表的时间复杂度，O(logN)</p><p><font color = 'blue'>跳表查询的时间复杂度分析，如果链表里有N个结点，会有多少级索引呢？</font></p><p>按照我们前面笔记，两两取首。每两个结点会抽出一个结点作为上一级索引的结点，以此估算:</p><p>第一级索引的结点个数大约就是n/2</p><p>第二级索引的结点个数大约就是n/4.</p><p>第三级索引的结点个数大约就是n/8，依次类推......</p><p>也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2^k)</p><p>假设索引有h级，最高级的索引有2个结点。通过上面的公式，</p><p>我们可以得到n/(2^h)=2，从而求得h=log2n-1(log以2为底，n的对数)</p><p>如果包含原始链表这一层，整个跳表的高度就是log2n(log以2为底，n的对数)</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/59.跳表时间复杂度.png" /></p></li><li><p>跳表空间复杂度</p><p><font color = 'blue'>跳表查询的空间复杂度分析</font></p><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢?</p><p>我们来分析一下跳表的空间复杂度。</p><p><font color = 'red'>第一步：</font>首先原始链表长度为n，</p><p><font color = 'red'>第二步：</font>两两取首，每层索引的结点数:n/2,n/4,n/8 ...,8,4,2每上升一级就减少一半，直到剩下2个结点,以此类推，如果我们把每层索引的结点数写出来，就是一个等比数列。</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/60.跳表.png" /></p><p>这几级索引的结点总和就是n/2+n/4+/8.+8+4+2=n-2。所以，跳表的空间复杂度是O(n)。也就是说，如果将包含n个结点的单链表构造成跳表，我们需要额外再用接近n个结点的存储空间。</p><p>同理，若三三取首，每层索引的节点数： n/3, n/9, n/27, ..., 9, 3,1，以此类推：</p><p>第一级索引的结点个数大约就是n/3，第二级索引的节点个数大约就是n/9，第三级索引的结点个数大约就是n/27，每往上一级，索引节点个数都除以3，。为了方便计算，我们吧最高一级的索引节点个数视为1.我们把每级索引节点个数写出来，就是一个等比数列。</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/三三取首计算公式.png" /></p><p>通过等比数列求和公式，总的索引大概是n/3+n/9+n/27+...+9+3+1=n/2。所以，三三取首的跳表的空间复杂度也是O(n),但是比上面两两取首的跳表，节省了一半的索引空间。</p><p>一般来说使用两两取首和三三取首就已经足够了，不需要再增加了。因为，如果我们继续增加，比如四四取首，五五取首，那空间复杂度就会越来越大，跳表的优势就没有那么明显了。</p></li></ol><h2 id="优缺点">优缺点</h2><p><font color = 'blue'>优点：</font></p><p>跳表是一个最典型的空间换时间解决方案，而且只有在<font color = 'red'>数据量较大的情况下</font>才能体现出来优势。而且应该是<font color = 'red'>读多写少的情况下</font>才能使用，所以它的适用范围应该还是比较有限的</p><p><font color = 'blue'>缺点：</font></p><p>维护成本相对要高，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)but新增或者删除时需要把所有索引都更新一遍，为了保证原始链表中数据的有序性，我们需要先找到要动作的位置，这个查找操作就会比较耗时最后在新增和删除的过程中的更新，时间复杂度也是o(logn)</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis笔记</title>
    <link href="/2023/09/08/redis%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/08/redis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="redis笔记">redis笔记</h1><p>redis笔记见<ahref="https://tangzhi.blog.csdn.net/article/details/109210263">REDIS6_分布式存储极致性能目录</a></p><p>尚未完成，待续...</p><h2 id="redlcok算法">Redlcok算法</h2><p>Redlock算法是redis作者提出的一种分布式锁算法，它的思想是由多个redis（这些redis是相互独立的，不存在主从复制或集群协调机制）实现。在加锁时，客户端首先要设置一个锁的失效时间，然后对每个redis实例进行加锁，如果从大多数的redis节点都取到锁且时间不超过锁的失效时间，那么就视为成功获取了锁；如果未能成功获取锁，那么就在<strong>所有</strong>redis实例上解锁（即便是没有成功加锁的节点也要再解锁，这是为了防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新加锁）。</p><div class="admonition info"><p class="admonition-title">info</p><p>官方推荐Redlock的节点个数为5个，但是也可以是3个或者7个(一般情况都是奇数)，只要大多数节点都能成功加锁就可以了。</p></div><h2id="最低保证分布式锁有效性以及安全性的要求">最低保证分布式锁有效性以及安全性的要求</h2><ul><li>互斥：任何时刻只有一个客户端能持有锁</li><li>释放死锁：即使锁定资源的服务崩溃或者分区，仍然能释放锁</li><li>容错性：只要多数redis节点（一半以上）在使用，client就可以获取和释放锁</li></ul><h2 id="redis的底层数据结构">redis的底层数据结构</h2><h3 id="redis6相关的底层模型和结构">redis6相关的底层模型和结构</h3><ul><li>String = SDS</li><li>Set = intset + hashtable</li><li>ZSet = skiplist + zipList</li><li>List = quicklist + zipList</li><li>Hash = zipList + hashtable</li></ul><h3 id="redis7相关的底层模型和结构">redis7相关的底层模型和结构</h3><div class="admonition info"><p class="admonition-title">info</p><p>在redis7中zipList被listpack紧凑列表替代，有关zipList的配置参数也被listpack替代，但是为了向下兼容，在配置文件中关于zipList的配置参数仍然存在,只不过不再使用，当你修改listpack的参数时，zipList的参数也会跟着改变;修改ziplist的参数时，listpack的参数也会改变，这两个参数是同步的，而实际上使用的都是listpack。</p></div><ul><li>String = SDS</li><li>Set = intset + hashtable</li><li>ZSet = skiplist + listpack紧凑列表</li><li>List = quicklist + zipList</li><li>Hash = listpack + hashtable</li></ul><h3id="为什么有了ziplist还要有listpack">为什么有了ziplist还要有listpack</h3><p>ziplist在更新数据后可能会出现连锁更新的问题，所以设计出了listpack来替代ziplist，listpack通过每个节点记录自己的长度且放在节点的尾部，来彻底解决掉ziplist存在的连锁更新的问题。</p><h2 id="quicklist">quicklist</h2><h3 id="redis6中的quicklist">redis6中的quicklist</h3><p>redis6中的quicklist是一个双向链表，双向链表的每个节点都是一个ziplist,redis7中的quicklist也是一个双向链表，但是不同的是它的每个节点都是listpack。</p><div class="admonition info"><p class="admonition-title">info</p><p>在早期的quicklist是有两种的，当列表对象的长度比较小或者数量比较少的时候，采用压缩列表ziplist来存储。当列表对象中元素的长度比较大的或者数量比较多的时候，则会转向双向链表linkedlist来存储。</p><p>这两者各有优缺点：</p><ul><li>ziplist的优点是内存紧凑，访问效率高，缺点是插入和删除效率低，并且数据量较大的时候，可能会出现连锁更新的问题。</li><li>linkedlist的优点是插入和删除效率高，缺点是内存不紧凑，并且节点较多的时候，会产生大量的内存碎片。</li></ul></div><h2id="网络模型-redis是单线程的吗为什么使用单线程">网络模型-Redis是单线程的吗？为什么使用单线程？</h2><p>redis到底是单线程还是多线程？</p><ul><li>如果仅仅看Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是看整个Redis，那么答案就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redisv4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入多线程，进一步提高对于多核CPU的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。</p><p>为什么Redis要选择单线程？</p><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-STL-lower_bound和upper_bound高级用法</title>
    <link href="/2023/08/21/Cpp-STL-lower-bound-upper-bound%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <url>/2023/08/21/Cpp-STL-lower-bound-upper-bound%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1id="cpp-stl-lower_bound和upper_bound高级用法">Cpp-STL-lower_bound和upper_bound高级用法</h1><h2 id="基本用法">基本用法</h2><p>我们都知道C++STL中有两个函数lower_bound和upper_bound，它们都是在有序序列中进行二分查找的，lower_bound返回的是第一个<strong>大于等于</strong>给定值的元素的位置，upper_bound返回的是第一个<strong>大于</strong>给定值的元素的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>    cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>) &lt;&lt; endl;    <span class="hljs-comment">// 5</span><br>    cout &lt;&lt; *<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>) &lt;&lt; endl;    <span class="hljs-comment">// 6</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是最简单的用法，其实lower_bound和upper_bound有4个参数，上面使用的是默认的<code>cmp</code>,但是有的时候我们可能需要针对特定问题来定义我们自己的比较方式,或者我们想要使用一个没有默认cmp的类型，那么就需要用到自定义<code>cmp</code>了。</p><h2 id="自定义cmp">自定义cmp</h2><p>假如我们现在想对一个二维数组进行二分查找，那么我们就需要自定义一个<code>cmp</code>函数，这个函数的参数是两个<code>vector&lt;int&gt;</code>，返回值是<code>bool</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>    cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, [](vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 3</span><br>    cout &lt;&lt; *<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, [](vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面自定义了一个比较函数，这个函数的参数是两个<code>vector&lt;int&gt;</code>，返回值是<code>bool</code>，这个函数的作用是比较两个<code>vector&lt;int&gt;</code>的第一个元素的大小，那么该二分查找就是对vector<int>的第一个元素进行二分查找。</p><h2 id="进阶">进阶</h2><p>自定义比较函数的例子里，我们二分搜索的目标是一个<code>vector&lt;int&gt;</code>，也就是说搜索目标和被搜索的序列的类型是一样的，但是如果这里的搜索目标是一个数而不是vector<int>呢？（即搜索目标和待搜索的序列类型不一样）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><br>    cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, [](vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> b) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b;<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 3</span><br><br>    cout &lt;&lt; *<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, [](<span class="hljs-type">int</span> a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a &lt; b[<span class="hljs-number">0</span>];<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们待二分搜索序列中的每个元素类型是<code>vector&lt;int&gt;</code>,而函数中的搜索目标却是一个<code>int</code>。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>这里需要注意的是，若要使用这种方法，上面的lower_bound和upper_bound的比较器是不一样的，以上面的例子来说，lower_bound的比较器是<code><ahref="vector%3Cint%3E%20a,%20int%20b"></a> &#123; return a[0] &lt; b;&#125;</code>，而upper_bound的比较器是<code><ahref="int%20a,%20vector%3Cint%3E%20b"></a> &#123; return a &lt; b[0];&#125;</code>，两个比较器的参数顺序以及函数体内的参数顺序刚好都是反过来的。</p></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂计算</title>
    <link href="/2023/08/15/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/08/15/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂计算">快速幂计算</h1><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在<span class="math inline">\(\Theta(\log n)\)</span> 的时间内计算 <spanclass="math inline">\(a^n\)</span> 的小技巧，而暴力的计算需要 <spanclass="math inline">\(\Theta(n)\)</span> 的时间。</p><p>计算 a 的 n 次方表示将 n 个 a 乘在一起： <spanclass="math inline">\(a^{n} = \underbrace{a \times a \cdots \timesa}_{n\text{a}}\)</span>。然而当 <span class="math inline">\(a,n\)</span>太大的时侯，这种方法就不太适用了。不过我们知道：<spanclass="math inline">\(a^{b+c} = a^b \cdot a^c,\,\,a^{2b} = a^b \cdot a^b= (a^b)^2\)</span>。二进制取幂的想法是，我们将取幂的任务按照指数的二进制表示 来分割成更小的任务。</p><p>快速幂的思想其实很简单，就是公式的转换</p><ol type="1"><li>当指数是偶数时，我们可以让指数除以2，底数乘以底数</li><li>当指数是奇数时，我们可以将指数变为偶数</li></ol><p><strong>例子</strong>：计算 <spanclass="math inline">\(2^{10}\)</span></p><ol type="1"><li>指数是偶数,<span class="math inline">\(2^{10} = 4^5\)</span></li><li>指数是奇数，<span class="math inline">\(4^{5} = 4 \times4^{4}\)</span></li><li>指数是偶数，<span class="math inline">\(4 \cdot 4^{4} = 4 \cdot 16^2= 4 \cdot 256^1\)</span></li><li>指数是奇数，<span class="math inline">\(4 \cdot 256^1 = 4 \cdot 256\cdot 256^0\)</span>，指数为<spanclass="math inline">\(0\)</span>时停止，那么答案就是<spanclass="math inline">\(4 \cdot 256 = 1024\)</span></li></ol><p>代码实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 递归实现</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">binpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-built_in">binpow</span>(a, b / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> res * res * a;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> res * res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 非递归实现</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">binpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a;<br>    a = a * a;<br>    b &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:</p><ul><li><ahref="https://oi-wiki.org/math/binary-exponentiation/">快速幂</a></li><li><ahref="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/solutions/2080665/kuai-su-mi-ji-suan-bei-tlezhi-pei-de-kon-houj/">快速幂计算——被TLE支配的恐惧</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp-string split函数</title>
    <link href="/2023/08/14/split%E5%87%BD%E6%95%B0/"/>
    <url>/2023/08/14/split%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="c-string-split函数">C++ string split函数</h1><p>C++标准库里面没有字符分割函数split,我们可以借助STL自己实现一个split函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s是需要分割的字符串, v是存放分割后的字符串的vector, c是分割符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SplitString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; v, <span class="hljs-type">const</span> std::string&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br>  std::string::size_type pos1, pos2;<br>  pos2 = s.<span class="hljs-built_in">find</span>(c);<br>  pos1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(std::string::npos != pos2)<br>  &#123;<br>    v.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(pos1, pos2-pos1));<br> <br>    pos1 = pos2 + c.<span class="hljs-built_in">size</span>();<br>    pos2 = s.<span class="hljs-built_in">find</span>(c, pos1);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(pos1 != s.<span class="hljs-built_in">length</span>())<br>    v.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(pos1));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 20-span容器</title>
    <link href="/2023/07/18/Cpp20-span%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/07/18/Cpp20-span%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="c-20-span容器">C++ 20-span容器</h1><p>span 是 C++20 中引入的一个新的标准容器,它类似于C++17的std::string_view，我们知道std::string_view可以创建std::string的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用std::string_view会让字符串处理的性能大幅提升。实际上，对于那些连续的序列对象我们都可以创建这样一份视图，对于std::vector这样的对象可以提高某些操作中的性能，另外对原生数组可以提高其访问的安全性。而span 用于表示连续的一段内存区间，类似于一个轻量级的只读数组容器。</p><p>它的定义在头文件 <span> 中，并位于 std 命名空间中。span包含了一个指向连续内存区域的指针以及它所占用的大小，可以通过它来访问这个内存区域中的元素。</p><p>过去如果一个函数想接受无法确定数组长度的数组作为参数，那么一定需要声明两个参数：数组指针和长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_data</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> len)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> buf[<span class="hljs-number">128</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">set_data</span>(buf, <span class="hljs-number">128</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种人工输入增加了编码的风险，数组长度的错误输入会引发程序的未定义行为，甚至是成为可被利用的漏洞。C++20标准库为我们提供了一个很好解决方案std::span，通过它可以定义一个基于连续序列对象的视图，包括原生数组，并且保留连续序列对象的大小。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;span&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_data</span><span class="hljs-params">(std::span&lt;<span class="hljs-type">int</span>&gt; arr)</span> </span>&#123;<br>    std::cout &lt;&lt; arr.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> buf[<span class="hljs-number">128</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">set_data</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>除了原生数组，std::vector和std::array也在std::span的处理之列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; buf1&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>std::array&lt;<span class="hljs-type">int</span>, 3&gt; buf2&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-built_in">set_data</span>(buf1);<br><span class="hljs-built_in">set_data</span>(buf2);<br></code></pre></td></tr></table></figure><p>值得注意的是，std::span还可以通过构造函数设置连续序列对象的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> buf[<span class="hljs-number">128</span>]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">set_data</span>(&#123; buf, <span class="hljs-number">16</span> &#125;);<br></code></pre></td></tr></table></figure><p>从std::string_view到std::span，我们可以看出C++标准库很乐于这种视图设计，因为这种设计和抽象的实现可以提高C++程序的可靠性而又不牺牲性能和可移植性。</p><h2 id="stdspan的用法">std::span的用法</h2><p>span 主要用于以下场景：</p><ul><li>作为函数的参数，用于指示函数需要处理的数据范围；</li><li>作为类的成员变量，用于表示对象所管理的内存区域；</li><li>作为数组的视图，用于访问数组的一部分</li></ul><h3 id="将数组转换为-span">将数组转换为 span</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, <span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>这里将一个整型数组 arr 转换为 span类型，并使用数组首地址和元素个数作为参数。</p><h3 id="使用-span-来遍历一个容器">使用 span 来遍历一个容器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; x : <span class="hljs-built_in">span</span>(vec)) &#123;<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 span(vec) 来构造一个 span 对象，遍历其中的元素并输出。</p><h3 id="使用-span-来获取子序列">使用 span 来获取子序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">auto</span> s1 = s.<span class="hljs-built_in">subspan</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>这里将一个 span 对象 s 分割为从第 1 个元素开始，长度为 3的子序列，并将结果存储到 s1 中。</p><h3 id="将-span-转换为其他容器类型">将 span 转换为其他容器类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(s.begin(), s.end())</span></span>;<br></code></pre></td></tr></table></figure><p>这里使用 s.begin() 和 s.end() 将 span 对象 s转换为迭代器范围，并使用这个迭代器范围构造一个 vector 容器 vec。</p><h2 id="span-的底层原理">span 的底层原理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> Extent = std::dynamic_extent&gt;<br><span class="hljs-keyword">class</span> span &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义迭代器类型</span><br>    <span class="hljs-keyword">using</span> iterator = T*;<br>    <span class="hljs-keyword">using</span> const_iterator = <span class="hljs-type">const</span> T*;<br> <br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> : data_(nullptr), size_(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(T* ptr, std::<span class="hljs-type">size_t</span> count)</span> : data_(ptr), size_(count) &#123;</span>&#125;<br>    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(T(&amp;arr)[N])</span> <span class="hljs-keyword">noexcept</span> : data_(arr), size_(N) &#123;</span>&#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(Container&amp; c)</span> <span class="hljs-keyword">noexcept</span> : data_(c.data()), size_(c.size()) &#123;</span>&#125;<br> <br>    <span class="hljs-comment">// 拷贝构造函数和拷贝赋值运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(<span class="hljs-type">const</span> span&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>= <span class="hljs-keyword">default</span>;<br>    span&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> span&amp; other) <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br> <br>    <span class="hljs-comment">// 访问元素和迭代器操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T* <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> size_ == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> idx) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> data_[idx]; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_[<span class="hljs-number">0</span>]; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_[size_<span class="hljs-number">-1</span>]; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_ + size_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_iterator <span class="hljs-title">cbegin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_iterator <span class="hljs-title">cend</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_ + size_; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    T* data_;  <span class="hljs-comment">// 元素指针</span><br>    std::<span class="hljs-type">size_t</span> size_;  <span class="hljs-comment">// 元素数量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>具体实现方式是通过指针来引用连续的一段内存，从而实现 span的基本功能。由于 span没有实际的内存所有权，所以它不能拥有或释放内存。它只是提供了对现有内存块的访问。</p><p>标准库中的 span还提供了一些其他的功能，比如对子区间的切片和子区间的迭代器等。实际的实现可能会更加复杂，但其基本的思想是一致的。</p><h2 id="span-与-array-vector-数组指针-的区别">span 与 array ,vector，数组指针 的区别</h2><h3 id="span-与-array-vector的区别">span 与 array ,vector的区别</h3><p>与 array 和 vector 相比，span的主要区别在于它不拥有自己的存储空间，而是引用了另一个数组或容器的内存空间。因此，当我们需要使用一个连续的内存块时，可以使用span 来代替 array 或 vector。</p><p>具体来说，array是一个固定大小的数组容器，其大小在编译时就确定了，不能动态改变。vector是一个动态增长的数组容器，可以动态分配内存，并在需要时扩大容量。而 span是一个非拥有型的容器，可以看作是一个指向连续内存区域的引用，可以指向任何类型的元素。</p><p>在使用方面，array 和 vector可以用来存储数据，并通过下标或迭代器来访问其中的元素；span则更多地用来表示一段内存区域，并提供类似于迭代器的操作来访问其中的元素（就是只读），如 begin、end、rbegin、rend 等。</p><h3 id="span-与-数组指针的区别">span 与 数组指针的区别</h3><ul><li>span是一个封装了数组指针和长度的轻量级容器，它提供了对数组的安全访问。指针只是一个指向内存位置的地址，没有长度信息。因此，使用指针时需要显式地传递长度信息，否则可能会导致缓冲区溢出等问题;</li><li>span支持范围操作，它可以使用STL中的算法和其他支持范围操作的库进行操作。指针只能通过指针运算和下标操作来访问和操作数据;</li><li>span是可传递性的，可以传递到函数中作为参数，而指针不能。这是因为在函数中传递指针时，我们必须显式地传递指针所指向的内存块的大小，否则函数无法确定内存块的大小;</li><li>span是一个类模板，可以指定数据类型和长度类型。指针只能指向特定类型的数据。</li></ul><h2 id="参考">参考</h2><ul><li><ahref="https://www.jb51.net/article/277100.htm">C++20中的span容器及用法小结</a></li><li><ahref="https://0cch.com/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/">使用std::span代替数组指针传参</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp17-std::string_view用法</title>
    <link href="/2023/07/17/Cpp17-std-string-view%E7%94%A8%E6%B3%95/"/>
    <url>/2023/07/17/Cpp17-std-string-view%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp17-stdstring_view">Cpp17-std::string_view</h1><h2 id="stdstring_view用法">std::string_view用法</h2><p>C++中有两种风格的字符串，分别是C风格的字符串、std::string字符串。C风格的字符串性能更高，但是叶不方便使用。如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//C风格字符串总是以null结尾</span><br>    <span class="hljs-type">char</span> cstr1[] = &#123; <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">char</span> cstr2[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">strcpy</span>(cstr1, cstr2);<br>    std::cout &lt;&lt; cstr2 &lt;&lt; std::endl;<br> <br>    <span class="hljs-comment">//C++风格的字符串操作更方便，但是性能不如C风格字符串</span><br>    std::string str = <span class="hljs-string">&quot;jam&quot;</span>;<br>    std::string str2 = str;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++17中我们可以使用std::string_view来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。std::string_view比std::string的性能要高很多，因为每个std::string都独自拥有一份字符串的拷贝，而std::string_view只是记录了自己对应的字符串的指针和偏移位置。当我们在只是查看字符串的函数中可以直接使用std::string_view来代替std::string。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;jam&quot;</span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView1</span><span class="hljs-params">(cstr)</span></span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView2</span><span class="hljs-params">(cstr, <span class="hljs-number">2</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;stringView1: &quot;</span> &lt;&lt; stringView1 &lt;&lt; <span class="hljs-string">&quot;, stringView2: &quot;</span> &lt;&lt; stringView2 &lt;&lt; std::endl;<br> <br>    std::string str = <span class="hljs-string">&quot;jam&quot;</span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView3</span><span class="hljs-params">(str.c_str())</span></span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView4</span><span class="hljs-params">(str.c_str(), <span class="hljs-number">2</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;stringView3: &quot;</span> &lt;&lt; stringView3 &lt;&lt; <span class="hljs-string">&quot;, stringView4: &quot;</span> &lt;&lt; stringView4 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">stringView1: jam, stringView2: ja<br>stringView3: jam, stringView4: ja<br></code></pre></td></tr></table></figure><p>我们可以把原始的字符串当作一条马路，而我们是在马路边的一个房子里，我们只能通过房间的窗户来观察外面的马路。这个房子就是std::string_view，你只能看到马路上的车和行人，但是你无法去修改他们，可以理解你对这个马路是只读的。正是这样std::string_view比std::string会快上很多。</p><h2 id="stdstring_view容易踩坑的点">std::string_view容易踩坑的点</h2><p>在Effective C++和C++ primer中都提到过，当一个函数有 std::string类型的参数，如果这个参数它不会被修改，那么应该以 const-reference的方式传递。即使用<code>const string &amp;str</code>而不是<code>string str</code>。</p><p>而上面说过，使用std::string会有性能问题，因为当我们一个函数的参数为<code>const string&amp; str</code>时，如果传进来的参数是一个C风格的字符串，那么编译器会自动的创建一个std::string对象，编译器会使用这个C风格的字符串构造一个std::string,这样就会多一份std::string的构造开销。而如果我们使用std::string_view，那么就不会有这个问题，因为std::string_view只是一个指针，不会拷贝字符串。</p><p>但是我们要注意，std::string_view并不是一个完全的替代std::string的类型，因为std::string_view只是一个引用，它并不拥有字符串，所以当我们使用std::string_view时，我们必须保证这个字符串的生命周期要比std::string_view的生命周期要长。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>在使用std::string_view作为函数参数的时候，最好不要使用引用传参，因为std::string_view的本质就是一个引用，使用引用的引用并不会带来更多好处。</p></div><p>参考：</p><ul><li><a href="https://www.cnblogs.com/yangxunwu1992/p/14018837.html">C++17 std::string_view使用介绍</a></li><li><ahref="https://uint128.com/2022/02/16/C-17-%E7%89%B9%E6%80%A7-%E4%BD%BF%E7%94%A8-std-string-view-%E6%97%B6%E5%B0%8F%E5%BF%83%E8%B8%A9%E5%9D%91/">C++17特性:使用 std::string_view 时小心踩坑</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-StringPiece</title>
    <link href="/2023/07/17/muduo%E5%BA%93-StringPiece/"/>
    <url>/2023/07/17/muduo%E5%BA%93-StringPiece/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-stringpiece">muduo库-StringPiece</h1><p>在 StringPiece.h 文件中，声明了两个类类型，一个是 StringArg，另一个是StringPiece，前者用于在传递函数参数时同时兼容 C 风格的字符串(constchar*)和 C++风格的字符串(std::string)。而后者则可用于构建同时兼任这两种风格字符串的实例对象。</p><p>如果函数参数使用 const std::string&amp;作为形参，尽管可以同时兼容两种风格的字符串，但是当传入一个很长的 char*时，会生成一个很大的 string 对象，其开销较大。而且使用 std::string时不可避免会带来很多不必要的拷贝，拷贝多了必然影响性能。因此在很多高性能C++ 框架的实现中，都会使用 StringPiece 作为 std::string 类型的wrapper，该类只持有目标字符串的指针，而避免额外的拷贝，同时也保证了兼容性。当仅仅读取字符串的值，可以使用该类型。</p><p>常见的实现如下：</p><ul><li><ahref="https://github.com/vmg/pcre/blob/master/pcre_stringpiece.h.in">pcre</a></li><li><ahref="https://source.chromium.org/chromium/chromium/src/+/main:base/strings/string_piece.h;l=1?q=string_piece.h&amp;ss=chromium">Chromium</a></li></ul><p>因为 StringPiece 不控制字符串的声明周期，因此调用方要保证在StringPiece 的生命周期内，其指向的字符串是始终有效的。</p><div class="admonition note"><p class="admonition-title">note</p><p>如果想使用 StringPiece 作为 hash 的 key，需要自定义哈希函数，可以参考Chromium 实现。</p></div><p>由于 StringPiece 只持有目标指针，所以为 POD(Plain Old Data)类型，同时拥有 trival 构造函数，因此可以定义 __type_traits 以指示 STL采用更为高效的算法实现。</p><div class="admonition info"><p class="admonition-title">trival构造函数</p><p>见<a href="https://gstarmin.github.io/2023/07/17/Cpp-%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C++非平凡构造函数</a></p></div><p>转载自<ahref="https://www.cnblogs.com/tuilk/p/16791395.html">Muduo库之StringPiece、Time</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-非平凡构造函数</title>
    <link href="/2023/07/17/Cpp-%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/17/Cpp-%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="c-非平凡构造函数">C++ 非平凡构造函数</h1><p><strong>什么是非平凡(non-trival)构造函数？</strong></p><p>简单来说，“平凡”意味着这些特殊的成员函数用很朴素的方式完成它们的工作。而”很朴素的方式“这个说法对不同的函数有不同的意义。</p><ol type="1"><li>对默认构造函数和析构函数来说，“平凡”意味着什么也不做。</li><li>对拷贝构造函数和拷贝赋值函数来说，“平凡”意味着只做简单的内存拷贝。</li></ol><p>下面是具体的规则：</p><p><strong>规则一</strong>：如果你为类显式定义了一个构造函数，那么它就是非平凡的构造函数，即使这个构造函数里什么都没做。因此，平凡的构造函数一定是你没写构造函数，编译器为你生成的那个函数。这个规则对其他几类函数同样适用。</p><p>可以想象，如果一个类同时拥有平凡构造函数，平凡拷贝构造函数，平凡拷贝赋值函数，平凡析构函数，那么这个类应该是非常简单的结构（这些函数咱肯定都没写）。</p><p><strong>规则二</strong>：规则一只是平凡的必要条件，除了不主动实现这些函数之外，“平凡构造函数”不允许在对象创建做任何隐式的初始化，“平凡拷贝构造函数”和“平凡拷贝赋值函数”不允许在对象拷贝的过程中做任何额外的操作。</p><p>规则二不太好理解，举两个例子：如果类有虚函数，那么相比没有虚函数的类，编译器为你生成的构造函数里需要进行额外的初始化（初始化虚指针等），因此这个类的构造函数不能认为是平凡的。同理，如果一个类有虚基类，这个类的构造函数也不是平凡的，因为这个类在构造的时候也需要进行一些隐式的额外操作来支持虚继承机制。</p><p>有虚函数和有虚基类这两种情况下，对象不能由简单的原始内存复制例程（如memcpy）进行复制，而需要进行额外的操作才能正确地重新初始化副本中的隐藏指针。由于这个原因，上述两种类的拷贝构造函数和拷贝赋值操作符也都不是平凡的。</p><p><strong>规则三</strong>：“平凡”是递归定义的，意味着类的每个组件都要是平凡的。这里说的组件，包括基类，成员变量。因为我们知道，类构造时会先调用基类的构造函数，调用成员变量的构造函数，如果它们不是平凡的，那么自己的构造函数怎么会是平凡的？</p><p>对于如下两个类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 没有显式定义 ctor、copy、assignment、dtor 所以均为 trival</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> &#123;<br>  <span class="hljs-type">int</span> a; <span class="hljs-comment">// POD类型</span><br>&#125;;<br> <br><span class="hljs-comment">// 没有显式定义 copy、assignment、dtor 所以均为 trival</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> &#123;<br>  <span class="hljs-built_in">T1</span>() &#123;&#125; <span class="hljs-comment">// 显示定义 ctor，为 non-trival ctor</span><br>  <span class="hljs-type">int</span> a;  <span class="hljs-comment">// POD</span><br>  std::string b; <span class="hljs-comment">// 非POD</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如何判断一个类是否为trival构造函数呢？c++STL提供了判断平凡性的类型萃取器，只要<code>#include&lt;type_traits&gt;</code>就可以使用。</p><div class="admonition note"><p class="admonition-title">note</p><p>在C++ 11中，有了 =delete 和 =default关键字，如果使用这两个关键字，那么该函数就为 trival类型，编译器会为其做出进一步优化。相对于空函数体而言，则更具有优势。</p></div><p>对于如下测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TestA</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">TestA</span>() &#123;&#125;<br> <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TestB</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">TestB</span>() = <span class="hljs-keyword">default</span>;<br> <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br>&#125;;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS_NUM 10000000</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">clock_t</span> start, end;<br>  start = <span class="hljs-built_in">clock</span>();<br>  TestA* a = <span class="hljs-keyword">new</span> TestA[CLASS_NUM];<br>  <span class="hljs-keyword">delete</span>[] a;<br>  end = <span class="hljs-built_in">clock</span>();<br>  cout &lt;&lt; <span class="hljs-string">&quot;non-trival: &quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;<br> <br>  start = <span class="hljs-built_in">clock</span>();<br>  TestB* b = <span class="hljs-keyword">new</span> TestB[CLASS_NUM];<br>  <span class="hljs-keyword">delete</span>[] b;<br>  end = <span class="hljs-built_in">clock</span>();<br>  cout &lt;&lt; <span class="hljs-string">&quot;trival: &quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">non-trival: 0.205<br>trival:     0.025<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://zhuanlan.zhihu.com/p/434531482">什么是非平凡(non-trivial)构造函数</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Buffer实现</title>
    <link href="/2023/07/15/muduo%E5%BA%93-Buffer%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/15/muduo%E5%BA%93-Buffer%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-buffer实现">muduo库-Buffer实现</h1><p>muduo库中的Buffer结构示意图如下图所示：</p><p><img src="/img/muduo/buffer/Buffer.png" /></p><p>它使用 vector来作为底层容器，可以进行动态的扩容操作。其次，前置的预留字节空间可用于填充数据序列化后的消息长度。该类的构造函数及其成员变量如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> : <span class="hljs-keyword">public</span> muduo::copyable &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kCheapPrepend = <span class="hljs-number">8</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kInitialSize = <span class="hljs-number">1024</span>;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Buffer</span><span class="hljs-params">(<span class="hljs-type">size_t</span> initialSize = kInitialSize)</span></span><br><span class="hljs-function">    : buffer_(kCheapPrepend + initialSize),</span><br><span class="hljs-function">      readerIndex_(kCheapPrepend),</span><br><span class="hljs-function">      writerIndex_(kCheapPrepend) &#123;</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">writableBytes</span>() == initialSize);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">prependableBytes</span>() == kCheapPrepend);<br>  &#125;<br> <br><span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">char</span>&gt; buffer_;<br>  <span class="hljs-type">size_t</span> readerIndex_;<br>  <span class="hljs-type">size_t</span> writerIndex_;<br> <br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> kCRLF[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，Buffer 类对于预留空间默认为 8 字节，而其默认大小为 8 + 1024，即1032 字节。</p><p>如下三个函数分别返回预留空间大小、可读空间大小和可写空间大小，而peek() 则返回读指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">prependableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">readableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">writableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>如下函数用于在可读区域中寻找回车换行符，search()方法的第一个参数和第二个参数是查找的范围，第三个和第四个参数是要查找的子集的头部和尾部。对于kCRLF 而言， ASCII 码为 13，的 ASCII 码为10，所以这实际上是两个字符，这也是如下调用 search() 方法时最后一个参数是kCRLF + 2 的原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> Buffer::kCRLF[] = <span class="hljs-string">&quot;\r\n&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findCRLF</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* crlf = std::<span class="hljs-built_in">search</span>(<span class="hljs-built_in">peek</span>(), <span class="hljs-built_in">beginWrite</span>(), kCRLF, kCRLF+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> crlf == <span class="hljs-built_in">beginWrite</span>() ? <span class="hljs-literal">NULL</span> : crlf;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findCRLF</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* start)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">peek</span>() &lt;= start);<br>  <span class="hljs-built_in">assert</span>(start &lt;= <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* crlf = std::<span class="hljs-built_in">search</span>(start, <span class="hljs-built_in">beginWrite</span>(), kCRLF, kCRLF+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> crlf == <span class="hljs-built_in">beginWrite</span>() ? <span class="hljs-literal">NULL</span> : crlf;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，可读区域中查找结尾符的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findEOL</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* eol = <span class="hljs-built_in">memchr</span>(<span class="hljs-built_in">peek</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">readableBytes</span>());<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(eol);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findEOL</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* start)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">peek</span>() &lt;= start);<br>  <span class="hljs-built_in">assert</span>(start &lt;= <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* eol = <span class="hljs-built_in">memchr</span>(start, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">beginWrite</span>() - start);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(eol);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下方法仅仅只是移动指针，而不操作数据。注意，在断言之后，len的大小只能小于等于可读空间的大小。因此，如果 len的长度小于可读空间的大小，说明数据还未读取完，移动读指针即可。而在 else中，则表示 len 的长度等于可读空间的大小，说明数据刚好读取完成，那么调用retrieveAll() 方法将读指针和写指针重置为初始化状态即可。而retrieveUntil() 则是移动可读指针直到指定位置为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(len &lt;= <span class="hljs-built_in">readableBytes</span>());<br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-built_in">readableBytes</span>())&#123;<br>    readerIndex_ += len;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">retrieveAll</span>();<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieveAll</span><span class="hljs-params">()</span> </span>&#123;<br>  readerIndex_ = kCheapPrepend;<br>  writerIndex_ = kCheapPrepend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieveUntil</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* end)</span></span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">peek</span>() &lt;= end);<br>  <span class="hljs-built_in">assert</span>(end &lt;= <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-built_in">retrieve</span>(end - <span class="hljs-built_in">peek</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>其过程如下图中最后两步操作所示：</p><p><img src="/img/muduo/buffer/Buffer-操作过程.png" /></p><p>如下函数则是从可读区域中读取数据，读取的数据大小与 int64的大小相同，读完之后，移动读指针并返回数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">readInt64</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int64_t</span> result = <span class="hljs-built_in">peekInt64</span>();<br>  <span class="hljs-built_in">retrieveInt64</span>();<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">peekInt64</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">readableBytes</span>() &gt;= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int64_t</span>));<br>  <span class="hljs-type">int64_t</span> be64 = <span class="hljs-number">0</span>;<br>  ::<span class="hljs-built_in">memcpy</span>(&amp;be64, <span class="hljs-built_in">peek</span>(), <span class="hljs-keyword">sizeof</span> be64);<br>  <span class="hljs-keyword">return</span> sockets::<span class="hljs-built_in">networkToHost64</span>(be64);<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">peek()函数</p><p>peek() 函数即 cin.peek() ,它与 cin.get() 类似,但有一个重要的区别，当 get函数被调用时，它将返回输入流中可用的下一个字符，并从流中移除该字符；但是，peek函数返回下一个可用字符的副本，而不从流中移除它。</p></div><p>如下函数是向可写区域追加数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece&amp; str)</span> </span>&#123;<br>  <span class="hljs-built_in">append</span>(str.<span class="hljs-built_in">data</span>(), str.<span class="hljs-built_in">size</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-comment">/*restrict*/</span> data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">ensureWritableBytes</span>(len);<br>  std::<span class="hljs-built_in">copy</span>(data, data+len, <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-built_in">hasWritten</span>(len);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-comment">/*restrict*/</span> data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">append</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data), len);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要追加的数据长度大于可写区域的长度，那么就需要扩容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ensureWritableBytes</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() &lt; len) &#123;<br>    <span class="hljs-built_in">makeSpace</span>(len);<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">writableBytes</span>() &gt;= len);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的扩容函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSpace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() + <span class="hljs-built_in">prependableBytes</span>() &lt; len + kCheapPrepend) <br>  &#123;<br>    buffer_.<span class="hljs-built_in">resize</span>(writerIndex_+len);<br>  &#125; <br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-built_in">assert</span>(kCheapPrepend &lt; readerIndex_);<br>    <span class="hljs-type">size_t</span> readable = <span class="hljs-built_in">readableBytes</span>();<br>    std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>()+readerIndex_,<br>              <span class="hljs-built_in">begin</span>()+writerIndex_,<br>              <span class="hljs-built_in">begin</span>()+kCheapPrepend);<br>    readerIndex_ = kCheapPrepend;<br>    writerIndex_ = readerIndex_ + readable;<br>    <span class="hljs-built_in">assert</span>(readable == <span class="hljs-built_in">readableBytes</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>可写区域的长度</strong>和<strong>预留区域的长度</strong>之和小于<strong>所需长度</strong>和<strong>初始化预留区域的长度</strong>(8)之和，就需要对缓冲区进行扩容，其过程如下图所示，可见，扩容后可写区域的长度即为所需长度len。</p><p><img src="/img/muduo/buffer/buffer扩容.png" /></p><p>否则，则表示预留空间和可写区域还很充足，为此需要将预留区域中多出来的部分移动到可写区域中去。其过程如下图所示，先将可写区域的内容向前移动，使得预留区域恢复为初始化大小，即8。然后移动读指针和写指针。</p><p><img src="/img/muduo/buffer/buffer扩容-1.png" /></p><p>对于如下函数，其目的是在可读区域前添加一段数据。而预留区域初始化的 8个字节便是为该函数所准备的，以便在可读区域前添加一些序列化后的数据长度信息，而无需进行数据的迁移，以少量的空间代价换取了时间。其过程如下：先将读指针前移len 个长度，然后将 data 中的数据拷贝进来即可。</p><!-- ![](/img/muduo/buffer/buffer前添加数据.png) --><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepend</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-comment">/*restrict*/</span> data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(len &lt;= <span class="hljs-built_in">prependableBytes</span>());<br>  readerIndex_ -= len;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* d = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data);<br>  std::<span class="hljs-built_in">copy</span>(d, d+len, <span class="hljs-built_in">begin</span>()+readerIndex_);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下方法是 Buffer 类最重要的方法，其目的是为了从 fd 上读取数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::readFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span>* savedErrno)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> extrabuf[<span class="hljs-number">65536</span>];<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> writable = <span class="hljs-built_in">writableBytes</span>();<br>  vec[<span class="hljs-number">0</span>].iov_base = <span class="hljs-built_in">begin</span>()+writerIndex_;<br>  vec[<span class="hljs-number">0</span>].iov_len = writable;<br>  vec[<span class="hljs-number">1</span>].iov_base = extrabuf;<br>  vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-keyword">sizeof</span> extrabuf;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> iovcnt = (writable &lt; <span class="hljs-keyword">sizeof</span> extrabuf) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">ssize_t</span> n = sockets::<span class="hljs-built_in">readv</span>(fd, vec, iovcnt);<br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    *savedErrno = errno;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(n) &lt;= writable) &#123;<br>    writerIndex_ += n;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    writerIndex_ = buffer_.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">append</span>(extrabuf, n - writable);<br>  &#125;<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 IP 数据包中有一个 16 位的长度字段，则说明 IP 数据包的最大长度为65536 字节，即 64K。同时由于 IP 数据包的分片机制，即单次发送的 IP报文长度不能超过 MTU(最大传输单元)，通常为 1500字节。为此，该函数在栈上申请了 64K的额外空间用于尽力接受一个完整的数据包，以防可写区域不足以容纳所接收到的网络数据。</p><p>而结构体 iovec 则用于定义一个向量元素，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> &#123;<br>    <span class="hljs-type">void</span>   *iov_base; <span class="hljs-comment">/* Starting address (内存起始地址）*/</span><br>    <span class="hljs-type">size_t</span> iov_len;   <span class="hljs-comment">/* Number of bytes to transfer（这块内存长度） */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>iov_base所指向的缓冲区用于存放网络接受的数据，或者是网络将要发送的数据。而iov_len 字段用于存放接受数据的最大长度，或者是实际写入的数据长度。</p><p>在 readFd 方法中，定义了两个 iovec结构体，一部分用于将读到的数据放在可写区域，另一部分用于将读到的数据放在额外缓冲区域。然后，使用如下方法进行分散读，即将数据从文件描述符读到分散的内存块中。其中的第三个参数表示iov 的数组长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span></span>;<br></code></pre></td></tr></table></figure><p>从 readFd 方法中可以看出，如果可写区域的长度小于65536，则两个内存块都使用，否则只使用可写区域即可。</p><p>最后根据 readv方法的返回值来确定是否需要额外缓冲区，如果返回的字节数要大于可写区域的长度，说明两个内存块都使用了，且可写区域中已经填充满了，其余的数据全部在额外缓冲区中，此时，只需移动写指针到缓冲区的数据末端，然后将额外缓冲区中的数据追加进来即可。</p><p>转载自<ahref="https://www.cnblogs.com/tuilk/p/16806370.html">Muduo库之Buffer</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-手动实现堆</title>
    <link href="/2023/07/12/Cpp-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A0%86/"/>
    <url>/2023/07/12/Cpp-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="c-手动实现堆">C++ 手动实现堆</h1><p>在C++ STL中其实是有堆的实现的，C++中的<code>priority_queue</code>就是由堆实现的，但是在面试中堆排序还是非常常问的，所以还是非常有必要手动实现一下堆。</p><h2 id="堆的定义">堆的定义</h2><p>堆是一种特殊的完全二叉树，其满足以下两个条件：</p><ol type="1"><li>堆中任意节点的值总是不大于（或不小于）其子节点的值。</li><li>堆总是一棵完全二叉树。</li></ol><p>其中节点值不小于其子节点的堆称为<strong>大跟堆</strong>，节点值不大于其子节点的堆称为<strong>小跟堆</strong>。</p><h2 id="堆的实现">堆的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> n)</span>     <span class="hljs-comment">// 调整为大根堆</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = idx * <span class="hljs-number">2</span>, right = idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, largest = idx;<br>    <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; nums[left] &gt; nums[largest])<br>    &#123;<br>        largest = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(right &lt; n &amp;&amp; nums[right] &gt; nums[largest])<br>        largest = right;<br><br>    <span class="hljs-keyword">if</span>(largest != idx)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums[idx], nums[largest]);<br>        <span class="hljs-built_in">maxHeapify</span>(nums, largest, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> n)</span>     <span class="hljs-comment">// 建堆</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx = n / <span class="hljs-number">2</span>; idx &gt; <span class="hljs-number">-1</span>; --idx)<br>        <span class="hljs-built_in">maxHeapify</span>(nums, idx, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里初始给了一个数组，然后调用<code>buildMaxHeap</code>函数建堆，建堆的过程就是从最后一个非叶子节点开始，调用<code>maxHeapify</code>函数，将其调整为大根堆，然后再依次向前调整，直到根节点。</p><h2 id="堆排序">堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将nums从小到大排序, 直接在原数组上排序，没有返回值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMaxHeap</span>(nums, n);<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[n - <span class="hljs-number">1</span>]);     <span class="hljs-comment">// 弹出堆顶元素，并将堆大小-1，-1操作在下行</span><br>        <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, --n);       <span class="hljs-comment">// 调整为大根堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11-enable_shared_from_this类</title>
    <link href="/2023/07/11/Cpp11-enable-shared-from-this%E7%B1%BB/"/>
    <url>/2023/07/11/Cpp11-enable-shared-from-this%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1id="c11-enable_shared_from_this类">C++11-enable_shared_from_this类</h1><p>c++11 中的 shared_from_this() 来源于 boost 中的enable_shared_form_this 类和 shared_from_this()函数，功能为返回一个当前类的 std::share_ptr，使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>: <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Test</span>();<br>    ~<span class="hljs-built_in">Test</span>();<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">getSharedFromThis</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="enable_shared_from_this-的由来">enable_shared_from_this的由来</h2><p>在智能指针的使用过程中，我们会遇到这样一种情况，我们在类的成员函数调用某一个函数，而该函数需要传递一个当前对象的智能指针作为参数时，我们需要能够在成员函数中获得自己的智能指针。</p><p>在多线程程序中也存在这样的应用，如果我们的线程函数是一个成员函数，可以把该对象的智能指针作为参数传递到线程函数中，这种做法是人为的增加了对象的引用计数，延长对象的生命周期，防止线程函数在执行的时候对象被释放而引发内存错误。总之就是我们在实际的编码中会存在各种各样的应用。</p><p>我们可能有两个疑惑：</p><ol type="1"><li><p>把当前类对象作为参数传给其他函数时，为什么要传递 share_ptr呢？直接传递 this 指针不可以吗？</p><p>一个裸指针传递给调用者，谁也不知道调用者会干什么？假如调用者 delete了该对象，而 share_tr此时还指向该对象。</p></li><li><p>这样传递 share_ptr 可以吗？<code>share_ptr&lt;this&gt;</code>?</p><p>这样会造成2个非共享的share_ptr指向一个对象，最后造成2次析构该对象。</p></li></ol><p>我们不能人为地通过 this 来构造一个当前对象的 shared_ptr指标，如下错误的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(std::shared_ptr&lt;TestClass&gt; tt)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestClass</span>() &#123;&#125;    <br>    ~<span class="hljs-built_in">TestClass</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;TestClass&gt; tt = std::<span class="hljs-built_in">shared_ptr</span>&lt;TestClass&gt;(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-built_in">Test</span>(tt);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;TestClass&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t-&gt;<span class="hljs-built_in">TestPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>在 TestPtr() 函数中通过 this 构造出shared_ptr，就相当于把自己的的控制权交给了这个临时变量 tt，一旦 tt超出作用域就会释放，导致该对象也被释放。这是一个致命的错误。</p><p>为了解决这个问题，在 C++11 中提供了 enable_shared_from_this这个模板类（boost 库很早就提供了这个模板类），自己的对象继承自enable_shared_from_this 。enable_shared_from_this提供了一个shared_from_this()的方法返回自己的智能指针。与上面错误的例子区别在于，shared_from_this会增加该对象的引用计数，而不是重新建立一个临时的 shared_ptr来管理。看下面具体的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(std::shared_ptr&lt;TestClass&gt; tt)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TestClass&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestClass</span>() &#123;&#125;    <br>    ~<span class="hljs-built_in">TestClass</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;TestClass&gt; tt = <span class="hljs-built_in">shared_from_this</span>();<br>        <span class="hljs-built_in">Test</span>(tt);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;TestClass&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t-&gt;<span class="hljs-built_in">TestPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="shared_from_this-函数">shared_from_this() 函数</h2><p>shared_from_this的出现确实能够解决我们编码中所遇到的问题，但是它的坑也是比较多的。我们先来看看enable_shared_from_this 这个对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">enable_shared_from_this</span><br>&#123;<span class="hljs-comment">// provide member functions that create shared_ptr to this</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Ty _EStype;<br><br>    <span class="hljs-function">shared_ptr&lt;_Ty&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return shared_ptr</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr));<br>    &#125;<br><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">const</span> _Ty&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return shared_ptr</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">const</span> _Ty&gt;(_Wptr));<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">enable_shared_from_this</span>()<br>    &#123;<span class="hljs-comment">// construct (do nothing)</span><br>    &#125;<br><br>    <span class="hljs-built_in">enable_shared_from_this</span>(<span class="hljs-type">const</span> enable_shared_from_this&amp;)<br>    &#123;<span class="hljs-comment">// construct (do nothing)</span><br>    &#125;<br><br>    enable_shared_from_this&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> enable_shared_from_this&amp;)<br>    &#123;<span class="hljs-comment">// assign (do nothing)</span><br>        <span class="hljs-built_in">return</span> (*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">enable_shared_from_this</span>()<br>    &#123;<span class="hljs-comment">// destroy (do nothing)</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty2</span>&gt;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> _Do_enable(<br>            _Ty1 *,<br>            enable_shared_from_this&lt;_Ty2&gt;*,<br>            _Ref_count_base *);<br><br>    <span class="hljs-keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty2</span>&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _Do_enable(<br>    _Ty1 *_Ptr,<br>            enable_shared_from_this&lt;_Ty2&gt; *_Es,<br>            _Ref_count_base *_Refptr)<br>&#123; <span class="hljs-comment">// reset internal weak pointer</span><br>    _Es-&gt;_Wptr._Resetw(_Ptr, _Refptr);<br>&#125; <br></code></pre></td></tr></table></figure><p>这是标准库的源码，我们看到在 enable_shared_from_this 内部储存了一个weak_ptr。shared_from_this 函数就是通过这个 weak_ptr得到了。但是另外一点，我们可以看到在enable_shared_from_this的构造函数中并没有对这个 weak_ptr 进行初始化。</p><p>这就是为什么我们不能在构造函数调用 shared_from_this()的原因，因为其内部的 weak_ptr 并没有初始化。所以会产生错误。</p><p>在实际的程序设计中如果我们需要在对象初始化中用到自己的shared_ptr。可以单独将初始化操作放到一个独立的 init 函数中，这时候再调用shared_from_this() 是没有问题的（但还是有点问题，下面会讲到）</p><p>熟悉 weak_ptr 的同学可能知道，我们在使用 weak_ptr 前，需要用一个shared_ptr 来对其进行初始化。对 weak_ptr初始化是要能获取到当前对象的引用计数对象，而引用计数对象可以通过shared_ptr 对象获取到。当然我们同样可以用一个已经初始化过的 weak_ptr来初始化另一个 weak_ptr，因为已初始化的weak_ptr也可能获取到对象的引用计数。</p><p>enable_shared_from_this 内部的 weak_ptr是通过<code>_Do_enable</code>函数初始化的。而<code>_Do_enable</code>函数实在shared_ptr的构造函数中调用的，这是至关重要的一个环节。正因为如此我们在调用shared_from_this 之前请确保程序已经显式地建立了 shared_ptr对象，要不然enable_shared_from_this 内部的 weak_ptr 始终是无效。</p><p>下面具体举例说明的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TestClass&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestClass</span>()<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">TestClass</span>()<br>    &#123;<br>        <span class="hljs-comment">//TestClassPtr tt = shared_from_this();</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;TestClass&gt; tt = <span class="hljs-built_in">shared_from_this</span>();<br>        <span class="hljs-built_in">Test</span>(tt);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TestClass t;<br>    t.<span class="hljs-built_in">TestPtr</span>(); <span class="hljs-comment">//shared_from_this()错误</span><br><br>    <span class="hljs-function">TestClass* <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t1-&gt;<span class="hljs-built_in">TestPtr</span>();<span class="hljs-comment">//shared_from_this()错误</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;TestClass&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t2-&gt;<span class="hljs-built_in">TestPtr</span>(); <span class="hljs-comment">//正确，已提前建立了shared_ptr</span><br>&#125; <br></code></pre></td></tr></table></figure><p>同理在析构函数中也不能调用 shared_from_this()。</p><p>在析构时，引用计数已经变为零，weak_ptr已经相当于指向的是一个无效的对象，不能通过此无效的 weak_ptr 构造shared_ptr。</p><p>转载自<ahref="https://www.cnblogs.com/WindSun/p/14697066.html">C++11的enable_shared_from_this</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-TCP连接</title>
    <link href="/2023/07/10/muduo%E5%BA%93-TCP%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/07/10/muduo%E5%BA%93-TCP%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-tcp连接">muduo库-TCP连接</h1><p><img src="/img/muduo/TCP连接/TCP建立连接流程.png" /></p><p>TCP连接中，两端是对等的，TCP协议也没有区分客户端（client）与服务器端（server），但互联网中通信中，往往有一端提供资源给另一端访问，我们把拥有资源的一端称为服务器端，请求资源的一端称为客户端。</p><p>对于server，会启用一个监听循环，不断接受client连接请求（三次握手），进行数据通信，通信完成以后断开连接（四次挥手）;对于client，在server启用监听循环时，向server发出连接请求，接收server数据，如有必要向server发送数据，通信完成后，断开连接。连接是指物理上一端（client）到另一端（server）的通信链路，通过server端&lt;ip,port&gt;与客户端&lt;ip, port&gt;，来唯一标识一个TCP连接。</p><div class="admonition note"><p class="admonition-title">TCP连接有长连接、短连接之分</p><p>短连接：client和server建立连接后，一般只传递一次读写操作，然后由client发起close，发送FIN分节，关闭连接。短连接只完成一次read/write操作，就会自动关闭。</p><p>长连接：client和server建立连接后，并不会自动关闭，后续的read/write操作会继续用这个连接。长连接没有确切时间限制，可能会长时间存在。</p></div><h2 id="tcpserver类">TcpServer类</h2><p><strong>muduo使用TcpConnection类来管理TCP连接，使用接受器Acceptor来接受连接，连接器Connector发起连接</strong>。TcpServer管理accept获得TcpConnection，生命周期由用户控制。</p><p>下图是TcpServer新建连接的相关函数调用顺序。当Channel::handleEvent()的触发条件是listeningsocket可读时，表明有新连接请求达到。TcpServer为新连接创建对应的TcpConnection对象。</p><p><img src="/img/muduo/TCP连接/TCP建立连接调用顺序.png" /></p><h2 id="acceptor类">Acceptor类</h2><p>Acceptor是TcpServer的一个内部类，主要职责是用来获得新连接的fd。Accetpor封装了服务器监听套接字fd以及相关处理方法。Acceptor类内部其实没有贡献什么核心的处理函数，主要是对其他类的方法调用进行封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* TCP连接接受器</span><br><span class="hljs-comment">* 基础调用为accept(2)/accept4(2)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> : <span class="hljs-keyword">private</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;)&gt; NewConnectionCallback;<br><br>    <span class="hljs-built_in">Acceptor</span>(EventLoop* loop, <span class="hljs-type">const</span> InetAddress&amp; listenAddr, <span class="hljs-type">bool</span> reuseport);<br>    ~<span class="hljs-built_in">Acceptor</span>();<br><br>    <span class="hljs-comment">/* 设置新连接回调 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNewConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> NewConnectionCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; newConnectionCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">/* 监听本地端口 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/* 判断当前是否正在监听端口 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listening</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> listening_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 处理读事件</span><br><br>    EventLoop *loop_;        <span class="hljs-comment">// 所属EventLoop</span><br>    Socket acceptSocket_;    <span class="hljs-comment">// 专门用于接受连接的套接字(sock fd)</span><br>    Channel acceptChannel_;  <span class="hljs-comment">// 专门接受连接通道, 监听conn fd</span><br>    NewConnectionCallback newConnectionCallback_; <span class="hljs-comment">// 新建连接回调</span><br>    <span class="hljs-type">bool</span> listening_;         <span class="hljs-comment">// 监听状态</span><br>    <span class="hljs-type">int</span> idleFd_;             <span class="hljs-comment">// 空闲fd, 用于fd资源不够用时, 可以空一个出来作为新建连接conn fd</span><br>&#125;;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">如果fd资源不够用了，导致accept(2)/accept4(2)创建连接失败，比如达到系统上限，怎么办？</p><p>Accetor用了这样一种技术：先申请一个空闲的fd（idleFd_），等到发生由于fd资源不够用时，就把这个备用fd暂时用于accept接收连接，然后再马上关闭，以防止不断产生可读事件（连接请求），从而回调相同的失败代码。及早建立连接后并关闭连接，让程序不会频繁响应同一个连接请求。</p></div><h3 id="acceptor封装的重要成员变量">Acceptor封装的重要成员变量</h3><ul><li>acceptSocket_：服务器监听套接字的文件描述符</li><li>acceptChannel_：是一个Channel类，把acceptSocket_及其感兴趣事件和事件对应的处理函数都封装进去。</li><li>EventLoop*loop：监听套接字的fd由哪个EventLoop负责循环监听以及处理相应事件，其实这个EventLoop就是mainEventLoop。</li><li>newConnectionCallback_:TcpServer构造函数中将TcpServer::newConnection()函数注册给了这个成员变量。这个TcpServer::newConnection函数的功能是公平的选择一个subEventLoop，并把已经接受的连接分发给这个subEventLoop。</li></ul><h3 id="acceptor封装的重要成员方法">Acceptor封装的重要成员方法</h3><ul><li>listen( )：该函数底层调用了linux的函数listen()，开启对acceptSocket_的监听同时将acceptChannel及其感兴趣事件（可读事件）注册到mainEventLoop的事件监听器上。换言之就是让mainEventLoop事件监听器去监听acceptSocket_</li><li>handleRead()：这是一个私有成员方法，这个方法是要注册到acceptChannel_上的，同时handleRead()方法内部还调用了成员变量newConnectionCallback_保存的函数。当mainEventLoop监听到acceptChannel_上发生了可读事件时（新用户连接事件），就是调用这个handleRead()方法。</li></ul><p>简单来说，handleRead()最终实现的功能就是接受新连接，并且以负载均衡的选择方式选择一个subEventLoop，并把这个新连接分发到这个subEventLoop上。</p><h3 id="acceptor构造与析构">Acceptor构造与析构</h3><p>Acceptor构造时，创建sockfd（套接字），待后续交给TcpServer来start监听套接字。空闲fd指向文件"/dev/null"，用来解决服务器fd资源耗尽问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.cc</span><br>Acceptor::<span class="hljs-built_in">Acceptor</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">bool</span> reuseport)<br>: <span class="hljs-built_in">loop_</span>(loop),<br>  <span class="hljs-built_in">acceptSocket_</span>(sockets::<span class="hljs-built_in">createNonblockingOrDie</span>(listenAddr.<span class="hljs-built_in">family</span>())),<br>  <span class="hljs-built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="hljs-built_in">fd</span>()),<br>  <span class="hljs-built_in">listening_</span>(<span class="hljs-literal">false</span>),<br>  <span class="hljs-built_in">idleFd_</span>(::<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC)) <span class="hljs-comment">// 申请空闲fd</span><br>&#123;<br>    <span class="hljs-built_in">assert</span>(idleFd_ &gt;= <span class="hljs-number">0</span>);<br>    acceptSocket_.<span class="hljs-built_in">setReuseAddr</span>(<span class="hljs-literal">true</span>);<br>    acceptSocket_.<span class="hljs-built_in">setReusePort</span>(reuseport);<br>    acceptSocket_.<span class="hljs-built_in">bindAddress</span>(listenAddr);<br>    acceptChannel_.<span class="hljs-built_in">setReadCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::handleRead, <span class="hljs-keyword">this</span>));<br>&#125;<br><br>Acceptor::~<span class="hljs-built_in">Acceptor</span>()<br>&#123;<br>    acceptChannel_.<span class="hljs-built_in">disableAll</span>(); <span class="hljs-comment">// disable all event of the channel</span><br>    acceptChannel_.<span class="hljs-built_in">remove</span>(); <span class="hljs-comment">// remove the channel from poller</span><br>    ::<span class="hljs-built_in">close</span>(idleFd_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acceptor监听">Acceptor监听</h3><p>Acceptor包含2类监听：</p><ol type="1"><li>监听套接字，即本地ip地址&amp;端口。</li><li>监听通道事件，读事件。</li></ol><div class="admonition attention"><p class="admonition-title">为什么不在构造时，就调用listen监听sockfd呢？</p><p>将非必要资源的初始化，延迟到需要时，用户可以通过调用TcpSever::start()来启动。这样，用户可以更灵活控制资源的申请和释放。</p></div><h3 id="acceptor接受连接">Acceptor接受连接</h3><p>Acceptor内部有一个Channel成员，当Poller监听到有Tcp连接请求时，就通过Channel的可读事件，在loop线程，来回调Acceptor::handleRead()。从而将connfd和IP地址传递给上一层TcpServer，用于创建TcpConnection对象管理Tcp连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.cc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理读Channel事件, accept连接</span><br><span class="hljs-comment">* @note 先accept, 然后将相关资源通过回调交由上一层的TcpServer进行处理(管理)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acceptor::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    InetAddress peerAddr;<br>    <span class="hljs-comment">// FIXME loop until no more</span><br>    <span class="hljs-type">int</span> connfd = acceptSocket_.<span class="hljs-built_in">accept</span>(&amp;peerAddr); <span class="hljs-comment">// 获取连接fd及对端ip地址</span><br>    <span class="hljs-keyword">if</span> (connfd &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (newConnectionCallback_)<br>        &#123; <span class="hljs-comment">// 创建新连接回调</span><br>            <span class="hljs-built_in">newConnectionCallback_</span>(connfd, peerAddr);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sockets::<span class="hljs-built_in">close</span>(connfd);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// 错误</span><br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;in Acceptor::handleRead&quot;</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Read the section named &quot;The special problem of</span><br><span class="hljs-comment">         * accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span><br><span class="hljs-comment">         * By Marc Lehmann, author of libev.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * The per-process limit of open file descriptors has been reached.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (errno == EMFILE)<br>        &#123; <span class="hljs-comment">// 文件描述符资源耗尽错误</span><br>            ::<span class="hljs-built_in">close</span>(idleFd_);<br>            idleFd_ = ::<span class="hljs-built_in">accept</span>(acceptSocket_.<span class="hljs-built_in">fd</span>(), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>            ::<span class="hljs-built_in">close</span>(idleFd_);<br>            <span class="hljs-comment">// reopen /dev/null, it dose not matter whether it succeeds or fails.</span><br>            idleFd_ = ::<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcpserver类-1">TcpServer类</h3><p>TcpServer类管理TcpConnection，供用户直接使用，生命周期由用户控制。接口如下，用户只需要设置好callback，然后调用start()即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.h</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tcp Server, 支持单线程和thread-poll模型.</span><br><span class="hljs-comment">* 接口类, 因此不要暴露太多细节.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpServer</span> : <span class="hljs-keyword">private</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span> (EventLoop*)&gt; ThreadInitCallback;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span><br>    &#123;<br>        kNoReusePort, <span class="hljs-comment">// 不允许重用本地端口</span><br>        kReusePort,   <span class="hljs-comment">// 允许重用本地端口</span><br>    &#125;;<br><br><span class="hljs-comment">//    TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span><br>    <span class="hljs-built_in">TcpServer</span>(EventLoop* loop,<br>              <span class="hljs-type">const</span> InetAddress&amp; listenAddr,<br>              <span class="hljs-type">const</span> std::string&amp; nameArg,<br>              Option option = kNoReusePort);<br>    ~<span class="hljs-built_in">TcpServer</span>(); <span class="hljs-comment">// force out-line dtor, for std::unique_ptr members.</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果没有监听, 就启动服务器(监听).</span><br><span class="hljs-comment">     * 多次调用没有副作用.</span><br><span class="hljs-comment">     * 线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置连接回调.</span><br><span class="hljs-comment">     * 非线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; connectionCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置消息回调.</span><br><span class="hljs-comment">     * 非线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMessageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> MessageCallback &amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; messageCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置写完成回调.</span><br><span class="hljs-comment">     * 非线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCompleteCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteCompleteCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; writeCompleteCallback_ = cb; &#125;<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>并没有连接关闭的回调，这是由TcpServer::removeConnection()负责的，进而把工作转交给TcpConnection::connectDestroyed()，用户不可更改设置。</p></div><h3 id="tcpserver的构造与析构">TcpServer的构造与析构</h3><p>TcpServer构造函数主要工作是为成员申请资源，为各回调设置回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TcpServer::<span class="hljs-built_in">TcpServer</span>(EventLoop* loop,<br>                     <span class="hljs-type">const</span> InetAddress&amp; listenAddr,<br>                     <span class="hljs-type">const</span> std::string&amp; nameArg,<br>                     Option option)<br>: <span class="hljs-built_in">loop_</span>(<span class="hljs-built_in">CHECK_NOTNULL</span>(loop)), <span class="hljs-comment">// 确保loop非空</span><br>  <span class="hljs-built_in">ipPort_</span>(listenAddr.<span class="hljs-built_in">toIpPort</span>()),  <span class="hljs-comment">// 将Ip, port转换为字符串</span><br>  <span class="hljs-built_in">name_</span>(nameArg), <span class="hljs-comment">// 名称</span><br>  <span class="hljs-built_in">acceptor_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Acceptor</span>(loop, listenAddr, option == kReusePort)),<br>  <span class="hljs-built_in">threadPool_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThreadPool</span>(loop, name_)), <span class="hljs-comment">// 初始化事件循环线程池</span><br>  <span class="hljs-built_in">connectionCallback_</span>(defaultConnectionCallback),    <span class="hljs-comment">// 连接回调为默认连接回调</span><br>  <span class="hljs-built_in">messageCallback_</span>(defaultMessageCallback),          <span class="hljs-comment">// 消息回调为默认消息回调</span><br>  <span class="hljs-built_in">nextConnId_</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 连接id</span><br>&#123;<br>    acceptor_-&gt;<span class="hljs-built_in">setNewConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::newConnection, <span class="hljs-keyword">this</span>, _1, _2)); <span class="hljs-comment">// 设置新建连接时的回调</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">同样是连接回调，TcpServer::newConnection()和connectionCallback_有何区别？</p><p>前者是Acceptor发生连接请求事件时，回调，用来新建一个Tcp连接；后者是在TcpServer内部新建连接即调用TcpServer::newConnection()时，回调connectionCallback_。</p></div><p>TcpServer析构工作内容很简单，主要销毁ConnectionMap中所有Tcp连接，而每个Tcp连接用的是一个TcpConnection对象来管理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 析构TcpServer对象, 销毁ConnectionMap中所有连接</span><br><span class="hljs-comment">*/</span><br>TcpServer::~<span class="hljs-built_in">TcpServer</span>()<br>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;] destructing&quot;</span>;<br><br><br>    <span class="hljs-comment">// reset all connection of @c connections_</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : connections_)<br>    &#123;<br>        <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(item.second)</span></span>; <span class="hljs-comment">// shared_ptr manage TcpConnection</span><br>        item.second.<span class="hljs-built_in">reset</span>();<br>        conn-&gt;<span class="hljs-built_in">getLoop</span>()-&gt;<span class="hljs-built_in">runInLoop</span>(<br>                std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TcpServer启动Tcp服务器，主要完成</p><ol type="1"><li>线程池的启动；</li><li>Acceptor监听Tcp连接请求。</li></ol><p>线程池需要指定其初始数量，当然，这需要在start()之前调用TcpServer::setThreadNum()设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 启动TcpServer, 初始化线程池, 连接接受器Accept开始监听(Tcp连接请求)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (started_.<span class="hljs-built_in">getAndSet</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        threadPool_-&gt;<span class="hljs-built_in">start</span>(threadInitCallback_);<br><br><br>        <span class="hljs-built_in">assert</span>(!acceptor_-&gt;<span class="hljs-built_in">listening</span>());<br>        loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>                std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::listen, <span class="hljs-built_in">get_pointer</span>(acceptor_)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">TcpServer如何获得新连接的connfd(accept返回值)?</p><p>TcpServer内部用Acceptor，保存用户提供的Connection-Callback和MessageCallback，新建TcpConnection对象（newConn()）的时候直接传递给TcpConnection的构造函数</p></div><div class="admonition attention"><p class="admonition-title">如何创建TcpConnection对象？</p><p>新连接请求到达时，Acceptor回调newConnection()，通过TcpServer::newConnection创建一个新TcpConnection对象，用于管理一个Tcp连接。</p><p>即，TcpServer::newConnection回调顺序 EventLoop =&gt; Channel =&gt;Acceptor =&gt; TcpServer</p></div><p>下面是用于创建TcpConnection对象的函数TcpServer::newConnection()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.cc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 新建一个TcpConnection对象, 用于连接管理.</span><br><span class="hljs-comment">* @details 新建的TcpConnection对象会加入内部ConnectionMap.</span><br><span class="hljs-comment">* @param sockfd accept返回的连接fd (accepted socket fd)</span><br><span class="hljs-comment">* @param peerAddr 对端ip地址信息</span><br><span class="hljs-comment">* @note 必须在所属loop线程运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::newConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-comment">/* 从EventLoop线程池中，取出一个EventLoop对象构造TcpConnection对象，便于均衡各EventLoop负责的连接数　*/</span><br>    EventLoop* ioLoop = threadPool_-&gt;<span class="hljs-built_in">getNextLoop</span>(); <span class="hljs-comment">// next event loop from the event loop thread pool</span><br><br>    <span class="hljs-comment">/* 设置连接对象名称, 包含基础名称+ip地址+端口号+连接Id</span><br><span class="hljs-comment">     * 因为要作为ConnectionMap的key, 要确保运行时唯一性 */</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="hljs-built_in">c_str</span>(), nextConnId_);<br>    ++nextConnId_;<br>    std::string connName = name_ + buf;<br><br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_<br>    &lt;&lt; <span class="hljs-string">&quot;] - new connection [&quot;</span> &lt;&lt; connName<br>    &lt;&lt; <span class="hljs-string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="hljs-built_in">toIpPort</span>();<br>    <br>    <span class="hljs-function">InetAddress <span class="hljs-title">localAddr</span><span class="hljs-params">(sockets::getLocalAddr(sockfd))</span></span>; <span class="hljs-comment">// 本地ip地址信息</span><br>    <span class="hljs-comment">// FIXME poll with zero timeout to double confirm the new connection</span><br>    <span class="hljs-comment">// FIXME use make_shared if necessary</span><br>    <span class="hljs-comment">/* 新建TcpConnection对象,　并加入ConnectionMap */</span><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;<br>    connections_[connName] = conn;<br>    <span class="hljs-comment">/* 为新建TcpConnection对象设置各种回调 */</span><br>    conn-&gt;<span class="hljs-built_in">setConnectionCallback</span>(connectionCallback_); <span class="hljs-comment">// 连接回调</span><br>    conn-&gt;<span class="hljs-built_in">setMessageCallback</span>(messageCallback_);       <span class="hljs-comment">// 消息回调</span><br>    conn-&gt;<span class="hljs-built_in">setWriteCompleteCallback</span>(writeCompleteCallback_); <span class="hljs-comment">// 写完成回调</span><br>    conn-&gt;<span class="hljs-built_in">setCloseCallback</span>( <span class="hljs-comment">// 关闭连接回调</span><br>            std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="hljs-keyword">this</span>, _1)); <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> unsafe</span><br>    <span class="hljs-comment">/* 确认连接是否已建立, 并初始化连接建立后的状态 */</span><br>    ioLoop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tcpconnection类">TcpConnection类</h2><p>这个类主要封装了一个已建立的TCP连接，以及控制该TCP连接的方法（连接建立和关闭和销毁），以及该连接发生的各种事件（读/写/错误/连接）对应的处理函数，以及这个TCP连接的服务端和客户端的套接字地址信息等。</p><p>TcpConnection类是唯一默认用shared_ptr来管理的类，唯一继承自enable_shared_from_this的类。这是因为其生命周期模糊：可能在连接断开时，还有其他地方持有它的引用，贸然delete会造成空悬指针。只有确保其他地方没有持有该对象的引用的时候，才能安全地销毁对象。</p><p><strong>我个人觉得TcpConnection类和Acceptor类是兄弟关系，Acceptor用于mainEventLoop中，对服务器监听套接字fd及其相关方法进行封装（监听、接受连接、分发连接给SubEventLoop等），TcpConnection用于SubEventLoop中，对连接套接字fd及其相关方法进行封装（读消息事件、发送消息事件、连接关闭事件、错误事件等）。</strong></p><h3 id="tcpconnection的重要变量">TcpConnection的重要变量</h3><ul><li>ocket_：用于保存已连接套接字文件描述符。</li><li>channel_：封装了上面的socket_及其各类事件的处理函数（读、写、错误、关闭等事件处理函数）。这个Channel种保存的各类事件的处理函数是在TcpConnection对象构造函数中注册的。</li><li>loop_：这是一个EventLoop*类型，该Tcp连接的Channel注册到了哪一个subEventLoop上。这个loop_就是那一个sub EventLoop。</li><li>inputBuffer_：这是一个Buffer类，是该TCP连接对应的用户接收缓冲区。</li><li>outputBuffer_：也是一个Buffer类，不过是用于暂存那些暂时发送不出去的待发送数据。因为Tcp发送缓冲区是有大小限制的，假如达到了高水位线，就没办法把发送的数据通过send()直接拷贝到Tcp发送缓冲区，而是暂存在这个outputBuffer_中，等TCP发送缓冲区有空间了，触发可写事件了，再把outputBuffer_中的数据拷贝到Tcp发送缓冲区中。</li><li>state_：这个成员变量标识了当前TCP连接的状态（Connected、Connecting、Disconnecting、Disconnected）</li><li>connetionCallback_、messageCallback_、writeCompleteCallback_、closeCallback_： 用户会自定义 [连接建立/关闭后的处理函数]、[收到消息后的处理函数]、[消息发送完后的处理函数]以及Muduo库中定义的[连接关闭后的处理函数]。这四个函数都会分别注册给这四个成员变量保存。</li></ul><h3 id="tcpconnection的重要成员方法">TcpConnection的重要成员方法</h3><p>handleRead()、handleWrite()、handleClose()、handleError()：这四个函数都是私有成员方法，在一个已经建立好的Tcp连接上主要会发生四类事件：可读事件、可写事件、连接关闭事件、错误事件。当事件监听器监听到一个连接发生了以上的事件，那么就会在EventLoop中调用这些事件对应的处理函数。</p><ul><li>handleRead()负责处理Tcp连接的可读事件，它会将客户端发送来的数据拷贝到用户缓冲区中（inputBuffer_），然后再调用connectionCallback_保存的[连接建立后的处理函数]。</li><li>handleWrite( )负责处理Tcp连接的可写事件。</li><li>handleClose()负责处理Tcp连接关闭的事件。大概的处理逻辑就是将这个TcpConnection对象中的channel_从事件监听器中移除。然后调用connectionCallback_和closeCallback_保存的回调函数。这closeCallback_中保存的函数是由Muduo库提供的，connectionCallback_保存的回调函数则由用户提供的（可有可无其实）</li></ul><p>TcpConnection表示的是“一次Tcp连接”，不可再生，一旦连接断开，该TcpConnection对象就没用了。TcpConnection没用发起连接的功能，构造函数参数是已经建立好连接的socketfd，初始状态是kConnecting。连接可以是TcpServer或TcpClient发起。</p><p>接收到消息时，通过Channel::handleEvent会将可读事件转交给TcpConnection::handleRead处理，而TcpConnection::handleRead又会通过messageCallback_将可读事件转交给TcpServer::messageCallback_，进而传递给用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpConnection.cc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从输入缓存inputBuffer_读取数据, 交给回调messageCallback_处理</span><br><span class="hljs-comment">* @param receiveTime 接收到读事件的时间点</span><br><span class="hljs-comment">* @details 通常是TcpServer/TcpClient运行回调messageCallback_, 将处理机会传递给用户</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleRead</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ssize_t</span> n = inputBuffer_.<span class="hljs-built_in">readFd</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno); <span class="hljs-comment">// 从指定fd读取数据到内部缓冲</span><br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">messageCallback_</span>(<span class="hljs-built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">handleClose</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        errno = savedErrno;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;TcpConnection::handleRead&quot;</span>;<br>        <span class="hljs-built_in">handleError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断开tcp连接">断开Tcp连接</h3><p>muduo中有2种关闭连接的方式：</p><ol type="1"><li>被动关闭：即对端先关闭连接，本地read(2)返回0，触发关闭逻辑，调用handleClose。</li><li>主动关闭：利用forceClose()或forceCloseWithDelay()成员函数调用handleClose，强制关闭或强制延时关闭连接。</li></ol><p>被动关闭流程见下图，图中“X”表示TcpConnection对象通常在此析构。</p><p><img src="/img/muduo/TCP连接/TCP被动断开.png" /></p><div class="admonition info"><p class="admonition-title">info</p><p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1,并在Channel中维护一个weak_ptr(tie_)，将这个shared_ptr对象赋值给tie_，由weak_ptr的特性，引用计数仍然为1</p><p>当连接关闭，在handleEvent，将tie_提升，得到一个shared_ptr,这时候引用计数就变成了2，然后erase，引用计数变为1，所以TcpConnection计数变为1，并没有销毁，然后再调用closeCallback_，closeCallback_在TcpServer::newConnection()为新连接新建TcpConnection时，已设为TcpServer::removeConnection()，而removeConnection()最终会调用TcpConnection::connectDestroyed()来销毁连接资源。</p></div><h3 id="channel与断开连接">Channel与断开连接</h3><p>Channel中有关闭连接的事件回调CloseCallback，由Channel::handleEvent()调用，从而触发TcpConnection::handleClose()：</p><p>调用链路：</p><p>Poller::poll()检测到Channel事件就绪 =&gt; EventLoop::loop()=&gt;Channel::handleEvent() =&gt; Channel::closeCallback_ =&gt;TcpConnection::handleClose()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Channel.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEvent</span><span class="hljs-params">(Timestamp recevieTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard;<br>    <span class="hljs-keyword">if</span> (tied_)<br>    &#123;<br>        guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>        &#123;<br>            <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据不同的激活原因, 调用不同的回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    eventHandling_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 正在处理事件</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-built_in">reventsToString</span>(); <span class="hljs-comment">// 打印fd及就绪事件</span><br>    <span class="hljs-keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))<br>    &#123; <span class="hljs-comment">// fd挂起(套接字已不在连接中), 并且没有数据可读</span><br>        <span class="hljs-keyword">if</span> (logHup_)<br>        &#123; <span class="hljs-comment">// 打印挂起log</span><br>            LOG_WARN &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="hljs-string">&quot; Channel::handle_event() POLLHUP&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 调用关闭回调</span><br>        <span class="hljs-keyword">if</span> (closeCallback_) <span class="hljs-built_in">closeCallback_</span>();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcpconnection与断开连接">TcpConnection与断开连接</h3><p>TcpConnection中有关闭连接的事件回调CloseCallback，由TcpConnection::handleClose()调用，从而触发TcpServer::removeConnection()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpConnection.h</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 关闭写半连接 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// NOT thread safe, no simultaneous calling</span><br><span class="hljs-comment">//    void shutdownAndForceCloseAfter(double seconds); // NOT thread safe, no simultaneous calling</span><br><br>    <span class="hljs-comment">/* 强制关闭连接 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forceClose</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 强制延时关闭连接 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forceCloseWithDelay</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span></span>;<br><br>    ...<br><br>    <span class="hljs-comment">/* Internal use only */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> CloseCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; closeCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">// called when TcpServer accepts a new connection</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectEstablished</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// should be called only once per connection</span><br>    <span class="hljs-comment">// called when TcpServer has removed me from its map</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectDestroyed</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// should be called only once per connection</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleClose</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// 处理关闭连接事件</span><br></code></pre></td></tr></table></figure><p><strong>被动关闭连接</strong></p><p>当收到对端FIN分节时，本地read返回0,，Tcp连接被动关闭，会触发调用本地TcpConnection::handleClose()，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理Tcp连接关闭</span><br><span class="hljs-comment">* @details 更新状态为kDisconnected, 清除所有事件通道监听</span><br><span class="hljs-comment">* @note 必须在所属loop线程中运行.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleClose</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>(); <span class="hljs-comment">// 确保在所属loop线程中运行</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="hljs-built_in">fd</span>() &lt;&lt; <span class="hljs-string">&quot; state = &quot;</span> &lt;&lt; <span class="hljs-built_in">stateToString</span>();<br>    <span class="hljs-built_in">assert</span>(state_ == kConnected || state_ == kDisconnecting);<br>    <span class="hljs-comment">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span><br>    <span class="hljs-built_in">setState</span>(kDisconnected); <span class="hljs-comment">// 更新Tcp连接状态</span><br>    channel_-&gt;<span class="hljs-built_in">disableAll</span>();     <span class="hljs-comment">// 停止监听所有通道事件(读写事件)</span><br><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">guardThis</span><span class="hljs-params">(shared_from_this())</span></span>;<br>    <span class="hljs-built_in">connectionCallback_</span>(guardThis); <span class="hljs-comment">// 连接回调</span><br>    <span class="hljs-comment">// must be the last line</span><br>    <span class="hljs-built_in">closeCallback_</span>(guardThis);      <span class="hljs-comment">//　关闭连接回调</span><br>&#125;<br></code></pre></td></tr></table></figure><p>closeCallback_在TcpServer::newConnection()为新连接新建TcpConnection时，已设为TcpServer::removeConnection()，而removeConnection()最终会调用TcpConnection::connectDestroyed()来销毁连接资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 主动销毁当前tcp连接, 移除通道事件</span><br><span class="hljs-comment">* @note 只有处于已连接状态(kConnected)的tcp连接, 才需要先更新状态, 关闭通道事件监听</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectDestroyed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">if</span> (state_ == kConnected) <span class="hljs-comment">// 只有kConnected的连接, 才有必要采取断开连接动作</span><br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnected);<br>        channel_-&gt;<span class="hljs-built_in">disableAll</span>(); <span class="hljs-comment">// 关闭通道事件监听</span><br><br>        <span class="hljs-built_in">connectionCallback_</span>(<span class="hljs-built_in">shared_from_this</span>()); <span class="hljs-comment">// 调用连接回调</span><br>    &#125;<br>    channel_-&gt;<span class="hljs-built_in">remove</span>(); <span class="hljs-comment">// 从EventLoop和Poller中移除监听通道事件</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>主动关闭连接</strong>:</p><p>主动关闭连接有两种方式：</p><ul><li>强制close连接</li><li>关闭一个方向的连接（读或写方向）</li></ul><p><strong>强制关闭连接</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 强制关闭连接, 只对连接为kConnected或kDisconnecting状态才有效</span><br><span class="hljs-comment">* @details 为防止意外, 动作应该放到loop末尾去做</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::forceClose</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> use compare and swap</span><br>    <span class="hljs-keyword">if</span> (state_ == kConnected || state_ == kDisconnecting)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        loop_-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class="hljs-built_in">shared_from_this</span>()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop循环中强制关闭连接, 只对连接为kConnected或kDisconnecting状态才有效</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::forceCloseInLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">if</span> (state_ == kConnected || state_ == kDisconnecting)<br>    &#123;<br>        <span class="hljs-comment">// as if we received 0 byte in handleRead()</span><br>        <span class="hljs-built_in">handleClose</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，除了状态更新，对于关闭连接的真正操作，被动、主动关闭连接都是由handleClose来完成的。</p><p>假设想延迟一段时间再关闭连接，可以调用forceCloseWithDelay()，区别在于交给EventLoop:runAfter()延时运行，而不是交给EventLoop::queueInLoop()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::forceCloseWithDelay</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state_ == kConnected || state_ == kDisconnecting)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        loop_-&gt;<span class="hljs-built_in">runAfter</span>(seconds,<br>                        <span class="hljs-built_in">makeWeakCallback</span>(<span class="hljs-built_in">shared_from_this</span>(),<br>                                          &amp;TcpConnection::forceClose)); <span class="hljs-comment">// not forceCloseInLoop to avoid race condition</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关闭一个方向的连接</strong>:</p><p>TcpConnection::shutdown()用于关闭写半连接，即发送FIN分节，关闭写通道，但仍然可以接收数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 关闭连接写方向, 只有已连接状态才有效</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::shutdown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> use compare and swap</span><br>    <span class="hljs-keyword">if</span> (state_ == kConnected)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> shared_from_this()?</span><br>        loop_-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::shutDownInLoop, <span class="hljs-built_in">shared_from_this</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于close和shutdown的区别，详见<ahref="https://www.cnblogs.com/fortunely/p/14854299.html">Linuxshutdown与clos</a></p><h3 id="tcpserver与断开连接">TcpServer与断开连接</h3><p>当新建一个tcp连接时，TcpServer会调用newConnection创建一个新TcpConnection对象管理Tcp连接，并将对象加入自己的ConnectionMap进行管理。</p><p>而当tcp连接断开时，需要调用removeConnection进行移除工作，而removeConnection会将工作转交给removeConnectionInLoop,确保在所属loop线程中执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 转交给removeConnectionInLoop, 在所属loop线程中执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> unsafe</span><br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="hljs-keyword">this</span>, conn));<br>&#125;<br></code></pre></td></tr></table></figure><p>removeConnectionInLoop要做的工作是将要移除的tcp连接对应TcpConnection对象，从ConnectionMap移除，然后销毁该对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop线程循环中, 排队移除指定tcp连接 conn</span><br><span class="hljs-comment">* @param conn 指向待移除tcp连接对应TcpConnection对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnectionInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_<br>    &lt;&lt; <span class="hljs-string">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">name</span>();<br>    <span class="hljs-type">size_t</span> n = connections_.<span class="hljs-built_in">erase</span>(conn-&gt;<span class="hljs-built_in">name</span>()); <span class="hljs-comment">// 从ConnectionMap中擦除待移除TcpConnection对象</span><br>    (<span class="hljs-type">void</span>)n;<br>    <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>);<br>    EventLoop* ioLoop = conn-&gt;<span class="hljs-built_in">getLoop</span>();<br>    ioLoop-&gt;<span class="hljs-built_in">queueInLoop</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn)); <span class="hljs-comment">// 在所属loop线程中排队销毁TcpConnection对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理">错误处理</h2><p>用于发送数据的TcpConnection::send()重载了下面几个版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">/* 发送消息给连接对端 */</span><br><span class="hljs-comment">//    void send(std::string&amp;&amp; mesage); // C++11</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* message, <span class="hljs-type">int</span> len)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece&amp; message)</span></span>;<br><span class="hljs-comment">//    void send(Buffer&amp;&amp; message);</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Buffer* message)</span></span>; <span class="hljs-comment">// this one will swap data</span><br><br><span class="hljs-number">3</span>个<span class="hljs-built_in">send</span>() 重载版本，最终都会转交给<span class="hljs-built_in">sendInLoop</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)，在所属loop线程中执行发送工作。<br><br><br><span class="hljs-comment">// 转发给send(const StringPiece&amp;), 最终转交给sendInLoop(const char*, int)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *message, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">send</span>(<span class="hljs-built_in">StringPiece</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(message), len));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 转交给 sendInLoop(const char*, int)</span><br><span class="hljs-comment">* 发送消息给对端, 允许在其他线程调用</span><br><span class="hljs-comment">* @param message 要发送的消息. StringPiece兼容C/C++风格字符串, 二进制缓存, 提供统一字符串接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state_ == kConnected)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (loop_-&gt;<span class="hljs-built_in">isInLoopThread</span>())<br>        &#123; <span class="hljs-comment">// 当前线程是所属loop线程</span><br>            <span class="hljs-built_in">sendInLoop</span>(message);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">// 当前线程并非所属loop线程</span><br>            <span class="hljs-built_in">void</span> (TcpConnection::*fp)(<span class="hljs-type">const</span> StringPiece&amp; message);<br>            fp = &amp;TcpConnection::sendInLoop;<br>            loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>                    std::<span class="hljs-built_in">bind</span>(fp,<br>                              <span class="hljs-keyword">this</span>, <span class="hljs-comment">// FIXME</span><br>                              message.<span class="hljs-built_in">as_string</span>()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 转交给sendInLoop(const char*, int)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece &amp;message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sendInLoop</span>(message.<span class="hljs-built_in">data</span>(), message.<span class="hljs-built_in">size</span>());<br>&#125;<br><br><span class="hljs-comment">// 转交给sendInLoop(const char*, int)</span><br><span class="hljs-comment">// FIXME efficiency!!!</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(Buffer *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state_ == kConnected)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (loop_-&gt;<span class="hljs-built_in">isInLoopThread</span>())<br>        &#123;<br>            <span class="hljs-comment">// send all readable bytes</span><br>            <span class="hljs-built_in">sendInLoop</span>(buf-&gt;<span class="hljs-built_in">peek</span>(), buf-&gt;<span class="hljs-built_in">readableBytes</span>());<br>            buf-&gt;<span class="hljs-built_in">retrieveAll</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sendInLoop定义如下，主要是向对端发送一次数据，如果发送完一次，就进行一次回调；如果待发送数据超高水位，就进行高水位回调；如果发生错误，就进行错误回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop线程中, 发送data[len]</span><br><span class="hljs-comment">* @param data 要发送的缓冲区首地址</span><br><span class="hljs-comment">* @param len　要发送的缓冲区大小(bytes)</span><br><span class="hljs-comment">* @details 发生write错误, 如果发送缓冲区未满,　对端已发FIN/RST分节 表明tcp连接发生致命错误(faultError为true)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-type">ssize_t</span> nwrote = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> remaining = len;<br>    <span class="hljs-type">bool</span> faultError = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (state_ == kDisconnected) <span class="hljs-comment">// 如果已经断开连接(kDisconnected), 就无需发送, 打印log(LOG_WARN)</span><br>    &#123;<br>        LOG_WARN &lt;&lt; <span class="hljs-string">&quot;disconnected, give up writing&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// write一次, 往对端发送数据, 后面再看是否发生错误, 是否需要高水位回调</span><br>    <span class="hljs-comment">// if no thing output queue, try writing directly</span><br>    <span class="hljs-keyword">if</span> (!channel_-&gt;<span class="hljs-built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// 如果通道没有使能监听写事件, 并且outputBuffer　没有待发送数据, 就直接通过socket写</span><br>        nwrote = sockets::<span class="hljs-built_in">write</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), data, len);<br>        <span class="hljs-keyword">if</span> (nwrote &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            remaining = len - nwrote;<br>            <span class="hljs-keyword">if</span> (remaining == <span class="hljs-number">0</span> &amp;&amp; writeCompleteCallback_)<br>            &#123;<br>                loop_-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(writeCompleteCallback_, <span class="hljs-built_in">shared_from_this</span>()));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// nwrote &lt; 0, error</span><br>        &#123;<br>            nwrote = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK) <span class="hljs-comment">// EWOULDBLOCK: 发送缓冲区已满, 且fd已设为nonblocking</span><br>            &#123; <span class="hljs-comment">// O_NONBLOCK fd, write block but return EWOULDBLOCK error</span><br>                LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;TcpConnection::sendInLoop&quot;</span>;<br>                <span class="hljs-keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> any others?</span><br>                &#123; <span class="hljs-comment">// EPIPE: reading end is closed; ECONNRESET: connection reset by peer</span><br>                    faultError = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余待发送数据</span><br>    <span class="hljs-built_in">assert</span>(remaining &lt;= len);<br>    <span class="hljs-keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有故障, 并且还有待发送数据, 可能是发送太快, 对方来不及接收</span><br>    &#123; <span class="hljs-comment">// no error and data remaining to be written</span><br>        <span class="hljs-type">size_t</span> oldLen = outputBuffer_.<span class="hljs-built_in">readableBytes</span>(); <span class="hljs-comment">// Buffer中待发送数据量</span><br><br>        <span class="hljs-keyword">if</span> (oldLen + remaining &gt;= highWaterMark_ <span class="hljs-comment">// Buffer及当前要发送的数据量之和 超 高水位(highWaterMark)</span><br>        &amp;&amp; oldLen &lt; highWaterMark_ <span class="hljs-comment">// 单独的Buffer中待发送数据量 未超 高水位</span><br>        &amp;&amp; highWaterMarkCallback_)<br>        &#123;<br>            loop_-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(highWaterMarkCallback_, <span class="hljs-built_in">shared_from_this</span>(), oldLen + remaining));<br>        &#125;<br>        <span class="hljs-comment">// append data to be written to the output buffer</span><br>        outputBuffer_.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data) + nwrote, remaining);<br>        <span class="hljs-comment">// enable write event for channel_</span><br>        <span class="hljs-keyword">if</span> (!channel_-&gt;<span class="hljs-built_in">isWriting</span>())<br>        &#123; <span class="hljs-comment">// 如果没有在监听通道写事件, 就使能通道写事件</span><br>            channel_-&gt;<span class="hljs-built_in">enableWriting</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition info"><p class="admonition-title">info</p><p>HighWaterMarkCallback指的是如果输出缓冲的长度超过用户指定大小，就会触发回调（只在上升沿触发一次）。</p></div><h3id="用户使用tcpserver与客户端进行通信">用户使用TcpServer与客户端进行通信</h3><div class="admonition attention"><p class="admonition-title">假设客户端请求与服务器建立连接，用户（库的使用者）如何在建立连接、发送数据时，执行自定义任务？</p><p>可以在TcpServer启动前，利用TcpServer::setConnectionCallback()、TcpServer::setMessageCallback()等设置回调接口注册任务，等Tcp连接达到指定状态后，会回调用户任务。</p></div><p><strong>示例：使用TcpServer接口类创建Tcp连接</strong></p><p>例如，用户自定义服务EchoServer回传收到的客户端消息，EchoServer使用TcpServer注册连接回调（setConnectionCallback）和消息回调（setMessageCallback）。</p><p>如果需要分阶段向客户端发送数据，还可以注册写完成回调（setWriteCompleteCallback）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// examples/simple/echo</span><br>EchoServer::<span class="hljs-built_in">EchoServer</span>(muduo::net::EventLoop *loop, <span class="hljs-type">const</span> muduo::net::InetAddress &amp;listenAddr)<br>: <span class="hljs-built_in">server_</span>(loop, listenAddr, <span class="hljs-string">&quot;EchoServer&quot;</span>)<br>&#123;<br>    server_.<span class="hljs-built_in">setConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onConnection, <span class="hljs-keyword">this</span>, _1));<br>    server_.<span class="hljs-built_in">setMessageCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onMessage, <span class="hljs-keyword">this</span>, _1, _2, _3));<br><br>    LOG_INFO &lt;&lt; server_.<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; listen on &quot;</span> &lt;&lt; listenAddr.<span class="hljs-built_in">toIpPort</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EchoServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    server_.<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EchoServer::onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;EchoServer - &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span><br>    &lt;&lt; conn-&gt;<span class="hljs-built_in">localAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot; is &quot;</span><br>    &lt;&lt; (conn-&gt;<span class="hljs-built_in">connected</span>() ? <span class="hljs-string">&quot;UP&quot;</span> : <span class="hljs-string">&quot;DOWN&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EchoServer::onMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buf, muduo::Timestamp time)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">muduo::string <span class="hljs-title">msg</span><span class="hljs-params">(buf-&gt;retrieveAllAsString())</span></span>;<br>    LOG_INFO &lt;&lt; conn-&gt;<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; echo &quot;</span> &lt;&lt; msg.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; bytes, &quot;</span><br>    &lt;&lt; <span class="hljs-string">&quot;data received at &quot;</span> &lt;&lt; time.<span class="hljs-built_in">toString</span>();<br>    conn-&gt;<span class="hljs-built_in">send</span>(msg);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>();<br>    muduo::net::EventLoop loop; <span class="hljs-comment">// 创建EventLoop对象</span><br>    muduo::<span class="hljs-function">net::InetAddress <span class="hljs-title">listenAddr</span><span class="hljs-params">(<span class="hljs-number">2007</span>)</span></span>; <span class="hljs-comment">// 创建包含ip地址、端口号的对象</span><br>    <span class="hljs-function">EchoServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;loop, listenAddr)</span></span>; <span class="hljs-comment">// 创建用户自定义EchoServer对象</span><br>    server.<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 启动EchoServer服务器</span><br>    loop.<span class="hljs-built_in">loop</span>();     <span class="hljs-comment">// 启动loop循环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://www.cnblogs.com/fortunely/p/16048017.html">muduo笔记网络库（七）TCP连接TcpConnection、Acceptor、TcpServer</a></li><li><ahref="https://zhuanlan.zhihu.com/p/495016351">万字长文梳理Muduo库核心代码及优秀编程细节思想剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Socket</title>
    <link href="/2023/07/06/muduo%E5%BA%93-Socket/"/>
    <url>/2023/07/06/muduo%E5%BA%93-Socket/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-socket">muduo库-Socket</h1><h2 id="socket类">Socket类</h2><p>Socket类是socket 文件描述符（sockfd）的一个轻量级封装，提供操作底层sockfd的常用方法。采用RTII方式管理sock fd，但本身并不创建sockfd，也不打开它，只负责关闭。</p><p>提供的public方法主要包括：获取tcp协议栈信息（tcp_info）；绑定ip地址（bind）；监听套接字（listen）；接收连接请求（accept）；关闭连接写方向（shutdown），等等。</p><div class="admonition note"><p class="admonition-title">note</p><p>Socket并不提供close sockfd的public方法，因为析构时，调用close关闭套接字。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* socket fd 包装类</span><br><span class="hljs-comment">*　RAII机制管理socket fd: 对close socket fd负责, 但不包括open/create.</span><br><span class="hljs-comment">* 监听socket, 常用于server socket.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function">    : sockfd_(sockfd)</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-comment">// Socket(Socket&amp;&amp;) // move ctor in c++11</span><br>    ~<span class="hljs-built_in">Socket</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sockfd_; &#125;<br>    <span class="hljs-comment">/* 获取tcp信息, 存放到tcp_info结构 */</span><br>    <span class="hljs-comment">// return true if success.</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getTcpInfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tcp_info*)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取tcp信息字符串形式(NUL结尾), 存放到字符串数组buf[len] */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getTcpInfoString</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> len)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">/* 绑定socket fd与本地ip地址,端口, 核心调用bind(2).</span><br><span class="hljs-comment">     * 失败则终止程序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// abort if address in use</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> InetAddress&amp; addr)</span></span>;<br>    <span class="hljs-comment">/* 监听socket fd, 核心调用listen(2).</span><br><span class="hljs-comment">     * 失败则终止程序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// abort if address in use</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接受连接请求, 返回conn fd(连接文件描述符). 核心调用accept(2).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * On success, returns a non-negative integer that is</span><br><span class="hljs-comment">     * a descriptor for the accepted socket, which has been</span><br><span class="hljs-comment">     * set to non-blocking and close-on-exec. *peeraddr is assigned.</span><br><span class="hljs-comment">     * On error, -1 is returned, and *peeraddr is untouched.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(InetAddress* peeraddr)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接写方向</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownWrite</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable TCP_NODELAY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTcpNoDelay</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable SO_REUSEADDR</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReuseAddr</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable SO_REUSEPORT</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReusePort</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable SO_KEEPALIVE</span><br><span class="hljs-comment">     * @param on</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setKeepAlive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sockfd_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实现主要转交给SocketsOps包装库函数后的包装函数。</p><h3 id="socket的构造与析构">Socket的构造与析构</h3><p>Socket构造和析构很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function">: sockfd_(sockfd)</span><br><span class="hljs-function">&#123;</span> &#125;<br><br>Socket::~<span class="hljs-built_in">Socket</span>()<br>&#123;<br>    sockets::<span class="hljs-built_in">close</span>(sockfd_);<br>&#125;<br></code></pre></td></tr></table></figure><p>Socket类不创建sockfd，其含义取决于构造Socket对象的调用者。如果是由调用socket(2)创建的sockfd，那就是本地套接字；如果是由accept(2)返回的sockfd，那就是acceptedsocket，代表一个连接。</p><p>例如，Acceptor持有的Socket对象，是由socket(2)创建的，代表一个套接字；TcpConnection只有一个Socket对象，是由TcpServer在新建TcpConnection对象时传入，而由Acceptor::handleRead()中通过Socket::accept()创建的sockfd参数的实参。</p><h3 id="socket获取tcp协议栈信息">Socket获取Tcp协议栈信息</h3><p>利用getsockopt + TCP_INFO选项，获取tcp协议栈信息。</p><ul><li><p>方法一：getTcpInfo获取tcp协议栈信息，存放到tcp_info结构对象;</p></li><li><p>方法二：getTcpInfoString获取tcp协议栈字符串形式，存放到数组buf[len]；</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 获取TcpInfo(Tcp信息), 存放到tcp_info结构对象tcpi中.</span><br><span class="hljs-comment">* @details 调用getsockopt获取TcpInfo, 对应opt name为TCP_INFO.</span><br><span class="hljs-comment">* @param tcpi [in] 指向tcp_info结构, 用来存放TcpInfo</span><br><span class="hljs-comment">* @return 获取TcpInfo结果</span><br><span class="hljs-comment">* - true 获取成功</span><br><span class="hljs-comment">* - false 获取失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Socket::getTcpInfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tcp_info *tcpi)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(*tcpi);<br>    <span class="hljs-built_in">memZero</span>(tcpi, len);<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">getsockopt</span>(sockfd_, SOL_TCP, TCP_INFO, tcpi, &amp;len) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将从getTcpInfo得到的TcpInfo转换为字符串, 存放到长度为len的buf中.</span><br><span class="hljs-comment">* @param buf 存放TcpInfo字符串的缓存</span><br><span class="hljs-comment">* @param len 缓存buf的长度, 单位是字节数</span><br><span class="hljs-comment">* @return 调用结果</span><br><span class="hljs-comment">* - true 返回存放到buf的TcpInfo有效</span><br><span class="hljs-comment">* - false 调用getsockopt()出错</span><br><span class="hljs-comment">* @see</span><br><span class="hljs-comment">* https://blog.csdn.net/zhangskd/article/details/8561950</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Socket::getTcpInfoString</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> len)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tcp_info</span> tcpi;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-built_in">getTcpInfo</span>(&amp;tcpi);<br>    <span class="hljs-keyword">if</span> (ok)<br>    &#123;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(len), <span class="hljs-string">&quot;unrecovered=%u &quot;</span><br>                           <span class="hljs-string">&quot;rto=%u ato=%u snd_mss=%u rcv_mss=%u &quot;</span><br>                           <span class="hljs-string">&quot;lost=%u retrans=%u rtt=%u rttvar=%u &quot;</span><br>                           <span class="hljs-string">&quot;sshthresh=%u cwnd=%u total_retrans=%u&quot;</span>,<br>                 tcpi.tcpi_retransmits,  <span class="hljs-comment">// 重传数, 当前待重传的包数, 重传完成后清零 //　Number of unrecovered [RTO] timeouts</span><br>                 tcpi.tcpi_rto,          <span class="hljs-comment">// 重传超时时间(usec)　// Retransmit timeout in usec</span><br>                 tcpi.tcpi_ato,          <span class="hljs-comment">// 延时确认的估值(usec) // Predicted tick of soft clock in usec</span><br>                 tcpi.tcpi_snd_mss,      <span class="hljs-comment">// 发送端MSS(最大报文段长度)</span><br>                 tcpi.tcpi_rcv_mss,      <span class="hljs-comment">// 接收端MSS(最大报文段长度)</span><br>                 tcpi.tcpi_lost,         <span class="hljs-comment">// 丢失且未恢复的数据段数 // Lost packets</span><br>                 tcpi.tcpi_retrans,      <span class="hljs-comment">// 重传且未确认的数据段数 // Retransmitted packets out</span><br>                 tcpi.tcpi_rtt,          <span class="hljs-comment">// 平滑的RTT(usec)　//　Smoothed round trip time in usec</span><br>                 tcpi.tcpi_rttvar,       <span class="hljs-comment">// 1/4 mdev (usec) // Medium deviation</span><br>                 tcpi.tcpi_snd_ssthresh, <span class="hljs-comment">// 慢启动阈值</span><br>                 tcpi.tcpi_snd_cwnd,     <span class="hljs-comment">// 拥塞窗口</span><br>                 tcpi.tcpi_total_retrans <span class="hljs-comment">// 本连接的总重传个数  // Total retransmits for entire connection</span><br>                           );<br>    &#125;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他常用接口">其他常用接口</h3><p>比如bindAddress、listen、accept等，与基础网络编程接口bind、listen、accept类似，不过由SocketOps进行轻度包裹。</p><p>值得一提的是setTcpNoDelay()，用于设置TCP_NODELAY选项，以禁用Nagle算法，从而不会等到收到ACK才进行下一次数据发送，而是tcp协议栈缓冲存中有数据就立即发送。适用于对性能要求较高的情况。</p><h2 id="inetaddress类">InetAddress类</h2><p>InetAddress类对地址信息进行了包装，是sockaddr_in的包装类。</p><p><strong>既然是表示ip地址，可以直接用sockaddr_in，为什么要用InetAddress重新包装一下？</strong></p><p>因为表示IPv4地址的sockaddr_in是C语言数据类型，并不包含对数据类型的操作，另外，支持IPv6的地址结构是sockaddr_in6。如果直接使用C风格的sockaddr_in，那么其他类要用来表示地址，不得不使用大量底层C接口。而使用C++类InetAddress包装sockaddr_in/sockaddr_in6，提供必要的C++接口，可以有效解决参数兼容问题。</p><p>InetAddress 声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* sockaddr_in包装类.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* POD(Plain Old Data) 接口类, 便于Ｃ++和Ｃ之间数据类型的兼容性.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InetAddress</span> : <span class="hljs-keyword">public</span> muduo::copyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用给定端口号构造一个端(ip + port).</span><br><span class="hljs-comment">     * 常用于TcpServer, 监听本地地址.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> portArg = <span class="hljs-number">0</span>, <span class="hljs-type">bool</span> loopbackOnly = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span> ipv6 = <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建一个InetAddress对象, 用于将一个port + 字符串形式的ip地址转化为InetAddress对象.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">InetAddress</span>(StringArg ip, <span class="hljs-type">uint16_t</span> portArg, <span class="hljs-type">bool</span> ipv6 = <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in&amp; addr)</span></span><br><span class="hljs-function">            : addr_(addr)</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6&amp; addr)</span></span><br><span class="hljs-function">            : addr6_(addr)</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-comment">/* 获取协议族类型 */</span><br>    <span class="hljs-function"><span class="hljs-type">sa_family_t</span> <span class="hljs-title">family</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> addr_.sin_family; &#125;<br>    <span class="hljs-comment">/* 获取ip地址字符串形式.</span><br><span class="hljs-comment">     * 对于ipv4, 为点分十进制; 对于ipv6, 为冒号十六进制. */</span><br>    <span class="hljs-function">string <span class="hljs-title">toIp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取ip地址+port字符串形式. */</span><br>    <span class="hljs-function">string <span class="hljs-title">toIpPort</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取端口号(主机端) */</span><br>    <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">port</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// default copy/assignment are Okay</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">getSockAddr</span>() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> sockets::<span class="hljs-built_in">sockaddr_cast</span>(&amp;addr6_); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSockAddrInet6</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6&amp; addr6)</span> </span>&#123; addr6_ = addr6; &#125;<br><br>    <span class="hljs-comment">/* 获取ipv4地址网络端(大端) */</span><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">ipv4NetEndian</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取端口号网络端(大端) */</span><br>    <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">portNetEndian</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> addr_.sin_port; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将hostname转换为IP地址, 存放到result, 而不改变port或sin_family.</span><br><span class="hljs-comment">     * 线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">resolve</span><span class="hljs-params">(StringArg hostname, InetAddress* result)</span></span>;<br><br>    <span class="hljs-comment">/* 设置IPv6 ScopeID(域ID) */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setScopedId</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> scope_id)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">union</span><br>    &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr_;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> addr6_;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>InetAddress是值语义的，便于在传递时拷贝。数据成员是一个union，对于IPv4，使用addr_；对于IPv6，则使用addr6_。</p><p>5个静态断言（static_assert）确保数据成员大小及联合体内部位段偏移，因为后面会直接将sockaddr_in6转换为sockaddr_in。</p><h3 id="inetaddress构造">InetAddress构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">in_addr_t</span> kInaddrAny = INADDR_ANY;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">in_addr_t</span> kInaddrLoopback = INADDR_LOOPBACK;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构造InetAddress对象</span><br><span class="hljs-comment">* @param portArg 端口号</span><br><span class="hljs-comment">* @param loopbackOnly　决定是否为回环地址</span><br><span class="hljs-comment">* @param ipv6　决定是否为ipv6地址</span><br><span class="hljs-comment">* @note 注意addr_/addr6_中存放的是网络字节序</span><br><span class="hljs-comment">*/</span><br>InetAddress::<span class="hljs-built_in">InetAddress</span>(<span class="hljs-type">uint16_t</span> portArg, <span class="hljs-type">bool</span> loopbackOnly, <span class="hljs-type">bool</span> ipv6)<br>&#123;<br>    <span class="hljs-comment">// 确保addr6_/addr_ 在InetAddress class内存中的偏移</span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">offsetof</span>(InetAddress, addr6_) == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;addr6_ offset 0&quot;</span>);<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">offsetof</span>(InetAddress, addr_) == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;addr_ offset 0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ipv6)<br>    &#123; <span class="hljs-comment">// ipv6地址</span><br>        <span class="hljs-built_in">memZero</span>(&amp;addr6_, <span class="hljs-built_in">sizeof</span>(addr6_));<br>        addr6_.sin6_family = AF_INET6;<br>        <span class="hljs-comment">// in6addr_loopback: 回环地址; in6addr_any： 任意地址</span><br>        in6_addr ip = loopbackOnly ? in6addr_loopback : in6addr_any;<br>        addr6_.sin6_addr = ip; <span class="hljs-comment">// ip地址</span><br>        addr6_.sin6_port = sockets::<span class="hljs-built_in">hostToNetwork16</span>(portArg); <span class="hljs-comment">// 端口号</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// ipv4地址</span><br>        <span class="hljs-built_in">memZero</span>(&amp;addr_, <span class="hljs-built_in">sizeof</span>(addr_));<br>        addr_.sin_family = AF_INET;<br>        <span class="hljs-comment">// kInaddrLoopback: 回环地址; kInaddrAny： 任意地址</span><br>        <span class="hljs-type">in_addr_t</span> ip = loopbackOnly ? kInaddrLoopback : kInaddrAny;<br>        addr_.sin_addr.s_addr = sockets::<span class="hljs-built_in">hostToNetwork32</span>(ip); <span class="hljs-comment">// ip地址</span><br>        addr_.sin_port = sockets::<span class="hljs-built_in">hostToNetwork16</span>(portArg);   <span class="hljs-comment">// 端口号</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 根据ip地址字符串形式 + 端口号, 构造InetAddress对象</span><br><span class="hljs-comment">* IPv6: 2409:8a4c:662f:2900:9b2:63:9618:56c0</span><br><span class="hljs-comment">* IPv4: 127.0.0.1</span><br><span class="hljs-comment">*/</span><br>InetAddress::<span class="hljs-built_in">InetAddress</span>(StringArg ip, <span class="hljs-type">uint16_t</span> portArg, <span class="hljs-type">bool</span> ipv6)<br>&#123;<br>    <span class="hljs-keyword">if</span> (ipv6 || <span class="hljs-built_in">strchr</span>(ip.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&#x27;:&#x27;</span>))<br>    &#123; <span class="hljs-comment">// 指定为ipv6地址类型, 或ip地址字符串中包含&#x27;:&#x27;</span><br>        <span class="hljs-built_in">memZero</span>(&amp;addr6_, <span class="hljs-built_in">sizeof</span>(addr6_));<br>        sockets::<span class="hljs-built_in">fromIpPort</span>(ip.<span class="hljs-built_in">c_str</span>(), portArg, &amp;addr6_); <span class="hljs-comment">// 将冒号16进制表示的ip地址+port, 转化为addr6_结构</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">memZero</span>(&amp;addr_, <span class="hljs-built_in">sizeof</span>(addr_));<br>        sockets::<span class="hljs-built_in">fromIpPort</span>(ip.<span class="hljs-built_in">c_str</span>(), portArg, &amp;addr_); <span class="hljs-comment">// 将冒号16进制表示的ip地址+port, 转化为addr6_结构</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 根据sockaddr_in构造InetAddress对象 */</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in&amp; addr)</span></span><br><span class="hljs-function">        : addr_(addr)</span><br><span class="hljs-function">&#123;</span> &#125;<br><br><span class="hljs-comment">/* 根据sockaddr_in6构造InetAddress对象 */</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6&amp; addr)</span></span><br><span class="hljs-function">        : addr6_(addr)</span><br><span class="hljs-function">&#123;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="将ip地址信息转换为字符串">将IP地址信息转换为字符串</h3><p>将IP地址、端口号转换为字符串形式，这种打印log、debug的时候，是需要常用的方法，可以调用toIp(),toIpPort()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 当对象ip地址转换为字符串, 如果是IPv4, 就转换为点分十进制; 如果是IPv6, 就转换为冒号十六进制.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">InetAddress::toIp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    sockets::<span class="hljs-built_in">toIp</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-built_in">getSockAddr</span>());<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 当对象ip地址＆port信息 转换为字符串, 如果是IPv4, 就转换为点分十进制; 如果是IPv6, 就转换为冒号十六进制.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">InetAddress::toIpPort</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    sockets::<span class="hljs-built_in">toIpPort</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-built_in">getSockAddr</span>());<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="将主机名或ipv4地址转换为inetaddress结构对象">将主机名或IPv4地址转换为InetAddress结构对象</h3><p>可以用InetAddress::resolve</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 转换用的临时缓存. 因为占用空间比较大, 不用函数栈; 又要确保线程安全, 有可能经常调用, 因此用thread local 变量 */</span><br><span class="hljs-type">static</span> __thread <span class="hljs-type">char</span> t_resolveBuffer[<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>]; <span class="hljs-comment">// 64KB = 64*1024</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* hostname转换为InetAddress</span><br><span class="hljs-comment">* @param hostname 主机名, 可以是本地主机名, 如&quot;localhost&quot;; 也可以是远程域名, 如&quot;google.com&quot;, &quot;192.168.0.10&quot;,</span><br><span class="hljs-comment">* @param out[out] 指向一个InetAddress对象, 存放地址信息</span><br><span class="hljs-comment">* @return 转换结果. true: 表示转换成功; false: 表示转换失败.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InetAddress::resolve</span><span class="hljs-params">(StringArg hostname, InetAddress *out)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(out != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> hent;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span>* he = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> herrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memZero</span>(&amp;hent, <span class="hljs-built_in">sizeof</span>(hent));<br><br><br>    <span class="hljs-comment">/* 将主机名或IPv4地址(点分十进制)转换为hostent结构 */</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">gethostbyname_r</span>(hostname.<span class="hljs-built_in">c_str</span>(), &amp;hent, t_resolveBuffer, <span class="hljs-built_in">sizeof</span>(t_resolveBuffer),<br>                              &amp;he, &amp;herrno);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span> &amp;&amp; he != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(he-&gt;h_addrtype == AF_INET &amp;&amp; he-&gt;h_length == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)); <span class="hljs-comment">// AF_INET: ipv4</span><br>        out-&gt;addr_.sin_addr = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">struct</span> in_addr*&gt;(he-&gt;h_addr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// error, gai_strerror(3) 能获取错误字符串信息</span><br>        <span class="hljs-keyword">if</span> (ret)<br>        &#123;<br>            LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;InetAddress::resolve&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="socketsops">SocketsOps</h3><p>SocketsOps准确来说是一个模块，而不是一个class，在sockets命名空间封装了系统底层提供的socket操作，比如socket(),bind(), listen(), accept(), connect(), close(), read(), readv(),write(), close(), shutdown()等等。</p><p>包裹函数的主要意义是为函数提供基本的出错处理，避免每次调用都要重写一次异常处理，使之更容易融入程序的框架。</p><p>我把包裹的函数分为4类：</p><ol type="1"><li>基础的sock fd操作</li><li>便于交互的转换操作</li><li>地址类型转型</li><li>协议栈信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基础的sock fd操作</span><br><br><span class="hljs-comment">/* 包裹socket(2), 创建非阻塞sockfd. 失败终止程序(LOG_SYSFATAL) */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createNonblockingOrDie</span><span class="hljs-params">(<span class="hljs-type">sa_family_t</span> family)</span></span>;<br><br><span class="hljs-comment">/* 包裹connect(2), 连接指定对端地址(addr) */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><span class="hljs-comment">/* 包裹bind(2), 绑定本地sockfd与本地ip地址addr. 失败终止程序(LOG_SYSFATAL) */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><span class="hljs-comment">/* 包裹listen(2), 监听本地sockfd. 失败终止程序(LOG_SYSFATAL) */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listenOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><span class="hljs-comment">/* 包裹accept(2)/accept4(2), 接受客户端请求连接, 返回连接sockfd */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr_in6* addr)</span></span>;<br><span class="hljs-comment">/* 包裹read(2), 从sockfd读取数据, 存放到数组buf[count] */</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-comment">/* 包裹readv(2), 从sockfd读取数据, 存放到不连续内存iov[iovcnt]中 */</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec* iov, <span class="hljs-type">int</span> iovcnt)</span></span>;<br><span class="hljs-comment">/* 包裹write(2), 将buf[count]中的数据写到sockfd连接 */</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-comment">/* 包裹close(2), 关闭sockfd */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><span class="hljs-comment">/* 包裹shutdown(8), 关闭连接写方向 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><br><span class="hljs-comment">// 便于交互的转换操作</span><br><br><span class="hljs-comment">/* 将地址addr中包含的ip地址+port信息转换为C风格字符串, 存放到数组buf[size] */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toIpPort</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><span class="hljs-comment">/* 将地址addr中包含的ip地址转换为C风格字符串, 存放到数组buf[size] */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toIp</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><br><span class="hljs-comment">/* 将参数ip, port转换为sockaddr_in结构的addr */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in* addr)</span></span>;<br><span class="hljs-comment">/* 将参数ip, port转换为sockaddr_in6结构的addr */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in6* addr)</span></span>;<br><br><br><span class="hljs-comment">// 地址类型转型</span><br><br><span class="hljs-comment">/* const sockaddr_in转型为const sockaddr　*/</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in* addr);<br><span class="hljs-comment">/* const sockaddr_in6转型为const sockaddr　*/</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6* addr);<br><span class="hljs-comment">/* sockaddr_in6转型为sockaddr　*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-keyword">struct</span> sockaddr_in6* addr);<br><span class="hljs-comment">/* const sockaddr转型为const sockaddr_in */</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* <span class="hljs-built_in">sockaddr_in_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr);<br><span class="hljs-comment">/* const sockaddr转型为const sockaddr_in6 */</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* <span class="hljs-built_in">sockaddr_in6_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr);<br><br><span class="hljs-comment">// 协议栈信息</span><br><br><span class="hljs-comment">/* 获取tcp/ip协议栈错误 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSocketError</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><span class="hljs-comment">/* 获取sockfd对应的本地地址 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> <span class="hljs-built_in">getLocalAddr</span>(<span class="hljs-type">int</span> sockfd);<br><span class="hljs-comment">/* 获取sockfd对应的对端地址 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> <span class="hljs-built_in">getPeerAddr</span>(<span class="hljs-type">int</span> sockfd);<br><span class="hljs-comment">/* 判断sockfd是否为自连接 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSelfConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="createnonblockingordie函数">createNonblockingOrDie()函数</h4><p>创建非阻塞sock fd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 创建一个非阻塞sock fd</span><br><span class="hljs-comment">* @param family 协议族, 可取值AF_UNIX/AF_INET/AF_INET6 etc.</span><br><span class="hljs-comment">* @return 成功, 返回sock fd; 失败, 程序终止(LOG_SYSFATAL)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::createNonblockingOrDie</span><span class="hljs-params">(<span class="hljs-type">sa_family_t</span> family)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> VALGRIND <span class="hljs-comment">// a kind of memory test tool</span></span><br>    <span class="hljs-type">int</span> sockfd = ::<span class="hljs-built_in">socket</span>(family, SOCK_STREAM, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::createNonblockingOrDie&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">setNonBlockAndCloseOnExec</span>(sockfd);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">int</span> sockfd = ::<span class="hljs-built_in">socket</span>(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::createNonblockingOrDie&quot;</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="connect函数">connect()函数</h4><p>请求连接服务器端addr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">connect</span>(sockfd, addr, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in6)));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bindordie函数">bindOrDie()函数</h4><p>绑定sock fd与本地地址addr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::bindOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = ::<span class="hljs-built_in">bind</span>(sockfd, addr, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in6)));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::bindOrDie&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="listenordie函数">listenOrDie()函数</h4><p>监听本地sockfd。如果协议支持重传（如TCP协议），那么listen第二个参数backlog会被忽略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::listenOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = ::<span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::listenOrDie&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="accept函数">accept函数</h4><p>接受连接请求。被包裹函数accept或accep4，其区别为：accept4一次调用能同时指定SOCK_NONBLOCK和SOCK_CLOEXEC选项；如果要用accept，则还需要额外调用setNonBlockAndCloseOnExec()，来设置sockfd的non-block、close-on-exec属性。</p><p>accept调用出错时，跟log记录错误号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* accept(2)/accept4(2)包裹函数, 接受连接并获取对端ip地址</span><br><span class="hljs-comment">* @param sockfd 服务器sock fd, 指向本地监听的套接字资源</span><br><span class="hljs-comment">* @param addr ip地址信息</span><br><span class="hljs-comment">* @return 由sockfd接收连接请求得到到连接fd</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr_in6 *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(*addr));<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> VALGRIND || defined(NO_ACCEPT4) <span class="hljs-comment">// VALGRIND: memory check tool</span></span><br>    <span class="hljs-type">int</span> connfd = ::<span class="hljs-built_in">accept</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(addr), &amp;addrlen);<br>    <span class="hljs-built_in">setNonBlockAndCloseOnExec</span>(connfd);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// set flags for conn fd returned by accept() at one time</span><br>    <span class="hljs-type">int</span> connfd = ::<span class="hljs-built_in">accept4</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(addr),<br>                           &amp;addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> savedErrno = errno;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;Socket::accept&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (savedErrno)<br>        &#123;<br>            <span class="hljs-keyword">case</span> EAGAIN:<br>            <span class="hljs-keyword">case</span> ECONNABORTED:<br>            <span class="hljs-keyword">case</span> EINTR:<br>            <span class="hljs-keyword">case</span> EPROTO:<br>            <span class="hljs-keyword">case</span> EMFILE:<br>                <span class="hljs-comment">// expected errors</span><br>                errno = savedErrno;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EBADF:<br>            <span class="hljs-keyword">case</span> EFAULT:<br>            <span class="hljs-keyword">case</span> EINVAL:<br>            <span class="hljs-keyword">case</span> ENFILE:<br>            <span class="hljs-keyword">case</span> ENOBUFS:<br>            <span class="hljs-keyword">case</span> ENOMEM:<br>            <span class="hljs-keyword">case</span> ENOTSOCK:<br>            <span class="hljs-keyword">case</span> EOPNOTSUPP:<br>                <span class="hljs-comment">// unexpected errors</span><br>                LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;unexpected error of ::accept &quot;</span> &lt;&lt; savedErrno;<br><br>            <span class="hljs-keyword">default</span>:<br>                LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;unknown error of ::accept &quot;</span> &lt;&lt; savedErrno;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> connfd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="readreadv函数">read()、readv()函数</h4><p>read直接转发给read(2)，没有特殊处理；readv直接转发给readv(2)，没有特殊处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sockets::read</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">read</span>(sockfd, buf, count);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sockets::readv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">readv</span>(sockfd, iov, iovcnt);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write函数">write()函数</h4><p>write直接转发给write(2)，没有特殊处理；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sockets::write</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">write</span>(sockfd, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="close函数">close()函数</h4><p>关闭sockfd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::close</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">close</span>(sockfd) &lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::close&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shutdownwrite函数">shutdownWrite()函数</h4><p>shutdownWrite关闭连接写方向：shutdown(2) + SHUT_WR</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::shutdownWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">shutdown</span>(sockfd, SHUT_WR) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::shutdownWrite&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="toipport-toip函数">toIpPort(), toIp()函数</h4><p>将ip地址、port信息由sockaddr对象，转换为字符串。核心调用inet_ntop(2)，将IPv4、IPv6地址由二进制转化为文本。利用snprintf，将ip地址和port文本信息组装到一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert struct sockaddr containing ip info to ip string pointed by buf</span><br><span class="hljs-comment">* @param buf [out] point to ip string buffer</span><br><span class="hljs-comment">* @param size size of buf (bytes)</span><br><span class="hljs-comment">* @param addr [in] point to struct sockaddr containing ip address and port info</span><br><span class="hljs-comment">* @note port of struct sockaddr is network byte order, but local operation needs</span><br><span class="hljs-comment">* host byte order.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::toIpPort</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (addr-&gt;sa_family == AF_INET6)<br>    &#123; <span class="hljs-comment">// IPv6</span><br>        buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;[&#x27;</span>;<br>        <span class="hljs-built_in">toIp</span>(buf + <span class="hljs-number">1</span>, size - <span class="hljs-number">1</span>, addr);<br>        <span class="hljs-type">size_t</span> end = ::<span class="hljs-built_in">strlen</span>(buf);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* addr6 = <span class="hljs-built_in">sockaddr_in6_cast</span>(addr);<br>        <span class="hljs-type">uint16_t</span> port = sockets::<span class="hljs-built_in">networkToHost16</span>(addr6-&gt;sin6_port);<br>        <span class="hljs-built_in">assert</span>(size &gt; end);<br>        <span class="hljs-built_in">snprintf</span>(buf + end, size - end, <span class="hljs-string">&quot;]:%u&quot;</span>, port);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// IPv4</span><br>    <span class="hljs-built_in">toIp</span>(buf, size, addr);<br>    <span class="hljs-type">size_t</span> end = ::<span class="hljs-built_in">strlen</span>(buf);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* addr4 = <span class="hljs-built_in">sockaddr_in_cast</span>(addr);<br>    <span class="hljs-type">uint16_t</span> port = sockets::<span class="hljs-built_in">networkToHost16</span>(addr4-&gt;sin_port);<br>    <span class="hljs-built_in">assert</span>(size &gt; end);<br>    <span class="hljs-built_in">snprintf</span>(buf + end, size - end, <span class="hljs-string">&quot;:%u&quot;</span>, port);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert IP address info from struct sockaddr to string buffer</span><br><span class="hljs-comment">* @param buf [out] string buffer with NUL-byte</span><br><span class="hljs-comment">* @param size length of string buffer</span><br><span class="hljs-comment">* @param addr [in] point to struct sockaddr, which contains ip, port info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::toIp</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (addr-&gt;sa_family == AF_INET)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(size &gt;= INET_ADDRSTRLEN);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* addr4 = <span class="hljs-built_in">sockaddr_in_cast</span>(addr);<br>        ::<span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;addr4-&gt;sin_addr, buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(size));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr-&gt;sa_family == AF_INET6)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(size &gt;= INET6_ADDRSTRLEN);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* addr6 = <span class="hljs-built_in">sockaddr_in6_cast</span>(addr);<br>        ::<span class="hljs-built_in">inet_ntop</span>(AF_INET6, &amp;addr6-&gt;sin6_addr, buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(size));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fromipport函数">fromIPPort()函数</h4><p>将ip地址、端口号文本转换为二进制（sockaddr_in/sockaddr_in6），sockaddr_in适用于IPv4，sockaddr_in6适用于IPv6。2个重载函数是toIpPort()的逆过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert ipv4 string to struct sockaddr_in</span><br><span class="hljs-comment">* @param ip ipv4 address string with format like &quot;127.0.0.1&quot;</span><br><span class="hljs-comment">* @param port local port for TCP/UDP</span><br><span class="hljs-comment">* @param addr [out] store ipv4 info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    addr-&gt;sin_family = AF_INET;<br>    addr-&gt;sin_port = <span class="hljs-built_in">hostToNetwork16</span>(port);<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;addr-&gt;sin_addr) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::fromIpPort&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert ipv6 string to struct socket_in6</span><br><span class="hljs-comment">* @param ip ipv6 address string with format like &quot;2409:8a4c:662f:2900:b42c:a0d9:fe5:2037&quot;</span><br><span class="hljs-comment">* @param port local port for TCP/UDP</span><br><span class="hljs-comment">* @param addr [out] store ipv6 info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in6 *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    addr-&gt;sin6_family = AF_INET6;<br>    addr-&gt;sin6_port = <span class="hljs-built_in">hostToNetwork16</span>(port);<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">inet_pton</span>(AF_INET6, ip, &amp;addr-&gt;sin6_addr) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::fromIpPort&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="地址转型函数">地址转型函数</h4><p>提供不同地址类型之间的转型，如sockaddr_in/sockaddr_in6/sockaddr*，要求成员内存布局必须是一样的。这也是为什么前面用static_assert来断言sockaddr_in/sockaddr_in6成员偏移的原因（offsetof），因为如果成员偏移不一样，也就是说对象的内存布局不一样，通过指针直接转型是不对的。</p><div class="admonition attention"><p class="admonition-title">为什么用static_cast对指针进行转型，而不用reinterpret_cast？</p><p>单独的static_cast，是无法将一种指针类型转换为另一种指针类型的，需要先利用implicit_cast（隐式转型）/static_cast（显式转型）将指针类型转换为void/constvoid （无类型）指针，然后才能转换为模板类型指针。</p><p>而reinterpret_cast可以直接做到，但reinterpret_cast通常并不安全，编译期也不会在编译期报错，通常不推荐使用。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// const sockaddr_in6* =&gt; const sockaddr*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* sockets::<span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6* addr)<br>&#123;<br><span class="hljs-comment">//    reinterpret_cast&lt;const struct sockaddr*&gt;();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// sockaddr_in6* =&gt; sockaddr*</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* sockets::<span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-keyword">struct</span> sockaddr_in6* addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-keyword">struct</span> sockaddr*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// const sockaddr_in* =&gt; const sockaddr*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* sockets::<span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in* addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// const sockaddr* =&gt; const sockaddr_in*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* sockets::<span class="hljs-built_in">sockaddr_in_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// const sockaddr* =&gt; const sockaddr_in6*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* sockets::<span class="hljs-built_in">sockaddr_in6_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getsocketerror函数">getSocketError()函数</h4><p>获取tcp协议栈错误。利用getsockopt +SO_ERROR选项，获取tcp协议栈内部错误。通常，在处理连接的读写事件时调用，检查是否发生错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::getSocketError</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> optval;<br>    <span class="hljs-type">socklen_t</span> optlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(optval));<br><br><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getsockopt</span>(sockfd, SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen))<br>    &#123;<br>        <span class="hljs-keyword">return</span> errno;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> optval;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getlocaladdr函数">getLocalAddr()函数</h4><p>从连接获取本地ip地址（包括端口号）。不论IPv4，还是IPv6，统一存放到sockaddr_in6结构对象中，因为该对象长度最长。核心调用getsockname(2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get a local ip address from an opened sock fd</span><br><span class="hljs-comment">* @param sockfd an opened sockfd</span><br><span class="hljs-comment">* @return local ip address info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> sockets::<span class="hljs-built_in">getLocalAddr</span>(<span class="hljs-type">int</span> sockfd)<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> localaddr;<br>    <span class="hljs-built_in">memZero</span>(&amp;localaddr, <span class="hljs-built_in">sizeof</span>(localaddr));<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(localaddr));<br>    <span class="hljs-comment">// get local ip addr info bound to sockfd</span><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getsockname</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(&amp;localaddr), &amp;addrlen) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::getLocalAddr&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> localaddr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getpeeraddr函数">getPeerAddr()函数</h4><p>获取连接对端的ip地址（包括端口号）。类似于getLocalAddr，地址信息都存放到sockaddr_in6结构对象中。核心调用getpeername(2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get a peer ip address from an opened sock fd</span><br><span class="hljs-comment">* @param sockfd an opened sockfd</span><br><span class="hljs-comment">* @return peer ip address info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> sockets::<span class="hljs-built_in">getPeerAddr</span>(<span class="hljs-type">int</span> sockfd)<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> peeraddr;<br>    <span class="hljs-built_in">memZero</span>(&amp;peeraddr, <span class="hljs-built_in">sizeof</span>(peeraddr));<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(peeraddr));<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getpeername</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(&amp;peeraddr), &amp;addrlen))<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::getPeerAddr&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> peeraddr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="isselfconnect函数">isSelfConnect()函数</h4><p>检查是否为自连接。利用了getLocalAddr()和getPeerAddr()，检查ip地址是否相同，来判断连接对端地址信息是否为本机。</p><p>isSelfConnect()函数同样分IPv4和IPv6两种情况，依据是sockaddr_in6的sin6_family成员。</p><div class="admonition note"><p class="admonition-title">note</p><p>对于IPv4，地址sin_addr.s_addr是32bit，能用“”判断是否相等；而对于IPv6，地址sin6_addr是28byte，无法用“”判断，需要用memcmp来比较二进制位。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 检查是否为自连接, 判断连接sockfd两端ip地址信息是否相同.</span><br><span class="hljs-comment">* @param sockfd 连接对应的文件描述符</span><br><span class="hljs-comment">* @return true: 是自连接; false: 不是自连接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sockets::isSelfConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> localaddr = <span class="hljs-built_in">getLocalAddr</span>(sockfd);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> peeraddr = <span class="hljs-built_in">getPeerAddr</span>(sockfd);<br>    <span class="hljs-keyword">if</span> (localaddr.sin6_family == AF_INET)<br>    &#123; <span class="hljs-comment">// IPv4</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* laddr4 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">struct</span> sockaddr_in*&gt;(&amp;localaddr);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* raddr4 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">struct</span> sockaddr_in*&gt;(&amp;peeraddr);<br>        <span class="hljs-keyword">return</span> laddr4-&gt;sin_port == raddr4-&gt;sin_port<br>        &amp;&amp; laddr4-&gt;sin_addr.s_addr == raddr4-&gt;sin_addr.s_addr;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (localaddr.sin6_family == AF_INET6)<br>    &#123; <span class="hljs-comment">// IPv6</span><br>        <span class="hljs-keyword">return</span> localaddr.sin6_port == peeraddr.sin6_port<br>        &amp;&amp; <span class="hljs-built_in">memcmp</span>(&amp;localaddr.sin6_addr, &amp;peeraddr.sin6_addr, <span class="hljs-built_in">sizeof</span>(localaddr.sin6_addr)) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/16048037.html">muduo笔记网络库（六）Socket类及SocketsOps库函数封装</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo-事件驱动EventLoop</title>
    <link href="/2023/07/03/muduo-EventLoop/"/>
    <url>/2023/07/03/muduo-EventLoop/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo-事件驱动eventloop">muduo-事件驱动EventLoop</h1><p>之前说过，muduo网络库处理事件是Reactor模式，one loop perthread，一个线程一个事件循环。这个循环称为EventLoop，这种以事件为驱动的编程模式，称为事件驱动模式。</p><p>这种事件驱动模型要求所有任务是非阻塞的，其典型特点是：如果一个任务需要很长时间才能完成，或者中间可能导致阻塞，就需要对任务进行分段，将其设置为非阻塞的，每次监听到前次任务完成，触发事件回调，从而接着完成后续任务。例如，要发送一个大文件，可以先发送一段，完成后，在写完成事件回调中又发送下一段，这样每次都发生一段，从而完成整个文件发送。</p><p>EventLoop是实现事件驱动模型的关键之一。核心是为线程提供运行循环，不断监听事件、处理事件，为用户提供在loop循环中运行的接口。</p><p>EventLoop事件驱动相关类图关系如下：</p><p><img src="/img/muduo/eventloop/eventloop事件驱动类图.png" /></p><p>上面的类图中有两种不同的关系表示：</p><p>聚合关系：has-a，表示拥有的关系，两种生命周期没有必然关联，可以独立存在。</p><p><img src="/img/muduo/eventloop/has-a.png" /></p><p>组合关系：contain-a，表包含的关系，是一种强聚合关系，强调整体与部分，生命周期一致。</p><p><img src="/img/muduo/eventloop/contain-a.png" /></p><h2 id="eventloop类">EventLoop类</h2><p>EventLoop是一个接口类，不宜暴露太多内部细节给客户，接口及其使用应尽量简洁。EventLoop的主要职责是：</p><ol type="1"><li>提供定时执行用户指定任务的方法，支持一次性、周期执行用户任务；</li><li>提供一个运行循环，每当Poller监听到有通道对应事件发生时，会将通道加入激活通道列表，运行循环要不断从取出激活通道，然后调用事件回调处理事件；</li><li><strong>每个EventLoop对应一个线程，不允许一对多或者多对一</strong>，提供判断当前线程是否为创建EventLoop对象的线程的方法；</li><li>允许在其他线程中调用EventLoop的public接口，但同时要确保线程安全；</li></ol><p>EventLoop类声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Reactor模式， 每个线程最多一个EventLoop (One loop per thread).</span><br><span class="hljs-comment">* 接口类, 不要暴露太多细节给客户</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span> : <span class="hljs-keyword">public</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; Functor;<br><br>    <span class="hljs-built_in">EventLoop</span>();<br>    ~<span class="hljs-built_in">EventLoop</span>(); <span class="hljs-comment">// force out-line dtor, for std::unique_ptr members.</span><br><br>    <span class="hljs-comment">/* loop循环, 运行一个死循环.</span><br><span class="hljs-comment">     * 必须在当前对象的创建线程中运行.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 退出loop循环.</span><br><span class="hljs-comment">     * 如果通过原始指针(raw pointer)调用, 不是100%线程安全;</span><br><span class="hljs-comment">     * 为了100%安全, 最好通过shared_ptr&lt;EventLoop&gt;调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Poller::poll()返回的时间, 通常意味着有数据达到.</span><br><span class="hljs-comment">     * 对于PollPoller, 是调用完poll(); 对于EPollPoller, 是调用完epoll_wait()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">pollReturnTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pollReturnTime_; &#125;<br><br>    <span class="hljs-comment">/* 获取loop循环次数 */</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> iteration_; &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在loop线程中, 立即运行回调cb.</span><br><span class="hljs-comment">     * 如果没在loop线程, 就会唤醒loop, (排队)运行回调cb.</span><br><span class="hljs-comment">     * 如果用户在同一个loop线程, cb会在该函数内运行; 否则， 会在loop线程中排队运行.</span><br><span class="hljs-comment">     * 因此, 在其他线程中调用该函数是安全的.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInLoop</span><span class="hljs-params">(Functor cb)</span></span>;<br><br>    <span class="hljs-comment">/* 排队回调cb进loop线程.</span><br><span class="hljs-comment">     * 回调cb在loop中完成polling后运行.</span><br><span class="hljs-comment">     * 从其他线程调用是安全的.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queueInLoop</span><span class="hljs-params">(Functor cb)</span></span>;<br><br>    <span class="hljs-comment">/* 排队的回调cb个数 */</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">queueSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// timers</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在指定时间点运行回调cb.</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">runAt</span><span class="hljs-params">(Timestamp time, TimerCallback cb)</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在当前时间点+delay延时后运行回调cb.</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">runAfter</span><span class="hljs-params">(<span class="hljs-type">double</span> delay, TimerCallback cb)</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 每隔interval sec周期运行回调cb.</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">runEvery</span><span class="hljs-params">(<span class="hljs-type">double</span> interval, TimerCallback cb)</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 取消定时器, timerId唯一标识定时器Timer</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">(TimerId timerId)</span></span>;<br><br>    <span class="hljs-comment">// internal usage</span><br><br>    <span class="hljs-comment">/* 唤醒loop线程, 没有事件就绪时, loop线程可能阻塞在poll()/epoll_wait() */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 更新Poller监听的channel, 只能在channel所属loop线程中调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span></span>;<br>    <span class="hljs-comment">/* 移除Poller监听的channel, 只能在channel所属loop线程中调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span></span>;<br>    <span class="hljs-comment">/* 判断Poller是否正在监听channel, 只能在channel所属loop线程中调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasChannel</span><span class="hljs-params">(Channel* channel)</span></span>;<br><br>    <span class="hljs-comment">// pid_t threadId() const &#123; return threadId_; &#125;</span><br>    <span class="hljs-comment">/* 断言当前线程是创建当前对象的线程, 如果不是就终止程序(LOG_FATAL) */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assertInLoopThread</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 判断前线程是否创建当前对象的线程.</span><br><span class="hljs-comment">     * threadId_是创建当前EventLoop对象时, 记录的线程tid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 判断是否有待调用的回调函数(pending functor).</span><br><span class="hljs-comment">     * 由其他线程调用runAt/runAfter/runEvery, 会导致回调入队列待调用.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">callingPendingFunctors</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> callingPendingFunctors_; &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 判断loop线程是否正在处理事件, 执行事件回调.</span><br><span class="hljs-comment">     * loop线程正在遍历,执行激活channels时, eventHandling_会置位; 其余时候, 会清除.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eventHandling</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> eventHandling_; &#125;<br>    <span class="hljs-comment">/* context_ 用于应用程序传参, 由网络库用户定义数据 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setContext</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::any&amp; context)</span></span><br><span class="hljs-function">    </span>&#123; context_ = context; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> boost::any&amp; <span class="hljs-title">getContext</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> context_; &#125;<br>    <span class="hljs-function">boost::any* <span class="hljs-title">getMutableContext</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> &amp;context_; &#125;<br><br>    <span class="hljs-comment">/* 获取当前线程的EventLoop对象指针 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> EventLoop* <span class="hljs-title">getEventLoopOfCurrentThread</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* 终止程序(LOG_FATAL), 当前线程不是创建当前EventLoop对象的线程时,</span><br><span class="hljs-comment">     * 由assertInLoopThread()调用  */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abortNotInLoopThread</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 唤醒所属loop线程, 也是wakeupFd_的事件回调 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// waked up</span><br>    <span class="hljs-comment">/* 处理pending函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPendingFunctors</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 打印激活通道的事件信息, 用于debug */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printActiveChannels</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// DEBUG</span><br><br>    <span class="hljs-keyword">typedef</span> std::vector&lt;Channel*&gt; ChannelList;<br><br>    <span class="hljs-type">bool</span> looping_;                <span class="hljs-comment">/* atomic, true表示loop循环执行中 */</span><br>    std::atomic&lt;<span class="hljs-type">bool</span>&gt; quit_;      <span class="hljs-comment">/* loop循环退出条件 */</span><br>    <span class="hljs-type">bool</span> eventHandling_;          <span class="hljs-comment">/* atomic, true表示loop循环正在处理事件回调 */</span><br>    <span class="hljs-type">bool</span> callingPendingFunctors_; <span class="hljs-comment">/* atomic, true表示loop循环正在调用pending函数 */</span><br>    <span class="hljs-type">int64_t</span> iteration_;           <span class="hljs-comment">/* loop迭代次数 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">pid_t</span> threadId_;                   <span class="hljs-comment">/* 线程id, 对象构造时初始化 */</span><br>    Timestamp pollReturnTime_;               <span class="hljs-comment">/* poll()返回时间点 */</span><br>    std::unique_ptr&lt;Poller&gt; poller_;         <span class="hljs-comment">/* 轮询器, 用于监听事件 */</span><br>    std::unique_ptr&lt;TimerQueue&gt; timerQueue_; <span class="hljs-comment">/* 定时器队列 */</span><br>    <span class="hljs-type">int</span> wakeupFd_;                           <span class="hljs-comment">/* 唤醒loop线程的eventfd */</span><br>    <span class="hljs-comment">/* 用于唤醒loop线程的channel.</span><br><span class="hljs-comment">     * 不像TimerQueue是内部类, 不应该暴露Channel给客户. */</span><br>    std::unique_ptr&lt;Channel&gt; wakeupChannel_;<br>    boost::any context_;            <span class="hljs-comment">/* 用于应用程序通过当前对象传参的变量, 由用户定义数据 */</span><br><br>    <span class="hljs-comment">/* 临时辅助变量 */</span><br>    ChannelList activeChannels_;    <span class="hljs-comment">/* 激活事件的通道列表 */</span><br>    Channel* currentActiveChannel_; <span class="hljs-comment">/* 当前激活的通道, 即正在调用事件回调的通道 */</span><br><br>    <span class="hljs-keyword">mutable</span> MutexLock mutex_;<br>    <span class="hljs-comment">/* 待调用函数列表, 存放不在loop线程的其他线程调用 runAt/runAfter/runEvery, 而要运行的函数 */</span><br>    <span class="hljs-function">std::vector&lt;Functor&gt; pendingFunctors_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>EventLoop不可拷贝，因为与之关联的不仅对象本身，还有线程以及threadlocal数据等资源。其功能主要分为下面这几大类：</p><ol type="1"><li>提供运行循环；</li><li>运行定时任务，一次性 or 周期；</li><li>处理激活通道事件；</li><li>线程安全。</li></ol><ul><li>对于1,loop()提供运行循环，quit()退出循环，iterator()查询循环次数，wakeup()用于唤醒loop线程，handleRead()读取唤醒消息;</li><li>对于2,runInLoop()在loop线程中“立即”运行一次用户任务，runAt()/runAfter()添加一次性定时任务，runEvery()添加周期定时任务，doPendingFunctors()回调所有的pending函数，vectorpendingFunctors_用于排队待处理函数到loop线程执行，queueSize()获取该vector大小；cancel()取消定时任务。</li><li>对于3,updateChannel()/removeChannel()/hasChannel()用于通道更新/移除/判断，vectoractiveChannels_存储当前所有激活的通道，currentActiveChannel_存储当前正在处理的激活通道；</li><li>对于4，isInLoopThread()/assertInLoopThread()判断/断言当前线程是创建当前EventLoop对象的线程，互斥锁mutex_用来做互斥访问需要保护数据。</li></ul><p>值得一提的是，boost::any类型的成员context_用来给用户提供利用EventLoop传数据的方式，相当于C里面的void*，用户可利用boost::any_cast进行转型。</p><h3 id="eventloop构造函数与析构函数">EventLoop构造函数与析构函数</h3><p>构造函数要点：</p><ul><li>检查当前线程是否已经创建了EventLoop对象，遇到错误就终止程序（LOG_FATAL）；</li><li>记住本对象所属线程id（threadId_）；</li></ul><p>析构函数要点：</p><ul><li>清除当前线程EventLoop指针，便于下次再创建EventLoop对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__thread EventLoop* t_loopInThisThread = <span class="hljs-number">0</span>; <span class="hljs-comment">// thread local变量, 指向当前线程创建的EventLoop对象</span><br><br>EventLoop::<span class="hljs-built_in">EventLoop</span>()<br>: <span class="hljs-built_in">looping_</span>(<span class="hljs-literal">false</span>),<br><span class="hljs-built_in">threadId_</span>(CurrentThread::<span class="hljs-built_in">tid</span>()),<br>&#123;<br>    LOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;EventLoop create &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; in thread &quot;</span> &lt;&lt; threadId_;<br>    <span class="hljs-keyword">if</span> (t_loopInThisThread) <span class="hljs-comment">// 当前线程已经包含了EventLoop对象</span><br>    &#123;<br>        LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;Another EventLoop &quot;</span> &lt;&lt; t_loopInThisThread<br>        &lt;&lt; <span class="hljs-string">&quot; exists in this thread &quot;</span> &lt;&lt; threadId_;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 当前线程尚未包含EventLoop对象</span><br>    &#123;<br>        t_loopInThisThread = <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br>EventLoop::~<span class="hljs-built_in">EventLoop</span>()<br>&#123;<br>    LOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; of thread &quot;</span> &lt;&lt; threadId_<br>    &lt;&lt; <span class="hljs-string">&quot; destructs in thread &quot;</span> &lt;&lt; CurrentThread::<span class="hljs-built_in">tid</span>();<br>    t_loopInThisThread = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>再次强调，一个线程只能有一个EventLoop对象。</p></div><p>这里通过threadlocal变量t_loopInThisThread指向创建的EventLoop对象，来确保每个线程只有一个EventLoop对象。同一个线程内，可通过static函数getEventLoopOfCurrentThread，返回该EventLoop对象指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">EventLoop *<span class="hljs-title">EventLoop::getEventLoopOfCurrentThread</span><span class="hljs-params">()</span> <span class="hljs-comment">// static</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t_loopInThisThread;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="assertinloopthread">assertInLoopThread</h3><p>有些成员函数只能在EventLoop对象所在线程调用,EventLoop提供了isInLoopThread()、assertInLoopThread()，分别用于判断、断言当前线程为创建EventLoop对象线程。</p><p>当assertInLoopThread()断言失败时，调用abortNotInLoopThread()终止程序（LOG_FATAL）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::assertInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-comment">// 断言当前线程（tid()）是调用当前EventLoop对象的持有者线程（threadId_）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">abortNotInLoopThread</span>();      <span class="hljs-comment">// 断言失败则终止程序</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventLoop::isInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 判断当前线程是否为当前EventLoop对象的持有者线程</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> threadId_ == CurrentThread::<span class="hljs-built_in">tid</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::abortNotInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-comment">// LOG_FATAL 终止程序</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;EventLoop::abortNotInLoopThread - EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span><br>    &lt;&lt; <span class="hljs-string">&quot; was created in threadId_ = &quot;</span> &lt;&lt; threadId_<br>    &lt;&lt; <span class="hljs-string">&quot;, current thread id = &quot;</span> &lt;&lt; CurrentThread::<span class="hljs-built_in">tid</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="loop循环">loop循环</h3><p>提供运行循环，不断监听事件、处理事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  真正的工作循环.</span><br><span class="hljs-comment">*  获得所有当前激活事件的通道，用Poller-&gt;poll()填到activeChannels_,</span><br><span class="hljs-comment">*  然后调用Channel::handleEvent()处理每个激活通道.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*  最后排队运行所有pending函数, 通常是其他线程通过loop来调用运行用户任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(!looping_);    <span class="hljs-comment">// to avoid reduplicate loop</span><br>    <span class="hljs-built_in">assertInLoopThread</span>(); <span class="hljs-comment">// to avoid new EventLoop() and loop() are not one thread</span><br>    looping_ = <span class="hljs-literal">true</span>;<br>    quit_ = <span class="hljs-literal">false</span>; <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> what if someone calls quit() before loop() ?</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; start looping&quot;</span>;<br><br>    <span class="hljs-keyword">while</span> (!quit_)<br>    &#123;<br>        activeChannels_.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清除激活事件的通道列表</span><br>        <span class="hljs-comment">// 监听所有通道, 可能阻塞线程, 所有激活事件对应通道会填入activeChannels_</span><br>        pollReturnTime_ = poller_-&gt;<span class="hljs-built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);<br>        ++iteration_; <span class="hljs-comment">// 循环次数+1</span><br>        <span class="hljs-keyword">if</span> (Logger::<span class="hljs-built_in">logLevel</span>() &lt;= Logger::TRACE)<br>        &#123;<br>            <span class="hljs-built_in">printActiveChannels</span>();<br>        &#125;<br>        <span class="hljs-comment">// TODO sort channel by priority</span><br>        <span class="hljs-comment">// 处理所有激活事件</span><br><br>        eventHandling_ = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (Channel* channel : activeChannels_)<br>        &#123;<br>            currentActiveChannel_ = channel;<br>            <span class="hljs-comment">// 通过Channel::handleEvent回调事件处理函数</span><br>            currentActiveChannel_-&gt;<span class="hljs-built_in">handleEvent</span>(pollReturnTime_);<br>        &#125;<br>        currentActiveChannel_ = <span class="hljs-literal">NULL</span>;<br>        eventHandling_ = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 运行pending函数, 由其他线程请求调用的用户任务</span><br>        <span class="hljs-built_in">doPendingFunctors</span>();<br>    &#125;<br><br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; stop looping&quot;</span>;<br>    looping_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>loop线程运行事件回调的关键是，用Poller::poll()将激活事件的通道填入通道列表activeChannels_，然后逐一调用每个通道的handleEvent，从而调用为Channel注册的事件回调来处理事件。</p><h3 id="添加更新删除通道">添加、更新、删除通道</h3><p>loop循环用来处理激活事件，用户可以用updateChannel/removeChannel更新/移除 Poller 监听的通道。</p><p>Poller类详见<ahref="https://gstarmin.github.io/2023/07/02/muduo%E5%BA%93-I-O%E5%A4%8D%E7%94%A8/">muduo库-I/O复用</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据具体poller对象, 来更新通道.</span><br><span class="hljs-comment">* 会修改poller对象监听的通道数组.</span><br><span class="hljs-comment">* @note 必须在channel所属loop线程运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    poller_-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据具体poller对象, 来删除通道.</span><br><span class="hljs-comment">* 会删除poller对象监听的通道数组.</span><br><span class="hljs-comment">* @note 如果待移除通道正在激活事件队列, 应该先从激活事件队列中移除</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">if</span> (eventHandling_)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(currentActiveChannel_ == channel ||<br>        std::<span class="hljs-built_in">find</span>(activeChannels_.<span class="hljs-built_in">begin</span>(), activeChannels_.<span class="hljs-built_in">end</span>(), channel) == activeChannels_.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    poller_-&gt;<span class="hljs-built_in">removeChannel</span>(channel);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可用hasChannel来判断Poller是否正在监听channel。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 判断poller是否正在监听通道channel</span><br><span class="hljs-comment">* @note 必须在channel所属loop线程运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventLoop::hasChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">return</span> poller_-&gt;<span class="hljs-built_in">hasChannel</span>(channel);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定时任务">定时任务</h3><p>EventLoop提供了runAt、runAfter、runEvery三个函数，用于在指定时间点、延迟时间、周期性时间运行用户任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能，由用户指定绝对时间</span><br><span class="hljs-comment">* @details 每为定时器队列timerQueue添加一个Timer,</span><br><span class="hljs-comment">* timerQueue内部就会新建一个Timer对象, TimerId就保含了这个对象的唯一标识(序列号)</span><br><span class="hljs-comment">* @param time 时间戳对象, 单位1us</span><br><span class="hljs-comment">* @param cb 超时回调函数. 当前时间超过time代表时间时, EventLoop就会调用cb</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAt</span><span class="hljs-params">(Timestamp time, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户相对时间, 通过runAt实现</span><br><span class="hljs-comment">* @param delay 相对时间, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAfter</span><span class="hljs-params">(<span class="hljs-type">double</span> delay, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), delay))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">runAt</span>(time, std::<span class="hljs-built_in">move</span>(cb));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户指定周期, 重复运行</span><br><span class="hljs-comment">* @param interval 运行周期, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runEvery</span><span class="hljs-params">(<span class="hljs-type">double</span> interval, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), interval))</span></span>;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, interval);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 取消指定定时器</span><br><span class="hljs-comment">* @param timerId Timer id, 唯一对应一个Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::cancel</span><span class="hljs-params">(TimerId timerId)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">cancel</span>(timerId);<br>&#125;<br></code></pre></td></tr></table></figure><p>用户运行一个loop线程，并添加定时任务示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(EventLoop::<span class="hljs-built_in">getEventLoopOfCurrentThread</span>() == <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 断言当前线程没有创建EventLoop对象</span><br>    EventLoop loop; <span class="hljs-comment">// 创建EventLoop对象</span><br>    <span class="hljs-built_in">assert</span>(EventLoop::<span class="hljs-built_in">getEventLoopOfCurrentThread</span>() == &amp;loop); <span class="hljs-comment">// 断言当前线程创建了EventLoop对象</span><br>    loop.<span class="hljs-built_in">runAfter</span>(<span class="hljs-number">1.0</span>, callback); <span class="hljs-comment">// 1sec后运行callback</span><br>    loop.<span class="hljs-built_in">loop</span>(); <span class="hljs-comment">// 启动loop循环</span><br>&#125;<br></code></pre></td></tr></table></figure><h3id="runinloop与queueinloop执行用户任务">runInLoop与queueInLoop执行用户任务</h3><p>同样是运行用户任务函数，runInLoop和queueInLoop都可以被多个线程执行，分为2种情况：1）如果当前线程是创建当前EventLoop对象的线程，那么立即执行用户任务；2）如果不是，那么在loop循环中排队执行（本次循环末尾），实际上这点也是由queueInLoop完成的。</p><p>queueInLoop只做了runInLoop的第2）种情况的工作，也就是只会在loop循环中排队执行用户任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行用户任务</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 可以被多个线程执行：</span><br><span class="hljs-comment">* 如果当前线程是创建当前EventLoop对象的线程，直接执行；</span><br><span class="hljs-comment">* 否则，用户任务函数入队列pendingFunctors_成为一个pending functor，在loop循环中排队执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::runInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInLoopThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">cb</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 排队进入pendingFunctors_，等待执行</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 如果当前线程不是创建当前EventLoop对象的线程 或者正在调用pending functor，</span><br><span class="hljs-comment">* 就唤醒loop线程，避免loop线程阻塞.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::queueInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        pendingFunctors_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || callingPendingFunctors_)<br>    &#123;<br>        <span class="hljs-built_in">wakeup</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要对pendingFunctors_加锁？</strong></p><p>因为queueInLoop可以被多个线程访问，意味着pendingFunctors_也能被多个线程访问，加锁确保线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行用户任务</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 可以被多个线程执行：</span><br><span class="hljs-comment">* 如果当前线程是创建当前EventLoop对象的线程，直接执行；</span><br><span class="hljs-comment">* 否则，用户任务函数入队列pendingFunctors_成为一个pending functor，在loop循环中排队执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::runInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInLoopThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">cb</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 排队进入pendingFunctors_，等待执行</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 如果当前线程不是创建当前EventLoop对象的线程 或者正在调用pending functor，</span><br><span class="hljs-comment">* 就唤醒loop线程，避免loop线程阻塞.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::queueInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        pendingFunctors_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || callingPendingFunctors_)<br>    &#123;<br>        <span class="hljs-built_in">wakeup</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个问题：</p><ul><li>为什么要唤醒 EventLoop？</li><li>wakeup 是怎么实现的?</li><li>pendingFunctors_是如何被消费的?</li></ul><p><strong>为什么要唤醒 EventLoop</strong>:</p><p>我们首先调用了 pendingFunctors_.push_back(cb), 将该函数放在pendingFunctors_中。EventLoop::loop 的每一轮循环在最后会调用doPendingFunctors 依次执行这些函数。</p><p>而 EventLoop 的唤醒是通过 Poller::poll()中调用poll()/epoll_wait()实现的，如果此时该 EventLoop 中迟迟没有事件触发，那么poll()/epoll_wait() 一直就会阻塞。这样会导致，pendingFunctors_中的任务迟迟不能被执行了。</p><p>所以必须要唤醒 EventLoop，从而让pendingFunctors_中的任务尽快被执行。</p><p><strong>wakeup 是怎么实现的</strong>:</p><p>muduo 这里采用了对 eventfd 的读写来实现对 EventLoop 的唤醒。</p><p>在 EventLoop 建立之后，就创建一个 eventfd，并将其可读事件注册到EventLoop 中。</p><p>wakeup() 的过程本质上是对这个 eventfd 进行写操作，以触发该 eventfd的可读事件。这样就起到了唤醒 EventLoop 的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>  sockets::<span class="hljs-built_in">write</span>(wakeupFd_, &amp;one, <span class="hljs-keyword">sizeof</span> one);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多库为了兼容 macOS，往往使用 pipe 来实现这个功能。muduo 采用了eventfd，性能更好些，但代价是不能支持 macOS 了。但是muduo似乎从一开始的定位就只支持 Linux。</p><p><strong>pendingFunctors_是如何被消费的</strong>：</p><p>下面讲下 doPendingFunctors 的实现，muduo是如何处理这些待处理的函数的，以及中间用了哪些优化操作。</p><p>代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::doPendingFunctors</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::vector&lt;Functor&gt; functors;<br><br>  callingPendingFunctors_ = <span class="hljs-literal">true</span>;<br><br>  &#123;<br>  <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>  functors.<span class="hljs-built_in">swap</span>(pendingFunctors_);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; functors.<span class="hljs-built_in">size</span>(); ++i)<br>  &#123;<br>    functors[i]();<br>  &#125;<br>  callingPendingFunctors_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行代码中却有两个非常巧妙的地方。</p><ol type="1"><li>callingPendingFunctors_的作用</li></ol><p>从代码可以看出，如果 callingPendingFunctors_为false，则说明此时尚未开始执行 doPendingFunctors 函数。</p><p>这个有什么作用呢，我们需要结合下 queueInLoop 中，对是否执行 wakeup()的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || callingPendingFunctors_)<br>&#123;<br>  <span class="hljs-built_in">wakeup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还需要结合下 EventLoop 循环的实现，其中 doPendingFunctors() 是每轮循环的最后一步处理。</p><p>如果调用 queueInLoop 和 EventLoop 在同一个线程，且callingPendingFunctors_为 false 时，则说明：此时尚未执行到doPendingFunctors()。</p><p>那么此时即使不用 wakeup，也可以在之后照旧执行 doPendingFunctors()了。</p><p>这么做的好处非常明显，可以减少对 eventfd 的 IO 读写。</p><ol start="2" type="1"><li>锁范围的减小</li></ol><p>在此函数中，有一段特别的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;Functor&gt; functors;<br>&#123;<br>  <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>  functors.<span class="hljs-built_in">swap</span>(pendingFunctors_);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个作用是 pendingFunctors_和 functors 的内容进行交换，实际上就是此时functors 持有了 pendingFunctors_的内容，而pendingFunctors_被清空了。</p><p>这个好处是什么呢？ 如果不这么做，直接遍历 pendingFunctors_,然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop将不可用。</p><p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是 swap那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用queueInLoop。</p><h4 id="eventfd唤醒线程">eventfd唤醒线程</h4><p>eventfd是Linux（Linux2.6以后）特有的，专用于事件通知的机制，类似于管道（pipe）、域套接字（UNIXDomain Socket）。</p><p>创建eventfd 函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-comment">/* 创建一个文件描述符(event fd), 用于事件通知 </span><br><span class="hljs-comment"> *  initval 计数初值</span><br><span class="hljs-comment"> * flags 标志位, 如果没用到可设为0, 也可以用以下选项 按位或 取值: </span><br><span class="hljs-comment"> *     EFD_CLOEXEC 为新建的fd设置close-on-exec(FD_CLOEXEC), 等效于以O_CLOEXEC方式open(2)</span><br><span class="hljs-comment"> *     EFD_NONBLOCK 等效于fcntl(2)设置O_NONBLOCK</span><br><span class="hljs-comment"> *     EFD_SEMAPHORE 将eventfd当信号量一样调用, read 将导致计数-1, write 将导致计数+1; 如果没指定该标志, read将返回8byte计数值, 且计数值归0, write将计数值+指定值.</span><br><span class="hljs-comment"> * 返回 新建的fd, 用于事件通知, 绑定到一个eventfd对象; 失败, 返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eventfd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> initval, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>创建完event fd后，可用read()读取eventfd，如果fd是阻塞的，read可能阻塞线程；如果eventfd设置了EFD_NONBLOCK，read返回EAGIAN错误。直到另外一个线程对eventfd进行write。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为wakeupChannel_设置读回调</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;EventLoop::handleRead, <span class="hljs-keyword">this</span>));<br><span class="hljs-comment">// we are always reading the wakeupfd</span><br><span class="hljs-comment">// 使能wakeupChannel_读事件</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">enableReading</span>();<br></code></pre></td></tr></table></figure><p>eventfd使用示例：</p><p>线程1阻塞等待，线程2唤醒线程1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_FORMAT_MACROS <span class="hljs-comment">// for 跨平台打印</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_func1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> <span class="hljs-comment">/* 等待线程 */</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> wakeupfd = *(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func1 start\n&quot;</span>);<br>    <span class="hljs-type">uint64_t</span> rdata;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">read</span>(wakeupfd, &amp;rdata, <span class="hljs-built_in">sizeof</span>(rdata));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;thread_func1 read error&quot;</span>);<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func1 success to be waked up, rdata = %&quot;</span> PRId64 <span class="hljs-string">&quot;\n&quot;</span>, rdata);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_func2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> <span class="hljs-comment">/* 唤醒线程 */</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> wakeupfd = *(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func2 ready to sleep 1 sec\n&quot;</span>);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">uint64_t</span> wdata = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">write</span>(wakeupfd, &amp;wdata, <span class="hljs-built_in">sizeof</span>(wdata));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;thread_func2 write error&quot;</span>);<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func2 success to wake up another thread, wdata = %&quot;</span> PRId64 <span class="hljs-string">&quot;\n&quot;</span>, wdata);<br>&#125;<br><br><span class="hljs-comment">/* 创建2个线程，thread_func1阻塞等待eventfd，thread_func2唤醒等等eventfd的线程 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> evfd = <span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (evfd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;eventfd error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">pthread_t</span> th1, th2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;th1, <span class="hljs-literal">NULL</span>, thread_func1, (<span class="hljs-type">void</span>*)&amp;evfd);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;th2, <span class="hljs-literal">NULL</span>, thread_func2, (<span class="hljs-type">void</span>*)&amp;evfd);<br>    <span class="hljs-built_in">pthread_join</span>(th1, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(th2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="eventloop使用eventfd唤醒loop线程">EventLoop使用eventfd唤醒loop线程</h3><ol type="1"><li>创建event fd</li></ol><p>构造函数中，wakeupFd_ 初值为createEventfd()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createEventfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> evtfd = ::<span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (evtfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;Failed in eventfd&quot;</span>;<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> evtfd;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>绑定event fd与唤醒通道wakeupChannel_,利用eventfd构造一个Channel对象后，传递给wakeupChannel_，便于Poller监听、事件回调</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为wakeupChannel_设置读回调</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;EventLoop::handleRead, <span class="hljs-keyword">this</span>));<br><span class="hljs-comment">// we are always reading the wakeupfd</span><br><span class="hljs-comment">// 使能wakeupChannel_读事件</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">enableReading</span>();<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>启动loop循环，可能阻塞在poll()/epoll_wait()</li><li>其他线程通过queueInLoop()调用wakeup()，唤醒阻塞的loop线程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 其他线程唤醒等待在wakeupFd_上的线程, 产生读就绪事件.</span><br><span class="hljs-comment">* @note write将添加8byte数据到内部计数器. 被唤醒线程必须调用read读取8byte数据.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = sockets::<span class="hljs-built_in">write</span>(wakeupFd_, &amp;one, <span class="hljs-built_in">sizeof</span>(one));<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">sizeof</span>(one))<br>    &#123;<br>        LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;EventLoop::wakeup() writes &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; bytes instead of 8&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>loop线程被唤醒后，读取event fd</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理wakeupChannel_读事件</span><br><span class="hljs-comment">* @note read wakeupfd_</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = sockets::<span class="hljs-built_in">read</span>(wakeupFd_, &amp;one, <span class="hljs-built_in">sizeof</span>(one));<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">sizeof</span>(one))<br>    &#123;<br>        LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;EventLoop::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; bytes instead of 8&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://www.cnblogs.com/fortunely/p/16127237.html">muduo笔记网络库（五）事件循环EventLoop</a></li><li><a href="https://www.cyhone.com/articles/analysis-of-muduo/">muduo源码剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-TimerQueue定时器队列</title>
    <link href="/2023/07/02/muduo%E5%BA%93-TimerQueue%E5%AE%9A%E6%97%B6%E5%99%A8%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/02/muduo%E5%BA%93-TimerQueue%E5%AE%9A%E6%97%B6%E5%99%A8%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-timerqueue定时器队列">muduo库-TimerQueue定时器队列</h1><p>网络编程中，有一类非常重要的事件，跟IO事件没有直接联系，而是内部产生的事件，即定时事件。</p><p>muduo网络库中的定时功能是如何实现的呢？传统的Reactor通过控制select和poll的等待时间，来实现定时，而Linux中，可以用timerfd来实现。前面讲过，timerfd是Linux特有的定时器，能有效融入select/poll/epoll框架，来做超时事件处理。</p><h2 id="timerfd简要介绍">timerfd简要介绍</h2><p>timerfd的特点是有一个与之关联fd，可绑定Channel，交由Poller监听感兴趣的事件（读、写等）。</p><p>timerfd 3个接口：timerfd_create，timerfd_settime，timerfd_gettime。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/timerfd.h&gt;</span></span><br><br><span class="hljs-comment">/* 创建一个定时器对象, 返回与之关联的fd</span><br><span class="hljs-comment">* clockid 可指定为CLOCK_REALTIME（系统范围时钟）或CLOCK_MONOTONIC（不可设置的时钟，不能手动修改）</span><br><span class="hljs-comment">* flags 可指定为TFD_NONBLOCK（为fd设置O_NONBLOCK），TFD_CLOEXEC（为fd设置close-on-exec）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">timerfd_create</span><span class="hljs-params">(<span class="hljs-type">int</span> clockid, <span class="hljs-type">int</span> flags)</span></span>;<br><br><span class="hljs-comment">/* 启动或停止绑定到fd的定时器</span><br><span class="hljs-comment"> * flags 指定0：启动一个相对定时器，由new_value-&gt;it_value指定相对定时值；TFD_TIMER_ABSTIME启动一个绝对定时器，由new_value-&gt;it_value指定定时值</span><br><span class="hljs-comment"> * old_value 保存旧定时值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">timerfd_settime</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> flags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerspec *new_value, <span class="hljs-keyword">struct</span> itimerspec *old_value)</span></span>;<br><br><span class="hljs-comment">/* 获取fd对应定时器的当前时间值  */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">timerfd_gettime</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> itimerspec *curr_value)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="定时功能相关类">定时功能相关类</h2><p>muduo库中，定时相关功能由3个class实现：TimerID、Timer、TimerQueue。用户可见的只有TimerId。</p><p>Timestamp类是时间戳类，用来保存超时时刻（精确到1us），保存的是UTC时间，即从Unix Epoch（1970-01-01 00:00:00）到指定时间的微秒数。</p><p>Timer类对应一个超时任务，保存了超时时刻Timestamp，超时回调函数，以及超时任务类型（一次or 周期）。</p><p>TimerId类用于保存Timer对象，以及独一无二的id。</p><p>TimerQueue类用于设置所有超时任务（Timer），需要高效组织尚未到期的Timer，快速查找已到期Timer，以及高效添加和删除Timer。TimerQueue用std::set存储，set会对Timer按到期时间先后顺序进行二叉搜索树排序，时间复杂度O(logN)。</p><p>TimerQueue的定时接口并不是直接暴露给库的使用者的，而是通过EventLoop的runAfter和runEvery来运行用户任务的。其中，runAfter延迟固定秒数后运行一次指定用户任务；runEvery延迟固定秒数后运行用户任务，后续以指定周期运行用户任务。</p><p>TimerQueue回调用户代码onTimer()的时序：</p><p><img src="/img/muduo/定时器/定时器时序图.png" /></p><p>时序图里的TimerQueue获取超时Timer（getExpired()）后，User及onTimer()是指用户自定义的超时处理函数，并非库本身的。</p><p>与普通Channel事件一样，超时任务TimerQueue也会使用一个Channel，专门用于绑定timerfd，交由Poller监听，发生可读事件（代表超时）后加入激活通道列表，然后EventLoop::loop()逐个Channel调用对应的回调，从而处理超时事件。</p><div class="admonition note"><p class="admonition-title">note</p><p>一个EventLoop只持有一个TimerQueue对象，而TimerQueue通过std::set持有多个Timer对象，但只会设置一个Channel。</p></div><h2 id="timer类">Timer类</h2><p>Timer类代表一个超时任务，但并不直接绑定Channel。Timer主要包含超时时刻（expiration_），超时回调（callback_），周期时间值（interval_），全局唯一id（sequence_）。</p><p>其声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于定时事件的内部类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Timer</span>(TimerCallback cb, Timestamp when, <span class="hljs-type">double</span> interval)<br>    : <span class="hljs-built_in">callback_</span>(std::<span class="hljs-built_in">move</span>(cb)),<br>    <span class="hljs-built_in">expiration_</span>(when),<br>    <span class="hljs-built_in">interval_</span>(interval),<br>    <span class="hljs-built_in">repeat_</span>(interval &gt; <span class="hljs-number">0.0</span>),<br>    <span class="hljs-built_in">sequence_</span>(s_numCreated_.<span class="hljs-built_in">incrementAndGet</span>())<br>    &#123; &#125;<br>    <span class="hljs-comment">/* 运行超时回调函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">callback_</span>();<br>    &#125;<br>    <span class="hljs-comment">/* 返回超时时刻 */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">expiration</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> expiration_; &#125;<br>    <span class="hljs-comment">/* 周期重复标志 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> repeat_; &#125;<br>    <span class="hljs-comment">/* 全局唯一序列号, 用来表示当前Timer对象 */</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">sequence</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sequence_; &#125;<br>    <span class="hljs-comment">/* 重启定时器, 只对周期Timer有效(repeat_为true) */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">(Timestamp now)</span></span>;<br>    <span class="hljs-comment">/* 当前创建的Timer对象个数, 每新建一个Timer对象就会自增1 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int64_t</span> <span class="hljs-title">numCreated</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> s_numCreated_.<span class="hljs-built_in">get</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> TimerCallback callback_; <span class="hljs-comment">/* 超时回调 */</span><br>    Timestamp expiration_;         <span class="hljs-comment">/* 超时时刻 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> interval_;        <span class="hljs-comment">/* 周期时间, 单位秒, 可用来结合基础时刻expiration_, 计算新的时刻 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> repeat_;            <span class="hljs-comment">/* 重复标记. true: 周期Timer; false: 一次Timer */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> sequence_;       <span class="hljs-comment">/* 全局唯一序列号 */</span><br><br>    <span class="hljs-comment">// global increasing number, atomic. help to identify different Timer</span><br>    <span class="hljs-type">static</span> AtomicInt64 s_numCreated_; <span class="hljs-comment">/* 类变量, 创建Timer对象的个数, 用来实现全局唯一序列号 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每当创建一个新Timer对象时，原子变量s_numCreated_就会自增1，作为全剧唯一序列号sequence_，用来标识该Timer对象。</p><h3 id="周期timer">周期Timer</h3><p>创建Timer时，超时时刻when决定了回调超时事件时间点，而interval决定了Timer是一次性的，还是周期性的。如果是周期性的，会在TimerQueue::reset中，调用Timer::restart，在当前时间点基础上，重启定时器。</p><h3 id="restart函数">restart函数</h3><p>restart重启Timer，根据Timer是否为周期类型，分为两种情况：</p><ol type="1"><li>周期Timer，restart将重置超时时刻expiration_为当前时间 +周期间隔时间；</li><li>非周期Timer，即一次性Timer，将restart将expiration_置为无效时间（默认自UTCEpoch以来的微妙数为0）；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::restart</span><span class="hljs-params">(Timestamp now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (repeat_)<br>    &#123;<br>        expiration_ = <span class="hljs-built_in">addTime</span>(now, interval_);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        expiration_ = Timestamp::<span class="hljs-built_in">invalid</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="timerid类">TimerId类</h2><p>TimerId来主要用来作为Timer的唯一标识，用于取消（canceling）Timer。</p><p>TimerId类声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* An opaque identifier, for canceling Timer.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerId</span> : <span class="hljs-keyword">public</span> muduo::copyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimerId</span>()<br>    : <span class="hljs-built_in">timer_</span>(<span class="hljs-literal">NULL</span>),<br>    <span class="hljs-built_in">sequence_</span>(<span class="hljs-number">0</span>)<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">TimerId</span>(Timer* timer, <span class="hljs-type">int64_t</span> seq)<br>    : <span class="hljs-built_in">timer_</span>(timer),<br>    <span class="hljs-built_in">sequence_</span>(seq)<br>    &#123; &#125;<br><br>    <span class="hljs-comment">// default copy-ctor, dtor and assignment are okay</span><br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerQueue</span>;<br><br><span class="hljs-keyword">private</span>:<br>    Timer* timer_;<br>    <span class="hljs-type">int64_t</span> sequence_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：TimerId并不直接生成Timer序列号sequence_，这是由Timer来生成的，通过构造函数传递给TimerId。而生成Timer标识的方式，在Timer类介绍中也提到过，只需要创建一个Timer对象即可，然后通过Timer::sequence()方法就可以取得该序列号。</p><h2 id="timerqueue类">TimerQueue类</h2><p>定时器队列TimerQueue是定时功能的核心，由所在EventLoop持有，绑定一个Channel，同时维护多个定时任务（Timer）。为用户（EventLoop）提供添加定时器（addTimer）、取消定时器（cancel）接口。</p><p><strong>同样是定时，TimerQueue与Timer有什么区别？</strong></p><p>TimerQueue包含2个Timer集合：</p><ol type="1"><li>timers_定时器集合：包含用户添加的所有Timer对象，std::set会用AVL搜索树，对集合元素按时间戳（Timestamp）从小到大顺序；</li><li>activeTimers_激活定时器集合：包含激活的Timer对象，与timers_包含的Timer对象相同，个数也相同，std::set会根据Timer*指针大小，对元素进行排序；</li><li>cancelingTimers_取消定时器集合：包含所有取消的Timer对象，与activeTimers_相对。</li></ol><p>注意：timers_和activeTimers_的类型并不相同，只是包含的Timer*相同。cancelingTimers_和activeTimers_的类型相同。</p><p>这也是TimerQueue并非Timer的原因，<strong>TimerQueue是一个Timer集合，根据其时间戳大小进行排序，更像是一个队列，先到期的先触发超时事件。因此，可称为Timer队列，即TimerQueue</strong>。</p><p>调用TimerQueue::addTimer的，只有EventLoop中这3个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能，由用户指定绝对时间</span><br><span class="hljs-comment">* @details 每为定时器队列timerQueue添加一个Timer,</span><br><span class="hljs-comment">* timerQueue内部就会新建一个Timer对象, TimerId就保含了这个对象的唯一标识(序列号)</span><br><span class="hljs-comment">* @param time 时间戳对象, 单位1us</span><br><span class="hljs-comment">* @param cb 超时回调函数. 当前时间超过time代表时间时, EventLoop就会调用cb</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAt</span><span class="hljs-params">(Timestamp time, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户相对时间, 通过runAt实现</span><br><span class="hljs-comment">* @param delay 相对时间, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAfter</span><span class="hljs-params">(<span class="hljs-type">double</span> delay, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), delay))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">runAt</span>(time, std::<span class="hljs-built_in">move</span>(cb));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户指定周期, 重复运行</span><br><span class="hljs-comment">* @param interval 运行周期, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runEvery</span><span class="hljs-params">(<span class="hljs-type">double</span> interval, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), interval))</span></span>;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, interval);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是TimerQueue中，3个集合相关的类型及成员定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;<br><span class="hljs-keyword">typedef</span> std::set&lt;Entry&gt; TimerList;<br><span class="hljs-keyword">typedef</span> std::pair&lt;Timer*, <span class="hljs-type">int64_t</span>&gt; ActiveTimer;<br><span class="hljs-keyword">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;<br><br><span class="hljs-comment">// Timer list sorted by expiration</span><br><span class="hljs-comment">/* 用户添加的所有Timer对象集合</span><br><span class="hljs-comment"> * 需要为set元素比较实现operator&lt; */</span><br>TimerList timers_;<br><br><span class="hljs-comment">// for cancel()</span><br>ActiveTimerSet activeTimers_;<br><span class="hljs-type">bool</span> callingExpiredTimers_; <span class="hljs-comment">/* atomic */</span><br>ActiveTimerSet cancelingTimers_;<br></code></pre></td></tr></table></figure><p>下面是TimerQueue中，3个集合相关的类型及成员定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;<br><span class="hljs-keyword">typedef</span> std::set&lt;Entry&gt; TimerList;<br><span class="hljs-keyword">typedef</span> std::pair&lt;Timer*, <span class="hljs-type">int64_t</span>&gt; ActiveTimer;<br><span class="hljs-keyword">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;<br><br><span class="hljs-comment">// Timer list sorted by expiration</span><br><span class="hljs-comment">/* 用户添加的所有Timer对象集合</span><br><span class="hljs-comment"> * 需要为set元素比较实现operator&lt; */</span><br>TimerList timers_;<br><br><span class="hljs-comment">// for cancel()</span><br>ActiveTimerSet activeTimers_;<br><span class="hljs-type">bool</span> callingExpiredTimers_; <span class="hljs-comment">/* atomic */</span><br>ActiveTimerSet cancelingTimers_;<br></code></pre></td></tr></table></figure><h3 id="timerqueue声明">TimerQueue声明</h3><p>除了前面提到的3个集合相关类型及成员，其他成员函数和变量声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时器队列.</span><br><span class="hljs-comment">* 不能保证回调能及时调用.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 只能在所在loop线程中运行, 因此线程安全是非必须的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerQueue</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TimerQueue</span><span class="hljs-params">(EventLoop* loop)</span></span>;<br>    ~<span class="hljs-built_in">TimerQueue</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 添加一个定时器.</span><br><span class="hljs-comment">     * 运行到指定时间， 调度相应的回调函数.</span><br><span class="hljs-comment">     * 如果interval参数 &gt; 0.0, 就周期重复运行.</span><br><span class="hljs-comment">     * 必须线程安全: 可能会由其他线程调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">addTimer</span><span class="hljs-params">(TimerCallback cb, Timestamp when, <span class="hljs-type">double</span> interval)</span></span>;<br>    <span class="hljs-comment">/* 取消指定TimerId的定时器 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">(TimerId)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTimerInLoop</span><span class="hljs-params">(Timer* timer)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancelInLoop</span><span class="hljs-params">(TimerId timerId)</span></span>;<br>    <span class="hljs-comment">// called when timerfd alarms</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// move out all expired timers</span><br>    <span class="hljs-function">std::vector&lt;Entry&gt; <span class="hljs-title">getExpired</span><span class="hljs-params">(Timestamp now)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(Timer* timer)</span></span>;<br><br>    EventLoop* loop_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> timerfd_;<br>    Channel timerfdChannel_; <span class="hljs-comment">// watch readable event of timerfd</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerQueue所属EventLoop对象，通过一个EventLoop*来传递，注意这是一个rawpointer，而非smartpointer。EventLoop对象与TimerQueue对象生命周期相同，而且只会通过EventLoop对象来调用TimerQueue对象方法，因此不存在与之相关的内存泄漏或非法访问的问题。</p><h3 id="timerqueue构造函数">TimerQueue构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TimerQueue::<span class="hljs-built_in">TimerQueue</span>(EventLoop *loop)<br>: <span class="hljs-built_in">loop_</span>(loop),<br><span class="hljs-built_in">timerfd_</span>(<span class="hljs-built_in">createTimerfd</span>()),<br><span class="hljs-built_in">timerfdChannel_</span>(loop, timerfd_),<br><span class="hljs-built_in">timers_</span>(),<br><span class="hljs-built_in">callingExpiredTimers_</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>    timerfdChannel_.<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">// we are always reading the timerfd, we disrm it with timerfd_settime.</span><br>    timerfdChannel_.<span class="hljs-built_in">enableReading</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>构造TimerQueue对象时，就会绑定TimerQueue所属EventLoop，即创建TimerQueue的EventLoop对象。另外，调用Channel::enableReading()，会将通道事件加入Poller的监听通道列表中。</p><p>交给Poller监听的timerfd，是由createTimerfd创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createTimerfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// create timers that notify via fd</span><br>    <span class="hljs-type">int</span> timerfd = ::<span class="hljs-built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (timerfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in timerfd_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> timerfd;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造TimerQueue对象时，就会绑定TimerQueue所属EventLoop，即创建TimerQueue的EventLoop对象。另外，调用Channel::enableReading()，会将通道事件加入Poller的监听通道列表中。</p><p>交给Poller监听的timerfd，是由createTimerfd创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createTimerfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// create timers that notify via fd</span><br>    <span class="hljs-type">int</span> timerfd = ::<span class="hljs-built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (timerfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in timerfd_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> timerfd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerqueue构造函数-1">TimerQueue构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TimerQueue::<span class="hljs-built_in">TimerQueue</span>(EventLoop *loop)<br>: <span class="hljs-built_in">loop_</span>(loop),<br><span class="hljs-built_in">timerfd_</span>(<span class="hljs-built_in">createTimerfd</span>()),<br><span class="hljs-built_in">timerfdChannel_</span>(loop, timerfd_),<br><span class="hljs-built_in">timers_</span>(),<br><span class="hljs-built_in">callingExpiredTimers_</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>    timerfdChannel_.<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">// we are always reading the timerfd, we disrm it with timerfd_settime.</span><br>    timerfdChannel_.<span class="hljs-built_in">enableReading</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>构造TimerQueue对象时，就会绑定TimerQueue所属EventLoop，即创建TimerQueue的EventLoop对象。另外，调用Channel::enableReading()，会将通道事件加入Poller的监听通道列表中。</p><p>交给Poller监听的timerfd，是由createTimerfd创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createTimerfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// create timers that notify via fd</span><br>    <span class="hljs-type">int</span> timerfd = ::<span class="hljs-built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (timerfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in timerfd_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> timerfd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerqueue析构">TimerQueue析构</h3><p>析构有2点需要注意：</p><ol type="1"><li>在remove绑定的通道前，要先disableAll停止监听所有通道事件；</li><li>timers_中Timer对象是在TimerQueue::addTimer中new出来的，需要手动delete；</li></ol><!-- 另外，对注释"do not remove channel, since we're in EventLoop::dtor();"并不明白是何用意。 --><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TimerQueue::~<span class="hljs-built_in">TimerQueue</span>()<br>&#123;<br>    <span class="hljs-comment">// 关闭所有(通道)事件, Poller不再监听该通道</span><br>    timerfdChannel_.<span class="hljs-built_in">disableAll</span>();<br>    <span class="hljs-comment">// 如果正在处理该通道, 会从激活的通道列表中移除, 同时Poller不再监听该通道</span><br>    timerfdChannel_.<span class="hljs-built_in">remove</span>();<br>    <span class="hljs-comment">// 关闭通道对应timerfd</span><br>    ::<span class="hljs-built_in">close</span>(timerfd_);<br><br>    <span class="hljs-comment">// do not remove channel, since we&#x27;re in EventLoop::dtor();</span><br><br>    <span class="hljs-comment">// TimerQueue::addTimer中new出来的Timer对象, 需要手动delete</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; timer : timers_)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> timer.second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerqueue重要接口">TimerQueue重要接口</h3><h4 id="addtimer-添加定时器">addTimer 添加定时器</h4><p>注意到addTimer会在构造一个Timer对象后，将其添加到timers_的工作转交给addTimerInLoop完成了。这是为什么？</p><p>因为调用EventLoop::runAt/runEvery的线程，可能并非TimerQueue的loop线程，而修改TimerQueue数据成员时，必须在所属loop线程中进行，因此需要通过loop_-&gt;runInLoop将工作转交给所属loop线程。runInLoop：如果当前线程是所属loop线程，则直接运行函数；如果不是，就排队到所属loop线程末尾，等待运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加一个定时器.</span><br><span class="hljs-comment">* @details 运行到指定时间点when, 调度相应的回调函数cb.</span><br><span class="hljs-comment">* 如果interval参数 &gt; 0.0, 就周期重复运行.</span><br><span class="hljs-comment">* 可能会由其他线程调用, 需要让对TimerQueue数据成员有修改的部分, 在所属loop所在线程中运行.</span><br><span class="hljs-comment">* @param cb 超时回调函数</span><br><span class="hljs-comment">* @param when 触发超时的时间点</span><br><span class="hljs-comment">* @param interval 循环周期. &gt; 0.0 代表周期定时器; 否则, 代表一次性定时器</span><br><span class="hljs-comment">* @return 返回添加的Timer对应TimerId, 用来标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">TimerQueue::addTimer</span><span class="hljs-params">(TimerCallback cb, Timestamp when, <span class="hljs-type">double</span> interval)</span></span><br><span class="hljs-function"></span>&#123;<br>    Timer* timer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Timer</span>(std::<span class="hljs-built_in">move</span>(cb), when, interval);<br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="hljs-keyword">this</span>, timer)); <span class="hljs-comment">// 转交所属loop线程运行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">TimerId</span>(timer, timer-&gt;<span class="hljs-built_in">sequence</span>());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在loop线程中添加一个定时器.</span><br><span class="hljs-comment">* @details addTimerInLoop 必须在所属loop线程中运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::addTimerInLoop</span><span class="hljs-params">(Timer *timer)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-type">bool</span> earliestChanged = <span class="hljs-built_in">insert</span>(timer);<br><br>    <span class="hljs-keyword">if</span> (earliestChanged)<br>    &#123;<br>        <span class="hljs-built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="hljs-built_in">expiration</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>addTimerInLoop的主要工作由2个函数来完成：insert，resetTimerfd。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 插入一个timer指向的定时器</span><br><span class="hljs-comment">* @details timers_是std::set&lt;std::pair&lt;Timestamp, Timer*&gt;&gt;类型, 容器会自动对元素进行排序,</span><br><span class="hljs-comment">* 默认先按pair.first即Timestamp进行排序, 其次是pair.second(.first相同情况下才比较second),</span><br><span class="hljs-comment">* 这样第一个元素就是时间戳最小的元素.</span><br><span class="hljs-comment">* @return 定时器timer当前是否已经超时</span><br><span class="hljs-comment">* - true timers_为空或已经超时</span><br><span class="hljs-comment">* - false timers_非空, 且最近的一个定时器尚未超时</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TimerQueue::insert</span><span class="hljs-params">(Timer *timer)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">bool</span> earliestChanged = <span class="hljs-literal">false</span>;<br>    Timestamp when = timer-&gt;<span class="hljs-built_in">expiration</span>(); <span class="hljs-comment">// 超时时刻</span><br>    TimerList::iterator it = timers_.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">if</span> (it == timers_.<span class="hljs-built_in">end</span>() || when &lt; it-&gt;first)<br>    &#123; <span class="hljs-comment">// 定时器集合为空 或者 新添加的timer已经超时(因为it指向的Timer超时时刻是距离当前最近的)</span><br>        earliestChanged = <span class="hljs-literal">true</span>; <span class="hljs-comment">// timer已经超时</span><br>    &#125;<br><br>    <span class="hljs-comment">// 同时往timers_和activeTimers_集合中, 添加timer</span><br>    <span class="hljs-comment">// 注意: timers_和activeTimers_元素类型不同, 但所包含的Timer是相同的, 个数也相同</span><br><br>    &#123; <span class="hljs-comment">// ensure insert new timer to timers_ successfully</span><br>        std::pair&lt;TimerList::iterator, <span class="hljs-type">bool</span>&gt; result<br>        = timers_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Entry</span>(when, timer));<br>        <span class="hljs-built_in">assert</span>(result.second); (<span class="hljs-type">void</span>)result;<br>    &#125;<br><br>    &#123; <span class="hljs-comment">// ensure insert new timer to activeTimers_ successfully</span><br>        std::pair&lt;ActiveTimerSet::iterator, <span class="hljs-type">bool</span>&gt; result<br>        = activeTimers_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">ActiveTimer</span>(timer, timer-&gt;<span class="hljs-built_in">sequence</span>()));<br>        <span class="hljs-built_in">assert</span>(result.second); (<span class="hljs-type">void</span>)result;<br>    &#125;<br><br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> earliestChanged;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cancel-取消定时器">cancel 取消定时器</h3><p>一个已超时的定时器，会通过TimerQueue::getExpired自动清除，但一个尚未到期的定时器如何取消？</p><p>可以通过调用TimerQueue::cancel。类似于addTimer，cancel也可能在别的线程被调用，因此需要将其转交给cancelInLoop执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 取消一个定时器, 函数可能在别的线程调用</span><br><span class="hljs-comment">* @param timerId 每个定时器都有一个唯一的TimerId作为标识</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::cancel</span><span class="hljs-params">(TimerId timerId)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="hljs-keyword">this</span>, timerId));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop线程中, 取消一个定时器</span><br><span class="hljs-comment">* @details 同时擦出timers_, activeTimers_中包含的Timer对象, timerId用来查找该Timer对象.</span><br><span class="hljs-comment">* @param timerId 待取消Timer的唯一Id标识</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::cancelInLoop</span><span class="hljs-params">(TimerId timerId)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>(); <span class="hljs-comment">// 确保当前线程是所属loop线程</span><br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-function">ActiveTimer <span class="hljs-title">timer</span><span class="hljs-params">(timerId.timer_, timerId.sequence_)</span></span>;<br>    ActiveTimerSet::const_iterator it = activeTimers_.<span class="hljs-built_in">find</span>(timer);<br>    <span class="hljs-keyword">if</span> (it != activeTimers_.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        <span class="hljs-comment">// 注意timers_和activeTimers_的Timer指针指向相同对象, 只能delete一次</span><br>        <span class="hljs-type">size_t</span> n = timers_.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">Entry</span>(it-&gt;first-&gt;<span class="hljs-built_in">expiration</span>(), it-&gt;first));<br>        <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>); (<span class="hljs-type">void</span>)n;<br>        <span class="hljs-keyword">delete</span> it-&gt;first; <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> no delete please</span><br>        activeTimers_.<span class="hljs-built_in">erase</span>(it);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (callingExpiredTimers_)<br>    &#123; <span class="hljs-comment">// 如果正在处理超时定时器</span><br>        cancelingTimers_.<span class="hljs-built_in">insert</span>(timer);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3id="handleread处理timerqueue上所有超时任务">handleRead处理TimerQueue上所有超时任务</h3><p>handleRead有几个要点：</p><ul><li>必须在所在loop线程运行；</li><li>可能不止一个定时任务超时，可用getExpired()获取；</li><li>所有超时任务执行完后，重置周期定时任务，释放一次性定时任务；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理读事件, 只能是所属loop线程调用</span><br><span class="hljs-comment">* @details 当PollPoller监听到超时发生时, 将channel加入激活通道列表, loop中回调</span><br><span class="hljs-comment">* 事件处理函数, TimerQueue::handleRead.</span><br><span class="hljs-comment">* 发生超时事件时, 可能会有多个超时任务超时, 需要通过getExpired一次性全部获取, 然后逐个执行回调.</span><br><span class="hljs-comment">* @note timerfd只会发生读事件.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-function">Timestamp <span class="hljs-title">now</span><span class="hljs-params">(Timestamp::now())</span></span>;<br>    <span class="hljs-built_in">readTimerfd</span>(timerfd_, now);<br><br>    std::vector&lt;Entry&gt; expired = <span class="hljs-built_in">getExpired</span>(now); <span class="hljs-comment">// 获取所有超时任务</span><br><br>    <span class="hljs-comment">// 正在调用超时任务回调时, 先清除取消的超时任务cancelingTimers_, 再逐个执行超时回调.</span><br>    <span class="hljs-comment">// 可由getExpired()获取的所有超时任务.</span><br>    callingExpiredTimers_ = <span class="hljs-literal">true</span>;<br>    cancelingTimers_.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">// safe to callback outside critical section</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; it : expired)<br>    &#123;<br>        it.second-&gt;<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 通过Timer::run()回调超时处理函数</span><br>    &#125;<br>    callingExpiredTimers_ = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 重置所有已超时任务</span><br>    <span class="hljs-built_in">reset</span>(expired, now);<br>&#125;<br></code></pre></td></tr></table></figure><p>getExpired以参数时间点now为界限，查找settimers_中所有超时定时任务（Timer）。set会对timers_元素进行排序，std::set::lower_bound()会找到第一个时间点&lt; now时间点的定时任务。</p><p>getExpired调用reset重置所有超时的周期定时任务，释放超时的一次性任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时任务超时时, 从set timers_中取出所有的超时任务, 以vector形式返回给调用者</span><br><span class="hljs-comment">* @note 注意从set timers_要和从set activeTimers_同步取出超时任务, 两者保留的定时任务是相同的</span><br><span class="hljs-comment">* @param now 当前时间点, 用来判断从set中的定时器是否超时</span><br><span class="hljs-comment">* @return set timers_中超时的定时器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">std::vector&lt;TimerQueue::Entry&gt; <span class="hljs-title">TimerQueue::getExpired</span><span class="hljs-params">(Timestamp now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    std::vector&lt;Entry&gt; expired;<br>    <span class="hljs-function">Entry <span class="hljs-title">sentry</span><span class="hljs-params">(now, <span class="hljs-keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;<br>    <span class="hljs-comment">// end.key &gt;= sentry.key, Entry.key is pair&lt;Timestamp, Timer*&gt;</span><br>    <span class="hljs-comment">// in that end.key.second &lt; sentry.key.second(MAX PTR)</span><br>    <span class="hljs-comment">// =&gt; end.key == sentry.key is impossible</span><br>    <span class="hljs-comment">// =&gt; end.key &gt; sentry.key</span><br>    TimerList::iterator end = timers_.<span class="hljs-built_in">lower_bound</span>(sentry);<br>    <span class="hljs-built_in">assert</span>(end == timers_.<span class="hljs-built_in">end</span>() || now &lt; end-&gt;first);<br>    std::<span class="hljs-built_in">copy</span>(timers_.<span class="hljs-built_in">begin</span>(), end, <span class="hljs-built_in">back_inserter</span>(expired));<br>    timers_.<span class="hljs-built_in">erase</span>(timers_.<span class="hljs-built_in">begin</span>(), end);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; it : expired)<br>    &#123;<br>        <span class="hljs-function">ActiveTimer <span class="hljs-title">timer</span><span class="hljs-params">(it.second, it.second-&gt;sequence())</span></span>;<br>        <span class="hljs-type">size_t</span> n = activeTimers_.<span class="hljs-built_in">erase</span>(timer);<br>        <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>); (<span class="hljs-type">void</span>)n;<br>    &#125;<br><br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> expired;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据指定时间now重置所有超时任务, 只对周期定时任务有效</span><br><span class="hljs-comment">* @param expired 所有超时任务</span><br><span class="hljs-comment">* @param now 指定的reset基准时间点, 新的超时时间点以此为基准</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::reset</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Entry&gt; &amp;expired, Timestamp now)</span></span><br><span class="hljs-function"></span>&#123;<br>    Timestamp nextExpire;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; it : expired)<br>    &#123;<br>        <span class="hljs-function">ActiveTimer <span class="hljs-title">timer</span><span class="hljs-params">(it.second, it.second-&gt;sequence())</span></span>;<br>        <span class="hljs-comment">// 只重置周期定时任务和没有取消的定时任务, 释放一次性超时的定时任务</span><br>        <span class="hljs-keyword">if</span> (it.second-&gt;<span class="hljs-built_in">repeat</span>()<br>        &amp;&amp; cancelingTimers_.<span class="hljs-built_in">find</span>(timer) == cancelingTimers_.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            it.second-&gt;<span class="hljs-built_in">restart</span>(now);<br>            <span class="hljs-built_in">insert</span>(it.second);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// FIXME move to a free list</span><br>            <span class="hljs-keyword">delete</span> it.second; <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> no delete please</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据最近的尚未达到的超时任务, 重置timerfd下一次超时时间</span><br>    <span class="hljs-keyword">if</span> (!timers_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        nextExpire = timers_.<span class="hljs-built_in">begin</span>()-&gt;second-&gt;<span class="hljs-built_in">expiration</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextExpire.<span class="hljs-built_in">valid</span>())<br>    &#123;<br>        <span class="hljs-built_in">resetTimerfd</span>(timerfd_, nextExpire);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/16001655.html">muduo笔记网络库（四）TimerQueue定时器队列</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-事件通道Channel</title>
    <link href="/2023/07/02/muduo%E5%BA%93-%E4%BA%8B%E4%BB%B6%E9%80%9A%E9%81%93Channel/"/>
    <url>/2023/07/02/muduo%E5%BA%93-%E4%BA%8B%E4%BB%B6%E9%80%9A%E9%81%93Channel/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-事件通道channel">muduo库-事件通道Channel</h1><p>之前说过，Poller的存在是为了监听事件，那么具体监听什么事件呢？</p><p>这就需要用到Channel类，它是muduo库负责注册读写事件的类，并<strong>保存了fd读写事件发生时调用的回调函数，如果poll/epoll有读写事件发生则将这些事件添加到对应的通道中。一个通道对应唯一EventLoop，一个EventLoop可以有多个通道</strong>。</p><p>一个通道对应唯一EventLoop，一个EventLoop可以有多个通道。</p><p><strong>一个Channel对象绑定了一个fd（文件描述符），可以用来监听发生在fd上的事件，事件包括空事件（不监听）、可读事件、写完成事件</strong>。当fd上被监听事件就绪时，对应Channel对象就会被Poller放入<strong>激活队列（activeChannels_）</strong>，进而在loop循环中调用封装在Channel的相应回调来处理事件。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>Channel类不负责fd的生存期，fd的生存期是有socket决定的，断开连接关闭描述符。</p></div><p>Channel可以通过EventLoop，向Poller更新自己关心的（监听）事件（通过mapPoller::channels_存储）。具体来说，对于PollPoller对象，会同步更新（poll）传给内核的poll事件数组pollfds_；对于EPollPoller对象，会同步更新（epoll）传递给内核的epoll事件数组events_；</p><p>可以这样理解，poll/epoll监听的是fd（上指定的事件pollfd.events），Poller监听的是Channel对象（上指定的事件events_），当监听到事件就绪时，将对应通道加入激活通道队列，在EventLoop的loop循环中依次调用Channel中注册的事件回调。</p><p>EventLoop、Poller、Channel这3个类构成了Reactor模式的核心，其时序关系如下图：</p><p><img src="/img/muduo/事件通道channel/时序图.png" /></p><h2 id="channel-类">Channel 类</h2><p>每个Channel对象从始至终只负责一个文件描述符（fd）的IO事件分发，但<strong>不拥有fd，也不会在析构时关闭fd</strong>。而是由诸如TcpConnection、Acceptor、EventLoop等，这样需要监听指定文件描述符上事件的类，将fd通过构造函数传递给Channel。</p><p>Channel会把不同的IO事件分发为不同的回调，如ReadCallback、WriteCallback，回调对象类型用std::function&lt;&gt;表示，用来定义某个可调用类型。</p><p>事件回调类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; EventCallback;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(Timestamp)&gt; ReadEventCallback;<br></code></pre></td></tr></table></figure><p>Channel成员函数主要包括：</p><ol type="1"><li>设置事件处理的回调函数setCallback（如setReadCallback）；</li><li>使能fd关心的事件events_，可调用enable（如enableReading），该fd及关心的事件会注册到Poller中进行监听；</li><li>关闭fd关心的事件events_，可调用disable*（如disableReading），会更新该fd在Poller中监听的事件；</li><li>关闭fd关心的所有事件events_，可调用disableAll，会更新该fd在Poller中监听的事件；</li><li>删除对fd的监听，会将其从Poller的ChannelMap中移除；</li><li>Poller监听到Channel事件被激活时，将其加入到激活列表，在EventLoop中回调handleEvent。</li></ol><h2 id="channel类内部结构">Channel类内部结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Channel绑定一个fd, 用于设置fd上要监听的事件, 以及相应的回调函数.</span><br><span class="hljs-comment">* Poller监听到有通道绑定的事件发生, 就会将其加入激活的通道列表,</span><br><span class="hljs-comment">* 然后在EventLoop::loop()中调用该Channel对应事件注册的回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span> : <span class="hljs-keyword">private</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; EventCallback; <span class="hljs-comment">// 除了读事件, 用于其他事件(如写/关闭/错误)回调类型</span><br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(Timestamp)&gt; ReadEventCallback; <span class="hljs-comment">// 读事件回调类型</span><br><br>    <span class="hljs-built_in">Channel</span>(EventLoop* loop, <span class="hljs-type">int</span> fd__);<br>    ~<span class="hljs-built_in">Channel</span>()<br><br>    <span class="hljs-comment">/* 处理事件, 监听事件激活时, 由EventLoop::loop调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(Timestamp recevieTime)</span></span>;<br>    <span class="hljs-comment">/* 设置事件回调，由Channel对象持有者配置Channel事件回调时调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadCallback</span><span class="hljs-params">(ReadEventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; readCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCallback</span><span class="hljs-params">(EventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; writeCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(EventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; closeCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setErrorCallback</span><span class="hljs-params">(EventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; errorCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br><br>    <span class="hljs-comment">/* 将shared_ptr管理的对象系到本地weak_ptr管理的tie_, 可用于保存TcpConnection指针 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tie</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">void</span>&gt;&amp;)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> fd_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">events</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_revents</span><span class="hljs-params">(<span class="hljs-type">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class="hljs-comment">// used by poller</span><br><span class="hljs-comment">//    int revents() const &#123; return revents_; &#125;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNoneEvent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_ == kNoneEvent; &#125;<br><br>    <span class="hljs-comment">/* 使能/禁用 监听 可读/可写事件, 会影响Poller监听的通道列表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableReading</span><span class="hljs-params">()</span> </span>&#123; events_ |= kReadEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableReading</span><span class="hljs-params">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableWriting</span><span class="hljs-params">()</span> </span>&#123; events_ |= kWriteEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableWriting</span><span class="hljs-params">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableAll</span><span class="hljs-params">()</span> </span>&#123; events_ = kNoneEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-comment">/* 判断是否请求监听 可写事件 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isWriting</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_ &amp; kWriteEvent; &#125;<br>    <span class="hljs-comment">/* 判断是否请求监听 可读事件 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isReading</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_ &amp; kReadEvent; &#125;<br><br>    <span class="hljs-comment">// for Poller</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> index_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_index</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123; index_ = idx; &#125;<br><br>    <span class="hljs-comment">// for debug</span><br>    <span class="hljs-function">string <span class="hljs-title">reventsToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">string <span class="hljs-title">eventsToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doNotLogHup</span><span class="hljs-params">()</span> </span>&#123; logHup_ = <span class="hljs-literal">false</span>; &#125;<br><br>    <span class="hljs-function">EventLoop* <span class="hljs-title">ownerLoop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> loop_; &#125;<br>    <span class="hljs-comment">/* 从EventLoop中移除当前通道.</span><br><span class="hljs-comment">     * 建议在移除前禁用所有事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* 将fd对应事件转化为字符串 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> string <span class="hljs-title">eventsToString</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ev)</span></span>;<br>    <span class="hljs-comment">/* update()将调用EventLoop::updateChannel更新监听的通道 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 根据不同的事件源激活不同的回调函数，来处理事件 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNoneEvent;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kReadEvent;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kWriteEvent;<br><br>    EventLoop* loop_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> fd_; <span class="hljs-comment">// file descriptor</span><br>    <span class="hljs-type">int</span> events_;   <span class="hljs-comment">// request events, set by user</span><br>    <span class="hljs-type">int</span> revents_;  <span class="hljs-comment">// returned events, current active events, set by EventLoop/Poller</span><br>    <span class="hljs-comment">// used by Poller</span><br>    <span class="hljs-comment">// PollPoller: index of poll fds array mapped to fd_</span><br>    <span class="hljs-comment">// EPollPoller: operation type for fd: kNew, kAdded, kDeleted</span><br>    <span class="hljs-type">int</span> index_;<br>    <span class="hljs-type">bool</span> logHup_;<br>    <span class="hljs-comment">/* 使用weak_ptr指向shared_ptr所指对象, 防止循环引用. 通常是生命周期不确定的对象, 如TcpConnection */</span><br>    std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; tie_;<br>    <span class="hljs-type">bool</span> tied_; <span class="hljs-comment">/* weak_ptr tie_绑定对象的标志 */</span><br>    <span class="hljs-type">bool</span> eventHandling_; <span class="hljs-comment">/* 正在处理事件的标志 */</span><br>    <span class="hljs-type">bool</span> addedToLoop_;   <span class="hljs-comment">/* 加入到loop中, 被监听/处理的标志 */</span><br>    ReadEventCallback readCallback_; <span class="hljs-comment">/* 可读事件回调 */</span><br>    EventCallback writeCallback_;    <span class="hljs-comment">/* 可写事件回调 */</span><br>    EventCallback closeCallback_;    <span class="hljs-comment">/* 关闭事件回调 */</span><br>    EventCallback errorCallback_;    <span class="hljs-comment">/* 错误事件回调 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="handleevent-处理事件">handleEvent 处理事件</h3><p>处理激活的Channel事件，由Poller更新激活的Channel列表，EventLoop::loop()根据激活Channel列表，逐个执行Channel中已注册好的相应回调。实际事件处理工作，由handleEventWithGuard完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理激活的Channel事件</span><br><span class="hljs-comment">* @details Poller中监听到激活事件的Channel后, 将其加入激活Channel列表,</span><br><span class="hljs-comment">* EventLoop::loop根据激活Channel回调对应事件处理函数.</span><br><span class="hljs-comment">* @param recevieTime Poller中调用epoll_wait/poll返回后的时间. 用户可能需要该参数.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEvent</span><span class="hljs-params">(Timestamp recevieTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * shared_ptr通过RAII方式管理对象资源guard</span><br><span class="hljs-comment">     * weak_ptr::lock可将weak_ptr提升为shared_ptr, 引用计数+1</span><br><span class="hljs-comment">     */</span><br>    std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard;<br>    <span class="hljs-keyword">if</span> (tied_)<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 为什么使用 tie?</span><br><span class="hljs-comment">         * 确保在执行事件处理动作时, 所需的对象不会被释放, 但又不能用shared_ptr,</span><br><span class="hljs-comment">         * 否则可能导致循环引用. 最好使用weak_ptr, 然后lock提升为shared_ptr, 这样更安全.</span><br><span class="hljs-comment">         */</span><br>        guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>        &#123;<br>            <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="handleeventwithguard-识别事件并回调">handleEventWithGuard识别事件并回调</h3><p>根据不同的激活原因，调用不的回调函数。这些回调函数，是在持有Channel对象，需要进行事件监听的class中进行设置，比如TcpConnection，EventLoop，Acceptor，TimerQueue等。而有些回调函数，经过层层传递，会呈现可网络库的调用者，比如TcpConnection会将处理一个socketfd的读事件回调（新建连接请求），传递给TcpServer::newConnection，这样用户就能通过TcpServer::setConnectionCallback设置其回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据不同的激活原因, 调用不同的回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    eventHandling_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 正在处理事件</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-built_in">reventsToString</span>(); <span class="hljs-comment">// 打印fd及就绪事件</span><br>    <span class="hljs-keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))<br>    &#123; <span class="hljs-comment">// fd挂起(套接字已不在连接中), 并且没有数据可读</span><br>        <span class="hljs-keyword">if</span> (logHup_)<br>        &#123; <span class="hljs-comment">// 打印挂起log</span><br>            LOG_WARN &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="hljs-string">&quot; Channel::handle_event() POLLHUP&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 调用关闭回调</span><br>        <span class="hljs-keyword">if</span> (closeCallback_) <span class="hljs-built_in">closeCallback_</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; POLLNVAL) <span class="hljs-comment">// 无效请求, fd没打开</span><br>    &#123; <span class="hljs-comment">// fd dont be opened</span><br>        LOG_WARN &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="hljs-string">&quot; Channel::handle_event() POLLNVAL&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL)) <span class="hljs-comment">// 错误条件, 或 无效请求, fd没打开</span><br>    &#123; <span class="hljs-comment">// error or fd dont be opened</span><br>        <span class="hljs-keyword">if</span> (errorCallback_) <span class="hljs-built_in">errorCallback_</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) <span class="hljs-comment">// 有待读数据, 或 紧急数据(e.g. TCP带外数据), 或流套接字对端关闭连接/写半连接</span><br>    &#123; <span class="hljs-comment">// there is data, urgent data,  to be read</span><br>        <span class="hljs-keyword">if</span> (readCallback_) <span class="hljs-built_in">readCallback_</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; POLLOUT)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (writeCallback_) <span class="hljs-built_in">writeCallback_</span>();<br>    &#125;<br>    eventHandling_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update-更新通道">update 更新通道</h3><p>通过EventLoop对象，传递给Poller对象，然后更新其监听的通道列表中对应通道。支持ADD/MOD操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    addedToLoop_ = <span class="hljs-literal">true</span>;<br>    loop_-&gt;<span class="hljs-built_in">updateChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    poller_-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Update array pollfds_</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* O(logN)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PollPoller::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    Poller::<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="hljs-built_in">fd</span>() &lt;&lt; <span class="hljs-string">&quot; events = &quot;</span> &lt;&lt; channel-&gt;<span class="hljs-built_in">events</span>();<br>    <span class="hljs-keyword">if</span> (channel-&gt;<span class="hljs-built_in">index</span>() &lt; <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// a new one, add to pollfds_</span><br>        <span class="hljs-comment">// ensure channel point to a new one</span><br>        <span class="hljs-built_in">assert</span>(channels_.<span class="hljs-built_in">find</span>(channel-&gt;<span class="hljs-built_in">fd</span>()) == channels_.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> pfd;<br>        pfd.fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>        pfd.events = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">short</span>&gt;(channel-&gt;<span class="hljs-built_in">events</span>());<br>        pfd.revents = <span class="hljs-number">0</span>;<br>        pollfds_.<span class="hljs-built_in">push_back</span>(pfd);<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pollfds_.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>        channel-&gt;<span class="hljs-built_in">set_index</span>(idx);<br>        channels_[pfd.fd] = channel; <span class="hljs-comment">// insert (fd, channel)</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// update existing one</span><br>        <span class="hljs-built_in">assert</span>(channels_.<span class="hljs-built_in">find</span>(channel-&gt;<span class="hljs-built_in">fd</span>()) != channels_.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">assert</span>(channels_[channel-&gt;<span class="hljs-built_in">fd</span>()] == channel);<br>        <span class="hljs-type">int</span> idx = channel-&gt;<span class="hljs-built_in">index</span>();<br>        <span class="hljs-comment">// ensure channel does exist in pollfds_</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= idx &amp;&amp; idx &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pollfds_.<span class="hljs-built_in">size</span>()));<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span>&amp; pfd = pollfds_[idx];<br>        <span class="hljs-built_in">assert</span>(pfd.fd == channel-&gt;<span class="hljs-built_in">fd</span>() || pfd.fd == -channel-&gt;<span class="hljs-built_in">fd</span>() - <span class="hljs-number">1</span>);<br>        pfd.fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>        pfd.events = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">short</span>&gt;(channel-&gt;<span class="hljs-built_in">events</span>());<br>        pfd.revents = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (channel-&gt;<span class="hljs-built_in">isNoneEvent</span>())<br>        &#123;<br>            <span class="hljs-comment">// ignore this pollfd</span><br>            pfd.fd = -channel-&gt;<span class="hljs-built_in">fd</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="remove-移除通道">remove 移除通道</h3><p>与update类似，也是通过EventLoop传递给Poller对象，将当前通道从Poller的事件列表中删除。支持DEL操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    addedToLoop_ = <span class="hljs-literal">true</span>;<br>    loop_-&gt;<span class="hljs-built_in">updateChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    poller_-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从监听的通道数组channels_中, 移除指定通道</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PollPoller::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    Poller::<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="hljs-built_in">fd</span>();<br>    <span class="hljs-built_in">assert</span>(channels_.<span class="hljs-built_in">find</span>(channel-&gt;<span class="hljs-built_in">fd</span>()) != channels_.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">assert</span>(channels_[channel-&gt;<span class="hljs-built_in">fd</span>()] == channel);<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">isNoneEvent</span>());<br>    <span class="hljs-type">int</span> idx = channel-&gt;<span class="hljs-built_in">index</span>();<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= idx &amp;&amp; idx &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pollfds_.<span class="hljs-built_in">size</span>()));<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span>&amp; pfd = pollfds_[idx]; (<span class="hljs-type">void</span>)pfd;<br><br>    <span class="hljs-comment">// ensure remove one invalid channel from channels_</span><br>    <span class="hljs-built_in">assert</span>(pfd.fd == -channel-&gt;<span class="hljs-built_in">fd</span>() - <span class="hljs-number">1</span> &amp;&amp; pfd.events == channel-&gt;<span class="hljs-built_in">events</span>());<br>    <span class="hljs-type">size_t</span> n = channels_.<span class="hljs-built_in">erase</span>(channel-&gt;<span class="hljs-built_in">fd</span>());<br>    <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>); (<span class="hljs-type">void</span>)n;<br><br>    <span class="hljs-comment">// remove pollfd from pollfds_ by index</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(idx) == pollfds_.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    &#123; <span class="hljs-comment">// last of pollfds_</span><br>        pollfds_.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// swap the pollfd to be removed with the last of pollfds_,</span><br>        <span class="hljs-comment">// then remove the last</span><br>        <span class="hljs-type">int</span> channelAtEnd = pollfds_.<span class="hljs-built_in">back</span>().fd;<br>        <span class="hljs-built_in">iter_swap</span>(pollfds_.<span class="hljs-built_in">begin</span>() + idx, pollfds_.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (channelAtEnd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            channelAtEnd = -channelAtEnd - <span class="hljs-number">1</span>;<br>        &#125;<br>        channels_[channelAtEnd]-&gt;<span class="hljs-built_in">set_index</span>(idx);<br>        pollfds_.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://www.cnblogs.com/fortunely/p/15997694.html">muduo笔记网络库（三）事件通道Channel</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-I/O复用</title>
    <link href="/2023/07/02/muduo%E5%BA%93-I-O%E5%A4%8D%E7%94%A8/"/>
    <url>/2023/07/02/muduo%E5%BA%93-I-O%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-io复用">muduo库-I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符，能有效提高程序性能。Linux下，实现I/O复用的系统调用主要有3个：</p><ol type="1"><li>select</li><li>poll</li><li>epoll</li></ol><p>muduo采用了2和3，分别用PollPoller/EPollPoller对poll/epoll进行了封装，基类Poller主要用于提供统一的接口。</p><h2 id="poller类">Poller类</h2><p>先来看看基类Poller定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO Multiplexing Interface</span><br><span class="hljs-comment">* Support poll(2), epoll(7)</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Only owner EventLoop IO thread can invoke it, so thread safe is not necessary.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO复用接口</span><br><span class="hljs-comment">* 禁止编译器生成copy构造函数和copy assignment</span><br><span class="hljs-comment">* 支持poll(2), epoll(7)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poller</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::vector&lt;Channel*&gt; ChannelList;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Poller</span><span class="hljs-params">(EventLoop* loop)</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Poller</span>();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Polls the I/O events.</span><br><span class="hljs-comment">     * Must be called in the loop thread.</span><br><span class="hljs-comment">     * poll(2) for PollPoller, epoll_wait(2) for EPollPoller</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 监听函数，根据激活的通道列表，监听指定fd的相应事件</span><br><span class="hljs-comment">     * 对于PollPoller会调用epoll_wait(2), 对于EPollPoller会调用poll(2)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 返回调用完epoll_wait/poll的当前时间（Timestamp对象）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Update channel listened</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 更新监听通道的事件 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 删除监听通道 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 判断当前Poller对象是否持有指定通道 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">hasChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">/* 默认创建Poller对象的类函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Poller* <span class="hljs-title">newDefaultPoller</span><span class="hljs-params">(EventLoop* loop)</span></span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 断言所属EventLoop为当前线程.</span><br><span class="hljs-comment">     * 如果断言失败，将终止程序（LOG_FATAL）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assertInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        ownerLoop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 该类型保存fd和需要监听的events，以及各种事件回调函数（可读/可写/错误/关闭等）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">typedef</span> std::map&lt;<span class="hljs-type">int</span>, Channel*&gt; ChannelMap;<br>    <span class="hljs-comment">// Poller don&#x27;t own the Channel, so the channel must be unregister(EventLoop::removeChannel) before its dtor.</span><br>    <span class="hljs-comment">// std::map used for speeding up to find out a channel by fd</span><br>    <span class="hljs-comment">/* 保存所有事件的Channel，一个Channel绑定一个fd */</span><br>    ChannelMap channels_;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 事件驱动循环, 用于调用poll监听fd事件</span><br><span class="hljs-comment">     */</span><br>    EventLoop* ownerLoop_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个EventLoop类都有一个Poller派生类的实例化对象，该对象的所有操作都在同一个IO线程完成的，不存在多线程抢占的问题，只有拥有EventLoop的IO线程，才能调用EventLoop所拥有的Poller对象的接口。因此只需要判断当前执行线程是否在EventLoop对象的创建线程即可，所以考虑Poller的线程安全不是必要的。</p><p>一个Channel对应一个fd（文件描述符），一个fd有三种事件状态：空事件（kNoneEvent），读事件（kReadEvent，即POLLIN|POLLPRI），写事件（kWriteEvent，即POLLOUT）。只有后2个，poll/epoll才会进行监听。</p><p>EventLoop会根据Poller::newDefaultPoller()，Poller对象。实际策略是根据是否设置了环境变量，来选择创建PollPoller，还是EPollPoller。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Poller *<span class="hljs-title">Poller::newDefaultPoller</span><span class="hljs-params">(EventLoop *loop)</span> <span class="hljs-comment">// static</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;MUDUO_USE_POLL&quot;</span>)) <span class="hljs-comment">// 如果设置了环境变量</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PollPoller</span>(loop);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">EPollPoller</span>(loop);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="epollpoller类">EPollPoller类</h2><p>EPollPoller以epoll为核心，实现了基类Poller的virtual函数，在其中调用了epoll_create/ctl/wait等接口。poll返回后，会将就绪的fd添加到激活队列activeChannels中管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO Multiplexing with epoll(7).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EPollPoller</span> : <span class="hljs-keyword">public</span> Poller<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EPollPoller</span>(EventLoop* loop);<br>    ~<span class="hljs-built_in">EPollPoller</span>() <span class="hljs-keyword">override</span>;<br>    <span class="hljs-comment">/* 监听函数, 调用epoll_wait() */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* ADD/MOD/DEL */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* DEL */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* events_数组初始大小 */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInitEventListSize = <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">/* 将op(EPOLL_CTL_Add/MOD/DEL)转换成字符串 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">operationToString</span><span class="hljs-params">(<span class="hljs-type">int</span> op)</span></span>;<br>    <span class="hljs-comment">/* poll返回后将就绪的fd添加到激活通道中activeChannels */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents,</span></span><br><span class="hljs-params"><span class="hljs-function">                            ChannelList* activeChannels)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 由updateChannel/removeChannel调用，真正执行epoll_ctl()控制epoll的函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> operation, Channel* channel)</span></span>;<br><br>    <span class="hljs-keyword">typedef</span> std::vector&lt;<span class="hljs-keyword">struct</span> epoll_event&gt; EventList;<br>    <span class="hljs-comment">/* epoll文件描述符，由epoll_create返回 */</span><br>    <span class="hljs-type">int</span> epollfd_;<br>    <span class="hljs-comment">/* epoll事件数组，为了适配epoll_wait参数要求 */</span><br>    EventList events_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>muduo在实现时，创建epoll fd时，并没有用epoll_create，而是用epoll_create1。原因在于：epoll_create1在打开epoll文件描述符时，可以直接指定FD_CLOEXEC选项，相当于open时指定O_CLOSEXEC。另外，epoll_create的size参数在Linux2.6.8以后，就已经没用了（&gt;0即可），内核会实现自动增长内部数据结构以描述监听事件。</p><p>值得一提的是，在Channel中定义了一个名为index_的成员，由Channel构造初值为0，可通过Channel::index()/set_index()访问，在不同的Poller中有不同的含义：在EPollPoller中，index_用来表示事件类型（kNew/kAdded/kDeleted）；在PollPoller中的含义，到PollPoller类解析中再讲。</p><h2 id="pollpoller类">PollPoller类</h2><p>PollPoller是Poller的另外一个派生类，以poll为核心，实现Poller的virtual函数，在其中调用了poll接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO Multiplexing with poll(2).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PollPoller</span> : <span class="hljs-keyword">public</span> Poller<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PollPoller</span>(EventLoop* loop);<br>    ~<span class="hljs-built_in">PollPoller</span>() <span class="hljs-keyword">override</span>;<br>    <span class="hljs-comment">/* 监听函数，调用poll() */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* ADD/MOD */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* DEL */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* poll返回后将就绪的fd添加到激活通道中activeChannels */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents,</span></span><br><span class="hljs-params"><span class="hljs-function">                            ChannelList* activeChannels)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">typedef</span> std::vector&lt;<span class="hljs-keyword">struct</span> pollfd&gt; PollFdList;<br>    <span class="hljs-comment">/* poll事件数组，适配poll(2)参数要求 */</span><br>    PollFdList pollfds_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在PollPoller中的index_表示一个事件在poll事件数组（pollfds_）中的索引：如果值为-1，表明该事件尚未在事件数组中；如果值&gt;=0，表明该事件已经在事件数组中。可以用来对Channel对应事件做标记，便于判断Channel是否已经位于事件数组，从而决定后续是执行添加、修改，还是删除操作。</p><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/15997621.html">muduo笔记网络库（二）I/O复用封装Poller</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-网络库概括</title>
    <link href="/2023/07/02/muduo%E5%BA%93-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%A6%82%E6%8B%AC/"/>
    <url>/2023/07/02/muduo%E5%BA%93-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-网络库概括">muduo库-网络库概括</h1><h2 id="网络事件的处理模式">网络事件的处理模式</h2><p>服务器编程中，通常有两种高效的事件处理模式：reactor模式，proactor模式。</p><h3 id="reactor模式">Reactor模式</h3><p>要求<strong>主线程</strong>（I/O单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知<strong>工作线程</strong>（逻辑单元）。除此之外，主线程不做其他任何实质性的工作。读写数据，接受新连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型（以epoll为例）实现Reactor模式工作流程：</p><ol type="1"><li>主线程往epoll内核事件表注册socket上的读就绪事件（epoll_ctl +EPOLL_CTL_ADD）；</li><li>主线程调用epoll_wait等待socket上有数据可读；</li><li>当socket上有数可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列；</li><li>阻塞在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上写就绪事件。</li><li>主线程调用epoll_wait等待socket可写；</li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li><li>阻塞在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li></ol><p>当然，epoll不止能监听socket上的事件，其他文件描述符都能监听。</p><p>下图是Reactor模式的工作流程示意：</p><p><img src="/img/muduo/网络库概括/reactor模式工作流程.png" /></p><h3 id="proactor模式">Proactor模式</h3><p>Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅负责业务逻辑。</p><p>使用异步I/O模型（以aio为例）实现Proactor模式工作流程：</p><ol type="1"><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置以及读操作完成时如何通知应用程序（回调函数）；</li><li>主线程继续处理其他逻辑；</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用；</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_write向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写完成时如何通知应用程序（仍以信号为例）；</li><li>main线程继续处理其他逻辑；</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕；</li><li>应用程序预先定义好的信号处理函数，选择一个工作线程来做善后处理，如决定是否关闭socket；</li></ol><p>下图是Proactor模式的工作流程示意：</p><p><img src="/img/muduo/网络库概括/proactor模式工作流程.png" /></p><h2 id="muduo网络库中的reactor模式">muduo网络库中的Reactor模式</h2><p>muduo网络库采用的是Reactor模式。服务器软件框架是one loop perthread，即一个线程一个事件循环。这个循环称为EventLoop，loop线程是指运行EventLoop::loop()的线程。这种以事件为驱动的编程模式称为事件驱动模式。</p><p>网络库是由<strong>Reactor +线程池</strong>来完成的，线程池中每个线程都是一个Reactor模型。这种结构在处理大量并发I/O连接任务的服务器上，就很有优势。</p><p>下图是实现Reactor模式各关键类及类图关系：</p><p><img src="/img/muduo/网络库概括/Reactor模式关键类图.png" /></p><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/15998209.html">muduo笔记网络库（一）概括</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake的使用</title>
    <link href="/2023/07/01/Cmake%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/01/Cmake%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake的使用">Cmake的使用</h1><p>CMake是一个跨平台的安装(编译)工具,可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件,能测试编译器所支持的C++特性,类似UNIX下的automake。</p><h2 id="编译一个独立的cpp文件">编译一个独立的cpp文件</h2><p>文件结构如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">singleFile/<br><span class="hljs-string">| -- CMakeLists.txt</span><br><span class="hljs-string">| -- helloWorld.cpp</span><br></code></pre></td></tr></table></figure><p>CMakeLists.txt的文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span> (<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.12</span>) <span class="hljs-comment"># camke版本号</span><br><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST) <span class="hljs-comment"># 将./下的所有*.cpp加入到SRC_LIST中</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>在singleFile文件夹下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ./<br></code></pre></td></tr></table></figure><p>可以看到编译生成的文件已经在当前目录下生成了：</p><p><img src="/img/CMake/单个文件cmake命令.png" /></p><p>然后执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>就可以生成我们程序的可执行文件了：</p><p><img src="/img/CMake/单个文件make命令.png" /></p><p>但是这样会有一个问题，就是编译生成的文件都在当前目录下，这样会导致文件夹很乱，所以我们可以创建一个build文件夹，那么文件结构就变为如下所示：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">singleFile/<br><span class="hljs-string">| -- CMakeLists.txt</span><br><span class="hljs-string">| -- build/</span><br><span class="hljs-string">| -- helloWorld.cpp</span><br></code></pre></td></tr></table></figure><p>然后在singleFile/build文件夹下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p>可以看到编译生成的文件全部都在build文件夹里生成了</p><p><img src="/img/CMake/单个文件-build文件夹cmake命令.png" /></p><div class="admonition note"><p class="admonition-title">note</p><p>这里需要注意的是，build文件夹的位置是可以改变的，甚至其名字也可以改，但是习惯上使用build作为文件夹的名字，示例里cmake命令后面的参数是两个点，是因为CMakelists.txt文件在上一级目录，所以需要用两个点来表示上一级目录,如果将build文件夹放在其他的地方，那么需要保证执行<code>cmake</code>命令的之后后边跟的路径是CMakeLists.txt文件所在的路径。</p></div><p>然后执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>就可以生成我们程序的可执行文件了：</p><p><img src="/img/CMake/单个文件-build文件夹make命令.png" /></p><h2 id="编译多个cpp文件">编译多个cpp文件</h2><p>文件结构如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">multiFile/<br>| <span class="hljs-comment">-- CMakeList.txt </span><br>| <span class="hljs-comment">-- main.cpp</span><br>| <span class="hljs-comment">-- build/</span><br>| <span class="hljs-comment">-- src/ </span><br>    <span class="hljs-comment">-- CMakeList.txt  </span><br>    <span class="hljs-comment">-- test.h</span><br>    <span class="hljs-comment">-- test.cpp</span><br></code></pre></td></tr></table></figure><p><code>main.cpp</code>,<code>test.cpp</code>,以及<code>test.h</code>文件的内容如下：</p><p>test.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>();<br>    ~<span class="hljs-built_in">Test</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>test.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;test.h&quot;</span></span><br><br>Test::<span class="hljs-built_in">Test</span>()<br>&#123;<br>&#125;<br><br>Test::~<span class="hljs-built_in">Test</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;src/test.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Test test;<br>    test.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根目录下CMakeLists.txt文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(main)<br><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src)<br><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_SRCS)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(main <span class="hljs-variable">$&#123;DIR_SRCS&#125;</span>)<br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main <span class="hljs-keyword">TEST</span>)<br></code></pre></td></tr></table></figure><p>src文件夹下的CMakeLists.txt文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_TEST_SRC)<br><span class="hljs-comment"># generate *.so</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(<span class="hljs-keyword">TEST</span> SHARED <span class="hljs-variable">$&#123;DIR_TEST_SRC&#125;</span>)<br></code></pre></td></tr></table></figure><p>在multiFile/build文件夹下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/img/CMake/多文件-build文件夹cmake命令.png" /></p><p>与编译单个文件时一样，执行<code>make</code>命令就可以生成可执行文件了：</p><p><img src="/img/CMake/多文件-build文件夹make命令.png" /></p><p>同时可以看到在"multiFile/build/src"文件夹下生成了.so文件</p><p><img src="/img/CMake/生成so文件.png" /></p><h2 id="调用-.so-.h文件结构">调用 *.so, *.h，文件结构:</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">libTest/<br>| <span class="hljs-comment">-- build/</span><br>| <span class="hljs-comment">-- include/</span><br>    <span class="hljs-comment">--  test.h</span><br>| <span class="hljs-comment">-- libs/</span><br>    <span class="hljs-comment">-- libTEST.so</span><br>| <span class="hljs-comment">-- CMakeLists.txt</span><br>| <span class="hljs-comment">-- main.cpp</span><br></code></pre></td></tr></table></figure><p>这里的<code>libTEST.so</code>文件是上面使用<code>cmake</code>命令生成的.so文件，<code>test.h</code>是之前的<code>test.h</code>文件，<code>main.cpp</code>文件的内容如下：</p><p>CMakeLists.txt的文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(main)<br><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(./<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_SRCS)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(main <span class="hljs-variable">$&#123;DIR_SRCS&#125;</span>)<br><span class="hljs-comment"># 绝对路径添加 *.so</span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main /home/starmin/Code/testCode/cmakeTest/libTest/libs/libTEST.so)<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>这里需要注意的是，<code>TARGET_LINK_LIBRARIES</code>后面的<code>libTEST.so</code>路径必须绝对路径,如果想要使用相对路径，需要设置链接库搜索目录（见下文<strong>设置链接库搜索目录</strong>）</p></div><p>在build文件夹下执行<code>cmake</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p><img src="/img/CMake/lib-build文件夹cmake.png" /></p><p>然后执行<code>make</code>命令：</p><p><img src="/img/CMake/lib-build文件夹make.png" /></p><h2 id="cmakelists.txt的常用选项">CMakelists.txt的常用选项</h2><p>上面是CMake最基本的集中使用方法，还有一些CMake常用的选项见下文</p><h3 id="指定cmake的最小版本">指定cmake的最小版本</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)    <span class="hljs-comment"># 指定cmake的最小版本</span><br></code></pre></td></tr></table></figure><h3 id="定义工程名称">定义工程名称</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(main)   <span class="hljs-comment"># 定义工程名称</span><br></code></pre></td></tr></table></figure><h3 id="显示定义变量">显示定义变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(var [value]) <span class="hljs-comment"># 显示定义变量</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 第一种用法，生成代码文件列表</span><br><span class="hljs-comment"># 先直接设置SRC_LIST的值</span><br><span class="hljs-keyword">set</span>(SRC_LIST add.h add.cpp)<br><span class="hljs-comment"># 然后再在SRC_LIST中追加main.cpp </span><br><span class="hljs-keyword">set</span>(SRC_LIST <span class="hljs-variable">$&#123;SRC_LIST&#125;</span> main.cpp)<br><br><span class="hljs-comment"># 第二中用法，设置库生成目录或者可执行文件生成目录</span><br><span class="hljs-keyword">set</span>( LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/linux) <br><span class="hljs-keyword">set</span>( EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br></code></pre></td></tr></table></figure><h3 id="编译链接库可执行程序">编译链接库/可执行程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 编译静态库</span><br><span class="hljs-keyword">add_library</span>(库名称 STATIC 代码文件名称) <br><br><span class="hljs-comment"># 编译动态库</span><br><span class="hljs-keyword">add_library</span>(库名称 SHARED 代码文件名称) <br><br><span class="hljs-comment"># 编译可执行程序</span><br><span class="hljs-keyword">add_executable</span>(可执行程序名 代码文件名称)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 编译静态库</span><br><span class="hljs-keyword">add_library</span>(add STATIC add.h add.cpp)<br><span class="hljs-keyword">add_library</span>(add STATIC <span class="hljs-variable">$&#123;ADD_SRC&#125;</span> <span class="hljs-variable">$&#123;ADD_HDR&#125;</span>)<br><br><span class="hljs-comment"># 编译动态库</span><br><span class="hljs-keyword">add_library</span>(add  SHARED add.h add.cpp) <br><span class="hljs-keyword">add_library</span>(add SHARED  <span class="hljs-variable">$&#123;ADD_SRC&#125;</span> <span class="hljs-variable">$&#123;ADD_HDR&#125;</span>)<br><br><span class="hljs-comment"># 编译可执行程序</span><br><span class="hljs-keyword">add_executable</span>(main add.h add.cpp mai.cpp)<br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;MAIN_SRC&#125;</span> <span class="hljs-variable">$&#123;MAIN_HDR&#125;</span>)<br></code></pre></td></tr></table></figure><h3id="指定静态库或者动态库编译输出目录">指定静态库或者动态库编译输出目录</h3><p>例如将当前编译的静态库或者动态库输出到当前项目文件夹lib子目录下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH  <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure><h3 id="指定可执行程序编译输出目录">指定可执行程序编译输出目录</h3><p>例如将当前可执行程序输出到当前项目文件夹的bin子目录下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#设定可执行二进制文件的目录</span><br><span class="hljs-keyword">set</span>( EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br></code></pre></td></tr></table></figure><h3 id="设置链接库搜索目录">设置链接库搜索目录</h3><p>例如将链接库搜索目录设置为当前项目文件夹下lib/linux文件夹</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>( <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/linux)<br></code></pre></td></tr></table></figure><h3 id="设置包含目录">设置包含目录</h3><p>例如将包含目录设置为当前项目文件夹下include文件夹</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><h3 id="设置宏定义">设置宏定义</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#预定义宏</span><br><span class="hljs-keyword">add_definitions</span>(-D宏名称)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_definitions</span>(-DWINDOWS)<br><span class="hljs-keyword">add_definitions</span>(-DLINUX)<br></code></pre></td></tr></table></figure><h3 id="静态链接库">静态链接库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main <span class="hljs-keyword">TEST</span>.so)    <span class="hljs-comment"># 链接库</span><br></code></pre></td></tr></table></figure><h3 id="添加子文件夹">添加子文件夹</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>该语句会在执行完当前文件夹CMakeLists.txt之后执行src子目录下的CMakeLists.txt</p></div><h3 id="add_subdirectory">ADD_SUBDIRECTORY</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src)   <span class="hljs-comment"># 添加子目录</span><br></code></pre></td></tr></table></figure><h3 id="源文件名赋值给变量">源文件名赋值给变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_SRCS)   <span class="hljs-comment"># 将当前目录下的所有源文件名赋值给变量DIR_SRCS</span><br></code></pre></td></tr></table></figure><p>参考：</p><ul><li><ahref="https://segmentfault.com/a/1190000021336082">CMake--使用教程基础篇</a></li><li><ahref="https://zhuanlan.zhihu.com/p/315768216">cmake常用命令的一些整理</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-日志类</title>
    <link href="/2023/06/29/muduo%E5%BA%93-%E6%97%A5%E5%BF%97%E7%B1%BB/"/>
    <url>/2023/06/29/muduo%E5%BA%93-%E6%97%A5%E5%BF%97%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-日志类">muduo库-日志类</h1><p>muduo库中的日志为诊断日志，用于将代码运行时的重要信息进行保存，方便故障诊断和追踪。日志通常分为如下两种：</p><ul><li><strong>同步日志</strong>：当需要写出一条日志消息时，只有等到这条日志消息完全写出时才能执行后续的程序，其问题在于可能会阻塞在磁盘写操作上；</li><li><strong>异步日志</strong>：当需要写日志消息时，只是将日志消息进行存储，当积累到一定量时或者达到时间间隔后，由后台线程自动将存储的所有日志进行数据；</li></ul><p>综上所述，异步日志的好处是前台线程不会阻塞在写日志上，后台线程真正写日志时，日志消息往往已经积累了很多，此时只需一次IO 操作，从而减少了 IO 函数的调用次数，提高了效率。</p><p>而一个日志库大体可以分为前端和后端两部分：</p><ul><li>前端：生成日志消息到缓冲区</li><li>后端：将缓冲区中的日志消息输出到本地文件</li></ul><p>日志的前端与后端就是一个典型的 "多生产者——单消费者" 问题：</p><ul><li>对于生产者而言，要尽可能坐到低延迟、低 CPU 开销、无阻塞；</li><li>对于消费者而言，要做到足够大的吞吐量，并占用少的资源；</li></ul><p>对于日志消息而言，要做到以下几点：</p><ol type="1"><li>每条日志消息占一行，且格式明确，便于 awk、grep 工具分析；</li><li>打印线程ID、日志级别、源文件、行号；</li><li>时间戳精确到微秒；</li><li>对于分布式系统而言，使用 GMT 时区；</li></ol><h2 id="日志框架设计思路">日志框架设计思路</h2><p>每一次日志操作，都进行三个步骤：</p><ol type="1"><li>打开文件</li><li>写文件</li><li>关闭文件</li></ol><p>但是，当写入日志的频率较高时，磁盘 IO占用较高。尽管在多线程文件操作中是线程安全的，但是多个线程写入日志的顺序确难以保证。</p><p>为此，可以在应用程序启动之初打开全局文件一次，后续每次日志操作，只需写入文件即可。</p><p>由于文件操作默认是存在缓冲区的，只有当缓冲区存满后，才将缓冲区的内容输出到文件中。相较于频繁的打开文件，此方案减少了打开文件、关闭文件的次数，效率得到了提升。</p><div class="admonition note"><p class="admonition-title">note</p><p>C++ 中的 ostream 并非线程安全，而 C 中的 fwrite 则是线程安全的。</p></div><p>为了进一步提高效率，尽可能地减少磁盘 IO的操作。可以使用一个线程安全队列，一边负责写日志消息，一边负责取日志消息。当所取日志条数或总长度达到一定数量时，我们才写入一次磁盘，以此来降低磁盘IO 的操作次数。</p><p>除此之外，多个线程还可以共用一个日志前端，使用多缓冲技术。例如 muduo库所采用的双缓冲技术，前端负责向 Buffer 中填入数据，后端则负责将 Buffer中的数据取出来写入到文件。</p><p>如图所示，准备两块缓冲区 Buffer A 和 Buffer B，前端负责往 Buffer A中写入日志消息，后端负责将 Buffer B 中的日志消息写入文件：</p><p><img src="/img/muduo/日志类/多缓冲技术.png" /></p><p>当 Buffer A 写满之后，交换 A 和 B，让后端将 Buffer A中的日志消息写入文件，而前端则往 Buffer B中写入新的日志消息，如此反复。</p><p><img src="/img/muduo/日志类/多缓冲技术-1.png" /></p><p>在大部分的时间中，前端线程和后端线程不会操作同一个缓冲区，这也就意味着前端线程的操作，不需要等待后端线程缓慢的写文件操作，因为不需要锁定临界区。</p><div class="admonition note"><p class="admonition-title">note</p><p>前端线程和后端线程仅仅只在交换缓冲区时会存在线程同步问题，因此只需要在交换缓冲区时使用互斥锁来保护临界区即可，这个时间极其短暂，这也就是提高吞吐量的关键所在。</p></div><p>同时，后端线程将缓冲区中的日志消息写入到文件系统中的频率，完全由自己的写入策略来决定，避免了每条新的日志消息都唤醒后端线程。</p><p>换言之，前端线程不是将一条条日志消息分别传送给后端线程，而是将多条消息组成一个大的Buffer 传递给后端进行处理，相当于批量处理，减少了线程唤醒的频率和 IO操作次数，降低开销。</p><p>在 Muduo的实现中，它在后端设置了一个已满缓冲区的队列，用于缓冲一个周期内临时要写的日志消息：</p><p><img src="/img/muduo/日志类/后端缓冲区队列.png" /></p><h2 id="logstream">LogStream</h2><p><code>FixedBuffer</code> 类是作为 <code>LogStream</code>类类型的缓冲区对象，其是一个模板类，传入一个非类型参数 <code>SIZE</code>用来表示缓冲区的大小，其示意图如图所示：</p><p><img src="/img/muduo/日志类/SIZE大小.png" /></p><p>如图所示，其在栈上维护一段大小为 <code>SIZE</code>的内存区域，<code>length</code> 为已写入数据的长度，而<code>avail</code> 为剩余可用的数据长度。</p><p><code>SmallBuffer</code> 的默认大小为 4KB，为前端的<code>LogStream</code> 所持有。而 <code>LargeBuffer</code> 的默认大小为4MB，为后端 的 <code>AsyncLogging</code> 所持有。</p><p>对于 <code>LogStream</code> 类类型来说，它将要输出的信息加载到<code>FixedBuffer</code> 的缓冲区中，等待后续的处理。它通过重载<code>&lt;&lt;</code>运算符来输出基本的数据类型到缓冲区。各种输入类型的调用链如下所示：</p><p><img src="/img/muduo/日志类/输入类型调用链.png" /></p><div class="admonition note"><p class="admonition-title">note</p><p>LogStream 不是线程安全的，因此对于每个 log 消息应当构造一个临时的LogStream，用完之后随即销毁。</p></div><p>在该类中，设计了大量的运算符重载函数，其效率要优于<code>iostream</code> 和 <code>stdio</code>，使用的思想源于 MatthewWilson 的 “带符号整形数据的除法与余数”算法实现。其巧妙之处在于，用一个对称的 <code>digits</code>数组搞定了负数转换的边界条件(二进制补码的正负数表示范围不对称):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> digits[] = <span class="hljs-string">&quot;9876543210123456789&quot;</span>;<br></code></pre></td></tr></table></figure><p>此外，由于 <code>LogStream</code> 本身并不支持格式化，因此设计 Fmt类类型将数值类型数据转化为一个长度不超过 32 位的字符对象Fmt，并重载了支持 Fmt 输出到 <code>LogStream</code> 的<code>&lt;&lt;</code> 操作符模板函数。</p><h2 id="logging">Logging</h2><p>在 <code>Logger</code> 类中定义了枚举变量 <code>LogLevel</code>来作为日志等级：</p><p>表格如下所示：</p><table><thead><tr class="header"><th>日志等级</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>TRACE</td><td>跟踪：指明程序的运行轨迹，比 DEBUG 级别的粒度更细</td></tr><tr class="even"><td>DEBUG</td><td>调试：指明细致的事件信息，对调试应用最有用</td></tr><tr class="odd"><td>INFO</td><td>信息：指明描述信息，从粗粒度上描述了应用的运行过程</td></tr><tr class="even"><td>WARN</td><td>警告：指明潜在的有害状况</td></tr><tr class="odd"><td>ERROR</td><td>错误：指明错误事件，但应用可能还能继续运行</td></tr><tr class="even"><td>FATAL</td><td>致命：指明非常严重的可能导致应用终止执行的错误事件</td></tr></tbody></table><p>如果日志设置为 <span class="math inline">\(L\)</span>，一个日志级别为<span class="math inline">\(P\)</span> 的输出日志只有满足 <spanclass="math inline">\(P≥L\)</span>时日志才会输出。</p><p>具体的输出关系见下表，其中横向表头为日志级别，纵向表头为输出级别：</p><table><thead><tr class="header"><th></th><th>TRACE</th><th>DEBUG</th><th>INFO</th><th>WARN</th><th>ERROR</th><th>FATAL</th></tr></thead><tbody><tr class="odd"><td>TRACE</td><td>✔️</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>DEBUG</td><td>✔️</td><td>✔️</td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>INFO</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td><td></td><td></td></tr><tr class="even"><td>WARN</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td><td></td></tr><tr class="odd"><td>ERROR</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td></tr><tr class="even"><td>FATAL</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr></tbody></table><p>0110 <code>Logger</code> 类使用了桥接模式，其具体实现交给内嵌类 Impl来完成，它主要负责整合日志信息，主要包括：日期、时间、微秒、线程、日志级别、日志正文、源文件名、行号。其通过成员变量<code>stream_</code>将日志输出到缓冲区中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">日期</span>      <span class="hljs-string">时间</span>     <span class="hljs-string">微秒</span>     <span class="hljs-string">线程</span>  <span class="hljs-string">级别</span>  <span class="hljs-string">正文</span>     <span class="hljs-string">源文件名:</span>       <span class="hljs-string">行号</span><br><span class="hljs-number">20220306</span> <span class="hljs-number">09</span><span class="hljs-string">:15:44.681220Z</span> <span class="hljs-number">4013 </span><span class="hljs-string">WARN</span>  <span class="hljs-string">Hello</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Logging_test.cpp:75</span><br></code></pre></td></tr></table></figure><p>除此之外，内嵌类 <code>SourceFile</code>的目的是为了在编译期计算源文件的名称。</p><p><code>Logger</code> 内部有两个成员变量 <code>OutputFunc</code> 和<code>FlushFunc</code>，均为函数指针，分别指向输出函数和刷新函数，默认的输出函数使用线程安全的<code>fwrite()</code> 函数，默认的刷新函数使用<code>fflush()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultOutput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> n = <span class="hljs-built_in">fwrite</span>(msg, <span class="hljs-number">1</span>, len, stdout);<br>  (<span class="hljs-type">void</span>)n;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFlush</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，通过全局变量 <code>g_output</code> 和 <code>g_flush</code>来控制输出函数和刷新函数，使用 <code>g_logTimeZone</code>来设置时区：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Logger::OutputFunc g_output = defaultOutput;<br>Logger::FlushFunc g_flush = defaultFlush;<br>TimeZone g_logTimeZone;<br></code></pre></td></tr></table></figure><p>文件内部定义了多个宏来便于调用 <code>Logger</code>将日志追加到缓冲区中，如果当前日志消息等级低于<code>g_logLevel</code>，就不会进行任何操作，几乎 0 操作，这是通过宏中的<code>if</code> 语句实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TRACE <span class="hljs-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \</span><br><span class="hljs-meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_DEBUG <span class="hljs-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \</span><br><span class="hljs-meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_INFO <span class="hljs-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \</span><br><span class="hljs-meta">  muduo::Logger(__FILE__, __LINE__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span><br></code></pre></td></tr></table></figure><p>在 <code>Logger</code> 的析构函数中，先由 <code>impl_</code>往缓冲区后添加后缀，即文件名和行数以及换行符，然后调用<code>g_output</code> 将缓冲区内容输出到指定的文件流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Logger::~<span class="hljs-built_in">Logger</span>() &#123;<br>  impl_.<span class="hljs-built_in">finish</span>();<br>  <span class="hljs-function"><span class="hljs-type">const</span> LogStream::Buffer&amp; <span class="hljs-title">buf</span><span class="hljs-params">(stream().buffer())</span></span>;<br>  <span class="hljs-built_in">g_output</span>(buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">length</span>());<br>  <span class="hljs-keyword">if</span> (impl_.level_ == FATAL) &#123;<br>    <span class="hljs-built_in">g_flush</span>();<br>    <span class="hljs-built_in">abort</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端日志的时序图如:</p><p><img src="/img/muduo/日志类/前端日志时序图.png" /></p><h2 id="日志类">日志类</h2><p><code>LogFile</code>主要负责对日志文件的操作，包括日志文件的滚动和写入，其构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LogFile::<span class="hljs-built_in">LogFile</span>(<span class="hljs-type">const</span> string&amp; basename,<br>                 <span class="hljs-type">off_t</span> rollSize,<br>                 <span class="hljs-type">bool</span> threadSafe,<br>                 <span class="hljs-type">int</span> flushInterval,<br>                 <span class="hljs-type">int</span> checkEveryN)<br>  : <span class="hljs-built_in">basename_</span>(basename),<br>    <span class="hljs-built_in">rollSize_</span>(rollSize),<br>    <span class="hljs-built_in">flushInterval_</span>(flushInterval),<br>    <span class="hljs-built_in">checkEveryN_</span>(checkEveryN),<br>    <span class="hljs-built_in">count_</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">mutex_</span>(threadSafe ? <span class="hljs-keyword">new</span> MutexLock : <span class="hljs-literal">NULL</span>),<br>    <span class="hljs-built_in">startOfPeriod_</span>(<span class="hljs-number">0</span>),  <span class="hljs-comment">// 本次写日志的起始时间</span><br>    <span class="hljs-built_in">lastRoll_</span>(<span class="hljs-number">0</span>), <span class="hljs-comment">// 上次滚动日志文件的时间</span><br>    <span class="hljs-built_in">lastFlush_</span>(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 上次刷新日志文件的时间</span><br>  <span class="hljs-built_in">assert</span>(basename.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;/&#x27;</span>) == string::npos);<br>  <span class="hljs-built_in">rollFile</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 <code>threadSafe</code> 主要用于控制日志后端的线程安全，默认为<code>true</code>。当只有一个后端线程来处理日志消息时，则无需线程安全。<code>rollSize</code>表示一次最大刷新的字节数，flushInterval表示刷新的时间间隔，单位为毫秒。</p><p><code>checkEveryN</code> 表示写数据的次数限制，默认为1024。<code>count_</code> 用来计数当前写数据的次数，如果超过<code>checkEveryN</code> 则清除以重新计数。</p><p><code>mutex_</code>根据是否需要开启线程安全来决定是否需要初始化互斥锁指针。</p><p>当写数据的次数超过指定的写数据限制时，需要写入新的日志文件，这是通过<code>rollFile()</code> 来实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LogFile::rollFile</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">time_t</span> now = <span class="hljs-number">0</span>;<br>  string filename = <span class="hljs-built_in">getLogFileName</span>(basename_, &amp;now);<br>  <span class="hljs-type">time_t</span> start = now / kRollPerSeconds_ * kRollPerSeconds_;<br> <br>  <span class="hljs-keyword">if</span> (now &gt; lastRoll_) &#123;<br>    lastRoll_ = now;<br>    lastFlush_ = now;<br>    startOfPeriod_ = start;<br>    file_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> FileUtil::<span class="hljs-built_in">AppendFile</span>(filename));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其创建并打开一个新的日志文件，然后更改 <code>unique_ptr</code>所指向的文件对象。</p><p>为了避免频繁的创建新的文件，该函数确保上次滚动事件到现在如果不足 1秒，就不会发生滚动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogFile::append_unlocked</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  file_-&gt;<span class="hljs-built_in">append</span>(logline, len);<br>  <span class="hljs-keyword">if</span> (file_-&gt;<span class="hljs-built_in">writtenBytes</span>() &gt; rollSize_) &#123;<br>    <span class="hljs-built_in">rollFile</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ++count_;<br>    <span class="hljs-keyword">if</span> (count_ &gt;= checkEveryN_) &#123;<br>      count_ = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">time_t</span> now = ::<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>      <span class="hljs-type">time_t</span> thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;<br>      <span class="hljs-keyword">if</span> (thisPeriod_ != startOfPeriod_) &#123;<br>        <span class="hljs-built_in">rollFile</span>();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now - lastFlush_ &gt; flushInterval_) &#123;<br>        lastFlush_ = now;<br>        file_-&gt;<span class="hljs-built_in">flush</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志名的生成是通过如下函数实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">LogFile::getLogFileName</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; basename, <span class="hljs-type">time_t</span>* now)</span> </span>&#123;<br>  string filename;<br>  filename.<span class="hljs-built_in">reserve</span>(basename.<span class="hljs-built_in">size</span>() + <span class="hljs-number">64</span>);<br>  filename = basename;<br>  <span class="hljs-type">char</span> timebuf[<span class="hljs-number">32</span>];<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> tm;<br>  *now = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">gmtime_r</span>(now, &amp;tm);<br>  <span class="hljs-built_in">strftime</span>(timebuf, <span class="hljs-keyword">sizeof</span> timebuf, <span class="hljs-string">&quot;.%Y%m%d-%H%M%S.&quot;</span>, &amp;tm);<br>  filename += timebuf;<br>  filename += ProcessInfo::<span class="hljs-built_in">hostname</span>();<br>  <span class="hljs-type">char</span> pidbuf[<span class="hljs-number">32</span>];<br>  <span class="hljs-built_in">snprintf</span>(pidbuf, <span class="hljs-keyword">sizeof</span> pidbuf, <span class="hljs-string">&quot;.%d&quot;</span>, ProcessInfo::<span class="hljs-built_in">pid</span>());<br>  filename += pidbuf;<br>  filename += <span class="hljs-string">&quot;.log&quot;</span>;<br>  <span class="hljs-keyword">return</span> filename;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志的文件名是通过<code>[基础名].[当前时间].[主机名].[进程号].log</code> 来构成的。</p><p><code>LogFile</code> 通过 <code>append()</code>方法将日志写入文件，它实质上调用的是 <code>append_unlocked()</code>方法，同时根据是否开启线程安全来决定是否需要添加互斥锁来保护临界区。</p><p>同样地，刷新操作也是根据是否启用线程安全来决定是否添加互斥锁保护临界区，其内部调用的是<code>AppendFile::flush()</code> 方法。</p><h2 id="asynclogging">AsyncLogging</h2><p><code>AsyncLogging</code> 主要负责提供大缓冲区，即<code>LargeBuffer</code>，默认大小为 4MB，以存放多条日志消息，而成员变量<code>BufferVector</code> 则用于存放多个<code>LargeBuffer</code>。其构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncLogging</span> : noncopyable &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Large Buffer Type</span><br>  <span class="hljs-keyword">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;<br>  <span class="hljs-keyword">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector; <span class="hljs-comment">// 已满缓冲队列类型</span><br>  <span class="hljs-keyword">typedef</span> BufferVector::value_type BufferPtr;<br> <br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> flushInterval_;                    <span class="hljs-comment">// 冲刷缓冲数据到文件的超时时间, 默认3秒</span><br>  std::atomic&lt;<span class="hljs-type">bool</span>&gt; running_;                  <span class="hljs-comment">// 后端线程loop是否运行标志</span><br>  <span class="hljs-type">const</span> string basename_;                      <span class="hljs-comment">// 日志文件基本名称</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">off_t</span> rollSize_;                       <span class="hljs-comment">// 日志文件滚动大小</span><br>  muduo::Thread thread_;                       <span class="hljs-comment">// 后端线程</span><br>  muduo::CountDownLatch latch_;                <span class="hljs-comment">// 门阀, 同步调用线程与新建的后端线程</span><br>  muduo::MutexLock mutex_;                     <span class="hljs-comment">// 互斥锁, 功能相当于std::mutex</span><br>  <span class="hljs-function">muduo::Condition cond_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;   <span class="hljs-comment">// 条件变量, 与mutex_配合使用, 等待特定条件满足</span><br>  <span class="hljs-function">BufferPtr currentBuffer_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>; <span class="hljs-comment">// 当前缓冲</span><br>  <span class="hljs-function">BufferPtr nextBuffer_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;    <span class="hljs-comment">// 空闲缓冲</span><br>  <span class="hljs-function">BufferVector buffers_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;    <span class="hljs-comment">// 已满缓冲队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前端线程通过调用 LOG_XXX &lt;&lt; "..." 输出日志消息时，可以通过调用AsyncLogging::append() 方法将日志消息传递给后端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsyncLogging::append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *logline, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-function">muduo::MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>  <span class="hljs-keyword">if</span> (currentBuffer_-&gt;<span class="hljs-built_in">avail</span>() &gt; len) &#123;<br>      currentBuffer_-&gt;<span class="hljs-built_in">append</span>(logline, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(len));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    buffers_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(currentBuffer_));<br> <br>    <span class="hljs-keyword">if</span> (nextBuffer_) &#123;<br>      currentBuffer_ = std::<span class="hljs-built_in">move</span>(nextBuffer_);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      currentBuffer_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Buffer);<br>    &#125;<br> <br>    currentBuffer_-&gt;<span class="hljs-built_in">append</span>(logline, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(len));<br>    cond_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>append()</code>可能被多个前端线程调用，因此必须考虑线程安全，采用互斥锁加锁。其基本思路如下图所示：</p><p><img src="/img/muduo/日志类/append互斥锁.png" /></p><p>最后需要唤醒后端线程，是因为后端线程很可能阻塞等待日志消息，当缓冲区满时，能及时唤醒后端线程将已满的数据写入到磁盘上，否则短时间内如果产生大量的日志消息，会造成数据堆积，甚至丢失，而后端线程一直休眠，直到3 秒超时后唤醒。</p><p>后端线程的启动和结束是在如下两个方法中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>  running_ = <span class="hljs-literal">true</span>;<br>  thread_.<span class="hljs-built_in">start</span>();<br>  latch_.<span class="hljs-built_in">wait</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;<br>  running_ = <span class="hljs-literal">false</span>;<br>  cond_.<span class="hljs-built_in">notify</span>();<br>  thread_.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中变量 <code>latch_</code> 的作用是等待 <code>thread_</code>线程启动完成。<code>stop()</code>则用于关闭后端线程，通常实在析构函数中自动调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">AsyncLogging</span>() &#123;<br>  <span class="hljs-keyword">if</span> (running_) &#123;<br>    <span class="hljs-built_in">stop</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后端线程函数 <code>threadFunc</code>，会创建 1 个<code>LogFile</code> 对象，用于控制日志文件的创建和写日志数据，创建 2个空闲缓冲区<code>buffer1</code>、<code>buffer2</code>，和一个待写缓冲队列<code>buffersToWrite</code>，分别用于替换当前缓冲<code>currentBuffer_</code>、空闲缓冲<code>nextBuffer_</code>、已满缓冲队列<code>buffers_</code>，避免在写文件过程中，锁住缓冲区和队列，导致前端无法写数据到后端缓冲。</p><p>threadFunc 内部的 loop 流程如下：</p><!-- ![](/img/muduo/日志类/threadFunc内部loop流程.png) --><p><img src="/img/muduo/日志类/threadFunc内部loop流程.png"  width = "100%" height = "25%"  align=center /></p><h2 id="总结">总结</h2><p>转载自 <ahref="https://www.cnblogs.com/tuilk/p/16793625.html">Muduo库之异步日志</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-ThreadLocalSingleton类</title>
    <link href="/2023/06/28/muduo%E5%BA%93-ThreadLocalSingleton%E7%B1%BB/"/>
    <url>/2023/06/28/muduo%E5%BA%93-ThreadLocalSingleton%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-threadlocalsingleton类">muduo库-ThreadLocalSingleton类</h1><p>ThreadLocalSingleton类图如下：</p><p><imgsrc="/img/muduo/ThreadLocalSingleton/ThreadLocalSingleton类图.png" /></p><p>ThreadLocalSingleton 类封装为了线程本地存储单例类。在 <ahref="https://gstarmin.github.io/2023/06/27/muduo%E5%BA%93-Singleton%E7%B1%BB/">Signleton</a>中提到过，常见的单例模式设计分为四种：</p><ul><li>懒汉式</li><li>双检锁</li><li>饿汉式</li><li>局部静态式</li></ul><p><code>ThreadLocalSingleton</code>类则采用了懒汉式的构建方法，而且由于是线程本地存储，则无需互斥锁来保证线程安全：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!t_value_) &#123;<br>    t_value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>    deleter_.<span class="hljs-built_in">set</span>(t_value_);<br>  &#125;<br>  <span class="hljs-keyword">return</span> *t_value_;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalSignleton 类有两个成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> __thread T* t_value_;<br><span class="hljs-type">static</span> Deleter deleter_;<br></code></pre></td></tr></table></figure><p>其中，<code>t_value_</code> 用于构建单例对象，由于 <code>T*</code>为指针类型，即 <code>POD</code> 类型，因此可以使用 <code>__thread</code>关键字进行修饰，使其成为线程本地存储数据，而无需使用<code>ThreadLocal</code> 类型。其次，<code>deleter_</code>变量则用于声明一个 Deleter 类对象，该类用于销毁<code>t_value_</code>所指的对象，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deleter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Deleter</span>() &#123;<br>    <span class="hljs-built_in">pthread_key_create</span>(&amp;pkey_, &amp;ThreadLocalSingleton::destructor);<br>  &#125;<br> <br>  ~<span class="hljs-built_in">Deleter</span>() &#123;<br>    <span class="hljs-built_in">pthread_key_delete</span>(pkey_);<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T* newObj)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">pthread_getspecific</span>(pkey_) == <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_setspecific</span>(pkey_, newObj);<br>  &#125;<br> <br>  <span class="hljs-type">pthread_key_t</span> pkey_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，<code>Deleter</code> 是一个 <code>TSD</code>(Thread SpecificData) 类型，只为线程本地所拥有。类似于 <code>ThreadLocal</code>类型，它使用 <strong>RAII</strong> 方式，在构造函数中创建<code>key</code>，以绑定 <code>ThreadLocalSingleton</code>类中的销毁函数，而在析构函数中则删除 <code>key</code>。</p><p>销毁对象的函数则如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-type">void</span>* obj)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(obj == t_value_);<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];<br>  T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy;<br>  <span class="hljs-keyword">delete</span> t_value_;<br>  t_value_ = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，首先判断类型 <code>T</code>是否为不完全类型，如果是，则会在编译期发生错误，否则可以调用<code>delete</code> 以调用析构函数，销毁该对象。</p><h2 id="总结">总结</h2><p><code>ThreadLocalSingleton</code> 类的结构图如下：</p><p><imgsrc="/img/muduo/ThreadLocalSingleton/ThreadLocalSingleton结构图.png" /></p><p>参考：</p><ul><li><ahref="https://www.cnblogs.com/tuilk/p/16796365.html#threadlocalsingleton">Muduo库之线程</a></li><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89069063">muduo/base库学习笔记（9）-----ThreadLocalSingleton类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Threadlocal类</title>
    <link href="/2023/06/27/muduo%E5%BA%93-Threadlocal%E7%B1%BB/"/>
    <url>/2023/06/27/muduo%E5%BA%93-Threadlocal%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-threadlocal类">muduo库-Threadlocal类</h1><p>首先来看一个概念：<strong>线程特定数据</strong></p><p>在单线程程序中，我们经常用全局变量共享数据。多线程环境下，全部变量被所有线程所共有。但有时应用程序设计中有必要提供线程私有的全局变量，仅在某个线程中有效。POSIX线程库通过维护一定的数据结构来解决这个问题，这些数据称之为<strong>线程特定数据(Thread-specificData，或TSD)</strong>。对于POD类型，可以用__thread来解决。</p><div class="admonition note"><p class="admonition-title">POD类型</p><p>POD(Plain Old Data)类型是C++ 定义的一类数据结构概念，比如 int、float等都是 POD 类型的。Plain 代表它是一个普通类型，Old代表它是旧的，与几十年前的 C 语言兼容，那么就意味着可以使用 memcpy()这种最原始的函数进行操作。两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有POD特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变。也就是说，能用C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据。</p></div><p>POSIX线程库通过四个函数操作线程特定数据，分别是<code>pthread_key_create</code>，<code>pthread_key_delete</code>，<code>pthread_getspecific</code>，<code>pthread_setspecific</code>。</p><p><img src="/img/muduo/ThreadLocal/线程特定数据.png" /></p><p>一旦某个线程创建了一个<code>key</code>，比如<code>key[1]</code>，那么其他线程也有自己的<code>key[1]</code>，它们通过各自的<code>key[1]</code>访问到的实际数据（堆上内存分配的空间）是不同的，<code>pthread_key_delete</code>只是删除<code>key</code>，实际数据空间的释放需要在<code>pthread_key_create</code>中注册一个回调函数<code>destructor</code>去<code>delete T*</code>。</p><p><code>ThreadLocal</code>类结构图如下：</p><p><img src="/img/muduo/ThreadLocal/ThreadLocal结构图.png" /></p><p>类的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_THREADLOCAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_THREADLOCAL_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Mutex.h&gt;</span>  <span class="hljs-comment">// MCHECK</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ThreadLocal</span>()<br>  &#123;<br>    <span class="hljs-comment">//构造函数中创建key，数据的销毁由destructor来销毁</span><br>    <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_key_create</span>(&amp;pkey_, &amp;ThreadLocal::destructor));  <br>  &#125;<br> <br>  ~<span class="hljs-built_in">ThreadLocal</span>()<br>  &#123;<br>    <span class="hljs-comment">//析构函数中销毁key</span><br>    <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_key_delete</span>(pkey_));<br>  &#125;<br> <br>  <span class="hljs-comment">//获取线程特定数据</span><br>  <span class="hljs-function">T&amp; <span class="hljs-title">value</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    T* perThreadValue = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-built_in">pthread_getspecific</span>(pkey_)); <span class="hljs-comment">//通过key获取线程特定数据</span><br>    <span class="hljs-keyword">if</span> (!perThreadValue)  <span class="hljs-comment">//如果是空的，说明特定数据还没有创建，那么就空构造一个</span><br>    &#123;<br>      T* newObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>      <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_setspecific</span>(pkey_, newObj));  <span class="hljs-comment">//设置特定数据</span><br>      perThreadValue = newObj;   <span class="hljs-comment">//返回</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> *perThreadValue;   <span class="hljs-comment">//返回对象引用，所以需要*</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-type">void</span> *x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    T* obj = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(x);<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];   <span class="hljs-comment">//检测是否是完全类型</span><br>    T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy; <br>    <span class="hljs-keyword">delete</span> obj;   <span class="hljs-comment">//如果是，我们就可以删除它了</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">pthread_key_t</span> pkey_;    <span class="hljs-comment">//key的类型是pthread_key_t类型</span><br>&#125;;<br> <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>muduo库注册的destroy()函数直接将它的入口参数x指针强制转化为T类型指针。然后直接调用delete。这是什么原因呢？</p><p>在pthread_key_create()函数中，传入了一个&amp;ThreadLocal::destructor的成员指针，当线成局部变量销毁时，如果传入的第二个参数不为NULL，系统将调用该函数取销毁实际的数据。由于是类成员函数，隐藏了一个指针是this指针，这时候void*x，x的地址实际上就是this的地址，也就是该对象的地址。</p><p>上面我们知道，<code>ThreadLocal</code>类只有一个成员，就是<code>pthread_key_t</code>类型成员<code>pkey_</code>(不是指针类型)，我们可以再回头看<code>pthread_key_create()</code>函数，我们发现它传入的第一个参数正是pkey_的地址，也就是pthread_key_t*类型。所以我们在<code>destructor()</code>函数中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T* obj = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(x);<br><span class="hljs-keyword">delete</span> obj; <br></code></pre></td></tr></table></figure><p>由于<code>pkey_</code>是传入<code>pthread_key_create()</code>的第一个参数，所以它的地址就是实际数据存放的地址。而<code>(void*)this == (void*)&amp;pkey_</code>，所以直接强制转化<code>this</code>指针为<code>T*</code>类型，然后以<code>T*</code>类型的方式<code>delete</code>，就会真实释放线程局部存储的数据。</p><p>参考：</p><ul><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89066789">muduo/base库学习笔记-ThreadLocal类</a></li><li><ahref="https://blog.csdn.net/FreeeLinux/article/details/53431275">muduo库的ThreadLocal类剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Singleton类</title>
    <link href="/2023/06/27/muduo%E5%BA%93-Singleton%E7%B1%BB/"/>
    <url>/2023/06/27/muduo%E5%BA%93-Singleton%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-singleton类">muduo库-Singleton类</h1><h2 id="singleton类的实现">Singleton类的实现</h2><p>常见的单例模式实现主要分为以下几种：</p><h3 id="懒汉式">懒汉式</h3><p>懒汉式要求先声明单例对象，然后在调用时才完成实例化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Signleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>      instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>  <span class="hljs-type">static</span> Signleton* instance;<br>&#125;;<br> <br>Signleton* Signleton::instance = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>这种写法并没有考虑到多线程的情况，因此在多线程情况下可能产生多个实例对象，违背单例原则。</p><h3 id="双检锁">双检锁</h3><p>为了解决 “懒汉式”中存在的多线程问题，我们可以通过互斥锁来避免多个实例的创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>      mutex.<span class="hljs-built_in">lock</span>();<br>      <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Signleton</span>();<br>      &#125;<br>      mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>      instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>  <span class="hljs-type">static</span> Signleton* instance;<br>  <span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> mutex;<br>&#125;;<br> <br>Signleton* Signleton::instance = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">pthread_mutex_t</span> Signleton::mutex = PTHREAD_MUTEX_INITIALIZER;<br></code></pre></td></tr></table></figure><p>进行两次判断以避免多次加锁和解锁操作，保证线程安全。这两次判空的意义如下：</p><ul><li>第一层判空是为了提高效率，即当有一个线程 new出来对象后，第二个线程就不用竞争第一个线程的对象锁而进行等待；</li><li>第二层判空是为了保证线程安全，防止多次实例化操作；</li></ul><p>但是，如果该单例对象比较大，那么加锁操作就会成为一个性能瓶颈。</p><h3 id="饿汉式">饿汉式</h3><p>为了解决双检锁所存在的性能瓶颈问题，设计出了 “饿汉式”的单例模式。饿汉式则要求单例对象的声明和实例化同时完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>      instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>  <span class="hljs-type">static</span> Signleton* instance;<br>&#125;;<br> <br>Signleton* Signleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Signleton</span>();<br></code></pre></td></tr></table></figure><p>因为单例对象的静态初始化是在程序开始之前，在静态资源区中已经初始化了实例对象，所以静态初始化也就保证了线程安全性。在性能要求较高时，可以采用这种方式，从而避免了频繁的加锁、解锁操作造成的资源浪费。</p><h3 id="静态内部类">静态内部类</h3><p>但是如果单例对象无需考虑销毁操作，单例对象的生命周期伴随着整个程序的生命周期，程序结束时，由操作系统自动回收资源。那么如果无需考虑销毁操作，则可以用静态内部类的方式进行实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> Signleton instance;<br>    <span class="hljs-keyword">return</span> &amp;instance;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="muduo库的singleton类实现">muduo库的Singleton类实现</h2><p>其类图如下图所示：</p><p><img src="/img/muduo/Singleton/Singleton类图.png" /></p><p>在 muduo 的实现中，模板类 <code>Singleton</code>的内部定义有两个静态成员变量：<code>ponce_</code>和<code>value_</code>。其中，前者是 <code>pthread_once_t</code>类型，以保证单例且线程安全。后者则是一个指针类型，指向单例对象。它们的初始化操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* Singleton&lt;T&gt;::value_ = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>类中的获取实例及初始化函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">pthread_once</span>(&amp;ponce_, &amp;Singleton::init);<br>  <span class="hljs-built_in">assert</span>(value_ != <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> *value_;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>  <span class="hljs-keyword">if</span> (!detail::has_no_destroy&lt;T&gt;::value)&#123;<br>    ::<span class="hljs-built_in">atexit</span>(destroy);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>pthread_once()</code> 保证 <code>init()</code>函数只调用一次，避免多线程竞争，保证了线程安全。而<code>has_no_destroy&lt;T&gt;</code> 则是为了判断该类型是否含有<code>no_destory()</code> 函数，如果不存在，则调用<code>atexit()</code>注册 <code>destroy()</code>函数，当程序正常终结时，调用指定的 <code>destroy()</code>函数以回收资源。</p><p>其中的 <code>has_no_destory&lt;T&gt;</code> 定义如下，这是利用了 C++中的 <strong>SFINEA(Substitution failure is not an error)</strong>机制，即“匹配失败不是错误”。具体来说，就是当重载的模板参数展开时，如果展开导致一些类型不匹配，编译器并不报错。而正好可以利用该机制来判断类是否存在某个成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_no_destroy</span> &#123;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">decltype</span>(&amp;C::no_destroy))</span></span>;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>假如类中存在 <code>no_destory()</code> 函数，那么<code>decltype(&amp;C::no_destory)</code>表达式会返回一个函数指针，该指针指向类中的 <code>no_destory()</code>函数。此时 <code>test&lt;T&gt;(0)</code> 就会匹配为<code>char test()</code> 函数，并返回 <code>char</code>，由于<code>sizeof(char)</code> 为 <code>1</code>，所以<code>sizeof(test&lt;T&gt;(0) == 1</code> 表达式会返回<code>true</code>，表示存在该函数。</p><p>假如类中不存在该函数，那么在匹配函数 <code>char test()</code>时就会匹配错误，进而选择次一级的匹配选项，即<code>int32_t test(...)</code>函数，由于该函数参数中为可变参数，所以可以接受任意类型的函数参数，<code>test&lt;T&gt;(0)</code>与该函数匹配成功，进而返回 <code>int32_t</code>。最后由于<code>sizeof(int32_t) == 1</code> 返回<code>false</code>，则表示不存在该函数。</p><p>该类中的 <code>destory()</code> 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];<br>  T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy;<br>  <span class="hljs-keyword">delete</span> value_;<br>  value_ = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中使用 <code>typedef</code>关键字定义了一个数组类型，用于在编译期判断类型 <code>T</code>是否是不完全类型，不完全类型指的是只有声明却没有定义的类，那么不完全类型在<code>delete</code> 操作时也就无法调用析构函数，因此在<code>delete value_</code> 操作之前需要判断类型 <code>T</code>是否为不完全类型。</p><p>muduo的单例模式采用模板类实现，它内部维护一个模板参数的指针，可以生成任何一个模板参数的单例。凭借SFINAE技术muduo库可以检测模板参数如果是类的话，并且该类注册了一个no_destroy()方法，那么muduo库不会去自动销毁它。否则muduo库会在init时，利用pthread_once()函数为模板参数，注册一个atexit时的destroy()垃圾回收方法，实现自动垃圾回收。智能指针也能达到类似的效果，我们平时写的单例模式在Singleton中写一个Garbage类也可以完成垃圾回收。</p><p>如果是不完全类型，那么 <code>sizeof(T) == 0</code> 为真，数组大小为<code>-1</code>，编译错误；如果是完全类型，那么<code>sizeof(T) == 0</code> 为假，数组大小为<code>1</code>，编译成功。</p><h2 id="总结">总结</h2><p>Singleton类的整体结构如下：</p><p><img src="/img/muduo/Singleton/Singleton.png" /></p><!-- ## Singleton类的实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_SINGLETON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_SINGLETON_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">// atexit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">namespace</span> detail<br>&#123;<br><span class="hljs-comment">//不能侦测继承的成员函数</span><br><span class="hljs-comment">// This doesn&#x27;t detect inherited member functions!</span><br><span class="hljs-comment">// http://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_no_destroy</span>      <br>&#123;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-title">test</span><span class="hljs-params">(typeof(&amp;C::no_destroy))</span></span>; <span class="hljs-comment">// or decltype in C++11</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>;    <span class="hljs-comment">//判断如果是类的话，是否有no_destroy方法。</span><br>&#125;;<br>&#125;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span>   <span class="hljs-comment">//得到对象</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">pthread_once</span>(&amp;ponce_, &amp;Singleton::init);   <span class="hljs-comment">//第一次调用会在init函数内部创建，pthread_once保证该函数只被调用一次！！！！</span><br>       <span class="hljs-comment">//并且pthread_once()能保证线程安全，效率高于mutex</span><br>    <span class="hljs-built_in">assert</span>(value_ != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> *value_;    <span class="hljs-comment">//利用pthread_once只构造一次对象</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Singleton</span>();<br>  ~<span class="hljs-built_in">Singleton</span>();<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>   <span class="hljs-comment">//客户端初始化该类</span></span><br><span class="hljs-function">  </span>&#123;<br>    value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();   <span class="hljs-comment">//直接调用构造函数</span><br>    <span class="hljs-keyword">if</span> (!detail::has_no_destroy&lt;T&gt;::value)   <span class="hljs-comment">//当参数是类且没有&quot;no_destroy&quot;方法才会注册atexit的destroy</span><br>    &#123;<br>      ::<span class="hljs-built_in">atexit</span>(destroy);   <span class="hljs-comment">//登记atexit时调用的销毁函数，防止内存泄漏</span><br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span>  <span class="hljs-comment">//程序结束后自动调用该函数销毁</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">//用typedef定义了一个数组类型，数组的大小不能为-1，利用这个方法，如果是不完全类型，编译阶段就会发现错误</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];  <span class="hljs-comment">//要销毁这个类型，这个类型必须是完全类型</span><br>    T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy;  <span class="hljs-comment">//这个</span><br> <br>    <span class="hljs-keyword">delete</span> value_;   <span class="hljs-comment">//销毁</span><br>    value_ = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">//赋空</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">pthread_once_t</span> ponce_;     <span class="hljs-comment">//pthread_once的参数</span><br>  <span class="hljs-type">static</span> T*             value_;        <span class="hljs-comment">//模板T类型的指针</span><br>&#125;;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;   <span class="hljs-comment">//初始化pthread_once</span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* Singleton&lt;T&gt;::value_ = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//静态成员外部会初始化为空</span><br> <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>muduo库与我们平时使用mutex取get_instance不同，我们平时通常在get_Instance中只产生对象，在此之前需要先手动调用init()方法。但muduo库使用了pthread_once()函数，该函数只会执行一次，且是线程安全的函数，所以只有在我们第一次get_instance()时，才会自动调用Init()方法。此后只会获取实例。--&gt;</p><p>参考：</p><ul><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89066488">muduo/base库学习笔记-Singleton类</a></li><li><ahref="https://blog.csdn.net/FreeeLinux/article/details/53428867">muduo库的Singleton类剖析</a></li><li><ahref="https://www.cnblogs.com/tuilk/p/16791415.html">Muduo库之WeakCallback、Singleton</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-BlockingQueue和BounderBlockingQueue</title>
    <link href="/2023/06/26/muduo%E5%BA%93-BlockingQueue%E5%92%8CBounderBlockingQueue/"/>
    <url>/2023/06/26/muduo%E5%BA%93-BlockingQueue%E5%92%8CBounderBlockingQueue/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-blockingqueue和bounderblockingqueue">muduo库-BlockingQueue和BounderBlockingQueue</h1><h2 id="无界阻塞队列-blockingqueue">无界阻塞队列 BlockingQueue</h2><p>muduo库的<code>BlcokingQueue</code>实际上用的生产这消费者模型。我们知道生产者消费者模型一般有两种实现方式，可以利用信号量也可以利用条件变量实现，muduo库采用条件变量实现。</p><p><code>BlockingQueue</code>比较简单，它是线程安全的，我们在外部调用它时无需加锁。</p><p><code>BlockingQueue</code>结构如下：</p><p><img src="/img/muduo/BlockingQueue/BlockingQueue结构图.png" /></p><p>其代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_BLOCKINGQUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_BLOCKINGQUEUE_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Condition.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Mutex.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">BlockingQueue</span>()<br>    : <span class="hljs-built_in">mutex_</span>(),<br>      <span class="hljs-built_in">notEmpty_</span>(mutex_),<br>      <span class="hljs-built_in">queue_</span>()    <span class="hljs-comment">//使用deque</span><br>  &#123;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span>    <span class="hljs-comment">//往阻塞队列放任务</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    queue_.<span class="hljs-built_in">push_back</span>(x);<br>    notEmpty_.<span class="hljs-built_in">notify</span>(); <span class="hljs-comment">// wait morphing saves us     //不空唤醒</span><br>    <span class="hljs-comment">// http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/</span><br>  &#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GXX_EXPERIMENTAL_CXX0X__</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    queue_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(x));<br>    notEmpty_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> emplace()</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br>  <span class="hljs-function">T <span class="hljs-title">take</span><span class="hljs-params">()</span>    <span class="hljs-comment">//取任务</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;     <span class="hljs-comment">//取任务时也要保证线程安全</span><br>    <span class="hljs-comment">// always use a while-loop, due to spurious wakeup</span><br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>())    <span class="hljs-comment">//如果为空就阻塞在这里啦，用while循环不必多说</span><br>    &#123;<br>      notEmpty_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(!queue_.<span class="hljs-built_in">empty</span>());    <span class="hljs-comment">//确保队列不空</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GXX_EXPERIMENTAL_CXX0X__</span><br>    <span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">(std::move(queue_.front()))</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">(queue_.front())</span></span>;   <span class="hljs-comment">//取出队头</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    queue_.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-comment">//弹出队头。</span><br>    <span class="hljs-keyword">return</span> front;   <span class="hljs-comment">//返回</span><br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     <span class="hljs-comment">//返回队列大小</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">size</span>();<br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">mutable</span> MutexLock mutex_;<br>  Condition         notEmpty_;<br>  std::deque&lt;T&gt;     queue_;<br>&#125;;<br> <br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// MUDUO_BASE_BLOCKINGQUEUE_H</span></span><br></code></pre></td></tr></table></figure><h2 id="有界阻塞队列-boundblockingqueue">有界阻塞队列BoundBlockingQueue</h2><p><code>BoundBlockingQueue</code>有界阻塞队列，实际上就是实现了一个循环队列。功能和上面的BlockingQueue都是一样的。</p><p><imgsrc="/img/muduo/BlockingQueue/BoundBlockingQueue结构图.png" /></p><p>muduo库实现该队列实际上是内部把<code>boost::circular_buffer</code>类作为底层数据结构实现的。</p><p>其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Condition.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Mutex.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/circular_buffer.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBlockingQueue</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BoundedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span></span><br><span class="hljs-function">    : mutex_(),</span><br><span class="hljs-function">      notEmpty_(mutex_),</span><br><span class="hljs-function">      notFull_(mutex_),</span><br><span class="hljs-function">      queue_(maxSize)</span><br><span class="hljs-function">  &#123;</span><br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">full</span>())<br>    &#123;<br>      notFull_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(!queue_.<span class="hljs-built_in">full</span>());<br>    queue_.<span class="hljs-built_in">push_back</span>(x);<br>    notEmpty_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br> <br>  <span class="hljs-function">T <span class="hljs-title">take</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>      notEmpty_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(!queue_.<span class="hljs-built_in">empty</span>());<br>    <span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">(queue_.front())</span></span>;<br>    queue_.<span class="hljs-built_in">pop_front</span>();<br>    notFull_.<span class="hljs-built_in">notify</span>();<br>    <span class="hljs-keyword">return</span> front;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">empty</span>();<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">full</span>();<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     <span class="hljs-comment">//返回大小</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">size</span>();<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     <span class="hljs-comment">//返回容量</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">capacity</span>();<br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">mutable</span> MutexLock          mutex_;<br>  Condition                  notEmpty_;<br>  Condition                  notFull_;<br>  boost::circular_buffer&lt;T&gt;  queue_;      <span class="hljs-comment">//使用boost的环形缓冲区</span><br>&#125;;<br> <br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span></span><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>这两个阻塞队列其实没啥区别，只是底层采用不同数据结构存储数据而已。</p><p>参考：</p><ul><li><ahref="https://blog.csdn.net/FreeeLinux/article/details/53428629">muduo库的BlockingQueue和BoundBlockingQueue类剖析</a></li><li><ahref="https://blog.csdn.net/daaikuaichuan/article/details/86499175">【muduo】base篇-BlockingQueue和BounderBlockingQueue</a></li><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89069643">muduo/base库学习笔记-BoundedBlockingQueue类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-ThreadPool类</title>
    <link href="/2023/06/26/muduo%E5%BA%93-ThreadPool%E7%B1%BB/"/>
    <url>/2023/06/26/muduo%E5%BA%93-ThreadPool%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-threadpool类">muduo库-ThreadPool类</h1><h2 id="线程池模型">线程池模型</h2><p>模型图如下：</p><p><img src="/img/muduo/ThreadPool/线程池模型.png" /></p><p>这个是通用线程池，双端队列存放的是多个可调用对象（即用户任务），而非函数指针，因此可以通过<code>std::bind</code>配接器传参。双端队列<code>queue_</code>，有时也称为工作队列。</p><p><strong>工作原理</strong>：首先创建并启动一组线程，称为线程池<code>threads_</code>，由用户指定其大小<code>maxQueueSize_</code>，每个元素对对应一个线程。每个线程函数都是一样的，在其中会运行一个loop循环：从双端队列取出一个任务对象task，如果非空，就执行之，如此往复。当有一个用户线程想要通过线程池运行一个用户任务时，就可以将用户任务函数及参数封装成一个可调用对象Taskf，然后通过线程池接口，将f加入双端队列末尾。当线程池有线程空闲时（未执行用户任务），就会从双端队列头部取出一个Task对象task，然后执行之。</p><h2 id="threadpool结构">ThreadPool结构</h2><p><img src="/img/muduo/ThreadPool/ThreadPool.png" /></p><h2 id="线程池的构造">线程池的构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ThreadPool::<span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> string &amp;nameArg)<br>: <span class="hljs-built_in">mutex_</span>(),<br>  <span class="hljs-built_in">notEmpty_</span>(mutex_),<br>  <span class="hljs-built_in">notFull_</span>(mutex_),<br>  <span class="hljs-built_in">name_</span>(nameArg),<br>  <span class="hljs-built_in">maxQueueSize_</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">running_</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户可以指定线程池名称，默认为"ThreadPool"，便于调试跟踪，日志诊断问题；值得注意的是工作队列最大大小maxQueueSize_初值0，用户可通过setMaxQueueSize修改其大小；</p><h2 id="启动与停止">启动与停止</h2><p>用户可通过<code>start()</code>启动线程池，需要指定线程组中子线程数量，一旦创建成功后，各子线程就会投入运行，直到调用<code>stop()</code>停止线程池运行。</p><p>由于<code>Thread</code>已内含一个门阀，会让调用线程等待新线程函数启动，因此，这里不必再设置门阀等待线程池中线程的启动。相反，如果有子线程运行所需要的数据，就需要在创建之前就准备好，比如<code>running_</code>，要在线程循环前就设置为<code>true</code>，否则子线程loop不会运行，而是直接退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::start</span><span class="hljs-params">(<span class="hljs-type">int</span> numThreads)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(threads_.<span class="hljs-built_in">empty</span>());<br>    running_ = <span class="hljs-literal">true</span>;<br>    threads_.<span class="hljs-built_in">reserve</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(numThreads));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i)<br>    &#123;<br>        <span class="hljs-type">char</span> id[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(id, <span class="hljs-built_in">sizeof</span>(id), <span class="hljs-string">&quot;%d&quot;</span>, i + <span class="hljs-number">1</span>);<br>        threads_.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> muduo::<span class="hljs-built_in">Thread</span>(<br>                std::<span class="hljs-built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="hljs-keyword">this</span>), name_ + id));<br>        threads_[i]-&gt;<span class="hljs-built_in">start</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (numThreads == <span class="hljs-number">0</span> &amp;&amp; threadInitCallback_)<br>    &#123;<br>        <span class="hljs-built_in">threadInitCallback_</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        running_ = <span class="hljs-literal">false</span>;<br>        notEmpty_.<span class="hljs-built_in">notifyAll</span>();<br>        notFull_.<span class="hljs-built_in">notifyAll</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; thr : threads_)<br>    &#123;<br>        thr-&gt;<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么<code>start()</code>中不加锁，而<code>stop()</code>却要加锁？因为<code>start()</code>中，在子线程启动后，并没有对共享数据进行访问，也就不存在竞态条件。而<code>stop()</code>中，有对共享数据，如<code>running_</code>、<code>notEmpty</code>、<code>notFull</code>，因此，需要加锁对这些数据进行保护。</p><p>这里，子线程退出方式是连接（join）线程，而非分离（detach）线程。个人认为两种方案都可以，不过，join更容易在开发阶段，排查问题，因为如果线程无法正常退出，调用线程会阻塞在join调用上。</p><h2 id="往工作队列加入任务对象">往工作队列加入任务对象</h2><p>调用线程通过<code>run()</code>，向线程池的请求运行用户指定的任务对象，该对象会被加入到工作队列末尾，空闲子线程会自动从工作队列中取任务对象执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::run</span><span class="hljs-params">(Task task)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (threads_.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">// 子线程数量为0</span><br>    &#123;<br>        <span class="hljs-built_in">task</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// 子线程数量非0</span><br>        MutexLockGuard <span class="hljs-built_in">lock</span>(mutex_);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isFull</span>() &amp;&amp; running_)<br>        &#123;<br>            notFull_.<span class="hljs-built_in">wait</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!running_) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">isFull</span>());<br><br>        queue_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(task));<br>        notEmpty_.<span class="hljs-built_in">notify</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有2个特殊情况需要注意：</p><ol type="1"><li><code>threads_</code>为空，即没有创建线程，可能是用户指定线程数为<code>0</code>或非法数量（如负数），也有可能是进程创建的线程数达到系统限制，从而创建线程失败。不论什么原因，为避免进程崩溃，可以直接在当前线程中调用用户任务。</li><li>采用的是isFull()成员来判断工作队列是否满，而不是容器自带的size()来判断。在isFull()内部，添加了一个互斥锁断言，确保isFull()的调用线程已经取得了mutex_锁；否则，一旦有其他线程在未取得锁的情况下，访问应受锁保护工作队列成员，可能导致意外情况。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadPool::isFull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    mutex_.<span class="hljs-built_in">assertLocked</span>();<br>    <span class="hljs-keyword">return</span> maxQueueSize_ &gt; <span class="hljs-number">0</span> &amp;&amp; queue_.<span class="hljs-built_in">size</span>() &gt;= maxQueueSize_;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从工作队列取任务对象">从工作队列取任务对象</h2><p>用take从工作队列头部取出一个任务对象。通常是子线程空闲时调用，取出后，用来执行用户任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ThreadPool::Task <span class="hljs-title">ThreadPool::take</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-comment">// always use a while-loop, due to spurious wakeup</span><br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>() &amp;&amp; running_)<br>    &#123;<br>        notEmpty_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    Task task;<br>    <span class="hljs-keyword">if</span> (!queue_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        task = queue_.<span class="hljs-built_in">front</span>();<br>        queue_.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (maxQueueSize_ &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            notFull_.<span class="hljs-built_in">notify</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子线程loop">子线程loop</h2><p>主要工作：从工作队列取用户任务，然后执行之。循环往复，直到线程池停止工作。</p><p>实现该工作的runInThread()是在用户调用start()时，自动启动的，不需要用户自行调研。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::runInThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (threadInitCallback_)<br>        &#123;<br>            <span class="hljs-built_in">threadInitCallback_</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (running_)<br>        &#123;<br>            <span class="hljs-function">Task <span class="hljs-title">task</span><span class="hljs-params">(take())</span></span>;<br>            <span class="hljs-keyword">if</span> (task)<br>            &#123;<br>                <span class="hljs-built_in">task</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> Exception&amp; ex)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;exception caught in ThreadPool %s\n&quot;</span>, name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;reason: %s\n&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;stack trace: %s\n&quot;</span>, ex.<span class="hljs-built_in">stackTrace</span>());<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; ex)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;exception caught in TheadPool %s\n&quot;</span>, name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;reason: %s\n&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;unknown exception caught in ThreadPool %s\n&quot;</span>, name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">throw</span> ; <span class="hljs-comment">// rethrow</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，用了try-catch语句块将代码包裹起来，因为不知道用户代码会干些什么，很有可能会产生异常，因此需要捕获异常。对于不确定的异常，可以rethrow（继续上抛）。另外，threadInitCallback_让用户有机会在线程初始化完成后，运行用户任务之前，做一些事情。</p><h2 id="threadpool的使用测试">ThreadPool的使用、测试</h2><p>基本流程:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建线程池对象</span><br><span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-string">&quot;MyThreadPool&quot;</span>)</span></span>;<br><span class="hljs-comment">// 设置工作队列最大尺寸</span><br>pool.<span class="hljs-built_in">setMaxQueueSize</span>(maxSize);<br><span class="hljs-comment">// 启动线程池线程组, 指定线程数量</span><br>pool.<span class="hljs-built_in">start</span>(threadNum);<br><span class="hljs-comment">// 运行用户指定任务</span><br>pool.<span class="hljs-built_in">run</span>(userTask); <span class="hljs-comment">// userTask是用户任务（可调用对象）</span><br>...<br><span class="hljs-comment">// 停止线程池（如有需要）</span><br>pool.<span class="hljs-built_in">stop</span>();<br></code></pre></td></tr></table></figure><p>截取自muduo的部分代码，对ThreadPool进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// from muduo project</span><br><span class="hljs-comment">// muduo/base/tests/ThreadPool_test.cc</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid=%d\n&quot;</span>, muduo::CurrentThread::<span class="hljs-built_in">tid</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_INFO &lt;&lt; str;<br>    <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100</span>*<span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_WARN &lt;&lt; <span class="hljs-string">&quot;Test ThreadPool with max queue size = &quot;</span> &lt;&lt; maxSize;<br>    <span class="hljs-function">muduo::ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-string">&quot;MainThreadPool&quot;</span>)</span></span>;<br>    pool.<span class="hljs-built_in">setMaxQueueSize</span>(maxSize);<br>    pool.<span class="hljs-built_in">start</span>(<span class="hljs-number">5</span>);<br><br>    LOG_WARN &lt;&lt; <span class="hljs-string">&quot;Adding&quot;</span>;<br>    pool.<span class="hljs-built_in">run</span>(print);<br>    pool.<span class="hljs-built_in">run</span>(print);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;task %d&quot;</span>, i);<br>        pool.<span class="hljs-built_in">run</span>(std::<span class="hljs-built_in">bind</span>(printString, std::<span class="hljs-built_in">string</span>(buf))); <span class="hljs-comment">// 演示了如何向线程池加入含参的可调用对象</span><br>    &#125;<br>    LOG_WARN &lt;&lt; <span class="hljs-string">&quot;Done&quot;</span>;<br>    <br>    <span class="hljs-comment">// 演示了如何等待线程池运行完用户任务</span><br>    <span class="hljs-function">muduo::CountDownLatch <span class="hljs-title">latch</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    pool.<span class="hljs-built_in">run</span>(std::<span class="hljs-built_in">bind</span>(&amp;muduo::CountDownLatch::countDown, &amp;latch));<br>    latch.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">// wait for pool running latch.countDown()</span><br>    pool.<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有2点问题：</p><ol type="1"><li><p>run只接受一个参数，那么调用线程如何向线程池传参？解决方案有很多，一种是使用模板函数，为向工作队列加用户任务的run函数添加不定参数的重载版本；另一种，是使用std::bind配机器，向run传递一个新的可调用对象。muduo采用的是后者。</p></li><li><p>调用线程端的用户，如何获取用户任务执行结果？run()没有任何返回值，用户只能自行设计用户任务函数及参数，通过参数状态取得结果。当然，还有另外的办法就是，让run()返回一个std::future<return_type>，通过future异步获取结果。</p></li></ol><h2 id="线程池大小的选择">线程池大小的选择</h2><p>若池中执行任务时，密集计算所占用的时间比重为<spanclass="math inline">\(P(0&lt;P&lt;=1)1\)</span>,而系统一共有<spanclass="math inline">\(C\)</span>个CPU，为了让<spanclass="math inline">\(C\)</span>个CPU都能得到充分利用而不过载，线程池大小的经验公式为：<spanclass="math inline">\(T=C/P\)</span>,即<spanclass="math inline">\(T*P=C\)</span>(让CPU刚好跑满)</p><h2 id="总结">总结</h2><p>参考：</p><ul><li><ahref="https://www.cnblogs.com/fortunely/p/15979792.html">muduo笔记线程池ThreadPool</a></li><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89073821">muduo/base库学习笔记-ThreadPool类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-线程同步CountDownLatch/Condition</title>
    <link href="/2023/06/26/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5CountDownLatch-Condition/"/>
    <url>/2023/06/26/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5CountDownLatch-Condition/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-线程同步countdownlatchcondition">muduo库-线程同步CountDownLatch/Condition</h1><h2 id="多线程同步中的问题">多线程同步中的问题</h2><p>多线程环境中，常有这样一种同步情况：一个线程等待其他所有线程完成指定工作。比如，在开启一个新线程后，虽然已经启动线程函数，很可能还有一些准备工作需要完成（如更新当前线程id，名称等信息），这样，调用线程（创建线程的线程）并不能马上投入工作，立即向新线程传递数据，可能造成未定义行为，如调用线程的某段代码依赖于子线程id。</p><p>在muduo库中使用<code>CountDownLatch</code>类来解决这个问题。</p><h2 id="condition">Condition</h2><p><code>Condition</code>类图：</p><p><img src="/img/muduo/CountDownLatch/Condition类图.png" /></p><p><code>Condition</code>类是muduo库中对系统线程条件变量类函数进行的封装；往往跟<code>mutexlock</code>配合使用，但也不控制其对象的生存期。</p><p><img src="/img/muduo/CountDownLatch/Condition结构图.png" /></p><p>整个condition类主要为方便用户使用，封装<code>pthread_cond_signal为notify()</code>，封装<code>pthread_cond_broadcast</code>为<code>notifyAll()</code>;封装<code>pthread_cond_wait</code>为<code>wait()</code>；封装<code>pthread_cond_timedwait</code>为<code>waitForSeconds()</code>;</p><h2 id="countdownlatch">CountDownLatch</h2><p><code>CountDownLatch</code> 也被称为门阀 、计数器 或者闭锁。用于多个线程之间的同步，特别是一个线程等待另一个或多个线程。<code>CountDownLatch</code>类图如下：</p><p><img src="/img/muduo/CountDownLatch/CountDownLatch类图.png" /></p><p><code>CountDownLatch</code>内部持有一个向下计数的计数器<code>count_</code>，构造时给定一个初值，代表需要等待的线程数。每个线程完成一个任务，<code>count_</code>减1，当<code>count_</code>值减到0时，代表所有线程已经完成了所有任务，在<code>CountDownLatch</code>上等待的线程就可以继续执行了。</p><p><img src="/img/muduo/CountDownLatch/CountDownLatch结构图.png" /></p><h3 id="countdownlatch的接口">CountDownLatch的接口</h3><p>需要等待其他线程完成任务的线程，调用<code>wait()</code>，等待<code>count_</code>变为0；</p><p>任务线程，如果完成了任务，就调用<code>countDown()</code>，将<code>count_</code>计数值<code>-1</code>，值减到<code>0</code>时，会唤醒所有等待线程继续执行；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Count down from a count user specified to zero.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Thread safe.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Wait until count_ decrease to 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Decrease 1 in count_</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the value of count_</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> MutexLock mutex_;<br>    <span class="hljs-function">Condition cond_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> count_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="countdownlatch的实现">CountDownLatch的实现</h3><p>通过<code>mutex_</code>，确保所有对<code>count_</code>的操作，都是线程安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CountDownLatch::<span class="hljs-built_in">CountDownLatch</span>(<span class="hljs-type">int</span> count) : <span class="hljs-built_in">mutex_</span>(), <span class="hljs-built_in">cond_</span>(mutex_), <span class="hljs-built_in">count_</span>(count)<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountDownLatch::wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">while</span> (count_ &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cond_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Count down count_ from init value to 0, then notify thread</span><br><span class="hljs-comment">* waiting on the condition cond_.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountDownLatch::countDown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    --count_;<br>    <span class="hljs-keyword">if</span> (count_ == <span class="hljs-number">0</span>)<br>    &#123;<br>        cond_.<span class="hljs-built_in">notifyAll</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountDownLatch::getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> count_;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://www.cnblogs.com/fortunely/p/15944815.html">muduo笔记线程同步CountDownLatch</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-lambda递归调用的问题</title>
    <link href="/2023/06/26/Cpp-lambda%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/26/Cpp-lambda%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp-lambda递归调用的问题">Cpp-lambda递归调用的问题</h1><p>今天写了一个<code>lambda</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function&lt;<span class="hljs-type">bool</span>(TreeNode*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>)&gt; isBST = [](TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> <span class="hljs-type">long</span> upper)<br>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root-&gt;right, root-&gt;val, upper);<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后发现报错了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Line 23: Char 20: error: variable &#x27;isBST&#x27; cannot be implicitly captured in a lambda with no capture-default specified<br>            return isBST(root-&gt;left, lower, root-&gt;val) &amp;&amp; isBST(root-&gt;right, root-&gt;val, upper);<br>                   ^<br>Line 16: Char 57: note: &#x27;isBST&#x27; declared here<br>        function&lt;bool(TreeNode*, long long, long long)&gt; isBST = [](TreeNode* root, long long lower, long long upper)<br>                                                        ^<br>Line 16: Char 65: note: lambda expression begins here<br>        function&lt;bool(TreeNode*, long long, long long)&gt; isBST = [](TreeNode* root, long long lower, long long upper)<br></code></pre></td></tr></table></figure><p>究其原因是在定义的时候<code>lambda</code>使用了按值捕获，而<code>lambda</code>表达式不能隐式capture，所以需要改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function&lt;<span class="hljs-type">bool</span>(TreeNode*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>)&gt; isBST = [&amp;](TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> <span class="hljs-type">long</span> upper)<br><span class="hljs-comment">//                                                       ^这里一定要使用引用捕获                                                        </span><br>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root-&gt;right, root-&gt;val, upper);<br>&#125;;<br></code></pre></td></tr></table></figure><p>之所以使用引用捕获而不是值捕获，原因是捕获的时候，fact还没有初始化。</p><p>这个问题其实和下面的代码问题是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <span class="hljs-comment">// not initialized</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref_n = n;<br><span class="hljs-type">int</span> val_n = n;<br>n = <span class="hljs-number">10</span>; <span class="hljs-comment">// initialized</span><br>cout &lt;&lt; <span class="hljs-string">&quot;n is &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;, ref_n is &quot;</span> &lt;&lt; ref_n &lt;&lt; <span class="hljs-string">&quot;, val_n is &quot;</span> &lt;&lt; val_n &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n is 10, ref_n is 10, val_n is 4198713<br></code></pre></td></tr></table></figure><p><code>n</code>和<code>ref_n</code>都能获得正确的值，但<code>val_n</code>就不一定能打印出什么来了。这就是因为，在使用<code>operator=</code>的时候，<code>val_n</code>将未初始化的<code>n</code>复制了一份，而之后<code>n</code>的初始化和<code>val_n</code>就无关了，所以<code>val_n</code>虽然初始化了，但和没初始化一样。</p><p>参考<ahref="https://zhuanlan.zhihu.com/p/414509010">C++中的递归lambda，以及携带额外变量</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-线程类Thread，当前线程类CurrentThread</title>
    <link href="/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E7%B1%BBThread%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%B1%BBCurrentThread/"/>
    <url>/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E7%B1%BBThread%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%B1%BBCurrentThread/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-线程类thread当前线程类currentthread">muduo库-线程类Thread，当前线程类CurrentThread</h1><h2 id="线程类thread要解决的问题">线程类Thread要解决的问题</h2><p>从用户角度，一个线程类应该要提供什么给用户？</p><p>线程类最核心的内容显然是为用户提供另一个执行流，让用户程序能以线程方式并发执行（调用线程与新线程“同时”执行），但同时能共享同一个进程的内存空间。同时，作为用户，我们希望能对这个线程设置用户提供的线程函数，还有对线程进行控制，包括启动、停止、回收资源（连接）；获得这个线程在内核或线程库中的线程id，是否已启动、是否已连接（被回收资源）等状态信息。为了方便调试、打印/查看log，我们可能还需要为线程设置标识，如用户指定的线程id和线程名称等信息。</p><p>现有的线程能提供什么？<br />Linux下，C++ 11 std::thread也是用NPTL提供的pthreads实现的，因此，我们主要考虑pthreads。</p><p>pthreads主要接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span></span>;<br><span class="hljs-comment">// 连接线程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span></span>;<br><span class="hljs-comment">// 分离线程, 线程分离后, 调用线程无需其他线程join</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><span class="hljs-comment">// 退出调用线程,</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br><span class="hljs-comment">// 取消(指定)线程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><span class="hljs-comment">// 判断2个线程id是否相同</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_equal</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span></span>;<br></code></pre></td></tr></table></figure><p>注：以上线程函数的使用，都需要用-pthread编译、链接。</p><h2 id="封装线程类thread">封装线程类Thread</h2><p>根据pthreads接口pthread_*，Thread要实现：</p><ul><li>基本线程的原语：线程的创建和等待结束。</li><li>线程控制的状态：是否已经创建（启动），是否已经结束（连接）。</li><li>线程属性：线程id，线程名称。</li><li>线程统计信息：通过Thread class创建的线程数量。</li></ul><p>线程类的拷贝没有实际意义，因为线程会对应内核中的数据结构，运行状态等。</p><h3 id="thread-接口">Thread 接口</h3><p>因此，我们可以为Thread设计如下接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; ThreadFunc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadFunc, <span class="hljs-type">const</span> string&amp; nameArg = string())</span></span>;<br>    ~<span class="hljs-built_in">Thread</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> started_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">pthread_t</span> <span class="hljs-title">pthreadId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pthreadId_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> tid_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> string&amp; <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">numCreated</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> numCreated_.<span class="hljs-built_in">get</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDefaultName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">bool</span> started_;    <span class="hljs-comment">// 启动状态</span><br>    <span class="hljs-type">bool</span> joined_;     <span class="hljs-comment">// 连接状态</span><br>    <span class="hljs-type">pthread_t</span> pthreadId_; <span class="hljs-comment">// 用来绑定NPTL线程</span><br>    <span class="hljs-type">pid_t</span> tid_;       <span class="hljs-comment">// 当前线程tid, 通过CurrentThread::tid()获取</span><br>    ThreadFunc func_; <span class="hljs-comment">// 用户设置的线程函数</span><br>    string name_;     <span class="hljs-comment">// 用户自定义名称, 用于debug, log</span><br>    CountDownLatch latch_; <span class="hljs-comment">// 向下计数器, 用于同步调用线程和新线程</span><br><br>    <span class="hljs-type">static</span> AtomicInt32 numCreated_; <span class="hljs-comment">// 原子类型, Thread class已经创建的线程数量</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="thread-实现">Thread 实现</h3><p>Thread对象构造，决定了数据成员的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">AtomicInt32 Thread::numCreated_;<br><br>Thread::<span class="hljs-built_in">Thread</span>(Thread::ThreadFunc func, <span class="hljs-type">const</span> string&amp; nameArg)<br>: <span class="hljs-built_in">started_</span>(<span class="hljs-literal">false</span>),<br>  <span class="hljs-built_in">joined_</span>(<span class="hljs-literal">false</span>),<br>  <span class="hljs-built_in">pthreadId_</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">tid_</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">func_</span>(std::<span class="hljs-built_in">move</span>(func)),<br>  <span class="hljs-built_in">name_</span>(nameArg),<br>  <span class="hljs-built_in">latch_</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 计数器初值为1, 只需要等待一个线程任务完成</span><br>&#123;<br>    <span class="hljs-built_in">setDefaultName</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* default Thread name: Thread + id (self-defined increased atomic id starts with 1)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::setDefaultName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = numCreated_.<span class="hljs-built_in">incrementAndGet</span>();<br>    <span class="hljs-keyword">if</span> (name_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;Thread%d&quot;</span>, num);<br>        name_ = buf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>latch_是用来解决调用线程和新线程的同步问题的。只有新线程准备好了以后，调用线程才能继续正常运行。因此，初值为1；<br /></li><li>setDefaultName()利用类的原子变量numCreated_，来组装构建线程对象的名称（name_）。</li></ol><p>start()中创建线程，并启动线程函数；join()连接线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(!started_); <span class="hljs-comment">//to avoid repeated start()</span><br>    started_ = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> move(func_)</span><br>    detail::ThreadData* data = <span class="hljs-keyword">new</span> detail::<span class="hljs-built_in">ThreadData</span>(func_, name_, &amp;tid_, &amp;latch_);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pthreadId_, <span class="hljs-literal">NULL</span>, &amp;detail::startThread, data))<br>    &#123; <span class="hljs-comment">// non-zero: error</span><br>        started_ = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">delete</span> data; <span class="hljs-comment">// or no delete?</span><br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in pthread_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// zero: success</span><br>        latch_.<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-built_in">assert</span>(tid_ &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(started_);<br>    <span class="hljs-built_in">assert</span>(!joined_);<br>    joined_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 置连接状态</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_join</span>(pthreadId_, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 连接线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>1）我们并没有直接启动线程函数，而是先构建一个自定义内部类ThreadData对象，包含了线程相关信息，然后再传递给新线程函数。<br />2）线程创建pthread_create失败时，调用LOG_SYSFATAL，会打印log并直接导致程序终止；成功时，会利用latch_等待新线程函数启动运行到指定位置（已经设置好线程tid）。<br />3）我们将pthread_create线程函数交给detail::startThread来执行，而该函数内部又通过传入的ThreadData参数，将运行ThreadData::runInThread()，再在其中运行用户设置的线程函数。而这个函数，是在Thread构建时，由用户指定的。</p><h3 id="内部类threaddata">内部类ThreadData</h3><p>自定义的线程数据结构ThreadData，作为实现细节，包含在detail命名空间即可。<br />ThreadData主要实现：<br />1）新线程通用数据的封装；<br />2）新线程的启动与调用线程的同步；<br />3）try-catch 捕捉并处理用户传入的线程函数异常；<br />4）调用prctl修改线程在内核中的名称；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadData</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;<br>    ThreadFunc func_;<br>    string name_;<br>    <span class="hljs-type">pid_t</span>* tid_;<br>    CountDownLatch* latch_;<br><br>    <span class="hljs-built_in">ThreadData</span>(ThreadFunc func,<br>               <span class="hljs-type">const</span> string&amp; name,<br>               <span class="hljs-type">pid_t</span>* tid,<br>               CountDownLatch* latch)<br>               : <span class="hljs-built_in">func_</span>(std::<span class="hljs-built_in">move</span>(func)),<br>               <span class="hljs-built_in">name_</span>(name),<br>               <span class="hljs-built_in">tid_</span>(tid),<br>               <span class="hljs-built_in">latch_</span>(latch)<br>    &#123; &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set Thread name, tid</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * run thread func set by ctor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        *tid_ = muduo::CurrentThread::<span class="hljs-built_in">tid</span>(); <span class="hljs-comment">// help to cache current thread tid</span><br>        tid_ = <span class="hljs-literal">NULL</span>;<br>        latch_-&gt;<span class="hljs-built_in">countDown</span>();<br>        latch_ = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// as latch_&#x27;s member count_ init value = 1, abandon it after countDown()</span><br><br>        muduo::CurrentThread::t_threadName = name_.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;muduoThread&quot;</span> : name_.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-comment">// Set the name of the calling thread</span><br>        ::<span class="hljs-built_in">prctl</span>(PR_SET_NAME, muduo::CurrentThread::t_threadName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">func_</span>();<br>            muduo::CurrentThread::t_threadName = <span class="hljs-string">&quot;finished&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (...)<br>        &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="当前线程currentthread">当前线程CurrentThread</h2><p>muduo中有个很特殊的命名空间：muduo::CurrentThread。CurrentThread包含了线程的本地数据（threadlocal），以及对调用线程的若干操作。</p><p>thread local数据主要包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CurrentThread.h</span><br><span class="hljs-comment">// thread local</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">int</span> t_cachedTid;      <span class="hljs-comment">// 缓存线程tid</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">char</span> t_tidString[<span class="hljs-number">32</span>]; <span class="hljs-comment">// 线程tid的字符串形式</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">int</span> t_tidStringLength; <span class="hljs-comment">// t_tidStringLength的实际长度</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">const</span> <span class="hljs-type">char</span>* t_threadName; <span class="hljs-comment">// 线程名称</span><br><br><span class="hljs-comment">// CurrentThread.cc</span><br>__thread <span class="hljs-type">int</span> t_cachedTid = <span class="hljs-number">0</span>;<br>__thread <span class="hljs-type">char</span> t_tidString[<span class="hljs-number">32</span>];<br>__thread <span class="hljs-type">int</span> t_tidStringLength = <span class="hljs-number">6</span>;<br>__thread <span class="hljs-type">const</span> <span class="hljs-type">char</span>* t_threadName = <span class="hljs-string">&quot;unknown&quot;</span>;<br><span class="hljs-built_in">static_assert</span>(std::is_same&lt;<span class="hljs-type">int</span>, <span class="hljs-type">pid_t</span>&gt;::value, <span class="hljs-string">&quot;pit_t should be int&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：这里有个static_assert，用于编译期断言线程tid的类型pid_t是否与int相同。</p><h3 id="cachetid获取当前线程tid">cacheTid()获取当前线程tid</h3><p>前面https://www.cnblogs.com/fortunely/p/15930558.html，已经提到：因为pthread_self()获得的pthread_t类型的线程id，是glibc维护的一个动态分配的内存指针，而且是反复使用的，容易导致线程id值重复。因此我们用系统调用gettid，来获取Linux线程id。<br />考虑到线程id在线程创建后并不会改变，为了避免频繁系统调用，我们用threadlocal变量t_cachedTid在第一次请求线程id时，通过gettid系统调用缓存线程id，其他时候，直接返回该缓存值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CurrentThread::cacheTid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (t_cachedTid == <span class="hljs-number">0</span>)<br>    &#123;<br>        t_cachedTid = detail::<span class="hljs-built_in">gettid</span>();<br>        t_tidStringLength = <span class="hljs-built_in">snprintf</span>(t_tidString, <span class="hljs-built_in">sizeof</span>(t_tidString), <span class="hljs-string">&quot;%5d &quot;</span>, t_cachedTid);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">detail::gettid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">pid_t</span>&gt;(::<span class="hljs-built_in">syscall</span>(SYS_gettid));<br>&#125;<br></code></pre></td></tr></table></figure><h3id="ismainthread判断调用线程是否为main线程">isMainThread()判断调用线程是否为main线程</h3><p>Linux中，线程本质上是通过进程来实现的，也就是说，新建线程对应tid跟pid的值是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Only main thread&#x27;s tid == ::getpid()</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CurrentThread::isMainThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tid</span>() == ::<span class="hljs-built_in">getpid</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sleepusec-休眠指定微秒数">sleepUsec() 休眠指定微秒数</h3><p>通过系统调用nanosleep实现休眠功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CurrentThread::sleepUsec</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> usec)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> ts = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    ts.tv_sec = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">time_t</span>&gt;(usec / Timestamp::kMicroSecondsPerSecond);<br>    ts.tv_nsec = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span>&gt;(usec % Timestamp::kMicroSecondsPerSecond * <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">//    std::this_thread::sleep_for(std::chrono::microseconds());</span><br>    ::<span class="hljs-built_in">nanosleep</span>(&amp;ts, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么不用usleep？</strong><br />因为usleep在POSIX.1-2001不推荐使用, POSIX.1-2008中已经废除。推荐使用nanosleep。当然，C++中还可以用std::this_thread::sleep_for。</p><h2id="threadnameinitializer类初始化main线程信息">ThreadNameInitializer类初始化main线程信息</h2><p>有没有一种办法，能初始化main线程信息，包括线程名、tid？<br />答案是有的，可以设置一个全局对象，在构造时就初始化调用线程信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadNameInitializer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadNameInitializer</span>() <span class="hljs-comment">// 线程名称初始化</span><br>    &#123;<br>        muduo::CurrentThread::t_threadName = <span class="hljs-string">&quot;main&quot;</span>; <span class="hljs-comment">// 初始化线程名</span><br>        CurrentThread::<span class="hljs-built_in">tid</span>(); <span class="hljs-comment">// 缓存tid</span><br>        <span class="hljs-built_in">pthread_atfork</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;childAfterFork); <span class="hljs-comment">// 清除fork子进程对应线程信息</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> ThreadNameInitializer init; <span class="hljs-comment">// 全局变量，会由mian线程构造对象</span><br></code></pre></td></tr></table></figure><p>由于线程信息在初始化以后，并不会自行改变：tid是缓存一次，线程名是不会变化。如果在main线程中，fork创建子进程，子进程对应线程也会继承父线程（main）的线程信息，显然，这不是我们想要的。我们需要专门为子进程清除从父进程继承而来的线程信息。</p><p>因此，需要通过pthread_atfork，在fork结束前，子进程中注册用于清理子进程的main线程信息的清理函数childAfterFork。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childAfterFork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    muduo::CurrentThread::t_cachedTid = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear child tid</span><br>    muduo::CurrentThread::t_threadName = <span class="hljs-string">&quot;child&quot;</span>;<br>    CurrentThread::<span class="hljs-built_in">tid</span>();<br>    <span class="hljs-comment">// no need to call pthread_atfork(NULL, NULL, &amp;childAfterFork);</span><br>&#125;<br></code></pre></td></tr></table></figure><hr /><h2 id="知识点">知识点</h2><h3id="is_same模板判断两种类型是否相同">is_same模板判断两种类型是否相同</h3><p>如果int和pid_t是同种类型，用is_same::value将返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> sameType = std::is_same&lt;<span class="hljs-type">int</span>, <span class="hljs-type">pid_t</span>&gt;::value;<br></code></pre></td></tr></table></figure><p>本文转载自<ahref="https://www.cnblogs.com/fortunely/p/15947679.html">muduo笔记线程类Thread，当前线程CurrentThread</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-线程安全相关类MutexLock MutexLockGuard</title>
    <link href="/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%B1%BBMutexLock-MutexLockGuard/"/>
    <url>/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%B1%BBMutexLock-MutexLockGuard/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-线程安全相关类mutexlock-mutexlockguard">muduo库-线程安全相关类MutexLockMutexLockGuard</h1><h2 id="互斥锁mutex的选择">互斥锁mutex的选择</h2><p>互斥锁mutex有2种方案：</p><ul><li>C++11以后，使用<code>std::mutex</code>，当然，特殊应用场景下，也有另外三种：<code>std::recursive_mutex</code>（递归mutex类），<code>std::timed_mutex</code>（定时mutex类），<code>recurisive_timed_mutex</code>（定时递归mutex类）；</li><li>Linux平台下，使用NPTL提供的<code>pthread_mutex</code>。</li></ul><p>muduo采用第2种方案，自定义<code>MutexLock</code>对<code>pthread_mutex</code>进行了轻度包装。</p><h2 id="mutexlock类">MutexLock类</h2><p>MutexLock类，除了基础的lock/unlock，支持Condition（条件变量）外，还支持查询锁的持有线程tid（holder），断言当前线程是否持有锁等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CAPABILITY, RELEASE, ASSERT_CAPABILITY等宏定义适用于clang/SWIG编译器下的线程安全</span><br><span class="hljs-comment">// 其他编译器如GCC可以安全擦除, 这里保留, 可以作为标记提醒程序员</span><br><br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">CAPABILITY</span><span class="hljs-params">(<span class="hljs-string">&quot;mutex&quot;</span>)</span> MutexLock : public noncopyable</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MutexLock</span>()<br>    : <span class="hljs-built_in">holder_</span>(<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="hljs-literal">NULL</span>)); <span class="hljs-comment">// 宏函数MCHECK, 用于检查库函数/系统调用的返回值</span><br>    &#125;<br>    ~<span class="hljs-built_in">MutexLock</span>()<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(holder_ == <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex_));<br>    &#125;<br>    <span class="hljs-comment">// must be called when locked, i.e. for assertion</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLockedByThisThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 断言 当前调用线程持有锁, 失败返回false, 不会导致程序终止</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> holder_ == CurrentThread::<span class="hljs-built_in">tid</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assertLocked</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">ASSERT_CAPABILITY</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> <span class="hljs-comment">// 断言 调用线程持有锁, 会导致程序终止, 用于debug</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isLockedByThisThread</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// internal usage</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * lock mutex_ and check lock status.</span><br><span class="hljs-comment">     * assign current thread&#x27;s tid as the lock&#x27;s holder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-title">ACQUIRE</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex_));<br>        <span class="hljs-built_in">assignHolder</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * unassign the lock&#x27;s holder, then unlock mutex_.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> <span class="hljs-title">RELEASE</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">unassignHolder</span>();<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex_));<br>    &#125;<br>    <span class="hljs-comment">/* non-const, because return a pointer to class&#x27;s (private) data */</span><br>    <span class="hljs-function"><span class="hljs-type">pthread_mutex_t</span>* <span class="hljs-title">getPthreadMutex</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;mutex_;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Condition</span>;<br><br>    <span class="hljs-comment">/* give up the MutexLock */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnassignGuard</span> : <span class="hljs-keyword">public</span> noncopyable <span class="hljs-comment">// 用于放弃锁, 如条件变量中需要放弃锁时可用到</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">UnassignGuard</span><span class="hljs-params">(MutexLock&amp; owner)</span></span><br><span class="hljs-function">        : owner_(owner)</span><br><span class="hljs-function">        &#123;</span><br>            owner_.<span class="hljs-built_in">unassignHolder</span>(); <span class="hljs-comment">// clear lock owner_ holder</span><br>        &#125;<br>        ~<span class="hljs-built_in">UnassignGuard</span>()<br>        &#123;<br>            owner_.<span class="hljs-built_in">assignHolder</span>();  <span class="hljs-comment">// set current thread as the lock holder</span><br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        MutexLock&amp; owner_; <span class="hljs-comment">// 互斥锁对象引用</span><br>    &#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set current thread as the lock holder</span><br><span class="hljs-comment">     * by assigning current thread&#x27;s tid to holder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assignHolder</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        holder_ = CurrentThread::<span class="hljs-built_in">tid</span>(); <span class="hljs-comment">// 设置锁的持有线程tid为当前线程tid</span><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * clear the lock holder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unassignHolder</span><span class="hljs-params">()</span> <span class="hljs-comment">// 清除锁的持有线程tid</span></span><br><span class="hljs-function">    </span>&#123;<br>        holder_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_mutex_t</span> mutex_;<br>    <span class="hljs-type">pid_t</span> holder_;         <span class="hljs-comment">// 持有锁的线程tid, 初值0表示无效线程</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：MutexLock是引用传递，要操作原来的MutexLock对象，需要传递引用。</p><h2 id="mutexlockguard类">MutexLockGuard类</h2><p>类同std::lock_guard，MutexLockGuard通过RAII方式管理MutexLock资源：构造MutexLockGuard对象时，取得mutex_锁；释放对象时，释放mutex_锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RAII方式管理MutexLock锁资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SCOPED_CAPABILITY</span> MutexLockGuard : <span class="hljs-keyword">public</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MutexLockGuard</span><span class="hljs-params">(MutexLock&amp; mutex)</span> <span class="hljs-title">ACQUIRE</span><span class="hljs-params">(mutex)</span></span><br><span class="hljs-function">    : mutex_(mutex)</span><br><span class="hljs-function">    &#123;</span><br>        mutex_.<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">MutexLockGuard</span>() <span class="hljs-built_in">RELEASE</span>()<br>    &#123;<br>        mutex_.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    MutexLock&amp; mutex_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="测试">测试</h2><p>思路：利用MutexLockGuard在local作用域内，获取指定MutexLock互斥锁，对全局变量进行递增操作。多个线程同时进行这一操作，最终通过判断全局变量是否为预期值，来判断MutexLock和MutexLockGuard是否正常工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MutexLock g_mutex;<br>vector&lt;<span class="hljs-type">int</span>&gt; g_vec;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kCount = <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>;<br><br><span class="hljs-type">int</span> g_count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> g_threadfunc_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span> <span class="hljs-params">((__noinline__))</span></span>; <span class="hljs-comment">// 阻止foo内联</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kCount; ++i) &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>        g_vec.<span class="hljs-built_in">push_back</span>(i);<br>        g_threadfunc_count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>    <span class="hljs-keyword">if</span> (!g_mutex.<span class="hljs-built_in">isLockedByThisThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    ++g_count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof pthread_mutex_t: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_mutex_t</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof Mutex: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(MutexLock));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof pthread_cond_t: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_cond_t</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof Condition: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(Condition));<br>    <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">foo</span>());<br>    <span class="hljs-keyword">if</span> (g_count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MCHECK calls twice.\n&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxThreads = <span class="hljs-number">8</span>;<br>    g_vec.<span class="hljs-built_in">reserve</span>(kMaxThreads * kCount);<br><br>    <span class="hljs-function">Timestamp <span class="hljs-title">start</span><span class="hljs-params">(Timestamp::now())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kCount; ++i) &#123;<br>        g_vec.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;single thread without lock %f seconds\n&quot;</span>, <span class="hljs-built_in">timeDifference</span>(Timestamp::<span class="hljs-built_in">now</span>(), start));<br><br>    start = Timestamp::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">threadFunc</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signle thread with lock %f seconds\n&quot;</span>, <span class="hljs-built_in">timeDifference</span>(Timestamp::<span class="hljs-built_in">now</span>(), start));<br><br>    <span class="hljs-comment">// 多线程核心测试部分</span><br>    <span class="hljs-comment">// multi-thread invoke threadFunc try to get the same mutex at the same time</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nthreads = <span class="hljs-number">0</span>; nthreads &lt; kMaxThreads; ++nthreads)<br>    &#123;<br>        std::vector&lt;std::unique_ptr&lt;Thread&gt;&gt; threads;<br>        g_vec.<span class="hljs-built_in">clear</span>();<br>        g_threadfunc_count = <span class="hljs-number">0</span>;<br>        start = Timestamp::<span class="hljs-built_in">now</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthreads; ++i) &#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(&amp;threadFunc));<br>            threads.<span class="hljs-built_in">back</span>()-&gt;<span class="hljs-built_in">start</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthreads; ++i) &#123;<br>            threads[i]-&gt;<span class="hljs-built_in">join</span>();<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d thread(s) with lock %f seconds\n&quot;</span>, nthreads, <span class="hljs-built_in">timeDifference</span>(Timestamp::<span class="hljs-built_in">now</span>(), start));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_threadfunc_count = %d\n&quot;</span>, g_threadfunc_count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">sizeof pthread_mutex_t: 40<br>sizeof Mutex: 48<br>sizeof pthread_cond_t: 48<br>sizeof Condition: 56<br>single thread without lock 0.166781 seconds<br>signle thread with lock 0.455777 seconds<br>0 thread(s) with lock 0.000000 seconds<br>g_threadfunc_count = 0<br>1 thread(s) with lock 0.425418 seconds<br>g_threadfunc_count = 10000000<br>2 thread(s) with lock 4.080142 seconds<br>g_threadfunc_count = 20000000<br>3 thread(s) with lock 4.136063 seconds<br>g_threadfunc_count = 30000000<br>4 thread(s) with lock 5.242511 seconds<br>g_threadfunc_count = 40000000<br>5 thread(s) with lock 6.609551 seconds<br>g_threadfunc_count = 50000000<br>6 thread(s) with lock 7.620478 seconds<br>g_threadfunc_count = 60000000<br>7 thread(s) with lock 8.231012 seconds<br>g_threadfunc_count = 70000000<br></code></pre></td></tr></table></figure><p>本文转载自<ahref="https://www.cnblogs.com/fortunely/p/15943954.html">muduo笔记线程安全相关类MutexLock, MutexLockGuard</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAII原理</title>
    <link href="/2023/06/22/RAII%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/22/RAII%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="raii原理">RAII原理</h1><blockquote><p>RAII是什么? RAII（Resource Acquisition IsInitialization）是由C++之父BjarneStroustrup提出的，中文翻译为资源获取即初始化，即使用局部对象来管理资源的技术称为资源获取即初始化；</p></blockquote><blockquote><p>这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p></blockquote><p>资源的使用一般经历三个步骤:</p><ul><li>获取资源；</li><li>使用资源；</li><li>销毁资源；</li></ul><p>但是资源的销毁往往是程序员经常忘记的一个环节；C++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期（正如本文开篇所讲）；</p><p>给一个简单的例子来看下局部对象的自动销毁的特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">person</span><span class="hljs-params">(std::string name = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">int</span> age = <span class="hljs-number">0</span>)</span> :</span><br><span class="hljs-function">            name_(std::move(name)), age_(age) &#123;</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Init a person!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">person</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destroy a person!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::string name_;<br>    <span class="hljs-type">int</span> age_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPerson</span><span class="hljs-params">()</span> </span>&#123;<br>    person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">testPerson</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Init a person!<br>Destroy a person!<br></code></pre></td></tr></table></figure><p>从person类可以看出，当我们在testPerson函数中声明一个局部对象的时候，会自动调用构造函数进行对象的初始化，当整个testPerson函数执行完成后，自动调用析构函数来销毁对象，整个过程无需人工介入，由操作系统自动完成；</p><p>于是，很自然联想到，当我们在使用资源的时候，在构造函数中进行初始化，在析构函数中进行销毁；</p><p>整个RAII过程为四个步骤：</p><ul><li><strong>设计一个类封装资源</strong>；</li><li><strong>在构造函数中初始化</strong>；</li><li><strong>在析构函数中执行销毁操作</strong>；</li><li><strong>使用时声明一个该对象的类</strong>；</li></ul><p>最后，举一个RAII在实际应用中的例子来结束本文；</p><p>Linux下经常会使用多线程技术，而在多线程中经常使用互斥锁保护临界资源一次只被一个线程访问，按照我们前面的分析，我们封装一下POSIX标准的互斥锁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mutex.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CPP_LEARN_MUTEX_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPP_LEARN_MUTEX_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mutex</span>();<br>    ~<span class="hljs-built_in">Mutex</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> mu_&#123;&#125;;<br><br>    <span class="hljs-comment">// No copying</span><br>    <span class="hljs-built_in">Mutex</span>(<span class="hljs-type">const</span> Mutex&amp;);<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Mutex&amp;);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CPP_LEARN_MUTEX_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mutex.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CPP_LEARN_TEST_MUTEX_LOCK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPP_LEARN_TEST_MUTEX_LOCK_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mutex.h&quot;</span></span><br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MutexLock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MutexLock</span><span class="hljs-params">(Mutex *mu)</span></span><br><span class="hljs-function">            : mu_(mu)  &#123;</span><br>        <span class="hljs-keyword">this</span>-&gt;mu_-&gt;<span class="hljs-built_in">Lock</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">MutexLock</span>() &#123; <span class="hljs-keyword">this</span>-&gt;mu_-&gt;<span class="hljs-built_in">Unlock</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Mutex *<span class="hljs-type">const</span> mu_;<br><br>    <span class="hljs-comment">// No copying allowed</span><br>    <span class="hljs-built_in">MutexLock</span>(<span class="hljs-type">const</span> MutexLock&amp;);<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MutexLock&amp;);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CPP_LEARN_TEST_MUTEX_LOCK_H</span></span><br></code></pre></td></tr></table></figure><p>到这里我们就真正封装了互斥锁，下面我们来通过一个简单的例子来使用它，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test_mutex_lock.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_mutex_lock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREADS 10000</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>Mutex mutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">count</span><span class="hljs-params">([[maybe_unused]] <span class="hljs-type">void</span> *args)</span> </span>&#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>    num++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">pthread_t</span> thread[NUM_THREADS];<br><br>    <span class="hljs-keyword">for</span> (t = <span class="hljs-number">0</span>; t &lt; NUM_THREADS; t++) &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;thread[t], <span class="hljs-literal">nullptr</span>, count, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (t = <span class="hljs-number">0</span>; t &lt; NUM_THREADS; t++)<br>        <span class="hljs-built_in">pthread_join</span>(thread[t], <span class="hljs-literal">nullptr</span>);<br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-时间戳类Timestamp</title>
    <link href="/2023/06/21/muduo%E5%BA%93-%E6%97%B6%E9%97%B4%E6%88%B3%E7%B1%BBTimestamp/"/>
    <url>/2023/06/21/muduo%E5%BA%93-%E6%97%B6%E9%97%B4%E6%88%B3%E7%B1%BBTimestamp/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-时间戳类timestamp">muduo库-时间戳类Timestamp</h1><h2id="如何度量程序在某一时刻的时间">如何度量程序在某一时刻的时间？</h2><p>通常，我们用时刻来表示，比如"2023-06-2623:43:00.000000"，这种方式便于人查看，但不便于程序中的比较和计算。比如有2个时刻A和B，计算哪个时刻在前，哪个在后，或者要计算时刻A和B的时间差时，这种字符串表示方式就很麻烦。</p><p>我们想到将字符串形式的时刻，用自纪元时间（Epoch时间，1970-01-0100:00:00 +0000 (UTC)）以来的时间戳来表示，精度为1us（微秒）。</p><h2 id="linux中如何获取这个时间呢">Linux中，如何获取这个时间呢？</h2><p>使用<code>gettimeofday</code>，分辨率1us，其实现也能达到毫秒级（当然分辨率不等于精度），再加上Linux是非实时任务系统，也能满足日常计时功能。前面讲过，<code>time</code>只能精确到1s，<code>ftime</code>已被废弃，<code>clock_gettime</code>精度高，但系统调用开销比<code>gettimeofday</code>大，网络编程中，最适合用<code>gettimeofday</code>来计时。muduo中也是这么做的。</p><p>有没有一种可能，两个线程，或者两段出现在1us内执行？答案是有可能的，对于常规情况，即使时间戳相同，并不影响我们的日常计时功能；对于特殊需求，比如排序、查找，需要区分时间戳大小的，后面遇到具体情况具体分析。</p><h2 id="timestamp类">Timestamp类</h2><p><img src="/img/muduo/Timestamp/Timestamp.png" /></p><p>由于时间戳希望在不同变量之间赋值、拷贝，因此设计成值语义的，继承自copyableclass。</p><p>数据成员：</p><p>成员变量<code>microSecondsSinceEpoch_</code>，用来来表示从Epoch时间到目前为止的微妙数，初值0（也表示无效值）。</p><p><code>microSecondsSinceEpoch_</code>的数据类型为什么是<code>int64_t</code>，而不是<code>int32_t</code>或者<code>uint64_t</code>？因为32位连一年的微妙数都不能表示，而<code>int64_t</code>可以表示290余年的微妙数（一年按<spanclass="math inline">\(365243600 *100000\)</span>计算），未来还能表示一百余年，也就是说，其范围满足目前日常需求。而有符号的<code>int64_t</code>可以用来让2个时间戳进行差值计算，从而表示先后顺序。当然，时间戳本身为负数没有意义。</p><h3 id="构造函数">构造函数</h3><p>可以像这样定义Timstamp及其构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Time stamp in UTC, in microseconds resolution.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timestamp</span> : <span class="hljs-keyword">public</span> copyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs an invalid Timestamp</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">Timestamp</span>() : <span class="hljs-built_in">microSecondsSinceEpoch_</span>(<span class="hljs-number">0</span>)<br>    &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a Timestamp at specific time</span><br><span class="hljs-comment">     * @param microSecondsSinceEpochArg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timestamp</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> microSecondsSinceEpochArg)</span></span><br><span class="hljs-function">            : microSecondsSinceEpoch_(microSecondsSinceEpochArg)</span><br><span class="hljs-function">    &#123;</span><br>    &#125;<br>    ...<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int64_t</span> microSecondsSinceEpoch_;<br>&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li>继承自copyable，表明这是一个值语义的class，其对象能够进行copy操作；</li><li>defaultctor（构造函数），存储时间戳变量<code>microSecondsSinceEpoch_</code>初值0，0和负数都表示无效值。同时，也提供单一参数版本<code>ctor</code>，给调用者构造指定时间戳值的Timestamp对象的机会。</li></ol><h3 id="对象有效性">对象有效性</h3><p>至于<code>microSecondsSinceEpoch_</code>符号，我们可以定义成员函数valid()判断其有效性，通过invalid()构造一个无效的Timestamp对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> microSecondsSinceEpoch_ &gt; <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> Timestamp <span class="hljs-title">invalid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Timestamp</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>gettimeofday()</code>获取当前时刻，转化为微秒，并构造一个<code>Timestamp</code>临时对象。1换算公式：sec= 1e6 usec</p><h3 id="时间换算">时间换算</h3><p>如何将由<code>time()</code>获得的自Epoch时间（1970-01-01 00:00:00+0000 (UTC).）以来的秒数（time_t类型），转化为Timestamp类型对象？</p><p>可以定义<code>fromUnixTime</code>来完成这个工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Timestamp <span class="hljs-title">fromUnixTime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fromUnixTime</span>(t, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Timestamp <span class="hljs-title">fromUnixTime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> t, <span class="hljs-type">int</span> microseconds)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Timestamp</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(t) * kMicroSecondsPerSecond + microseconds);<br>    &#125;<br></code></pre></td></tr></table></figure><p>第一个重载版本，只转换提供的秒数，微秒数默认0；第二个版本，提供了秒数和微秒数的设置</p><h3 id="对象交换">对象交换</h3><p>有时为了避免对象数据成员的拷贝，会利用swap对对象进行交换操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Timestamp&amp; that)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);<br>    &#125;<br></code></pre></td></tr></table></figure><p>就目前的设计来说，完全可以用std::swap来交换2个对象，而不用定义Timestamp::swap()。这里是为了以后方便扩展，自定义swap行为。</p><h3 id="获取时间戳">获取时间戳</h3><p>获取从Epoch时间，到目前为止的时间戳数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">microSecondsSinceEpoch</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> microSecondsSinceEpoch_;&#125;; <span class="hljs-comment">// 微秒数</span><br>    <span class="hljs-function"><span class="hljs-type">time_t</span> <span class="hljs-title">secondsSinceEpoch</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 秒数</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="获取可打印字符串">获取可打印字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">toFormattedString</span><span class="hljs-params">(<span class="hljs-type">bool</span> showMicroseconds = <span class="hljs-literal">true</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STDC_FORMAT_MACROS <span class="hljs-comment">// PRId64, for printf data in cross platform</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_FORMAT_MACROS</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-function">string <span class="hljs-title">Timestamp::toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int64_t</span> seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;<br>    <span class="hljs-type">int64_t</span> microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;%&quot;</span> PRId64 <span class="hljs-string">&quot;.%06&quot;</span> PRId64 <span class="hljs-string">&quot;&quot;</span>, seconds, microseconds);<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">Timestamp::toFormattedString</span><span class="hljs-params">(<span class="hljs-type">bool</span> showMicroseconds)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">time_t</span> seconds = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> tm_time;<br>    <span class="hljs-built_in">gmtime_r</span>(&amp;seconds, &amp;tm_time); <span class="hljs-comment">// convert seconds since Epoch to UTC time (struct tm)</span><br><br>    <span class="hljs-keyword">if</span> (showMicroseconds)<br>    &#123;<br>        <span class="hljs-type">int</span> microseconds = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;</span>,<br>                 tm_time.tm_year + <span class="hljs-number">1990</span>, tm_time.tm_mon + <span class="hljs-number">1</span>, tm_time.tm_mday,<br>                 tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,<br>                 microseconds);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,<br>                 tm_time.tm_year + <span class="hljs-number">1990</span>, tm_time.tm_mon + <span class="hljs-number">1</span>, tm_time.tm_mday,<br>                 tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>toString()</code>将秒数、微秒数转换为可打印的std::string类型，用PRId64跨平台输出64bit数据到string缓存；</li><li><code>toFormattedString()</code>将时间戳转换为人类可理解的格式化时间字符串，形如"yyyymmddhh:mm:ss.zzzzzz"。</li></ol><h3 id="辅助函数非class-member函数">辅助函数（非class member函数）</h3><p>常需要比较2个时间先后顺序，计算这2个时刻之间的时间差，一个时刻加上一段时间来得到另外一个时刻，可以通过定义helper函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Timestamp lhs, Timestamp rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">microSecondsSinceEpoch</span>() &lt; rhs.<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Gets time difference of two timestamps, result in seconds.</span><br><span class="hljs-comment">* @param high</span><br><span class="hljs-comment">* @param low</span><br><span class="hljs-comment">* @return (high - low) in seconds.</span><br><span class="hljs-comment">* @c double has 52-bit precision, enough for one-microsecond</span><br><span class="hljs-comment">* resolution for next 100 years.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">timeDifference</span><span class="hljs-params">(Timestamp high, Timestamp low)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int64_t</span> diff = high.<span class="hljs-built_in">microSecondsSinceEpoch</span>() - low.<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(diff) / Timestamp::kMicroSecondsPerSecond;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Add @c seconds to given timestamp.</span><br><span class="hljs-comment">* @param timestamp given basic timestamp</span><br><span class="hljs-comment">* @param seconds given seconds to be added to timestamp</span><br><span class="hljs-comment">* @return timestamp + seconds as Timestamp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> Timestamp <span class="hljs-title">addTime</span><span class="hljs-params">(Timestamp timestamp, <span class="hljs-type">double</span> seconds)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int64_t</span> delta = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(seconds * Timestamp::kMicroSecondsPerSecond);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Timestamp</span>(timestamp.<span class="hljs-built_in">microSecondsSinceEpoch</span>() + delta);<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>operator&lt;()</code>除了比较2个时间戳大小关系（代表的先后顺序），也是实现等价关系判断的重要条件；</li><li><code>timeDifference()</code>计算2个时间戳差值，精确到1usec，用小数表示，而整数部分表示1sec；</li><li><code>addTime()</code> 利用一个基准时间戳timestamp +时间段seconds(秒数)，得到新的Timestamp对象。</li></ol><h3 id="单元测试">单元测试</h3><p>单元测试测什么？muduo是以class为单位，根据提供给用户的功能点进行测试。有些进行的是覆盖测试。</p><p>Timestamp主要功能点：</p><ol type="1"><li>构造对象：默认对象，无效对象；</li><li>值语义，即引用传递、值传递对象；</li><li><code>now()</code>获取当前时间；</li><li><code>microSecondsSinceEpoch()</code>获取微秒数，<code>secondsSinceEpoch()</code>获取秒数；</li><li><code>valid()</code>判断对象是否有效；</li><li><code>fromUnixTime()</code> 将Epoch时间转换为Timestamp对象；</li><li><code>toString()</code> 将时间戳转换为string类型；</li><li><code>toFormattedString()</code>将时间戳转换为格式化字符串string类型；</li></ol><p>辅助函数主要功能点：</p><ol type="1"><li><code>operator&lt;()</code> 比较2个Timestamp对象大小；</li><li><code>timeDifference()</code>计算2个Timestamp对象差值；</li><li><code>ddTime()</code> 将一个Timestamp加上指定时间；</li></ol><p>由于<code>toString()</code>和<code>toFormattedString()</code>可以输出类的信息，因此可以作为测试时判断的依据。</p><!-- Timestamp的单元测试，可以这样设计：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp_unittest.cc</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">now</span><span class="hljs-params">(Timestamp::now())</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, now.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 测试now() + copy ctor</span><br>    <span class="hljs-built_in">passByValue</span>(now); <span class="hljs-comment">// 测试值传递</span><br>    <span class="hljs-built_in">passByConstReference</span>(now); <span class="hljs-comment">// 测试引用传递</span><br>    <span class="hljs-built_in">benchmark</span>(); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">passByValue</span><span class="hljs-params">(Timestamp x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, x.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">passByConstReference</span><span class="hljs-params">(<span class="hljs-type">const</span> Timestamp&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, x.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">benchmark</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNumber = <span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>;<br><br>    std::vector&lt;Timestamp&gt; stamps;<br>    stamps.<span class="hljs-built_in">reserve</span>(kNumber);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kNumber; ++i) &#123;<br>        stamps.<span class="hljs-built_in">push_back</span>(Timestamp::<span class="hljs-built_in">now</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, stamps.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, stamps.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, muduo::<span class="hljs-built_in">timeDifference</span>(stamps.<span class="hljs-built_in">back</span>(), stamps.<span class="hljs-built_in">front</span>()));<br><br>    <span class="hljs-type">int</span> increments[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int64_t</span> start = stamps.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kNumber; ++i) &#123;<br>        <span class="hljs-type">int64_t</span> next = stamps[i].<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>        <span class="hljs-type">int64_t</span> inc = next - start;<br>        start = next;<br>        <span class="hljs-keyword">if</span> (inc &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;reverse!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inc &lt; <span class="hljs-number">100</span>)<br>        &#123;<br>            ++increments[inc];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;big gap %d\n&quot;</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(inc));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d: %d\n&quot;</span>, i, increments[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs shell">1645946164.776317<br>1645946164.776317<br>1645946164.776317<br>1645946164.777235<br>1645946164.981893<br>0.204658<br>big gap 109<br>big gap 193<br>big gap 162<br>big gap 158<br>big gap 35248<br>big gap 7007<br>big gap 142<br>big gap 6098<br>big gap 2142<br>big gap 12422<br>big gap 262<br>big gap 12291<br>big gap 12078<br>big gap 222<br>big gap 12069<br>big gap 229<br>0: 901839<br>1: 97441<br>2: 83<br>3: 191<br>4: 175<br>5: 13<br>6: 47<br>7: 22<br>8: 10<br>9: 6<br>10: 7<br>11: 10<br>12: 4<br>13: 12<br>14: 4<br>15: 4<br>16: 5<br>17: 10<br>18: 2<br>19: 2<br>20: 1<br>21: 0<br>22: 2<br>...<br>``` --&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 小结</span></span><br><br>1. 有些重要函数功能点，并未测试到，比如`toFormattedString()`；<br>2. 针对特定函数，设计的测试用例并不全面，比如并没有永非法的时间戳数值（如&lt;0），来验证生成的`Timestamp`有效性。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 重要知识点</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 模板boost::less_than_comparable</span></span><br><br>要求实现`&lt;`，可自动实现`&gt;`，`&lt;=`，`&gt;=`。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 编译时断言BOOST_STATIC_ASSERT</span></span><br><br>相当于C++11里面的static_assert，可以在编译时进行断言。<br><br>```C++<br>BOOST_STATIC_ASSERT(sizeof(Timestamp) == sizeof(int64_t)); // 断言Timestamp大小等于int64_t（64位）<br></code></pre></td></tr></table></figure><h3 id="跨平台打印prid64">跨平台打印PRId64</h3><p><code>int64_t</code>表示64位整数，在32位系统总是<code>long long int</code>，在64位系统中是<code>long int</code>，所以打印<code>int64_t</code>的格式化方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, value);  <span class="hljs-comment">// 64bit OS</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, value); <span class="hljs-comment">// 32bit OS</span><br></code></pre></td></tr></table></figure><p>可以看到，转义字符是不一样的，也就是说这种写法不跨平台。</p><p>跨平台的方法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_FORMAT_MACROS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __STDC_FORMAT_MACROS</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%&quot;</span> PRId64 <span class="hljs-string">&quot;\n&quot;</span>, value);<br></code></pre></td></tr></table></figure><p>这样，32位系统、64位系统是通用的。</p><p>为什么需要包含<code>__STDC_FORMAT_MACROS</code>？因为开启<code>PRId64</code>宏，默认要开启宏<code>__cplusplus</code>或者<code>__STDC_FORMAT_MACROS</code>。在C语言中，没有定义<code>__cplusplus</code>，就必须定义<code>__STDC_FORMAT_MACROS</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-原子类AtomicIntegerT&lt;T&gt;</title>
    <link href="/2023/06/21/muduo%E5%BA%93-%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicIntegerT-T/"/>
    <url>/2023/06/21/muduo%E5%BA%93-%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicIntegerT-T/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-原子类atomicintegert">muduo库-原子类AtomicIntegerT<T></h1><p>C++中的原子操作有两种实现方式：</p><ol type="1"><li>C++11以后，提供st::atomic可以实现T类型数据的原子操作，主要包括：初始化、读取值、写值、自增自减（i.e.前置或后置++）等。</li><li>C++11以前的版本，需要用GCC编译器提供的原子操作接口，实现原子操作。</li></ol><h2 id="atomicintegert模板类">AtomicIntegerT模板类</h2><p>muduo产生与C++11流行之前，因此用了第二种方案。实际上，Linux下面，C++11中的原子操作实现，也是用的第一种方案实现的。</p><p>自定义AtomicIntegerT模板：</p><p><imgsrc="/img/muduo/原子类AtomicIntegerT/AtomicIntegerT类图.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/* GCC atomic operation see</span><br><span class="hljs-comment">* https://www.cnblogs.com/the-tops/p/6347584.html</span><br><span class="hljs-comment">* https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerT</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AtomicIntegerT</span>()<br>    :<span class="hljs-built_in">value_</span>(<span class="hljs-number">0</span>)<br>    &#123; &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// CAS(compare and swap)</span><br>        <span class="hljs-comment">// in gcc &gt;= 4.7: __atomic_load_n(&amp;value, __ATOMIC_SEQ_CST)</span><br>        <span class="hljs-keyword">return</span> __sync_val_compare_and_swap(&amp;value_, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 先fetch获取值（value_），然后再add加x</span><br>    <span class="hljs-function">T <span class="hljs-title">getAndAdd</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST)</span><br>        <span class="hljs-keyword">return</span> __sync_fetch_and_add(&amp;value_, x);<br>    &#125;<br>    <span class="hljs-comment">// getAndAdd()中已经用原子操作改变了value_值，这里是通过值传递方式返回 old value_ + x</span><br>    <span class="hljs-function">T <span class="hljs-title">addAndGet</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getAndAdd</span>(x) + x;<br>    &#125;<br>    <span class="hljs-comment">// 前缀式递增，相当于++value_</span><br>    <span class="hljs-function">T <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 前缀式递减，相当于--value_</span><br>    <span class="hljs-function">T <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 求和，相当于value_ = value_ + x</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">getAndAdd</span>(x);<br>    &#125;<br>    <span class="hljs-comment">// 单纯递增，不关心返回值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">incrementAndGet</span>();<br>    &#125;<br>    <span class="hljs-comment">// 单纯递减，不关心返回值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">decrementAndGet</span>();<br>    &#125;<br>    <span class="hljs-comment">// 先fetch old value_，然后set value_ = newValue</span><br>    <span class="hljs-function">T <span class="hljs-title">getAndSet</span><span class="hljs-params">(T newValue)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST)</span><br>        <span class="hljs-keyword">return</span> __sync_lock_test_and_set(&amp;value_, newValue);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T value_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了使用方便，同时避免重复命名、实例化、甚至编译，使用AtomicIntegerT包装int32_t,int64_t，然后重定义，我们在.h文件中声明这2个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// namespace muduo::detail</span><br><span class="hljs-keyword">typedef</span> detail::AtomicIntegerT&lt;<span class="hljs-type">int32_t</span>&gt; AtomicInt32;<br><span class="hljs-keyword">typedef</span> detail::AtomicIntegerT&lt;<span class="hljs-type">int64_t</span>&gt; AtomicInt64;<br></code></pre></td></tr></table></figure><h2 id="单元测试">单元测试</h2><p>主要针对AtomicInt64、AtomicInt32这2个常用的、具体的类型，进行测试。</p><p><strong>方法</strong>:通过构造实例对象后，调用成员函数get()、getAndAdd()、addAndGet()、incrementAndGet()、decrementAndGet()，对原子对象进行修改，然后根据返回值判断值是否为预期值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// AtomicInt64 的测试</span><br>&#123;<br>    AtomicInt64 a0;<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">getAndAdd</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">incrementAndGet</span>() == <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">4</span>);<br>    a0.<span class="hljs-built_in">increment</span>();<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">-3</span>) == <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">getAndSet</span>(<span class="hljs-number">100</span>) == <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// AtomicInt32 的测试类同，只需要修改a0的类型为AtomicInt32即可，具体代码略</span><br>... <br></code></pre></td></tr></table></figure><h2 id="相关知识点">相关知识点</h2><h3 id="gcc原子操作">GCC原子操作</h3><p>GCC提供了一套原子操作的接口，可以实现原子操作。这些接口都是以__sync开头的，如__sync_fetch_and_add()，__sync_val_compare_and_swap()等。</p><p><strong>原子自增操作</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">type __sync_fetch_and_add(type *ptr, type value)<br></code></pre></td></tr></table></figure><p><strong>原子赋值操作</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">type __sync_lock_test_and_set(type *ptr, type value)<br></code></pre></td></tr></table></figure><p>使用这些原子操作时，编译时需要加<code>-march=cpu-type</code>（CPU体系结构=CPU类型，可以指定为native）</p><h3 id="volatile关键字">volatile关键字</h3><p>确保本条指令不会因为编译器的优化而省略，而且要求每次从内存直接读值，而不是读高速cache中的备份。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">volatile</span> T value_;<br></code></pre></td></tr></table></figure><p>本文参考自：<ahref="https://www.cnblogs.com/haippy/p/3235560.html">muduo笔记原子类AtomicIntegerT<T></a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-标记类copyable noncopyable</title>
    <link href="/2023/06/21/muduo%E5%BA%93-%E6%A0%87%E8%AE%B0%E7%B1%BBcopyable-noncopyable/"/>
    <url>/2023/06/21/muduo%E5%BA%93-%E6%A0%87%E8%AE%B0%E7%B1%BBcopyable-noncopyable/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-标记类copyable-noncopyable">muduo库-标记类copyablenoncopyable</h1><h2 id="值语义与引用语义">值语义与引用语义</h2><p><strong>值语义</strong>指的是对象的拷贝与元对象无关，就像拷贝int一样。C++的内置类型（bool/int/double/char）都是值语义，标准库里的<code>complex</code>,<code>pair</code>,<code>vector</code>,<code>map</code>等等也都是值语义，拷贝之后就与原对象脱离关系。</p><p>与值语义对应的对象语义，或者叫做<strong>引用语义</strong>，对象语义指的是面向对象意义下的对象，对象拷贝是禁止的。</p><h2id="如何为一个class实现值语义引用语义">如何为一个class实现值语义，引用语义</h2><p>当构造一个class对象时，会先bit-wise构造其数据成员。而继承的baseclass那部分，会被派生类隐式继承，作为派生类数据成员。</p><p>形如下面的代码，编译器会将base class对象作为deriveclass的数据成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> b;<br>    A a; <span class="hljs-comment">// 编译器自动生成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果A的构造函数是private，编译器就无法在B中构造baseclass，即A那部分。这样，编译器也就无法为B合成构造函数。copy操作、move操作也是如此。</p><p>因此，我们可以为定义2个标记class，其他类继承这2个标记类，用于表示是否支持copy操作。</p><h3 id="copyable-class">copyable class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* A tag class emphasises the objects are copyable.</span><br><span class="hljs-comment">* The empty base class optimization applies.</span><br><span class="hljs-comment">* Any derived class of copyable should be a value type.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">copyable</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">copyable</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">copyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="noncopyable-class">noncopyable class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* A tag class emphasises the objects are non-copyable.</span><br><span class="hljs-comment">* A derived class should be a reference type rather than a value type.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">noncopyable</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">noncopyable</span>(<span class="hljs-type">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br><br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="用法以及使用这两个类的原因">用法以及使用这两个类的原因</h3><p>为什么不直接使用C++11关键字default/delete，指定支持/阻止编译器合成相关ctor、copy操作、move操作？</p><p>答案是当然可以，default/delete能达到同样目的，但不像继承自copyable、noncopyable这种标记类一样作用明显，程序员一眼都能看出其特性：是否允许copy。</p><p>本文转载自<ahref="https://www.cnblogs.com/fortunely/p/15943391.html">muduo笔记标记类copyable, noncopyable</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法模板</title>
    <link href="/2023/06/08/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/08/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="kmp算法模板">KMP算法模板</h1><p>KMP算法的原理以及图解见<ahref="https://www.zhihu.com/question/21923021/answer/281346746">如何更好地理解和掌握KMP 算法?</a></p><p>下面给出KMP算法的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// KMP算法</span><br><span class="hljs-comment">// 匹配成功返回匹配的起始位置，失败返回-1</span><br><span class="hljs-comment">// haystack为主串，needle为模式串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(string haystack, string needle)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = haystack.<span class="hljs-built_in">size</span>(), len2 = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(len2 + <span class="hljs-number">1</span>)</span></span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || needle[i] == needle[j])<br>            &#123;<br>                ++i;<br>                ++j;<br>                next[i] = j;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <br>                j = next[j];  <br>                <br>        &#125;<br>        i = <span class="hljs-number">0</span>;<br>        j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || haystack[i] == needle[j])<br>            &#123;<br>                ++i;<br>                ++j;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == len2)<br>            <span class="hljs-keyword">return</span> i - j;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL下添加系统调用</title>
    <link href="/2023/06/05/WSL%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2023/06/05/WSL%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl下添加系统调用">WSL下添加系统调用</h1><p>由于WSL的内核是在原版基础之上有做修改的，所以要先去下载内核的源码。https://github.com/microsoft/WSL2-Linux-Kernel.</p><p>查看当前系统内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>然后去源码中找到对应的版本并下载，下载完成后解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zvxf linux-msft-wsl-5.15.90.1.tar.gz<br><span class="hljs-built_in">cd</span> WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1<br></code></pre></td></tr></table></figure><h2 id="新增系统调用号">新增系统调用号</h2><p>在arch/x86/include/generated/uapi/asm/unistd_64.h中添加系统调用号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_my_func 335</span><br></code></pre></td></tr></table></figure><p>注意这里的系统调用号可以随便取，但一定要是唯一的，不然会报错。<code>my_func</code>是系统调用名。</p><h2 id="修改系统调用向量表">修改系统调用向量表</h2><p>修改arch/x86/entry/syscalls/syscall_64.tbl文件</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">335 </span><span class="hljs-number">64</span> my_oper sys_my_func<br></code></pre></td></tr></table></figure><p>此处的系统调用号必须与之前声明的保持一致，<code>my_func</code>为调用函数名，<code>sys_my_func</code>为实际调用的函数。</p><h2 id="添加系统调用的声明">添加系统调用的声明</h2><p>在include/linux/syscalls.h中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>;<br></code></pre></td></tr></table></figure><p>其中<code>asmlinkage</code>是一个宏，用于声明函数的调用方式，<code>long</code>是返回值类型，<code>sys_my_func</code>为函数名，<code>int count</code>为函数参数。</p><h2 id="添加具体实现">添加具体实现</h2><p>在kernel/sys.c中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-title function_">my_oper</span><span class="hljs-params">(<span class="hljs-type">int</span> *result, <span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">char</span> *op)</span><br>&#123;<br><span class="hljs-keyword">if</span>(op)<br>&#123;<br><span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;+&#x27;</span>)<br>*result = num1 + num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>*result = num1 - num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;*&#x27;</span>)<br>*result = num1 * num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;\\&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(num2 != <span class="hljs-number">0</span>)<br>*result = num1 / num2;<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;divided number can&#x27;t bere zero.\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;operator is empty.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>SYSCALL_DEFINE1(my_func, <span class="hljs-type">int</span>, count)<br>&#123;<br>printk(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">tstart</span>, <span class="hljs-title">tend</span>;</span><br>ktime_get_real_ts64(&amp;tstart);<br><span class="hljs-type">int</span> i, result, times = count / <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_add = <span class="hljs-string">&#x27;+&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, &amp;op_add);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_add is ok. op_add count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_sub = <span class="hljs-string">&#x27;-&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;op_sub);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_sub is ok. op_sub count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_mul = <span class="hljs-string">&#x27;*&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, &amp;op_mul);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_mul is ok. op_mul count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_div = <span class="hljs-string">&#x27;\\&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;op_div);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_div is ok. op_div count is :%d&quot;</span>, i);<br>ktime_get_real_ts64(&amp;tend);<br>printk(<span class="hljs-string">&quot;my_func running time is %ld usec/n&quot;</span>, <span class="hljs-number">1000000000</span> * (tend.tv_sec-tstart.tv_sec) + (tend.tv_nsec-tstart.tv_nsec));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>DEFINE后面的数字是传入的参数个数,这里是1个，所以是1。<code>my_func</code>是系统调用名，<code>count</code>是传入的参数。</p><p>注意：函数实现不要写在条件编译的范围内。</p><h2 id="编译内核">编译内核</h2><p>编译内核需要.config配置文件，可以通过<code>make menuconfig</code>生成，也可以直接复制现有的.config文件。这里使用<code>make menuconfig</code>生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><p><img src="/img/Linux/make-menuconfig.png" /></p><p><code>make menuconfig</code>会打开一个配置界面，这里不需要修改别的配置，只需要修改内核版本号，以便与现在的内核区分开，然后保存退出。</p><p>编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make<br></code></pre></td></tr></table></figure><p>编译完成后，生成的内核文件在项目目录arch/x86/boot下面，文件名为bzImage。</p><h2 id="替换内核">替换内核</h2><p>将内核文件bzImage从wsl系统中拷贝出来，放在windows文件系统中任意路径下，例如C:_usr_kernel</p><p>然后进入C:.wslconfig 的文件，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[wsl2]<br>kernel=C:\\wsl_usr_kernel\\bzImage<br></code></pre></td></tr></table></figure><p>注意双反斜杠，否则不生效。然后在powershell中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><p>重启wsl系统，查看内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>可以看到内核版本已经变成了我们刚刚编译的版本。</p><p>如果要恢复原来的内核，只需要删除.wslconfig文件，然后执行<code>wsl --shutdown</code>重启wsl系统即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据期末复习</title>
    <link href="/2023/06/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据期末复习">大数据期末复习</h1><h2 id="ch1-intruction">Ch1 Intruction</h2><h3 id="what-is-big-data">What is big data?</h3><p><strong>Big data</strong> is used to describe a massive volume ofboth structured and unstructured data that is so large that it'sdifficult to process using traditional database and softwaretechniques.</p><p><strong>大数据</strong>用来描述大量的结构化和非结构化的数据，这些数据非常大，难以用传统的数据库和软件技术来处理。</p><h3 id="the-4v-features-of-big-data">The 4V Features of big data</h3><p><img src="/img/大数据/4V-features.png" /></p><ul><li>Volume (Scale of Data)</li><li>Velocity (Data Stream)</li><li>Variety (Different types of data)</li><li>Veracity (Uncertainty, missing value)</li></ul><h3 id="what-is-data-mining">What is data mining?</h3><p><strong>Data mining</strong> consists of <strong>applying dataanalysis</strong> and <strong>discovery algorithms</strong> that, underacceptable computational efficiency limitations, produce a particularenumeration of patterns over the data.</p><p><strong>数据挖掘</strong>包括<strong>应用数据分析</strong>和<strong>发现算法</strong>，在可接受的计算效率限制下，在数据上产生特定的模式列举。</p><h3 id="the-kdd-processcore-part">The KDD Process(core part)</h3><p><img src="/img/大数据/KDD-process.png" /></p><h3 id="the-main-tasks-of-data-mining">The main tasks of Datamining</h3><ul><li>Association Rule Mining(关联规则挖掘)</li><li>Cluster Analysis(聚类分析)</li><li>Classification/Prediction(分类/预测)</li><li>Outlier Detection(异常点检测)</li></ul><h3id="the-relationship-between-data-minning-and-other-subjectse.g.-database">Therelationship between Data minning and other subjects(e.g. Database)</h3><p>Data mining is known as Knowledge Discovery in Database (KDD) in thefield of artificial intelligence, is also considered as a fundamentalstep in the process of knowledge discovery in database.</p><p>数据挖掘在人工智能领域被称为数据库知识发现（KDD），也被认为是数据库知识发现过程中的一个基本步骤。</p><h3 id="the-challenges-of-big-data-mining">The challenges of big datamining</h3><ul><li>Curse of dimensionality(维度灾难)</li><li>Storage cost</li><li>Query speed <!-- - Data Quality- Data Complexity- Data Privacy and Security- Scalability- Ethics(伦理学)- interpretability --></li></ul><h2 id="ch2-foundations-of-data-mining">Ch2 Foundations of DataMining</h2><h3id="supervised-learningunsupervised-learningsemi-supervised-learning">Supervisedlearning/Unsupervised learning/Semi-supervised learning</h3><ul><li><strong>Supervised learning</strong>: targets to learn the mappingfunction or relationship between the features and the labels based onthe labeled data. Namely, <span class="math inline">\(𝑌=𝐹(𝑋|𝜃)\)</span>.(e.g. Classification, Prediction)</li><li><strong>Unsupervised learning</strong>: aims at learning theintrinsic structure from unlabeled data. (e.g. Clustering, Latent FactorLearning and Frequent Items Mining)</li><li><strong>Semi-supervised learning</strong>: can be regarded as theunsupervised learning with some constraints on labels, or the supervisedlearning with additional information on the distribution of data.</li></ul><h3 id="loss-function">LOSS FUNCTION</h3><p><img src="/img/大数据/ch2-lossfunction.png" /></p><p><span class="math inline">\(l_1\)</span> norm:</p><p><span class="math display">\[L(\beta) =\frac{1}{N}\sum\limits_{i =1}^{N}L(Y_i, F(X_i | \beta)) + \frac{\lambda}{2} || \beta||_2\]</span></p><p><span class="math inline">\(l_2\)</span> norm:</p><p><span class="math display">\[L(\beta) =\frac{1}{N}\sum\limits_{i =1}^{N}L(Y_i, F(X_i | \beta)) + \frac{\lambda}{2} || \beta||_1\]</span></p><p><span class="math inline">\(||A||_∗\)</span> nuclear norm:</p><p><span class="math display">\[||A||_∗=∑\limits_i{σ_i}(A).\]</span></p><h3 id="overfittingunderfitting-problem">Overfitting/Underfittingproblem</h3><p><strong>Reason</strong>?</p><p><strong>How to avoid overfitting</strong>?</p><h3 id="classfied-algorithms">Classfied Algorithms</h3><h4 id="decision-tree">Decision Tree</h4><ul><li>How to construct DT?</li><li>Attribute selection Criteria<ul><li>Information Gain</li><li>Information Gain Ratio</li><li>Gini index</li></ul></li></ul><h4 id="knn">KNN</h4><p><strong>Lazy Learning</strong>: Lazy Learning does not extract rulesor generalizations from a specific model. Instead, it searches forhistorical instances that are similar to the testing instance and makesa prediction based on their output results. (LazyLearning并没有从特定的模型中提取基本规则或一般情况，而是在预测时查找与测试实例相似的历史实例，并根据它们的输出结果做出预测)</p><p><strong>advantage</strong>:</p><ul><li>local data distribution（适用本地数据分布）</li><li>Incremental/online learning（渐进式/在线学习）</li><li>large number of classes（可以对很大的类型数量分类）</li></ul><p><strong>disvantage</strong>:</p><ul><li>parameter k(要设置参数k)</li><li>imbalanced data（数据不平衡时分类效果差）</li><li>slow inference（推理慢）</li></ul><h4 id="naive-bayse">Naive bayse</h4><p><strong>basic idea</strong></p><p><strong>advantage</strong></p><h4 id="svm">SVM</h4><ol type="1"><li>basic concept</li><li>Linear seperation problem<ol type="1"><li>Why SVM works well on small size of samples?<ol type="1"><li>可以处理高维空间</li><li>可以控制正则化参数防止过拟合</li><li>对噪声鲁棒性强</li><li>适用非线性分类</li></ol></li><li>Good generalization</li></ol></li><li>NonLinear problem<ol type="1"><li>solution: map data into high dimension space</li><li>Trick: kernel Trick <span class="math inline">\(K(X,Y) = \Phi(X)\Phi(Y)\)</span></li><li>Kernel function: Gaussian kernel, polynormial kernel</li></ol></li></ol><p>损失函数是平方损失加上L1正则化</p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2 + \alpha \sum_{j=1}^n|\theta_j|\]</span></p><p>其中，第一项是平方损失，第二项是L1正则化项，<spanclass="math inline">\(\alpha\)</span>是正则化参数。</p><h3 id="ensemble-learning">Ensemble Learning</h3><p>Rationale for Ensemble Learning: No Free Lunch thm: There is noalgorithm that is always the most accurate</p><p><strong>Two Criteria</strong>:</p><ul><li>Good base learner</li><li>diversity</li></ul><p><strong>Three Strategies</strong>:</p><ul><li>Bagging(Random Forest)</li><li>Boosting(AdaBoost)</li><li>Stacking</li></ul><h3 id="clustering">Clustering</h3><h4 id="k-means-procedure-and-darwbacks">K-means procedure anddarwbacks</h4><p>K-means procedure:</p><ol type="1"><li>从数据中选择k个对象作为初始聚类中心;</li><li>计算每个聚类对象到聚类中心的距离来划分；</li><li>再次计算每个聚类中心;</li><li>计算标准测度函数，之道达到最大迭代次数，则停止，否则，继续操作。</li></ol><p>优点：</p><ul><li>原理简单，实现容易；</li><li>复杂度与样本数量线性相关，对于处理大数据集合，该算法非常高效，且伸缩性较好。</li></ul><p>drawbacks（缺点）:</p><ul><li>K需要事先给定；</li><li>Kmeans需要人为地确定初始聚类中心，不同的初始聚类中心可能导致完全不同的聚类结果；</li><li>结果不一定是全局最优，只能保证局部最优；</li><li>对噪声和离群点敏感；</li><li>该方法不适于发现非凸面形状的簇或大小差别很大的簇；</li><li>需样本存在均值（限定数据种类）。</li></ul><h4 id="dbscan">DBSCAN</h4><p><strong>Advantage</strong>:</p><ul><li>可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</li><li>可以在聚类的同时发现异常点，对数据集中的异常点不敏感;</li><li>聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</li></ul><p><strong>Disadvantage</strong>:</p><ul><li>如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差。If thedensity of the sample set is not uniform and the distance betweenclusters is very different, the clustering quality is poor.</li><li>如果样本集较大时，聚类收敛时间较长。If the sample set is large, theclustering convergence time is long.</li><li>调参相对于传统的K-Means之类的聚类算法稍复杂. Parameter adjustment ismore complex than K-means.</li></ul><h3 id="subspace-learning">Subspace learning</h3><h4 id="dimension-reduction">Dimension Reduction</h4><p><strong>Models</strong>:</p><ul><li>Linear methods<ul><li>PCA(Principal Component Analysis)</li><li>MDS(Multi-Dimensional Scaling)</li></ul></li><li>Nonlinear methods<ul><li>LLE(Locally Linear Embedding)</li><li>LEM(Laplacian eigenmaps)</li><li>Isomap</li></ul></li></ul><h4 id="feature-selectionclassification">Featureselection(Classification)</h4><ul><li>Filter Method(IG, <span class="math inline">\(\mathcal{X}^2\)</span>)</li><li>wrapper Method</li><li>Embedded Methods</li></ul><h3 id="subspace-clustering子空间聚类">SubspaceClustering(子空间聚类)</h3><ul><li>Sparse subspace clustering (SSC)</li><li>Low-rank representation (LRR)</li></ul><h2 id="ch3-hashing">Ch3 Hashing</h2><h3 id="the-role-of-hashing作用">The role of Hashing(作用)</h3><ul><li>After using the hash code to represent the data, <strong>therequired storage space will be greatlyreduced</strong>（使用哈希码表示数据后，所需要的存储空间会被大幅减小）</li><li>Can <strong>reduce data dimensionality</strong>, thereby alleviatingthe <strong>dimensionality curseproblem</strong>(可以降低数据维度，从而减轻维度灾难问题)</li><li>Can realize fast neighbor retrieval at constant or sub-linear level,and provide support for the rapid realization of upper-level learningtasks(可以实现常数或者次线性级别的快速近邻检索，为上层学习任务的快速实现提供支撑)</li></ul><h3 id="find-similar-items">Find similar items</h3><p>Three Essential Techniques for Similar items:</p><ul><li><strong>K-Shingling</strong>：convert documents, emails, etc., tosets.</li><li><strong>Min-hashing</strong>：convert large sets to shortsignatures, while preserving similarity.</li><li><strong>Locality-sensitive hashing</strong> : focus on pairs ofsignatures likely to be similar.</li></ul><p><img src="/img/大数据/ch3-the-big-pic.png" /></p><h4 id="shingles">Shingles</h4><p>A k-shingle (or k-gram) for a document is <strong>a sequence of kcharacters that appears in the document</strong>.一个文件的k-shingle（或k-gram）是一个出现在文件中的k个字符的序列。</p><p>Example: <span class="math inline">\(k=2; doc = abcab\)</span>. Setof 2-shingles = <span class="math inline">\(\{ab, bc, ca\}\)</span>.</p><h4 id="min-hashing">min-hashing</h4><p>definition:min-hash is an algorithm for <strong>text and datasimilarity comparison</strong> that efficiently extracts the signatureof each data from large-scale data, thus supporting fast comparison oftheir similarity.min-hash是一种用于文本和数据相似度比较的算法，它可以高效地从大规模数据中提取每个数据的签名，从而支持快速地比较它们之间的相似程度。</p><h5 id="signature-matrix-rightarrow-how-to-compute-similarity">signaturematrix <span class="math inline">\(\Rightarrow\)</span> how to computesimilarity</h5><p><img src="/img/大数据/ch3-similarity.png" /></p><p>Jaccard similarity：不将<spanclass="math inline">\((0,0)\)</span>计入分母，相同的行占全部行的比率</p><p>matrix similarity：相同的行占全部行的比率</p><p><strong>Signature Matrix的计算方法</strong>：</p><p><img src="/img/大数据/ch3-signature计算方法.png" /></p><p>上图中间矩阵是输入矩阵，左侧的每一列都代表输入矩阵行的一种排列，那么signaturematrix的每一行都对应左侧的一种排列方式，该行的每列数字对应该种排列方式对应列的第一个1的出现行数。</p><h5 id="locality-sensitive-hashinglsh">Locality-SensitiveHashing（LSH）</h5><p>假设我们在主内存中有代表大量对象的数据</p><ul><li>可能是对象本身</li><li>可能是min-hashing中的签名</li></ul><p>我们要逐一进行比较，找到那些足够相似的pair。但是检查所有的pair是很困难的。</p><ul><li>一般的想法：使用一个函数f(x,y)，告诉人们x和y是否是一个候选对：一对元素的相似性必须被评估。</li><li>对于min-hash矩阵：哈希列到许多桶中，并使同一桶中的元素成为候选对。</li></ul><p>基本思想：Generate from the collection of all elements (signatures inour example) a small list of candidate pairs: pairs of elements whosesimilarity must be evaluated.</p><p>简单来说就是从我们Min-hashing得到的标记矩阵生成可能相似的文档对列表。</p><p>候选相似文档对 <span class="math inline">\(\Rightarrow\)</span>这一对的Jaccard相似度必须被准确计算出来</p><p>方法：</p><ul><li>选一个相似度标准 <span class="math inline">\(t\)</span>，并且 <spanclass="math inline">\(t&lt;1\)</span>，如果两个文档的相似度大于 <spanclass="math inline">\(t\)</span>，则认为这两个文档相似。</li><li>如果列<span class="math inline">\(c\)</span>和列<spanclass="math inline">\(d\)</span>被视为候选文档对，那么他们一定要满足<spanclass="math inline">\(M(i,c)=M(i,d)&gt;=t\)</span>，其中M是标记矩阵。</li></ul><h5 id="lsh-for-minhashing-signatures">LSH for MinhashingSignatures</h5><p>总体思想：把标记矩阵里的hash很多遍，只有hash到同一个桶(bucket)里的列才被认为是可能相似的。</p><p><strong>Partion Into Bands</strong></p><p><img src="/img/大数据/Partion-Into-Bands.png" /></p><p>Divide matrix M into b bands of r rows. For each band, hash itsportion of each column to a hash table with k buckets.如图所示，把标记矩阵(signature matrix)的所有行分成 <spanclass="math inline">\(b\)</span> 个带(bands)，每个带有 <spanclass="math inline">\(r\)</span>行。对于每条带，对带里面每列进行hash，分别hash到<spanclass="math inline">\(k\)</span>个桶中，并让<spanclass="math inline">\(k\)</span>尽可能得大。</p><p>只有有<spanclass="math inline">\(&gt;=1\)</span>的band哈希到同一个桶中，就把这两列当作候选相似对。</p><p><img src="/img/大数据/Partion-Into-Bands-例子.png" /></p><h5 id="example---bands">Example - Bands</h5><p>假设有 100,000 列，每列有100个标记，因此存储标记需要40MB;我们希望找到所以相似度大于80%的文档对，用上面的方法，把标记分为20个带，每个带里有5个标记。</p><p>这样的话，如果文档<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的相似度是<spanclass="math inline">\(80\%\)</span>，那么他们的任意一个带的<spanclass="math inline">\(5\)</span>个标记都相同的概率是: <spanclass="math inline">\((0.8)^5=0.328\)</span>，看起来好像不大，但是只要有任意一个带都相同就被认为是候选对，所以他们不被选上的概率，即20个带都不相同的概率为：<spanclass="math inline">\((1−0.328)^20=0.00035\)</span> ，也就是每<spanclass="math inline">\(3000\)</span>个相似度为<spanclass="math inline">\(80\%\)</span>的文档对里才会有一对漏选。</p><p>我们再考虑文档<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>只有<spanclass="math inline">\(40\%\)</span>的相似度，那么他们任意一个带的<spanclass="math inline">\(5\)</span>个标记都相同的概率为 <spanclass="math inline">\((0.4)^5=0.01\)</span>，则文档<spanclass="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>被选为候选对的概率，即他们中有一个带完全相同的概率为:<span class="math inline">\(C^1_{20}×0.01=0.2\)</span> ，就是说每<spanclass="math inline">\(5\)</span>个<spanclass="math inline">\(40\%\)</span>相似度的文档对里就有一对会被误选为候选对。但是相似度小于<spanclass="math inline">\(40\%\)</span>的文档对里误选的概率就非常小了。</p><h3 id="learn-to-hash">Learn to Hash</h3><ol type="1"><li>Data indenpendent:Random projection</li><li>Data dependent:<ol type="1"><li>PCA hashing</li><li>Spectral Hashing</li></ol></li></ol><h4 id="pca-hashing">PCA hashing</h4><p>分为两个阶段</p><p><strong>Projection Stage（投影阶段）</strong>:</p><p>用一个转换矩阵<span class="math inline">\(W\)</span>,可以将<spanclass="math inline">\(x\)</span>投影到一个新的特征平面。</p><p><span class="math display">\[Y=W^T X\]</span></p><p><strong>Quantization Stage（量化阶段）</strong>:</p><p><span class="math display">\[h(x) = sgn(W^T X)\]</span></p><p>最小化quantization loss（量化损失）</p><p><span class="math display">\[Q(B,Y) = ||B - Y^T R||^2_F\]</span></p><p><span class="math inline">\(R\)</span>是正交矩阵. <spanclass="math inline">\(B = Sgn(Y^T R)\)</span></p><p>基本思想是旋转数据以最小化量化损失。</p><p>实现方法：从<spanclass="math inline">\(R\)</span>的随机初始化开始，采用类似K-means的迭代算法来优化<spanclass="math inline">\(R\)</span>。在每次迭代中，每个数据点首先被分配到最近的聚类中心，然后更新<spanclass="math inline">\(R\)</span>以使量化损失最小化。</p><h4 id="spectral-hashing谱哈希">Spectral Hashing（谱哈希）</h4><p><img src="/img/大数据/Spectral-Hashing公式.png" /></p><h4id="general-approach-to-learning-based-hashinglearning-based哈希的一般方法">GeneralApproach to Learning-Based Hashing(Learning-Based哈希的一般方法)</h4><p>将哈希学习问题分解为两个步骤：</p><ol type="1"><li>hash bit learning. 哈希比特学习</li><li>hash function learning based on the learned bits.基于所学习的哈希比特的哈希函数学习</li></ol><p><img src="/img/大数据/ch3-Learning-Based-Hashing-步骤.png" /></p><h2 id="ch4-sampling">Ch4 Sampling</h2><p>Why sampling?</p><ul><li>Big data issue<ul><li>Store complexity</li><li>Calculate complexity</li></ul></li><li>Posterior estimation<ul><li>Expectation estimation</li></ul></li></ul><h3 id="inverse-transform-sampling逆采样变换">Inverse TransformSampling(逆采样变换)</h3><p>Inverse Transform Sampling based on the inverse of CumulativeDistribution Function (CDF). 逆采样变换（Inverse TransformSampling）是伪随机数采样的一种基本方法。在已知任意概率分布的累积分布函数<spanclass="math inline">\(CDF\)</span>时，可以通过<spanclass="math inline">\(CDF\)</span>的逆函数来实现随机数的采样。</p><p>简单来说，假设<spanclass="math inline">\(X\)</span>为一个连续随机变量，其概率密度函数为<spanclass="math inline">\(PDF(X)\)</span>，累计分布函数为<spanclass="math inline">\(CDF(X)\)</span>。这时候若想生成符合<spanclass="math inline">\(X\)</span>分布的随机变量样本，只需在<spanclass="math inline">\([0, 1]\)</span>范围内生成随机变量<spanclass="math inline">\(x\)</span>,然后放入<spanclass="math inline">\(CDF\)</span>的反函数中，即可得到符合<spanclass="math inline">\(X\)</span>分布的随机变量样本。</p><p>方法：</p><p><img src="/img/大数据/ch4-CDF.png" /></p><p>优点：</p><ul><li>简单</li><li>适用于任意分布</li></ul><p>缺点：</p><ul><li>Hard to get the inverse function. 很难确定逆函数</li></ul><h3 id="rejection-sampling拒绝采样">Rejection Sampling(拒绝采样)</h3><p>Rejection Sampling accept the samples in the region under the graphof its density function and reject others. 拒绝采样（RejectionSampling）是一种基本的随机数采样方法。它的基本思想是：对于一个难以采样的分布，我们可以找到一个容易采样的分布，使得容易采样的分布包含难以采样的分布，然后从容易采样的分布中采样，若采样的点在难以采样的分布中，则接受该点，否则拒绝该点。</p><p>方法：</p><p><img src="/img/大数据/ch4-Rejection-Sampling.png" /></p><p>步骤：</p><p><img src="/img/大数据/ch4-Rejection-Sampling-步骤.png" /></p><p>这就使得Proposal Distribution <spanclass="math inline">\(q(x)\)</span>的支撑集（support）要大于目标分布<spanclass="math inline">\(p(x)\)</span>的支撑集。所以<spanclass="math inline">\(q(x)\)</span>的分布选择很重要。</p><h3 id="importance-sampling重要性采样">ImportanceSampling(重要性采样)</h3><p>Importance Sampling not reject but assign weight to each instance sothat the correct distribution is targeted. 重要性采样（ImportanceSampling）与RejectionSampling(拒绝采样)的区别在于，重要性采样不会拒绝采样的点，而是对采样的点赋予一个权重，使得采样的点更多地来自于目标分布。</p><h3 id="importance-sampling和rejection-sampling的区别">ImportanceSampling和Rejection Sampling的区别</h3><ul><li>RS的实例有一个相同的权重，只有部分的实例会被保留</li><li>IS的实例有不同的权重，所有的实例都会被保留</li><li>IS对对proposal distribution的选择更不敏感</li></ul><h3 id="markov-chain-monte-carlomcmc">Markov Chain MonteCarlo(MCMC)</h3><p>MCMC methods are a class of algorithms for <strong>sampling from aprobability distribution based on constructing a Markov chain</strong>that has the desired distribution as its <strong>equilibriumdistribution</strong>. The state of the chain after a number of steps isthen used as a sample of the desired distribution.</p><p>马尔可夫链蒙特卡洛（Markov Chain MonteCarlo，MCMC）是一种基于马尔可夫链的随机采样方法。它的基本思想是：对于一个难以采样的分布，我们可以构造一个马尔可夫链，使得该马尔可夫链的平稳分布为该难以采样的分布，然后从该马尔可夫链中采样，得到的样本服从该难以采样的分布。</p><p><strong>蒙特卡洛法</strong>：</p><p>蒙特卡洛法（Monte CarloMethod）是一种基于随机数的数值计算方法。它的基本思想是：对于一个难以计算的问题，我们可以构造一个概率分布，使得该概率分布的期望为该问题的解，然后从该概率分布中采样，得到的样本的平均值即为该问题的解。</p><h4 id="detailed-balance-condition细致平衡条件">Detailed BalanceCondition(细致平衡条件)</h4><p>细致平衡条件（Detailed BalanceCondition）是马尔可夫链平稳分布的一个必要条件。它的基本思想是：对于一个马尔可夫链，若该马尔可夫链的平稳分布为<spanclass="math inline">\(\pi(x)\)</span>，则该马尔可夫链的任意两个状态<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>满足：</p><p><span class="math display">\[\pi(x)P(x, y) = \pi(y)P(y,x)\]</span></p><p>其中<span class="math inline">\(P(x, y)\)</span>为从状态<spanclass="math inline">\(x\)</span>转移到状态<spanclass="math inline">\(y\)</span>的概率,<spanclass="math inline">\(\pi(x)\)</span>为状态<spanclass="math inline">\(x\)</span>的概率。那么<spanclass="math inline">\(\pi(x)\)</span>就是该马尔可夫链的平稳分布。</p><h4 id="the-procedure-of-mcmcmcmc的流程">The Procedure ofMCMC(MCMC的流程)</h4><p><img src="/img/大数据/ch4-MCMC流程.png" /></p><h3 id="metropolis-hastings-algorithmmh算法">Metropolis-HastingsAlgorithm(MH算法)</h3><p>由于MCMC采样有收敛太慢的问题,所以在MCMC的基础之上进行改进，引出MH算法。</p><p><img src="/img/大数据/ch4-MH算法流程.png" /></p><p>MH算法的具体流程如下：</p><p><img src="/img/大数据/ch4-MH算法具体流程.png" /></p><p>一般来说M-H采样算法较MCMC算法应用更广泛，然而在大数据时代，M-H算法面临着两个问题：</p><ol type="1"><li>在高维时的计算量很大，算法效率很低，同时存在拒绝转移的问题，也会加大计算量</li><li>由于特征维度大，很多时候我们甚至很难求出目标的各特征维度联合分布，但是可以方便求出各个特征之间的条件概率分布（因此就思考是否能只知道条件概率分布的情况下进行采样）。</li></ol><h3 id="gibbs-sampling">Gibbs Sampling</h3><p>Gibbs Sampling是MH算法的一种特殊情况。它的基本思想是：</p><p><img src="/img/大数据/ch4-Gibbs.png" /> <imgsrc="/img/大数据/ch4-Gibbs-1.png" /></p><p>因此可以得出在二维的情况下Gibbs采样算法的流程如下：</p><p><img src="/img/大数据/ch4-Gibbs-二维流程.png" /></p><p>而在多维的情况下，比如一个n维的概率分布<spanclass="math inline">\(π(x_1, x_2, ...x_n)\)</span>，我们可以通过在<spanclass="math inline">\(n\)</span>个坐标轴上轮换采样，来得到新的样本。对于轮换到的任意一个坐标轴<spanclass="math inline">\(x_i\)</span>上的转移，马尔科夫链的状态转移概率为<spanclass="math inline">\(P(x_i|x_1, x_2, ..., x_{i−1}, x_{i+1}, ...,x_n)\)</span>，即固定<spanclass="math inline">\(n−1\)</span>个坐标轴，在某一个坐标轴上移动。而在多维的情况下Gibbs采样算法的流程如下：</p><p><img src="/img/大数据/ch4-Gibbs-多维流程.png" /></p><h3 id="gibbs-sampling和mh算法的联系与区别">GibbsSampling和MH算法的联系与区别</h3><ul><li>Gibbs Sampling和MH都是MCMC</li><li>Acceptance Ratio:<ul><li>Gibbs Sampling: <span class="math inline">\(1\)</span></li><li>MH: <span class="math inline">\(\frac{\pi(y)q(y, x)}{\pi(x)q(x, y)}&lt; 1\)</span></li></ul></li><li>MH不需要知道条件概率，而Gibbs Sampling需要知道条件概率</li></ul><h3 id="reservoir-sampling">Reservoir sampling</h3><p>Reservoirsampling是一种随机采样算法，它的基本思想是：对于一个数据流，我们希望从中随机采样出<spanclass="math inline">\(k\)</span>个样本，但是我们不知道数据流的长度，也就是说我们不知道<spanclass="math inline">\(k\)</span>的大小。具体流程如下：</p><p><img src="/img/大数据/ch4-Reservoir.png" /></p><h2 id="ch5-data-stream-mining">Ch5 Data Stream Mining</h2><h3 id="data-stream">Data Stream</h3><p><strong>What is Data Stream?</strong></p><p>A data stream is a massive sequence of data objects which have someunique features.</p><h4 id="properity-of-data-stream">Properity of Data Stream</h4><p>数据流（Data Stream）是一种连续不断的数据，它的特点是：</p><ul><li>One by One(逐个到达)</li><li>Potentially Unbounded(无界)</li><li><strong>Concept Drift(概念漂移)</strong></li></ul><h4 id="conncept-drift概念漂移">Conncept Drift(概念漂移)</h4><p>Concept Drift is the probability distribution changes.</p><p>概念漂移（ConceptDrift）是指数据流中的数据分布随着时间的推移而发生变化的现象。概念漂移分为两种类型：</p><ul><li>Real concept drift (真实概念漂移)</li><li>Virtual concept drift (虚假概念漂移)</li></ul><h4 id="concept-drift-detection概念漂移检测">Concept DriftDetection(概念漂移检测)</h4><ol type="1"><li>Distribution-based detector(基于分布的检测器)</li></ol><p>监测两个固定或可变化的数据窗口之间的数据分布变化，如果数据分布发生变化，则认为发生了概念漂移。方法很简单：只要<spanclass="math inline">\(W\)</span>的两个足够大的子窗口<spanclass="math inline">\(W_1\)</span>和<spanclass="math inline">\(W_2\)</span>的数据分布不同，就认为发生了概念漂移，这时较旧的窗口就被放弃。</p><p><strong>draw back(缺点)</strong>：</p><ul><li>Hard to determine window size.</li><li>Learn concept drift slower</li><li>Virtual concept drift</li></ul><p><strong>Adaptive Windowing(ADWIN)</strong>:</p><p>ADWIN 的思想是从时间窗口 <span class="math inline">\(W\)</span>开始，在上下文没有明显变化时动态增大窗口 <spanclass="math inline">\(W\)</span>，并在检测到变化时将其缩小。该算法试图找到显示不同平均值的 <span class="math inline">\(W -w_0\)</span> 和 <span class="math inline">\(w_1\)</span> 的两个子窗口。这意味着窗口的旧部分 <span class="math inline">\(- w_0\)</span>是基于与实际不同的数据分布，因此被删除。</p><ol type="1"><li>Error-rate based detector(基于错误率的检测器)</li></ol><p>根据分类性能的变化来捕捉概念的漂移,如果分类器的错误率超过了某个阈值，则认为发生了概念漂移。</p><p>DDM算法：</p><p>DDM算法的基本思想是：在数据流中，如果某个时间点的错误率比之前的错误率大很多，则认为发生了概念漂移。确定错误率的变化是否显著的方法如下公式：</p><p><span class="math display">\[p_i + s_i \ge p_{min} + 3 \timess_{min}\]</span></p><p>误差率是指观察到错误的概率<spanclass="math inline">\(p_i\)</span>，其标准差为<spanclass="math inline">\(s_i = sqrt(p_i (1 - p_i) / i)\)</span></p><p><strong>draw back(缺点)</strong>：</p><ul><li>Sensitive to noise</li><li>Hard to deal with gradual concept drift</li><li>Depend on learning model itself heavily</li></ul><h4 id="data-stream面临的挑战">Data Stream面临的挑战</h4><ul><li>Infinite Length(无限长度)</li><li>Evolving Nature(不断变化的数据)</li></ul><h3 id="data-stream-clissification数据流分类">Data StreamClissification(数据流分类)</h3><p>流程：</p><ul><li>从数据流中读取下一个可用数据(要求1)</li><li>用读取的数据更新分类器，并且这样做不回超过对它设置的内存限制(要求2)，并尽可能快地完成（要求3）</li><li>算法已经学习了足够的数据，以便在新数据上进行分类(要求4)</li></ul><p><strong>典型算法</strong>：</p><ul><li>VFDT(very fast decision tree, KDD'00)</li><li>CVFDT(Concept-adapting very fast decision tree, KDD'01)</li><li>SyncStream(同步流算法, KDD'14)</li></ul><h4 id="vfdt">VFDT</h4><p>Hoeffding树是一种基于决策树学习的数据流分类算法，在处理数据流时，可以保证挖掘效率的同时，达到对数据流一些必要操作的要求。该算法简单的对数据流中的每个样本检查一次，并逐步生成一颗决策树，而在这些样本更新完决策树之后无需进行存储。在内存中只需维护决策树信息，因为在决策树的叶结点中存储着决策树扩展所必须的统计信息，并且在处理训练数据集时，可以用决策树中的信息进行预测。</p><p>VFDT（very fast decision tree）是基于Hoeffdingtree改进的算法和系统，它和Hoeffdingtree算法相似之处在于都是根据<strong>Hoeffding不等式</strong>来决定决策节点的最佳属性从而建立决策树模型。</p><p>Hoeffding 不等式:</p><p>Hoeffding不等式适用于有界的随机变量。设有两两独立的一系列随机变量<spanclass="math inline">\(X_1, X_2, ..., X_n\)</span>，且<spanclass="math inline">\(X_i\)</span>的取值范围是<spanclass="math inline">\([a_i, b_i]\)</span>，这<spanclass="math inline">\(n\)</span>个随机变量的经验期望<spanclass="math inline">\(\bar{X}=\frac{X_1 + \dots +X_n}{n}\)</span>满足以下不等式：</p><p><span class="math display">\[P(|\bar{X} - E(\bar{X})| \ge \epsilon)\ge \exp(-\frac{2n^2\epsilon^2}{\sum_{i=1}^n(b_i - a_i)^2})\]</span></p><p><span class="math display">\[P(|\bar{X} - E(\bar{X})| \ge \epsilon)\le 2 \exp(-\frac{2n^2\epsilon^2}{\sum_{i=1}^n(b_i -a_i)^2})\]</span></p><p>其中<span class="math inline">\(E(\bar{X})\)</span>是<spanclass="math inline">\(\bar{X}\)</span>的期望，<spanclass="math inline">\(\epsilon\)</span>是一个正数。</p><p>VFDT系统解决了Hoeffdingtree算法没有提到的实际问题，就是当两个属性的信息熵差不多时，这个时候就会发生两个属性之间的权衡。这是系统需要花费大量的时间和空间，利用更多的样本来决定选择哪个属性为最佳的决策节点的属性，而这显然是浪费的。</p><p>VFDT算法相较于Hoeffding Tress算法的改进：</p><ul><li>提供了一个用户定义的阈值<span class="math inline">\(τ\)</span>用来解决“两个属性的信息熵差不多时的博弈”。当信息熵差值小于某个阈值时，即可判定其为决策节点属性。</li><li>允许设定节点的最小样本个数值<spanclass="math inline">\(n_{min}\)</span>，在用户能够承受的置信度下，让用户设定每个节点最小的样本数将有效的减少样本信息熵<spanclass="math inline">\(G\)</span>的计算而消耗的时间复杂度。</li><li>提供重新扫描数据集和二次抽样的功能，并且在数据流中的样本数减少时，决策树的精度也会无限逼近于读取所有样本建立决策树的精度。</li></ul><p><strong>以下是 VFDT 算法的基本流程</strong>：</p><ol type="1"><li><p>构建决策树：对于一个分类问题，首先需要构建一颗决策树。该决策树会被VFDT 算法不断地更新和重新构建。</p></li><li><p>建立示例集：随机选择一些实例作为示例集。</p></li><li><p>计算初始统计信息：对于示例集中的每个实例，计算它们分类结果的概率分布。</p></li><li><p>增量统计每个实例：对于新增加的每个实例，将其加入当前的示例集，并更新分类结果的概率分布。</p></li><li><p>检查增量误差：计算每个分类器的误差，并选择一个误差最小的分类器来更新决策树。</p></li><li><p>执行更新：将当前分类器放到决策树上对应的位置，并更新决策树。</p></li></ol><p>重复步骤 4-6，直到决策树满足一定条件。</p><p>VFDT算法是一种增量式建树算法，它通过不断更新决策树的方法来尽可能地减小误差。这种算法的好处是，可以随时加入新的数据，更新模型，同时不需要重新训练整个模型。但是，VFDT算法也存在一些缺点，比如计算复杂度较高，对异常数据较为敏感等。</p><h5 id="vfdt的优缺点">VFDT的优缺点</h5><p><strong>优点</strong>：</p><ul><li>Scales better than traditional methods(比传统方法更好)<ul><li>Sublinear with sampling(子线性采样)</li><li>Very small memory utilization(非常小的内存使用率)</li></ul></li><li>Incremental(增量学习)<ul><li>Make class predictions in parallel(并行预测分类)</li><li>New examples are added as they come(新的样本随着到来而添加)</li></ul></li></ul><p><strong>缺点</strong>：</p><ul><li>Could spend a lot of time with ties(可能会花费很多时间)</li><li>Memory used with tree expansion(内存使用率随着树的扩展而增加)</li><li>Number of candidate attributes(候选属性的数量大)</li></ul><h4id="cvfdtconcept-adapting-very-fast-decision-tree">CVFDT(Concept-adaptingvery fast decision tree)</h4><p>CVFDT是VFDT的改进版，它保持了VFDT的精度和速度，VFDT算法假设所分析处理的数据流是平稳分布的，所以应对数据流中概念变化时采用的是单一的决策树模型，这就导致VFDT的决策树模型不能及时反映数据流随时间变化的趋势。</p><p>另外VFDT也没有处理连续值属性的问题。因为在CVFDT中滑动窗口的引入，过时的样本都被删除，所以 CVFDT 树比 VFDT 树要小很多。CVFDT根据滑动窗口中的数据流样本来持续检测旧的决策树的有效性从而保证建立模型与概念漂移同步。</p><p>CVFDT算法对VFDT算法的改进如下：</p><ul><li><strong>CVFDT算法解决了VFDT算法不能处理数据流中概念漂移的问题</strong>。通过在VFDT算法基础上添加滑动窗口使得建立决策树模型的数据流能够不断实现更新，保证在概念漂移的数据流中保持模型的准确率。</li><li>对于每个节点包括根节点都有相应的ID。样本遍历每个节点时不仅会在节点处保存其样本的属性信息，同时窗口中的样本也会保存其遍历过的节点信息。当样本滑出窗口时，该样本所经历过的节点统计值将依次减一。</li><li>CVFDT还为每个决策节点设置备选子树，周期性的检测每个决策节点的准确率从而决定替代子树是否替换当前的决策节点，从而也有效的提高了决策树模型的准确率。</li></ul><p>CVFDT算法流程如下：</p><p><img src="/img/大数据/ch5-CVFDT-流程.png" /></p><p>CVFDT算法采用增量的方式训练决策树，解决了VFDT算法不能处理连续属性的问题，并且在处理大规模数据时效率更高。</p><h4 id="syncstream">SyncStream</h4><p>KNN style</p><!-- 待完善 --><h4 id="open-set-problem">Open-set problem</h4><ul><li>Novel class Dection(Extreme Value Theory,EVT)</li></ul><p>EVT 中心思想是概率分布，可给出事件发生概率的数学公式。</p><ul><li>Continued learning(Elastic Weight Consolidation,EWC)</li></ul><p>EWC的基本思想：模型中的一些参数对前面的任务很重要。只改变不重要的参数</p><p>Gradient Episodic Memory(GEM)的基本思想:限制梯度的方向来改善之前的工作</p><ul><li>Class-incremental learning</li></ul><p>问题：</p><ol type="1"><li>怎么平衡新旧类的样本</li><li>怎么平衡新旧类的样本的重要性</li><li>怎么提取榜样样本(exemplars examples)</li></ol><p><strong>Knowledge Distillation(知识蒸馏)</strong>:</p><p><strong>Weight Aligning(权重对齐)</strong>:通过对齐权重来减少模型的参数数量</p><h3 id="data-stream-clustering流聚类">Data StreamClustering(流聚类)</h3><h4 id="framework">Framework</h4><p>有两个阶段</p><ol type="1"><li>online Dataabstraction(数据抽象):将数据归纳为具有内存效率的数据结构</li><li>offline clustering(离线聚类):使用聚类算法来寻找数据类别</li></ol><!-- online阶段首先根据K-mens算法生成p个初始的聚类中心(micro clusters)，并为每一个簇提供一个独一无二的ID，其中P是大于具体的聚类数目但是要远远小于具体数据点的个数。对于每一个到来的数据点，要么被现有的微集群吸收（是否在一个集群的最大边界内-均值根偏差RMS），要么自己成立一个集群。但是数据点不属于现有的集群有两种情况，一种是该点是一个异常点，第二种是该点是一个新集群的起始点。那么如果要新建立一个集群的话，就需要将已有的集群删除一个或者合并两个相似的集群。若要删除一个集群的话，首先判断删除该集群是否会有不良的影响，所以根据该集群的数据点的时间戳信息来判断，如果该簇的时间戳不满足设定的阈值，将其删除。合并集群的话，将两个最近的集群进行合并。 --><p>流聚类算法：</p><p><img src="/img/大数据/ch5-流聚类算法.png" /></p><!-- offline clustering(离线聚类)根据用户输入的需要查看的时间，从特征金字塔中取出两个时间段的汇总信息，相减之后就得到用户所需时间段的近似数据集，在此基础上进行聚类即可。 --><h4 id="online-data-abstraction">online Data abstraction</h4><p><strong>Micro-Cluster</strong>: A Micro-Cluster is a set ofindividual data points that are close to each other and will be treatedas a single unit in further offlineMacro-clustering.(Micro-Cluster是一组彼此接近的单个数据点，将在进一步的离线宏聚类中作为单个单元处理。)</p><p><strong>Cluster Feature</strong>:用来表示一个Micro-Cluster的属性，<span class="math inline">\(CF = (N,LS, SS)\)</span></p><p>其中<span class="math inline">\(LS = \sum\limits_{i=1}^N X_i, SS =\sum\limits_{i=1}^N X_i^2\)</span></p><p>其中<span class="math inline">\(N\)</span>是数据点，<spanclass="math inline">\(LS,SS\)</span>中的<spanclass="math inline">\(X_i\)</span>是一个向量。</p><p><strong>Cluster Feature</strong>的属性：Additivity Property</p><p><img src="/img/大数据/ch5-CF属性-1.png" /> <imgsrc="/img/大数据/ch5-CF属性-2.png" /></p><ol type="1"><li>动态选择short-term和long-term的代表性example，代表性高的保留，代表性低的删除，没有，若代表性没有改变，就进行statisticsummary(摘要统计)</li><li>Cluster Feature的属性：Additivity Property</li></ol><h2 id="ch6-graph-mining">Ch6 Graph Mining</h2><h3 id="key-node-identification">Key Node Identification</h3><h4 id="centrality">Centrality</h4><p><strong>DegreeCentrality</strong>:节点度的大小用来衡量节点的重要性（节点的直接影响）。</p><p><strong>BetweennessCentrality</strong>：每个顶点的间性中心度是通过该顶点的这些最短路径的数量。</p><p><strong>ClosenessCentrality</strong>：计算为节点与图中所有其他节点之间的最短路径长度之和。</p><h3 id="k-shell-decomposition">K-shell Decomposition</h3><p>将图中结点度为1的所有结点和对应的连边去掉后，新的网络中可能会有新的度为1的结点，把这些结点和边也去掉，重复操作，直到不再有度为1的结点为止。这种操作类似于剥去网络最外面一层壳，所以把所有去除的结点以及他们之间的连边称为网络的1-壳(1-shell)。网络中度为0的独立结点称为0-壳(0-shell)。在去除1-壳后的网络中，所有结点度都大于等于2，因此，接着把度为2的结点和对应连边去掉，直到不再有度为2的结点为止，则去除的结点和边称为2-壳(2-shell)。依此类推，直到网络中每个结点都划分到相应k-shell中，就得到网络的k-shell分解。</p><p>每个结点都唯一对应一个k-shell，这个k-shell中的结点的度一定大于等于k。但是注意，度相同的结点不一定属于同一个k-shell。并且，度大的结点既可能属于k值大的k-shell(最内层)，可能能属于k值较小的shell(外层)。所以，度值大的未必就重要。</p><p>优点：</p><ul><li>计算复杂度低</li><li>直观的揭示了网络的层次结构</li></ul><p>缺点：</p><ul><li>不能在很多网络中使用，如星形网络、树形网络等。</li><li>不能很好地反映网络的重要性，有时候甚至不如单纯用节点度值衡量效果好。</li></ul><h3id="eigenvector特征向量e.g.pagerank">Eigenvector（特征向量）e.g.PageRank</h3><p>PageRank是Google最早的搜索引擎核心用的就是这个算法</p><p>PageRank基本思想：如果一个页面被很多其他页面链接到的话说明这个页面比较重要，如果一个页面被一个很重要的页面链接到的话，那么这个页面也很重要。</p><h3 id="community-detection">Community Detection</h3><h4 id="cut-based-methods">Cut-based Methods</h4><h5 id="minimum-cut">Minimum Cut</h5><p>由于大多数节点互动是在组内进行的，而组与组之间的互动则很少。所以我们可以把communitydetection问题转换为一个最小割问题。最小割问题是指在一个无向图中，找到一条边的集合，使得这些边的权重之和最小，且删除这些边之后，图被分成两个部分。</p><h5 id="ratio-cut-normalized-cut">Ratio Cut &amp; Normalized Cut</h5><p>由于最小割往往返回一个不平衡的partation，其中的一个集合是一个单点，所以我们可以用RatioCut和NormalizedCut来解决这个问题。思想是在最小割的基础之上修改目标函数以考虑到partation的平衡性。</p><p><img src="/img/大数据/ch6-ratio-cut.png" /></p><p><img src="/img/大数据/ch6-norm-cut.png" /></p><p>其中<span class="math inline">\(C_i\)</span>是一个子集和，<spanclass="math inline">\(\bar{C_i}\)</span>是<spanclass="math inline">\(C_i\)</span>的补集，<spanclass="math inline">\(|C_i|\)</span>是子集和的大小，<spanclass="math inline">\(vol(C_i)\)</span>是子集和中所有节点的度之和。</p><p>在 RatioCut切图中，不仅要考虑使不同组之间的权重最小化，也考虑了使每个组中的样本点尽量多。</p><p>在 Norm Cut切图中，除了考虑最小化损失函数之外，还考虑了子图之间的权重大小。</p><p>由于子图样本的个数多并不一定权重就大，切图时基于权重也更合目标，因此一般来说Normcut 切图优于 RatioCut 切图。</p><h5 id="modularity-maximization模块度最大化">ModularityMaximization(模块度最大化)</h5><p>模块度通过考虑度分布来衡量Community partition的强度。</p><p>给定一个有<spanclass="math inline">\(m\)</span>条边的网络，学位为<spanclass="math inline">\(d_i\)</span>和<spanclass="math inline">\(d_j\)</span>的两个节点之间的预期边数为<spanclass="math inline">\(d_i d_j / 2 m\)</span></p><p>给定如下例子：</p><p><img src="/img/大数据/ch6-Modularity-Maximization-例子图.png" /></p><p>则节点<span class="math inline">\(1\)</span>和<spanclass="math inline">\(2\)</span>之间的预期边数为<spanclass="math inline">\(3 * 2 / (2 * 14)\)</span></p><p>Strength of a community: <span class="math inline">\(\sum\limits_{i\in C, j \in C} A_{ij} - \frac{d_i d_j}{2m}\)</span></p><p>Modularity(模块度)：<span class="math inline">\(Q =\frac{1}{2m}\sum\limits_{l =1}^k \sum\limits_{i \in C, j \in C} (A_{ij}- \frac{d_i d_j}{2m})\)</span> )</p><p>数值越大，表明community structure越好.</p><h5 id="simulatingdistance-dynamics">Simulating:Distance Dynamics</h5><p>动态距离(Distance Dynamics)是CommunityDetection的一种新视角，它的基本思想是模拟边距离的动态变化。</p><p>它将整个网络视为一个动态系统，根据不同的互动模式模拟距离动态（距离动态与节点动态）.所有边的距离都会收敛，从而直观地识别出社区结构。</p><p>如果两个节点相连，每个节点都会吸引另一个节点，使得另一个节点移动到自己身边.</p><p>边距离:受三种不同类型节点的影响:(a)直接链接节点;(b)共同邻居;(c)独占邻居</p><ul><li>直接链接节点的影响：使u和v更接近。</li><li>共同邻居的影响：使u和v更接近。</li><li>独占邻居的影响：使u和v更接近或更远。</li></ul><p>Distance Dynamics的步骤：</p><ol type="1"><li>Initialization：计算每条边的Jaccard距离</li><li>Dynamics: 研究每条边距离的变化</li><li>Community Detection : 删除距离为1的边</li></ol><p><img src="/img/大数据/ch6-Distance-Dynamics-流程.png" /></p><h3 id="graph-embedding">Graph embedding</h3><h4 id="motivation">Motivation</h4><ul><li>网络包含数十亿的节点和边，对整个网络进行复杂的推理是难以实现的。</li><li>机器学习算法需要向量表示</li><li>如何在Graph embedding的过程中保留Commmunity structure</li><li>如何有效地处理大规模网络</li></ul><p>Graph embedding的目标是将每个节点映射到一个低维空间。</p><p>图是一种非欧几里得结构，图的属性：</p><ul><li>节点的编号是任意的</li><li>图具有任意的大小</li><li>结构复杂</li></ul><p>困难：</p><ul><li>衡量节点之间的相似度</li><li>编码网络信息并生成节点表示</li></ul><h4 id="deepwalk">DeepWalk</h4><!-- DeepWalk的思想类似word2vec，使用图中节点与节点的共现关系来学习节点的向量表示。那么关键的问题就是如何来描述节点与节点的共现关系，DeepWalk给出的方法是使用随机游走(RandomWalk)的方式在图中进行节点采样。RandomWalk是一种可重复访问已访问节点的深度优先遍历算法。给定当前访问起始节点，从其邻居中随机采样节点作为下一个访问节点，重复此过程，直到访问序列长度满足预设条件。![](/img/大数据/ch6-deepwalk-流程.png)#### Node2Vec**优化目标**:设$f(u)$是是将顶点 $u$ 映射为embedding向量的映射函数,对于图中每个顶点$u$,定义$N_{S}(u)$为通过采样策略$S$采样出的顶点$u$的近邻顶点集合。node2vec优化的目标是给定每个顶点条件下，令其近邻顶点（**如何定义近邻顶点很重要**）出现的概率最大。![](/img/大数据/ch6-Node2vec-公式.png) --><p>详见<a href="https://zhuanlan.zhihu.com/p/56380812">【GraphEmbedding】DeepWalk：算法原理，实现和应用</a></p><h4 id="node2vec">Node2vec</h4><p>详见<a href="https://zhuanlan.zhihu.com/p/56542707">【GraphEmbedding】node2vec：算法原理，实现和应用</a></p><h2 id="ch7-hadoopspark">Ch7 Hadoop/Spark</h2><h3 id="hadoop">Hadoop</h3><h4 id="what-is-hadoop">What is Hadoop</h4><p>Hadoop是一个软件框架，用于在大型计算机集群中分布式处理大型数据集。</p><h4 id="design-principles-of-hadoop">Design Principles of Hadoop</h4><ul><li>Need to process big data</li><li>Need to parallelize computation across thousands of nodes</li><li>Commodity hardware<ul><li>Large number of low-end cheap machines working in parallel to solvea computing problem</li></ul></li><li>This is in contrast to Parallel DBs<ul><li>Small number of high-end expensive machines</li></ul></li><li>Automatic parallelization &amp; distribution<ul><li>Hidden from the end-user</li></ul></li><li>Fault tolerance(容错) and automatic recovery<ul><li>Nodes/tasks will fail and will recover automatically</li></ul></li><li>Clean and simple programming abstraction.(干净而简单的编程抽象)<ul><li>Users only provide two functions “map” and “reduce”</li></ul></li></ul><h4 id="hadoop-architecture">Hadoop Architecture</h4><ul><li>Distributed file system (HDFS)</li><li>Execution engine (MapReduce)</li></ul><p><img src="/img/大数据/ch7-Hadoop-Architecture.png" /></p><h3 id="eco-system-of-hadoop">Eco-system of Hadoop</h3><ul><li>HDFS:Storing(存储)</li><li>MapReduce:computation</li><li>HBASE:NoSQL database</li><li>Hive:Data warehouse(数据仓库)</li><li>Pig:Data flow language</li><li>Zookeeper:Coordination service</li><li>Core:Filesystems and I/O</li><li>Avro:Cross-language serialization(跨语言序列化)</li></ul><h3 id="hadoop-distributed-file-systemhdfs分布式文件系统">HadoopDistributed File System(HDFS)：分布式文件系统</h3><p><strong>Main Properties of HDFS</strong>:</p><ul><li><strong>Large</strong>:一个HDFS实例可能由数以千计的服务器机器组成，每个机器都存储着文件系统的部分数据</li><li><strong>Replication</strong>:每个数据块被多次复制（默认为3）。</li><li><strong>Failure</strong>:失败是常态而不是例外</li><li><strong>FaultTolerance</strong>:检测故障和快速自动恢复故障是HDFS的一个核心架构目标</li></ul><h4 id="namenode-datanode"><strong>NameNode + DataNode</strong></h4><ul><li>NameNode(meta-information)<ul><li>Managing FsImage file and EditLog file to manager metainformation</li><li>EditLog is used to update FsImage (Checkpoint).</li></ul></li><li>DataNode(actual data)<ul><li>Store data</li><li>Block operation</li></ul></li></ul><h4 id="fault-tolerance-replication-heartbeat"><strong>FaultTolerance</strong>: Replication + HeartBeat</h4><ul><li>HeartBeat:DataNode</li><li>Replication:Steady NameNode</li></ul><h3 id="mapreduce">MapReduce</h3><p>MapReduce的思想就是“分而治之”</p><h4 id="map">Map</h4><p>Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：</p><ul><li>一是数据或计算的规模相对原任务要大大缩小;</li><li>二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算;</li><li>三是这些小任务可以并行计算，彼此间几乎没有依赖关系。</li></ul><h4 id="reduce">Reduce</h4><p>Reducer负责对map阶段的结果进行汇总。至于需要多少个Reducer，用户可以根据具体问题具体设置。</p><h3 id="spark基于内存的计算框架">Spark(基于内存的计算框架)</h3><p>MapReduce is great at one-pass computation,but inefficient formulti-pass algorithms.</p><h4 id="what-is-spark">What is Spark</h4><p><strong>Apache Spark is a fast and general-purpose cluster computingsystem.</strong>It also supports a rich set of higher-level toolsincluding <strong>Spark SQL</strong> for SQL and structured dataprocessing,<strong> MLlib</strong> for machinelearning,<strong> GraphX</strong> for graph processing,and <strong>Spark Streaming</strong> for streaming processing.</p><h4 id="memory-based-computation">Memory based computation</h4><h5 id="rdd">RDD</h5><p>Spark的主要抽象是resilient distributed dataset(RDD),它表示一个只读的对象集合，在一组机器上进行分区，如果一个分区丢失，可以重建。</p><p>An RDD can be created 2 ways:</p><ul><li>Parallelize a collection</li><li>Read data from an external source</li></ul><h5 id="operations-on-rdd">Operations on RDD</h5><ul><li>transformations：create a new dataset from an existing one</li><li>actions: return a value to the driver program after running acomputation on the dataset</li></ul><h4 id="fault-tolerance">Fault Tolerance</h4><p>暂无待续.</p><h3 id="mapreduce-vs-spark">MapReduce VS Spark</h3><p><strong>MapReduce</strong>:</p><ul><li>Great at <strong>one-pass computation</strong>, but inefficient for<strong>multi-pass algorithms</strong>.</li><li>No efficient primitives for datasharing(没有用于数据共享的有效基元)</li></ul><p><strong>Spark</strong>:</p><ul><li>Extends a programming language with a distributed collectiondata-structure（RDD）.(用分布式集合数据结构（RDD）扩展了一种编程语言)</li><li>Clean APIs in Java, Scala, Python, R.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和数组与差分数组</title>
    <link href="/2023/06/01/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2023/06/01/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和数组与差分数组">前缀和数组与差分数组</h1><h2 id="一维前缀和">一维前缀和</h2><p>对于一维数组<code>nums</code>，其前缀和数组<code>prefix</code>为<span class="math display">\[prefix[i] = \sum\limits^{i}_{1} nums[i]\]</span></p><p>实际中多在前面加一个<code>0</code>，这样<code>prefix[i]</code>就刚好是<code>nums</code>数组的前<code>i</code>项和。</p><h2 id="一维差分数组">一维差分数组</h2><p>一维数组<code>nums</code>的差分数组<code>diff</code>定义：</p><p><span class="math display">\[diff[i] = nums[i] - nums[i - 1]\]</span></p><p>二维差分、二维前缀和与一维差分一维前缀和同理。</p><p>二维前缀和、二维差分定义以及例题详见<ahref="https://juejin.cn/post/7051851325746708511">Hard题学算法(二维前缀和+二维差分）</a></p><h2id="从差分数组前缀和数组求原数组">从差分数组、前缀和数组求原数组</h2><p><strong>差分数组求原数组</strong>：差分数组的前缀和数组就是原数组</p><p><strong>前缀和数组求原数组</strong>（以二维为例,默认在前面添加了一维的<code>0</code>防止越界）：</p><p><span class="math display">\[nums[i][j] = prefix[i + 1][j + 1] -prefix[i][j + 1] - prefix[i + 1][j] + prefix[i][j]\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习期末复习</title>
    <link href="/2023/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习期末复习">机器学习期末复习</h1><h2 id="第一章-机器学习简介">第一章 机器学习简介</h2><h3 id="机器学习的概念">机器学习的概念</h3><p>是一种实现人工智能的方法</p><h3 id="机器学习的要素">机器学习的要素</h3><ul><li>模型：对于监督学习，模型就是要学习的条件概率或者决策函数</li><li>策略<ul><li>目标：选择最优的模型</li><li>损失函数，损失函数越小，模型就越好<ul><li>平方损失函数：<spanclass="math inline">\(L(Y，f(X))=(Y-f(x))^2\)</span>, 其中<spanclass="math inline">\(Y\)</span>是标签（真实值), <spanclass="math inline">\(f(X)\)</span>是预测值。</li></ul></li><li>风险函数（期望损失）：损失函数的期望</li><li>经验风险：训练集的平均损失，训练集的拟合情况 <spanclass="math display">\[结构风险  =  经验风险 + 正则化项 (系数 *模型复杂度)\]</span></li></ul></li><li>算法：用什么样的计算方法求解最优模型。归结为最优化问题</li></ul><h3 id="机器学习的类型">机器学习的类型</h3><ul><li>监督学习：监督学习是指通过让机器学习大量带有标签的样本数据，训练出一个模型，并使该模型可以根据输入预测相应输出的过程</li><li>无监督学习：训练数据不再是（input,output）对的形式，样本数据没有标签</li><li>强化学习：通过感知外界环境的变化来调整学习方式，然后通过奖惩的方式来判别学习方式是否正确，通过一步步调整学习方式，最终找到一个最优的方式。通过一个智能体在与复杂而不确定的环境交互中最大化总回报来学习的一种计算方法</li></ul><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>训练误差：训练集的平均损失</p><p>测试误差：测试集的平均损失</p><h3 id="回归和分类">回归和分类</h3><p>回归：因变量𝑦 ∈ ℝ是连续变量 分类：label是离散变量</p><h3 id="过拟合">过拟合</h3><p>欠拟合：模型在训练集上误差很大，在测试集上误差也大。由于模型能力不足（不灵活）</p><p>过拟合(Over-fitting)：模型在训练集上误差很低，但是在测试数据上误差很高。由于训练数据太少和/或模型能力太强等原因造成</p><p><img src="/img/机器学习/过拟合.jpg" /></p><p>解决过拟合的方法:</p><ul><li>扩大训练集</li><li>正则化Regularization：通过修改目标函数来惩罚模型的复杂度<ul><li>L1正则化：可以使参数稀疏化</li><li>L2正则化：可以防止过拟合</li></ul></li><li>通过验证集来选择模型</li></ul><h3 id="模型选择方法">模型选择方法</h3><p><strong>正则化</strong>:</p><p>结构风险 = 经验风险 + 正则化项</p><p><img src="/img/机器学习/期末复习/结构风险.png" /></p><p>在回归问题中，正则化项可以是L1,L2范数：</p><p><img src="/img/机器学习/期末复习/L1L2范数.png" /></p><p>其中，L1 L2范数分别为</p><p><img src="/img/机器学习/期末复习/L1L2范数定义.png" /></p><p><strong>奥卡姆剃刀原理</strong>：在已知数据的情况下，越简单的模型越好</p><p><strong>贝叶斯估计视角</strong>：正则化项为模型先验概率</p><h3 id="交叉验证">交叉验证</h3><p>数据集划分为三个部分：训练集，测试集，验证集。训练集用于模型训练，测试集用于最终对学习方法评估，验证集用于模型选择。在学习到不同复杂度的模型中，选择验证集最小预测误差的模型。</p><ul><li>简单交叉验证：划分训练集和测试集，用不同的模型对训练集进行训练，最终在测试集评价每一个模型的误差，选出误差最小的模型。</li><li>S折交叉验证：把数据集划分成s份，用其中的s-1份训练模型，用剩下的一份测试模型。其中，一共有s种组合，对s种组合重复对对模型进行训练和评测。最终，选出在这s次训练和评测中，平均误差最小的模型。</li><li>留一交叉验证：s折交叉验证的特殊情况：S=N，N为数据集的个数。即为：只留一个样本用作测试。</li></ul><h3 id="泛化能力">泛化能力</h3><p>对未知数据集的预测能力</p><h3 id="生成模型与判别模型">生成模型与判别模型</h3><ul><li>生成模型：生成方法由数据学习联合概率分布<spanclass="math inline">\(P(X,Y)\)</span>,然后求出条件概率分布 <spanclass="math inline">\(P(Y|X)\)</span>作为预测的模型：<spanclass="math inline">\(P(Y|X) = {P(X,Y)/P(X)}\)</span>。最后模型: <spanclass="math inline">\(P(Y)=P(Y|X)*P(X)\)</span>。</li><li>判别模型：直接学习决策函数或者 P(Y|X)作为预测的模型。</li></ul><h3 id="二分类评价指标">二分类评价指标</h3><p>精确率和召回率：TP, FP, TN, FN（true/false positive/negitive）</p><p>精确率: <span class="math inline">\(P = \frac{TP}{TP +FP}\)</span></p><p>召回率: <span class="math inline">\(R = \frac{TP}{TP+FN}\)</span></p><h3 id="贝叶斯定理">贝叶斯定理</h3><p><span class="math inline">\(P(A|H) =\frac{P(A)P(H|A)}{P(H)}\)</span></p><h4 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h4><p><strong>先验概率</strong>:<spanclass="math inline">\(P(Y=c_k),k=1,2,...,K\)</span></p><p><strong>条件概率（似然概率）</strong>:<spanclass="math inline">\(P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,...,K\)</span></p><p><strong>后验概率</strong>:<spanclass="math inline">\(P(Y=c_k|X=x)=\frac{P(Y=c_k)P(X=x|Y=c_k)}{\sum_{k=1}^KP(Y=c_k)P(X=x|Y=c_k)}\)</span></p><h2 id="第二章-概率论概述">第二章 概率论概述</h2><h3 id="频率论学派和贝叶斯学派">频率论学派和贝叶斯学派</h3><p><strong>频率论学派（Frequentist）</strong>：通过大量独立实验将概率解释为事件发生频率的均值（大数定律）</p><p><strong>贝叶斯学派（Bayesian）</strong>：则将概率解释为信念度（degreeofbelief）。当考虑的试验次数非常少的时候，贝叶斯方法的解释非常有用。此外，贝叶斯理论将我们对于随机过程的先验知识纳入考虑，当我们获得新数据的时候，这个先验的概率分布就会被更新到后验分布中</p><h3 id="高斯分布">高斯分布</h3><p><img src="/img/机器学习/期末复习/高斯分布.jpg" /></p><h3 id="极大似然估计和最大后验估计">极大似然估计和最大后验估计</h3><p><strong>极大似然估计（频率学派模型参数估计常用方法）</strong>：通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！即最大化<spanclass="math inline">\(P(x_0|\theta)\)</span></p><p><img src="/img/机器学习/期末复习/极大似然估计.jpg" /></p><p><strong>最大后验估计（贝叶斯派模型参数估计的常用方法）</strong>：最大化在给定数据样本的情况下模型参数的后验概率。即最大化<span class="math inline">\(P(\theta | x_0) = \frac{P(x_0 |\theta)P(\theta)}{P(x_0)}\)</span>。最大似然估计是求参数 <spanclass="math inline">\(\theta\)</span>使似然函数最大。最大后验概率估计则是想求<spanclass="math inline">\(\theta\)</span>使<spanclass="math inline">\(P(x_0|\theta)\)</span>最大 。求得的<spanclass="math inline">\(\theta\)</span>不单单让似然函数大,<spanclass="math inline">\(\theta\)</span>自己出现的先验概率也得大。</p><p><img src="/img/机器学习/期末复习/最大后验分布.png" /></p><h2 id="第三章-优化方法简介">第三章 优化方法简介</h2><h3 id="梯度下降法">梯度下降法</h3><p>一种求解的最优化算法（无约束），主要解决求最小值问题，基本思想是下山，即不断逼近最优点的思想，通过求梯度的反方向，来确定错误面中的最低点的方向（有可能是局部最低点），从而不断逼近最小值。设损失函数为：<spanclass="math inline">\(J(\theta)=\frac{1}{2}[f(x)-y]^2\)</span>,则梯度下降为：<span class="math inline">\(\theta_{n+1} = \theta_{n} - \alphaJ&#39;(\theta)\)</span> 其中<spanclass="math inline">\(\alpha\)</span>为学习率。</p><h4 id="确定学习率的方法">确定学习率的方法</h4><ul><li>线性搜索法：<span class="math inline">\(\eta_t = argminf(x - \eta\Delta f(x))\)</span>,一般来说在实际中代价太高</li><li>线性回溯搜索算法：<span class="math inline">\(f(x-\eta \Delta f(x))\le f(x) - \alpha \eta ||\Delta f(x)||^2\)</span>,在实际中work well</li></ul><h4 id="应用梯度下降的不同形式">应用梯度下降的不同形式</h4><ul><li>批量梯度下降（BGD）：更新参数时使用所有样本进行更新，梯度更新比较耗时，但是会更准确朝极值方向更新，迭代次数少</li><li>随机梯度下降(SGD)：每步仅选取一个样本求梯度，梯度更新快，但下降时候波动大，更容易从一个局部最优跳到另一个局部最优，准确度下降。迭代次数多，可能不收敛，或陷入局部极值或鞍点。</li><li>小批量梯度下降(MBGD)：上面两个的折衷，每步采用固定一部分的样本计算梯度梯度更新比BGD快，迭代次数比SGD少。学习过程仍会有振荡，为更接近最小值，需要增加学习率衰减项，避免过度振荡。</li></ul><p><strong>使用建议</strong>：当训练集比较小时，批学习，采用拟牛顿或者共轭梯度下降；当训练集大时，随机梯度下降；当训练集介于其间时，小批量学习</p><h3 id="拉格朗日乘子法和kkt条件">拉格朗日乘子法和KKT条件</h3><p>梯度下降只能求解无约束问题，对于有约束问题，使用梯度下降法，很可能最小值点根本不在约束范围内，所以用拉格朗日乘子法。</p><h4 id="拉格朗日乘子法">拉格朗日乘子法</h4><p>求解有约束最小值问题（约束为等式）：</p><p><span class="math display">\[\min{f(x)} \\s.t.g(x) = 0\]</span></p><p>即在 <span class="math inline">\(g(x)=0\)</span>的条件下，求 <spanclass="math inline">\(f(x)\)</span>的最小值，引入一个自由变量 <spanclass="math inline">\(\lambda\)</span>,构造拉格朗日函数：</p><p><span class="math display">\[L(x,\lambda)=f(x) + \lambdag(x)\]</span></p><p>则新的方程又变成了无约束问题，对其中的 <spanclass="math inline">\(x,\lambda\)</span>求偏导，联立方程组使其等于0，则所得解就是原方程的解。</p><h4 id="kkt条件">KKT条件</h4><p>用于求解约束为不等式时候的约束问题，只是判断x是否为最优解的<strong>必要条件</strong>。和拉格朗日乘子法一样，引入自由变量，构造拉格朗日函数，设约束条件：</p><p><span class="math display">\[g(x)=0 \\ t(x)≤0\]</span></p><p>求解 <span class="math inline">\(\min f(x)\)</span>.</p><p>同理构造拉格朗日函数：</p><p><span class="math display">\[L(x,\lambda,\theta)=f(x) + \lambda g(x)+ \theta t(x)\]</span></p><p>则对应kkt条件有：</p><ul><li>L对x的偏导数为0；</li><li>g(x)=0;</li><li><span class="math inline">\(\theta t(x)=0\)</span>;</li><li><span class="math inline">\(\theta \ge 0\)</span>;</li></ul><p><img src="/img/机器学习/期末复习/KKT条件.jpg" /></p><h5 id="拉格朗日乘子法求解">拉格朗日乘子法求解</h5><p><img src="/img/机器学习/期末复习/拉格朗日乘子法求解.jpg" /></p><p><strong>总结：同时包含等式和不等式约束的一般优化问题</strong></p><h3 id="对偶">对偶</h3><p>在机器学习中，对偶（duality）是指将一个优化问题转化为其对偶形式，从而更容易地解决原始问题。具体来说，对于一个原始优化问题，通过构建一个拉格朗日函数，并对其进行最大化或最小化，可以得到对偶问题。通过解决对偶问题，我们可以获得原始问题的解。这种方法在解决某些优化问题时非常有用，因为对偶问题可能比原始问题更容易求解。</p><p>用<spanclass="math inline">\(p^*\)</span>表示原问题（最小化）的最优值；<spanclass="math inline">\(d^*\)</span>表示对偶问题（最大化）的最优值。</p><p><strong>弱对偶性</strong>：<span class="math inline">\(d^* \lep^*\)</span>。即使原问题不是凸优化，不等式也成立</p><p><strong>强对偶性</strong>：<span class="math inline">\(d^* =p^*\)</span></p><h4 id="为什么要研究对偶问题">为什么要研究对偶问题</h4><ul><li>虽然对偶方法并不能保证成功，但是它对于某些类别的函数有效，在这些情况下，它总能带来更简单的优化问题，特别是当原问题中自变量的维度比约束的数量大得多的情况下,</li><li>对偶函数总是凹函数，无论原问题如何。所以对偶函数的优化是个凸优化问题</li></ul><h3 id="牛顿法">牛顿法</h3><p>用目标函数的二阶泰勒展开近似该目标函数，通过求解这个二次函数的极小值来求解凸优化的搜索方向</p><h2 id="第四章-回归的线性模型">第四章 回归的线性模型</h2><h3 id="线性回归最小二乘法">线性回归最小二乘法</h3><p>回归就是一个输入连续输出连续的模型，比如 <spanclass="math inline">\(f(x) = \lambda x + \beta\)</span>,其中： <spanclass="math inline">\(\lambda\)</span>为要学习的参数， <spanclass="math inline">\(\beta\)</span>为偏置，过于简单不多说。</p><p><strong>最小二乘法标准</strong>：平方损失函数达到最小</p><p>对于上述一元线性回归模型来说，损失函数 <spanclass="math inline">\(J(\lambda,\beta)=(f(x_i)-y_i)^2\)</span>,使损失函数最小，便是求偏导=0，所以去算损失函数关于参数和偏置的偏导为0即可求解。</p><h3 id="岭回归">岭回归</h3><p>岭回归是一种特殊的线性回归方法，它在<strong>普通线性回归的基础上增加了一个L2正则化项</strong>。</p><p>普通线性回归的损失函数为：</p><p><span class="math display">\[J(\boldsymbol{\theta}) = \frac{1}{m}\sum_{i=1}^{m}{(\boldsymbol{\theta}^{\top}\boldsymbol{x}^{(i)} -y^{(i)})^2}\]</span></p><p>岭回归损失函数为：</p><p><span class="math display">\[J(\boldsymbol{\theta}) = \frac{1}{m}\sum_{i=1}^{m}{(\boldsymbol{\theta}^{\top}\boldsymbol{x}^{(i)} -y^{(i)})^2} + \alpha \sum_{j=1}^{n}{\theta_j^2}\]</span></p><p>其中， <spanclass="math inline">\(\alpha\)</span>是正则化强度的调节参数， <spanclass="math inline">\(\boldsymbol{\theta}\)</span>是回归系数向量， <spanclass="math inline">\(\boldsymbol{x}^{(i)}\)</span>是第 <spanclass="math inline">\(i\)</span>个样本的特征向量，<spanclass="math inline">\(y^{(i)}\)</span>是第 <spanclass="math inline">\(i\)</span>个样本的目标值(标签)， <spanclass="math inline">\(n\)</span>是特征数。</p><p>岭回归通过增加正则化项，使得回归系数更加稳定，从而防止过拟合。在L2正则化下，回归系数会被压缩到接近于0的数值，但不会变成0。因此，岭回归可以保留所有的特征，而不用像特征选择那样舍弃一些特征。</p><p>岭回归的求解方法与普通线性回归类似，只是在最小化损失函数时需要加上正则化项的贡献。最常用的方法是使用解析解：</p><p><span class="math display">\[\boldsymbol{\theta} =(\boldsymbol{X}^{\top}\boldsymbol{X} +\alpha\boldsymbol{I})^{-1}\boldsymbol{X}^{\top}\boldsymbol{y}\]</span></p><p>其中， <spanclass="math inline">\(\boldsymbol{X}\)</span>是样本特征矩阵， <spanclass="math inline">\(\boldsymbol{y}\)</span>是目标值向量， <spanclass="math inline">\(\boldsymbol{I}\)</span>是单位矩阵。</p><p>岭回归的一个关键问题是如何选择正则化强度参数 <spanclass="math inline">\(\alpha\)</span>。通常可以通过交叉验证来选择最佳的<span class="math inline">\(\alpha\)</span>值。</p><h3 id="lasso回归">Lasso回归</h3><p>Lasso回归是一种用于特征选择的线性回归模型，它的<strong>损失函数是平方损失加上L1正则化</strong>。L1正则化会让一部分特征的系数变为0，从而达到特征选择的目的。</p><p>Lasso回归的损失函数为：</p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2 + \alpha \sum_{j=1}^n|\theta_j|\]</span></p><p>其中，第一项是平方损失，第二项是L1正则化项， <spanclass="math inline">\(\alpha\)</span>是正则化参数。</p><p>Lasso回归的优化算法是坐标轴下降法，也称为坐标下降法。它的基本思想是，每次只更新一个参数的值，将其他参数的值固定住。</p><p>Lasso回归有一个重要的应用场景是特征选择。如果某个特征的系数为0，说明这个特征对目标变量没有太大的影响，可以将其从模型中剔除，从而简化模型并提高泛化性能。</p><h2 id="第五章-分类的线性模型">第五章 分类的线性模型</h2><h3 id="线性分类概念">线性分类概念</h3><p>线性分类是一种常见的机器学习技术，旨在将数据分成两个或多个类别。它的基本思想是在特征空间中找到一条直线、平面或超平面，将不同类别的数据分开。线性分类可以用于二元分类（将数据分成两个类别）和多元分类（将数据分成三个或更多类别）问题。</p><p><img src="/img/机器学习/期末复习/线性分类概念.jpg" /></p><p>在二元分类中，线性分类器会将数据点分为两个类别，通常用“+1”和“-1”表示。对于一个新的数据点，分类器会计算它与这条直线、平面或超平面之间的距离，并根据其距离的符号来预测其所属的类别。如果距离为正，则预测其属于正类；如果距离为负，则预测其属于负类。</p><p>线性分类器可以用很多不同的算法来训练。其中，最常用的算法是支持向量机（SVM）。SVM算法通过寻找最大间隔超平面来分割数据。这条超平面可以最大限度地扩大不同类别数据点之间的距离，从而提高分类器的性能。</p><p>除了SVM之外，还有其他的线性分类器算法，例如感知器（perceptron）和逻辑回归（logisticregression）。这些算法也可以用来解决线性分类问题，但它们的性能和训练速度可能会有所不同。</p><h3id="判别函数概率生成模型概率判别模型">判别函数、概率生成模型、概率判别模型</h3><h4 id="判别函数模型">判别函数模型</h4><p>判别函数模型通过学习一个判别函数来直接将输入映射到输出类别，它<strong>不需要生成训练样本的概率分布</strong>。判别函数模型通常适用于高维稠密数据，并且由于它只关注分类结果，而不是关注如何生成数据，因此在训练数据不太充分或噪声较大的情况下也能够有很好的表现。常见的判别函数模型包括支持向量机（SVM）和神经网络（NeuralNetwork）。</p><h4 id="概率生成模型">概率生成模型</h4><p>概率生成模型先对样本的概率分布进行建模，然后通过贝叶斯公式计算后验概率来进行分类或预测。概率生成模型适用于多类别分类或回归问题，并且能够较好地处理缺失数据和噪声。常见的概率生成模型包括朴素贝叶斯（NaiveBayes）和高斯混合模型（Gaussian Mixture Model）。</p><p>概率生成模型先对类条件密度<spanclass="math inline">\(p(x|C_k)\)</span>和先验类概率分布<spanclass="math inline">\(p(C_k)\)</span>建模然后再使⽤贝叶斯定理计算后验类概率分布<spanclass="math inline">\(p(C_k|x)\)</span>.最后，使⽤决策论来确定每个输⼊<spanclass="math inline">\(x\)</span>的类别等价地，直接对联合概率分布建模，再归一化得到后验概率。</p><p><img src="/img/机器学习/期末复习/概率生成模型.jpg" /></p><h4 id="概率判别模型">概率判别模型</h4><p>概率判别模型是通过直接对条件概率分布进行建模来预测输出。与概率生成模型不同，它不需要显式地建模输入的概率分布，而是直接估计类别条件概率。概率判别模型适用于多分类问题，其预测性能优于概率生成模型。常见的概率判别模型包括逻辑回归（LogisticRegression）和多层感知器（Multilayer Perceptron）。</p><p>概率判别模型直接对后验概率<spanclass="math inline">\(p(C_k|x)\)</span>建模,再使⽤决策论来确定每个新的输⼊<spanclass="math inline">\(x\)</span>的类别。</p><h3 id="逻辑回归">逻辑回归</h3><p>Logistic Regression虽然被称为回归，但其实际上是分类模型，并常用于二分类</p><p>逻辑回归是一种经典的机器学习算法，用于处理分类问题。它基于线性模型，将输入特征与输出标签之间的关系建模为一个sigmoid函数，并通过最大化似然函数来学习模型参数。在预测时，逻辑回归将输入特征传入模型，并通过sigmoid函数计算输出标签的概率值，从而得到最终的分类结果。</p><p>假设我们有一个二分类问题，样本集合为</p><p><spanclass="math display">\[D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}\]</span></p><p>其中 <span class="math inline">\(x_i\in R^m\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的 <spanclass="math inline">\(m\)</span>维输入特征向量, <spanclass="math inline">\(y_i\in\{0,1\}\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的标签。</p><p>逻辑回归的目标是学习一个函数 <spanclass="math inline">\(f(x)\)</span>，将输入特征 <spanclass="math inline">\(x\)</span>映射到一个 <spanclass="math inline">\([0,1]\)</span>之间的概率值，即：</p><p><span class="math display">\[P(Y=1|X=x)=\sigma(w^Tx+b)\]</span></p><p>其中, <spanclass="math inline">\(\sigma\)</span>是sigmoid函数，定义为：</p><p><spanclass="math display">\[\sigma(z)=\frac{1}{1+e^{-z}}\]</span></p><p>逻辑回归使用极大似然估计来学习模型参数 <spanclass="math inline">\(w\)</span>和 <spanclass="math inline">\(b\)</span>。</p><p>假设每个样本独立同分布地采样，根据贝叶斯定理，我们可以将样本的似然函数写为：</p><p><spanclass="math display">\[L(w,b)=\prod_{i=1}^nP(Y=y_i|X=x_i;w,b)\]</span></p><p>对数似然函数为：</p><p><span class="math display">\[\log L(w,b)=\sum_{i=1}^n\logP(Y=y_i|X=x_i;w,b)\]</span></p><p>我们的目标是最大化对数似然函数，可以通过梯度上升法来求解。具体来说，我们可以首先计算对数似然函数关于<span class="math inline">\(w\)</span>和 <spanclass="math inline">\(b\)</span>的梯度，然后更新模型参数，重复这个过程直到收敛。</p><p>在预测时，将输入特征 <spanclass="math inline">\(x\)</span>传入训练好的模型，计算 <spanclass="math inline">\(P(Y=1|X=x)\)</span>的值，若大于0.5则预测为正类，否则预测为负类。</p><h3 id="朴素贝叶斯分类器-1">朴素贝叶斯分类器</h3><p>朴素贝叶斯分类器是一种基于贝叶斯定理和特征条件独立假设的分类算法。它通常用于文本分类、垃圾邮件过滤、情感分析等自然语言处理任务。</p><p>假设我们有一个包含 <spanclass="math inline">\(n\)</span>个训练样本的数据集 <spanclass="math inline">\(D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}\)</span>，其中<spanclass="math inline">\(x_i=(x_{i1},x_{i2},\cdots,x_{im})\)</span>表示第<span class="math inline">\(i\)</span>个样本的 <spanclass="math inline">\(m\)</span>个特征， <spanclass="math inline">\(y_i\in\{c_1,c_2,\cdots,c_k\}\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的类别。</p><p>朴素贝叶斯分类器基于贝叶斯定理计算<strong>后验概率</strong> <spanclass="math inline">\(P(y|x)\)</span></p><p>即给定特征 <span class="math inline">\(x\)</span>下类别 <spanclass="math inline">\(y\)</span>的条件概率。根据贝叶斯定理，可以将 <spanclass="math inline">\(P(y|x)\)</span>表示为：</p><p><spanclass="math display">\[P(y|x)=\frac{P(x|y)P(y)}{P(x)}\]</span></p><p>其中， <span class="math inline">\(P(y)\)</span>是类别 <spanclass="math inline">\(y\)</span>的先验概率， <spanclass="math inline">\(P(x)\)</span>是特征 <spanclass="math inline">\(x\)</span>的边缘概率， <spanclass="math inline">\(P(x|y)\)</span>是在类别 <spanclass="math inline">\(y\)</span>下特征 <spanclass="math inline">\(x\)</span>的条件概率。在朴素贝叶斯分类器中，我们假设所有特征都是相互独立的，即：</p><p><span class="math display">\[P(x|y)=\prod_{i=1}^mP(x_i|y)\]</span></p><p>根据上述假设，朴素贝叶斯分类器将 <spanclass="math inline">\(P(y|x)\)</span>简化为：</p><p><span class="math display">\[P(y|x)=\frac{P(y)\prod_{i=1}^mP(x_i|y)}{P(x)}\]</span></p><p>由于 <spanclass="math inline">\(P(x)\)</span>是与类别无关的常量，因此可以忽略掉。于是我们只需要计算先验概率<span class="math inline">\(P(y)\)</span>和条件概率 <spanclass="math inline">\(P(x_i|y)\)</span>即可。</p><p>先验概率 <spanclass="math inline">\(P(y)\)</span>可以通过样本中每个类别出现的频率来估计。对于条件概率<spanclass="math inline">\(P(x_i|y)\)</span>，我们可以根据不同类型的特征进行不同的处理。</p><ul><li>对于离散型特征，我们可以直接计算每个取值出现的频率。</li><li>对于连续型特征，通常假设其服从正态分布，然后估计每个类别下的均值和方差。</li></ul><p>在预测时，我们将测试样本的特征代入上述公式，计算每个类别的后验概率，最终预测为概率最大的类别。</p><h2 id="第六章-支持向量机">第六章 支持向量机</h2><p>简单点讲，SVM就是一种二类分类模型，他的基本模型是的定义在特征空间上的<strong>间隔最大</strong>的线性分类器，SVM的学习策略就是间隔最大化。</p><p>对于支持向量机来说，数据点若是<spanclass="math inline">\(p\)</span>维向量，我们用<spanclass="math inline">\(p-1\)</span>维的超平面来分开这些点。但是可能有许多超平面可以把数据分类。最佳超平面的一个合理选择就是以最大间隔把两个类分开的超平面。因此，SVM选择能够使离超平面最近的数据点的到超平面距离最大的超平面。</p><p>以上介绍的SVM只能解决线性可分的问题，为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型:</p><ul><li><p>线性可分SVM</p><p>当训练数据线性可分时，通过硬间隔(hardmargin，什么是硬、软间隔下面会讲)最大化可以学习得到一个线性分类器，即硬间隔SVM</p></li><li><p>线性SVM</p><p>当训练数据不能线性可分但是可以近似线性可分时，通过软间隔(softmargin)最大化也可以学习到一个线性分类器，即软间隔SVM</p></li><li><p>非线性SVM</p></li></ul><p>当训练数据线性不可分时，通过使用核技巧(kerneltrick)和软间隔最大化，可以学习到一个非线性SVM</p><h3 id="个关键想法">3个关键想法</h3><ul><li>通过优化来求解一 个超平面分类器</li><li>寻找最大间隔分类器来提高模型 的 泛化能力（结构风险最小化）</li><li>采用核技巧使得在高维特征空间的计算更有效率</li></ul><h3 id="线性可分svm硬间隔">线性可分SVM——硬间隔</h3><p>考虑如下形式的线性可分的训练数据集:</p><p><span class="math display">\[(X_1, y_1),(X_2,y_2),...,(X_n,y_n)\]</span></p><p>其中<span class="math inline">\(X_i\)</span>是一个含有<spanclass="math inline">\(d\)</span>个元素的列向量, 即<spanclass="math inline">\(X_i \in R^d\)</span>;<spanclass="math inline">\(y_i\)</span>是标量,<span class="math inline">\(y\in +1, -1\)</span>,<spanclass="math inline">\(y+i=+1\)</span>时表示<spanclass="math inline">\(X_i\)</span>属于正类别,<spanclass="math inline">\(y_i=-1\)</span>时表示<spanclass="math inline">\(X_i\)</span>属于负类别。注：这里的<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(X_i\)</span>、<spanclass="math inline">\(W\)</span>都是列向量。</p><p>回忆一下感知机的目标:找到一个超平面使其能正确地将每个样本正确分类。感知机使用误分类最小的方法求得超平面，不过此时解有无穷多个。而线性可分支持向量机利用间隔最大化求最优分离超平面,这时解是唯一的。</p><p>一个超平面由法向量<span class="math inline">\(W\)</span>和截距<spanclass="math inline">\(b\)</span>决定,其方程为<spanclass="math inline">\(X^TW+b = 0\)</span>,可以规定法向量指向的一侧为正类,另一侧为负类。下图画出了三个平行的超平面，法方向取左上方向。</p><p><img src="/img/机器学习/期末复习/SVM硬间隔.png" /></p><p>为了找到最大间隔超平面，我们可以先选择分离两类数据的两个平行超平面，使得它们之间的距离尽可能大。在这两个超平面范围内的区域称为“间隔(margin)”，最大间隔超平面是位于它们正中间的超平面。这个过程如上图所示。</p><h4 id="间隔最大化">间隔最大化</h4><p>将高数里面求两条平行直线的距离公式推广到高维可求得上图中margin的<spanclass="math inline">\(\rho\)</span>:</p><p><span class="math display">\[margin = \rho =\frac{2}{||W||}\]</span></p><p>我们的目标是使<spanclass="math inline">\(\rho\)</span>最大，等价于使<spanclass="math inline">\(p^2\)</span>最大：</p><p><span class="math display">\[\max\limits_{W,b} \rho\Longleftrightarrow \max\limits_{W,b}\rho^2 \Longleftrightarrow\min\limits{W,b}\frac{1}{2}||W||^2 \tag{1}\]</span></p><p>上式的<spanclass="math inline">\(\frac{1}{2}\)</span>是为了后续求导后刚好能消去，没有其他特殊意义。</p><p>同时也不要忘了有一些约束条件:</p><p><span class="math display">\[X_i^tW+b\ge +1,y_i=+1 \\ X_i^tW+b\le-1,y_i=-1\]</span></p><p>总结一下，间隔最大化问题的数学表达就是</p><p><span class="math display">\[\begin{equation}\min\limits_{W,b} J(W)= \min\limits_{W,b}\frac{1}{2}||W||^2 \\s.t. \quad y_i(X_i^T+b) \ge 1, i = 1,2,...,n    \tag{2}\end{equation}\]</span></p><p>通过求解上式即可得到最优超平面<spanclass="math inline">\(\hat{W}\)</span>和<spanclass="math inline">\(\hat{b}\)</span>。</p><h4 id="支持向量">支持向量</h4><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离<strong>最近</strong>的数据点称为支持向量(supportvector)，支持向量是使<spanclass="math inline">\((2)\)</span>中的约束条件取等的点，即满足</p><p><span class="math display">\[y_i(X_i^TW+b)=1\]</span></p><p>的点。也即所有在直线<spanclass="math inline">\(X_i^TW+b=1\)</span>或直线<spanclass="math inline">\(X_i^TW+b=-1\)</span>的点。如下图所示:</p><p><img src="/img/机器学习/期末复习/支持向量.jpg" /></p><p><strong>在决定最佳超平面时只有支持向量起作用，而其他数据点并不起作用</strong>。如果移动非支持向量，甚至删除非支持向量都不会对最优超平面产生任何影响。也即支持向量对模型起着决定性的作用，这也是“支持向量机”名称的由来。</p><h4 id="对偶问题">对偶问题</h4><p>如何求解式<span class="math inline">\((2)\)</span>呢？</p><p>我们称式<spanclass="math inline">\((2)\)</span>所述问题为原始问题(primal problem),可以应用拉格朗日乘子法构造拉格朗日函数(Lagrangefunction)再通过求解其对偶问题(dualproblem)得到原始问题的最优解。转换为对偶问题来求解的原因是:</p><ul><li>对偶问题更易求解，由下文知对偶问题只需优化一个变量<spanclass="math inline">\(\alpha\)</span>且约束条件更简单；</li><li>能更加自然地引入核函数，进而推广到非线性问题。</li></ul><p>首先构建拉格朗日函数。为此需要引进拉格朗日乘子(Lagrangemultiplier),<span class="math inline">\(\alpha_i \ge0,i=1,2,...,n\)</span>。则拉格朗日函数为:</p><p><span class="math display">\[L(W,b,\alpha)=\frac{1}{2}||w||^2 -\sum\limits_{n}^{i=1}\alpha_i [y_i(X_i^TW+b)-1]\]</span></p><p>因此，给定一个<span class="math inline">\(W\)</span>和<spanclass="math inline">\(b\)</span>, 若满足式<spanclass="math inline">\((1)\)</span>的约束条件，那么有</p><p><spanclass="math display">\[\max\limits_{\alpha}L(W,b,\alpha)=J(W)=\frac{1}{2}||W||^2\]</span></p><p>则由上式可知，优化问题</p><p><span class="math display">\[\min\limits_{W,b}\max\limits_{\alpha}L(W,b,\alpha)\]</span></p><p>与式<span class="math inline">\((1)\)</span>所述问题完全等价。</p><p>根据拉格朗日对偶性，式<spanclass="math inline">\((1)\)</span>所述问题即原始问题的对偶问题是:</p><p><span class="math display">\[\max\limits_{\alpha} \min\limits_{W,b}L(W,b,\alpha)\]</span></p><p>为了求得对偶问题的解，需要先求得<spanclass="math inline">\(L(W,b,\alpha)\)</span>对<spanclass="math inline">\(W\)</span>和<spanclass="math inline">\(b\)</span>的极小再求对<spanclass="math inline">\(\alpha\)</span> 的极大。</p><ol type="1"><li>求<span class="math inline">\(\min\limits_{W,b}L(W,b,\alpha)\)</span>:对拉格朗日函数求导并令导数为0，有：</li></ol><p><span class="math display">\[\begin{equation}\nabla_W L(W, b, \alpha)=W-\sum_{i=1}^n \alpha_i y_i X_i=0\Longrightarrow W=\sum_{i=1}^n \alpha_i y_i X_i \tag{3}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation*}    \nabla_b L(W, b, \alpha)=-\sum_{i=1}^n \alpha_i y_i=0\Longrightarrow \sum_{i=1}^n \alpha_i y_i=0\end{equation*}\]</span></p><p>将上面两式代入<span class="math inline">\(L(W,b,\alpha)\)</span>:</p><p><span class="math display">\[\begin{aligned}&amp; L(\mathbf{w}, b,\boldsymbol{\alpha})=\frac{1}{2}\|\mathbf{w}\|^2-\sum_{i=1}^n\alpha_i\left[y_i\left(\mathbf{x}_i^T \mathbf{w}+b\right)-1\right] \\&amp; =\frac{1}{2} \sum_{i=1}^n \alpha_i y_i \mathbf{x}_i^T \sum_{j=1}^n\alpha_j y_j \mathbf{x}_j-\sum_{i=1}^n \alpha_i y_i \mathbf{x}_i^T\sum_{j=1}^n \alpha_j y_j \mathbf{x}_j-b \sum_{i=1}^n \alpha_iy_i+\sum_{i=1}^n \alpha_i \\&amp; =\sum_{i=1}^n \alpha_i-\frac{1}{2} \sum_{i=1}^n \alpha_i y_i\mathbf{x}_i^T \sum_{j=1}^n \alpha_j y_j \mathbf{x}_j=\sum_{i=1}^n\alpha_i-\frac{1}{2} \sum_{i, j=1}^n y_i y_j \alpha_{i} \alpha_j\mathbf{x}_i^T \mathbf{x}_{i=1}\end{aligned}\]</span></p><p>所以</p><p><span class="math display">\[\begin{equation}    \min _{W, b} L(W, b, \alpha)=-\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n\alpha_i \alpha_j y_i y_j X_i^T X_j+\sum_{i=1}^n \alpha_i \tag{4}\end{equation}\]</span></p><ol start="2" type="1"><li>求<spanclass="math inline">\(\min\limits{W,b}L(W,b,\alpha)\)</span>对<spanclass="math inline">\(\alpha\)</span>的极大：</li></ol><p>等价于式<span class="math inline">\((4)\)</span>对<spanclass="math inline">\(\alpha\)</span>求极大，也等价于式<spanclass="math inline">\((4)\)</span>取负数后对<spanclass="math inline">\(\alpha\)</span>求极小，即</p><p><span class="math display">\[\min _\alpha \frac{1}{2} \sum_{i=1}^n\sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j-\sum_{i=1}^n \alpha_i\tag{5}\]</span></p><p>同时满足约束条件：</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{i=1}^n \alpha_i y_i=0 \\&amp; \alpha_i \geq 0, i=1,2, \ldots, n\end{aligned} \tag{6}\]</span></p><p>至此，我们得到了原始最优化问题<spanclass="math inline">\((2)\)</span>和对偶最优化问题<spanclass="math inline">\((5)\)</span>、<spanclass="math inline">\((6)\)</span>。</p><p>因为原始优化问题的目标函数和不等式约束条件都是凸函数，并且该不等式约束是严格可行的(因为数据是线性可分的),所以存在<spanclass="math inline">\(\hat{W},\hat{b},\hat{\alpha}\)</span>，使得<spanclass="math inline">\(\hat{W},\hat{b}\)</span>是原始问题的解，<spanclass="math inline">\(\hat{\alpha}\)</span>是对偶问题的解。这意味着求解原始最优化问题<spanclass="math inline">\((2)\)</span>可以转换为求解对偶最优化问题<spanclass="math inline">\((5),(6)\)</span>。</p><p>那么如何求解优化问题<span class="math inline">\((5)\)</span>、<spanclass="math inline">\((6)\)</span>的最优解<spanclass="math inline">\(\hat{\alpha}\)</span>呢？不难发现这是一个二次规划问题，有现成的通用的算法来求解。</p><p>假设我们现在求得了<span class="math inline">\((4)\)</span>、<spanclass="math inline">\((5)\)</span>的最优解<spanclass="math inline">\(\hat{\alpha}\)</span>，则根据式<spanclass="math inline">\((4)\)</span>可求得最优<spanclass="math inline">\(\hat{W}\)</span>：</p><p><span class="math display">\[\hat{W}=\sum\limits_{i=1}^n\hat{\alpha}_i y_i X_i \tag{5}\]</span></p><p>因为至少存在一个<span class="math inline">\(\hat{\alpha}_j &gt;0\)</span>(若不存在，即<spanclass="math inline">\(\hat{\alpha}\)</span>全为0，则<spanclass="math inline">\(\hat{W}=0\)</span>, 即<spanclass="math inline">\(margin=\frac{2}{||W||} =\infty\)</span>,显然不行), 再根据KKT条件，即</p><p><span class="math display">\[\left\{\begin{array}{l}\text { 乘子非负 }: \alpha_i \geq 0(i=1,2, \ldots n . \text { 下同 }) \\\text { 约束条件 }: y_i\left(X_i^T W+b\right)-1 \geq 0 \\\text { 互补条件 }: \alpha_i\left(y_i\left(X_i^T W+b\right)-1\right)=0\end{array}\right.\]</span></p><p>所以至少存在一个<span class="math inline">\(j\)</span>,使<spanclass="math inline">\(y_j(X_T\hat{W}+\hat{b})-1=0\)</span>,即可求得最优<spanclass="math inline">\(\hat{b}\)</span>:</p><p><span class="math display">\[\begin{aligned}\hat{b} &amp; =\frac{1}{y_j}-X_j^T \hat{W} \\&amp; =y_j-X_j^T \hat{W} \\&amp; =y_j-\sum_{i=1}^n \hat{\alpha}_i y_i X_j^T X_i\end{aligned}   \tag{7}\]</span></p><p>至此，所以我们就求得了整个线性可分SVM的解。求得的分离超平面为:</p><p><span class="math display">\[\sum_{i=1}^n \hat{\alpha}_i y_i X^T X_i+\hat{b}=0\]</span></p><p>则分类的决策函数为</p><p><span class="math display">\[f(X)=\operatorname{sign}\left(\sum_{i=1}^n \hat{\alpha}_i y_i X^TX_i+\hat{b}\right)\]</span></p><p>再来分析KKT条件里的互补条件，对于任意样本<spanclass="math inline">\((X_i,y_i)\)</span>，总会有<spanclass="math inline">\(\alpha_i=0\)</span>或者<spanclass="math inline">\(y_if(X_i)=y_i(X^T_i\hat{W}+b)=1\)</span>。则有若<spanclass="math inline">\(\alpha_i=0\)</span>，此样本点不是支持向量，对模型没有任何作用；若<spanclass="math inline">\(\alpha_i &gt;0\)</span>，此样本点位于最大间隔边界上，是一个支持向量，如下图所示:</p><p><img src="/img/机器学习/期末复习/硬间隔-1.png" /></p><p>此外，当样本点是非支持向量时，因为<spanclass="math inline">\(\alpha_i=0\)</span>，所以SVM的解中的求和项中第<spanclass="math inline">\(i\)</span>项就为0，所以SVM的解<spanclass="math inline">\((6)\)</span>、<spanclass="math inline">\((7)\)</span>可简化为如下形式:</p><p><span class="math display">\[\hat{W}=\sum\limits_{i\in S V}\hat{\alpha}_{i}y_{i}X_{i}\\\hat{b}=y_{j}-\sum\limits_{i\in S V}\hat{\alpha}_{i}y_{i}X_{j}^{T}X_{i}\]</span></p><p>类似的，判别函数也可转换成如下形式:</p><p><span class="math display">\[f(X)=s i g n(\sum\limits_{i\in SV}\hat{\alpha}_{i}y_{i}X^{T}X_{i}+\hat{b})\]</span></p><p>所以，整个SVM的解只与支持向量SV有关，与非支持向量无关。</p><h3 id="线性svm软间隔">线性SVM——软间隔</h3><p>上述<strong>硬间隔</strong>是完全分类准确，其损失函数不存在；其损失值为0；只要找出两个异类正中间的那个平面，而<strong>软间隔</strong>允许一定量的样本分类错误，即允许少量样本不满足约束</p><p><span class="math display">\[y_{i}(X_{i}^{T}W+b)\geq1\]</span></p><p>为了使不满足上述条件的样本点尽可能少，我们需要在优化的目标函数<spanclass="math inline">\((1)\)</span>里面新增一个对这些点的惩罚项。最常用的是hinge损失:</p><p><span class="math display">\[l_{h i n g e}(z)=m ax(\mathsf{0,1-z})\]</span></p><p>即若样本点满足约束条件损失就是0, 否则损失就是,则优化目标<spanclass="math inline">\(（1）\)</span>变成</p><p><span class="math display">\[\begin{equation}\min\limits_{W,b} \frac{1}{2}||W||^2 + C\sum\limits_{i=1}^n \max{(0, 1 -u_i(X_i^TW + b))}  \tag{8}\end{equation}\]</span></p><p>其中<span class="math inline">\(C&gt;0\)</span>称为惩罚参数，<spanclass="math inline">\(C\)</span>越小时对误分类惩罚越小，越大时对误分类惩罚越大，当<spanclass="math inline">\(C\)</span>取正无穷时就变成了硬间隔优化。实际应用时我们要合理选取<spanclass="math inline">\(C\)</span>,<spanclass="math inline">\(C\)</span>越小越容易欠拟合，<spanclass="math inline">\(C\)</span>越大越容易过拟合。</p><p>如果我们引入“松弛变量”<span class="math inline">\(\xi_i \ge0\)</span>, 那么式<span class="math inline">\((8)\)</span>可重写成</p><p><span class="math display">\[\min\limits_{W,b,\xi}{\frac{1}{2}||W||^{2}+C\sum\limits_{i=1}^{n}\xi_{i}} \\ s.t. \quady_i(X_i^TW+b) \ge 1 - \xi_i \\ \xi_i \ge 0, i = 1,2,...,n\]</span></p><p>上式所述问题即软间隔支持向量机。</p><p>而其对偶问题与硬间隔同理。</p><h3 id="非线性svm核技巧">非线性SVM——核技巧</h3><p>首先回顾前面的线性SVM的优化目标</p><p><span class="math display">\[\min _\alpha \frac{1}{2} \sum_{i=1}^n\sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j-\sum_{i=1}^n\alpha_i\]</span></p><p>以及约束条件</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{i=1}^n \alpha_i y_i=0 \\&amp; \alpha_i \geq 0, i=1,2, \ldots, n\end{aligned}\]</span></p><p>前面介绍的都是线性问题，但是我们经常会遇到非线性的问题(例如异或问题)，此时就需要用到核技巧(kerneltrick)将线性支持向量机推广到非线性支持向量机。如果样本在特征空间内线性不可分，则需要利用核函数将其映射到高维空间中，让其在高维空间中线性可分。根据SVM基础形式的求解，我们可能会想到下面的方式：</p><p><span class="math display">\[f(\boldsymbol X)=\sum_{i=1}^{N} w_i\phi_i(\boldsymbol X)+b\]</span></p><p>这里的<spanclass="math inline">\(\phi_i()\)</span>就是从输入的特征空间到某个更高维的特征空间的映射，这就意味着建议了非线性的学习器分为两步：</p><ul><li>使用一个变换将原空间的数据映射到新空间(例如更高维甚至无穷维的空间)；</li><li>然后在新空间里用线性方法从训练数据中学习得到模型。</li></ul><p>这种基本型的求解是非常难的，因为这个映射函数是非常难以寻找和求解的！（据说NP难），而了解了SVM的对偶形式给了另一种求解思路：</p><p><span class="math display">\[f(\boldsymbol X)=\sum_{i=1}^{l} \alpha_iy_i \left \langle \boldsymbol \phi_i(\boldsymbol X_i) \cdot \boldsymbol\phi(\boldsymbol X) \right \rangle + b\]</span></p><p>注意到，我们在求解的时候需要计算<spanclass="math inline">\(ϕi(X_i)⋅ϕ(X)\)</span>，也就是映射后的两个样本的高维特征的内积形式，如果有一种方法可以在特征空间中直接计算这个东西，是不是就很方便了？对的，核函数就是做这个的：</p><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i) =\boldsymbol \phi(\boldsymbol X) \cdot \boldsymbol \phi(\boldsymbolX_i)\]</span></p><p>那么现在的优化目标就变为</p><p><span class="math display">\[\min\limits_{\alpha}\frac{1}{2}\sum_{i=1}^{n}\sum_{j=1}^{n}\alpha_{i}\alpha_{j}y_{i}y_{j}K(X_{i},X_{j})\;-\;\sum_{i=1}^{n}\alpha_{i}\\s.t.\,\,\,\,\sum_{i=1}^{n}\alpha_{i}y_{i}=0 \\0\leq\alpha_{i}\leq C,i=1,2,\cdot\cdot,n.\]</span></p><p>上述的思想就是SVM核函数的核心思想。</p><h4 id="多项式核函数">多项式核函数</h4><p>对于一个多项式核函数</p><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i) = [(X\cdot X_i) + c]^q\]</span></p><p>可以得到q阶多项式分类器</p><h4 id="高斯径向基核rbf">高斯径向基核RBF</h4><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i)=  exp(-\frac{|X-X_i|^2}{\sigma^2})\]</span></p><p>每个基函数中心对应一个支持向量，它们及输出权值由算法自动确定。</p><h4 id="sigmod核">Sigmod核</h4><p><span class="math display">\[K(X, X_i)=tanh(\nu(X,X_)+c)\]</span></p><p>包含一个隐层的多层感知器，隐层节点数是由算法自动确定。</p><p>注：上述SVM内容转载于<ahref="https://zhuanlan.zhihu.com/p/49331510">看了这篇文章你还不懂SVM你就来打我</a></p><h2 id="第七章-混合模型与期望最大">第七章 混合模型与期望最大</h2><p><strong>聚类基本思想</strong>：将相似的实例分组在一起。聚类结果在很大程度上取决于待聚类点之间的相似性（或距离）度量</p><p><strong>聚类算法</strong></p><ul><li>原型聚类：如K均值算法、高斯混合模型</li><li>密度聚类：如DBSCAN算法、Mean-Shift 算法</li><li>层次聚类：如Agglomerative 算法、Divisive算法、BIRCH 算法</li><li>谱聚类</li></ul><h3 id="k-means-聚类">K-means 聚类</h3><p>K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p><p>如果用数据表达式表示，假设簇划分为<spanclass="math inline">\((C_1,C_2,...C_k)\)</span>，则我们的目标是最小化平方误差<spanclass="math inline">\(E\)</span>：</p><p><span class="math display">\[E = \sum\limits_{i=1}^k\sum\limits_{x\in C_i} ||x-\mu_i||_2^2\]</span></p><p>其中<span class="math inline">\(μ_i\)</span>是簇<spanclass="math inline">\(C_i\)</span>的均值向量，有时也称为质心，表达式为：</p><p><span class="math display">\[\mu_i = \frac{1}{|C_i|}\sum\limits_{x\in C_i}x\]</span></p><p>如果我们想直接求上式的最小值并不容易，这是一个NP难的问题，因此只能采用启发式的迭代方法。</p><p>K-Means采用的启发式方式很简单，用下面一组图就可以形象的描述。</p><p><img src="/img/机器学习/期末复习/kmeans过程.png" /></p><p>K-Means的算法步骤为:</p><ol type="1"><li>选择初始化的 k 个样本作为初始聚类中心<spanclass="math inline">\(a=a_1,a_2,...,a_k\)</span></li><li>针对数据集中每个样本<span class="math inline">\(x_i\)</span>计算它到<span class="math inline">\(k\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；</li><li>针对每个类别 <spanclass="math inline">\(a_j\)</span>，重新计算它的聚类中心<spanclass="math inline">\(a_{j}=\frac{1}{|c_{i}|}\sum\limits_{x\inc_{i}}x\)</span>（即属于该类的所有样本的质心）;</li><li>重复上面 2 3两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。</li></ol><h3 id="高斯混合模型gmm">高斯混合模型（GMM）</h3><p>高斯混合模型（Gaussian MixedModel）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布）。</p><!-- ![](/img/机器学习/期末复习/GMM.jpg) --><p><span class="math display">\[p(\alpha)=\sum_{k=1}^{K}\pi_{k}\mathcal{N}(x \mid\mu_{k},\Sigma_{k})\]</span></p><p>其中<span class="math inline">\(\mathcal{N}(x\mid\mu_{k},\Sigma_{k})\)</span>称为混合模型中的第<spanclass="math inline">\(k\)</span>个分量（component）。混合系数<spanclass="math inline">\(\pi_k\)</span>满足<spanclass="math inline">\(\sum\limits^{K}_{k=1}\pi_k =1 \quad0\le \pi \le1\)</span>。可以认为<spanclass="math inline">\(\pi_k\)</span>就是每个分量<spanclass="math inline">\(\mathcal{N}(x | \mu_k,\Sigma_k)\)</span>的权重。</p><h3 id="em算法">EM算法</h3><p>EM 算法，全称 Expectation MaximizationAlgorithm。期望最大算法是一种迭代算法，用于含有隐变量（HiddenVariable）的概率参数模型的最大似然估计或极大后验概率估计。</p><h4 id="em算法思想">EM算法思想</h4><p>EM 算法的核心思想非常简单，分为两步：Expection-Step 和Maximization-Step。</p><ul><li>E-Step主要通过观察数据和现有模型来估计参数，然后用这个估计的参数值来计算似然函数的期望值；</li><li>而 M-Step是寻找似然函数最大化时对应的参数。由于算法会保证在每次迭代之后似然函数都会增加，所以函数最终会收敛。</li></ul><p>EM算法例子的执行过程<ahref="https://www.jianshu.com/p/1121509ac1dc">如何感性地理解EM算法？</a></p><p>事实上隐变量估计也可以通过梯度下降等优化方法求解，但由于求和的项数将随着隐变量的数目以指数级别上升，会给梯度计算带来麻烦；而EM算法可以看作一种非梯度优化方法。</p><h2 id="第八章-高斯过程">第八章 高斯过程</h2><p>高斯过程 Gaussian Processes是概率论和数理统计中随机过程的一种，是多元高斯分布的扩展，被应用于机器学习、信号处理等领域。本文对高斯过程进行公式推导、原理阐述、可视化以及代码实现，介绍了以高斯过程为基础的高斯过程回归Gaussian Process Regression 基本原理、超参优化、高维输入等问题。</p><p><a href="https://zhuanlan.zhihu.com/p/75589452">高斯过程 GaussianProcesses 原理、可视化及代码实现</a></p><h2 id="第九章-集成学习">第九章 集成学习</h2><h3 id="bagging">Bagging</h3><p>Bagging（装袋算法）的集成学习方法非常简单，假设我们有一个数据集<spanclass="math inline">\(D\)</span>，使用Bootstrapsample（有放回的随机采样，这里说明一下，有放回抽样是抽一个就放回一个，然后再抽，而不是这个人抽<spanclass="math inline">\(10\)</span>个，再放回，下一个继续抽，它是每一个样本被抽中概率符合均匀分布）的方法取了<spanclass="math inline">\(k\)</span>个数据子集（子集样本数都相等）：<spanclass="math inline">\(D_1，D_2，…，D_k\)</span>，作为新的训练集，我们使用这<spanclass="math inline">\(k\)</span>个子集分别训练一个分类器（使用分类、回归等算法），最后会得到<spanclass="math inline">\(k\)</span>个分类模型。我们将测试数据输入到这<spanclass="math inline">\(k\)</span>个分类器，会得到<spanclass="math inline">\(k\)</span>个分类结果，比如分类结果是<spanclass="math inline">\(0\)</span>和<spanclass="math inline">\(1\)</span>，那么这<spanclass="math inline">\(k\)</span>个结果中谁占比最多，那么预测结果就是谁。</p><p><strong>算法流程</strong>：</p><ul><li>从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</li><li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知机等）</li><li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</li></ul><p><strong>特点</strong>：</p><ul><li>关于bagging所采用的抽样方式为有放回抽样，抽样的样本数量等于总体样本数量；</li><li>由于某些样本在有放回的情况下不止被抽到一次，有些样本一次也不会被抽到；</li><li>可以并行产生所需要的样本子集个数以及并行训练子模型</li><li>对于二分类问题，一般选取样本子集个数为奇数（避免出现两个类别投票数相同）</li></ul><h3 id="adaboost">AdaBoost</h3><p><strong>Boosting</strong>指的是一类集成方法，其主要思想就是将弱的基学习器提升(boost)为强学习器。具体步骤如下:</p><ol type="1"><li>先用每个样本权重相等的训练集训练一个初始的基学习器；</li><li>根据上轮得到的学习器对训练集的预测表现情况调整训练集中的样本权重(例如提高被错分类的样本的权重使之在下轮训练中得到更多的关注),然后据此训练一个新的基学习器；</li><li>重复2直到得到<spanclass="math inline">\(M\)</span>个基学习器，最终的集成结果是<spanclass="math inline">\(M\)</span>个基学习器的组合。</li></ol><p><strong>Boosting算法簇中最著名的就是AdaBoost</strong>。</p><h4 id="基本思想">基本思想</h4><p>对于上述的Boosting算法步骤，需要回答两个问题:</p><ol type="1"><li>如何调整每一轮的训练集中的样本权重？</li><li>如何将得到的[公式]个组合成最终的学习器？</li></ol><p>AdaBoost(Adaptive Boosting, 自适应增强)算法采取的方法是:</p><ol type="1"><li><strong>提高上一轮被错误分类的样本的权值，降低被正确分类的样本的权值</strong>；</li><li><strong>线性加权求和</strong>。误差率小的基学习器拥有较大的权值，误差率大的基学习器拥有较小的权值。</li></ol><p>AdaBoost算法的流程如下：</p><p>输入：训练数据集<spanclass="math inline">\(T={(x1,y1),(x2,y2),(xN,yN)}\)</span>，其中，<spanclass="math inline">\(xi∈X⊆R^n\)</span>，<spanclass="math inline">\(yi∈Y=−1,1\)</span>，迭代次数<spanclass="math inline">\(M\)</span></p><ol type="1"><li><p>初始化训练样本的权值分布: <spanclass="math display">\[D_1=(w_{1,1},w_{1,2},…,w_{1,i}),w_{1,i}=\frac{1}{N},i=1,2,…,N\]</span></p></li><li><p>对于<span class="math inline">\(m=1,2,…,M\)</span></p><ol type="1"><li><p>使用具有权值分布<spanclass="math inline">\(D_m\)</span>的训练数据集进行学习，得到弱分类器<spanclass="math inline">\(Gm(x)\)</span></p></li><li><p>计算<spanclass="math inline">\(Gm(x)\)</span>在训练数据集上的分类误差率: <spanclass="math display">\[e_m=\sum_{i=1}^Nw_{m,i}  I(G_m (x_i )≠y_i)\]</span></p></li><li><p>计算<spanclass="math inline">\(Gm(x)\)</span>在强分类器中所占的权重： <spanclass="math display">\[α_m=\frac{1}{2}log\frac{1-e_m}{e_m}\]</span></p></li><li><p>更新训练数据集的权值分布（这里，<spanclass="math inline">\(z_m\)</span>是归一化因子，为了使样本的概率分布和为<spanclass="math inline">\(1\)</span>）：</p></li></ol><p><span class="math display">\[w_{m+1,i}=\frac{w_{m,i}}{z_m}exp⁡(-α_my_i G_m (x_i ))，i=1,2,…,10\]</span></p><p><span class="math display">\[z_m=\sum_{i=1}^Nw_{m,i}exp⁡(-α_m y_i G_m(x_i ))\]</span></p></li><li><p>得到最终分类器:</p><p><span class="math display">\[F(x)=sign(\sum_{i=1}^Nα_m G_m(x))\]</span></p></li></ol><h3 id="bagging和boosting的区别">Bagging和Boosting的区别</h3><ol type="1"><li>样本选择上</li></ol><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><ol start="2" type="1"><li>样例权重</li></ol><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><ol start="3" type="1"><li>预测函数</li></ol><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><ol start="4" type="1"><li>并行计算</li></ol><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><h2 id="第十章-半监督学习">第十章 半监督学习</h2><h3 id="基于图的半监督学习">基于图的半监督学习</h3><h4 id="图的概念">图的概念</h4><p>我们首先来看看如何从训练数据中构建出图，给定半监督数据集<spanclass="math inline">\(\{(𝑥_𝑖,𝑦_𝑖 )\}_{𝑖=1}^𝑙\)</span>和<spanclass="math inline">\(\{𝑥_𝑗\}_{𝑗=𝑙+1}^{𝑙+𝑢}\)</span>，每个数据样本（有标签&amp;无标签）是图上的一个顶点，显然，图会非常大，因为无标签数据很多，一旦图构建完成，学习的过程就包括给图中的每一个定点设置标签y值。在图中可以通过边将有标签和无标签数据点相连，边通常是无向的，表示的是两个节点（样本）之间的相似性。将边权重记作<spanclass="math inline">\(w_{ij}\)</span>，<spanclass="math inline">\(w_{ij}\)</span>越大，<spanclass="math inline">\(x_i\)</span>和<spanclass="math inline">\(x_j\)</span>越相似，两者的标签越可能相同。所以边权重非常重要，人们常常将边的权值定义为如下形式：</p><ul><li>全连接图：</li></ul><p>每一对定点之间都有边相连，边的权重随欧式距离<spanclass="math inline">\(||x_i-x_j||\)</span>的增加而降低，常用的权重方程如下：</p><p><span class="math display">\[w_{ij}=\exp(-\frac{||x_i-x_j||^2}{2\sigma^2})\]</span></p><p><spanclass="math inline">\(σ\)</span>叫做带宽参数用来控制权重衰减的速度。这个权重方程和高斯方程的形式相同，也叫做高斯核或者径向基函数；</p><ul><li>KNN图：</li></ul><p>每一个定点定义它的欧式距离上的最近邻，注意，如果<spanclass="math inline">\(x_i\)</span>在<spanclass="math inline">\(x_j\)</span>的<spanclass="math inline">\(k\)</span>近邻内，<spanclass="math inline">\(x_j\)</span>不一定在<spanclass="math inline">\(x_i\)</span>的<spanclass="math inline">\(k\)</span>近邻内，如果<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_j\)</span>中有一个在对方的<spanclass="math inline">\(k\)</span>近邻内我们就用边将它们连接，这就意味着一个定点可能会有超过<spanclass="math inline">\(k\)</span>条边，如果<spanclass="math inline">\(x_i,x_j\)</span>有边相连，边的权重<spanclass="math inline">\(w_{ij}\)</span>就是<spanclass="math inline">\(1\)</span>，否则为<spanclass="math inline">\(0\)</span>。KNN图可以自适应地适应样本在特征空间的密度（密集区KNN范围的半径小）；</p><ul><li><span class="math inline">\(ε\)</span>NN图：</li></ul><p>将距离小于<span class="math inline">\(ε\)</span>的顶点连一条边。</p><h4 id="mincut">MINCUT</h4><p>我们将带有正标签的样本作为源点（就好像流从这里出发流经边），相似的，负标签样本作为终点（流消失的点），目标是找到一个最小的边集，使得删除这些边可以阻止所有从源点到终点的流，我们定义这样的一组边集叫做“cut”，割的大小用这些边的权重和来定义。一旦图被“割”开，与源点相连的点都被标记为正，反之为负。也就是说，我们想要找到这样的一个作用在顶点上的函数<spanclass="math inline">\(f(x)\in\{0,1\}\)</span>用来标记x的标签，使得对于有标签样本来说<spanclass="math inline">\(f(x_i)=y_i\)</span>，而且cut最小:</p><p><span class="math display">\[\sum_{i,j\geq f(x_{i})\neq f(x_{j})}w_{ij}\]</span></p><p>我们将最小割问题形式化为正则化风险最小化问题（合适的损失函数和正则化器）。对任何有标签的顶点<spanclass="math inline">\(x_i\)</span>，<spanclass="math inline">\(f(x_i)\)</span>就是<spanclass="math inline">\(x_i\)</span>对应的标签<spanclass="math inline">\(y_i\)</span>，可以用这样一个损失函数来表示：<spanclass="math inline">\(c(\mathbf{x},\mathbf{y},f(\mathbf{x}))=\infty\cdot(\mathbf{y}-f(\mathbf{x}))^{2}\)</span>,而正则化项则对应cut的大小，考虑到所有无标签样本的类别非负即正，cut的大小可以重写为<spanclass="math inline">\(\Omega(f)=\sum\limits_{i,\,i=1}^{i=n}w_{ij}(f(\mathbf{x}_{i})-f(\mathbf{x}_{j}))^{2}/4\)</span>。注意，当前的和是针对所有点对的，如果<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_j\)</span>不相连，<spanclass="math inline">\(w_{ij}=0\)</span>。那么最小割的正则化风险最小化问题可以写作</p><p><span class="math display">\[\min\limits_{f:f(x) \in \{-1,1\}} \infty\sum_{i=1}^{l}(y_{i}-f(\mathbf{x}_{i}))^{2}+\sum_{i,j=1}^{l+u}w_{ij}(f(\mathbf{x}_{i})-f(\mathbf{x}_{j}))^{2}\]</span></p><p>这是一个整数规划问题，因此，最小割问题可以有许多多项式时间算法可以解决。这种形式的最小割问题可能存在多个最优解，比如下图有两个带标签点一正一负，每条边有相同的权重，有6种最小割解决方案（移除任意一条边即可）。</p><h4 id="调和函数harmonic-function">调和函数（HARMONIC FUNCTION）</h4><p>对于有标签数据，调和函数的值为标签值；对于无标签数据，标签值是其邻居顶点标签值的权重平均</p><p><span class="math display">\[\begin{array}{r cl}{f(\mathbf{x}_{i})}&amp;{=}&amp;{y_{i},}&amp;{i=1,\cdot\cdot,l}\end{array}\]</span></p><p><span class="math display">\[f(x_j) = \frac{\sum\limits_{k=1}^{l+u}w_{jk}f(x_k)}{\sum\limits_{k=1}^{l+u} w_{jk}}, j =l+1,\cdots,l+u\]</span></p><p>然后把它代入上面提到过的目标函数，并松弛<spanclass="math inline">\(f\)</span>使它的值域为实数：</p><p><span class="math display">\[\min\limits_{f:f(x)\in\mathbb{R}} \infty\sum\limits_{i=1}^{l}(y_{i}-f({\bfx}_{i}))^{2}+\sum\limits_{i=1}^{l+u}w_{i j}(f({\bf x}_{i})-f({\bfx}_{j}))^{2}\]</span></p><p>相当于求解：</p><p><spanclass="math display">\[\min\limits_{f:f(x)\in\mathbb{R}}\sum\limits_{i=1}^{l+u}w_{ij}(f({\bf x}_{i})-f({\bf x}_{j}))^{2}\]</span></p><p>对<span class="math inline">\(f\)</span>进行松弛使得<spanclass="math inline">\(f\)</span>有一个闭式解，也就是说上述目标方程有全局最优解，缺点是<spanclass="math inline">\(f(x)\)</span>现在是一个<spanclass="math inline">\([0,1]\)</span>的实数，并不能直接作为一个标签。这可以通过设定阈值进行处理（如，若<spanclass="math inline">\(f(x)&gt;=0.5\)</span>，预测标签<spanclass="math inline">\(y=1\)</span>，否则为<spanclass="math inline">\(0\)</span>）.</p><p>调和函数有许多有趣的解释，比如，将图看作一张电网，每一条边的电阻为<spanclass="math inline">\(1/w_{ij}\)</span>，有标签的点连接到<spanclass="math inline">\(1v\)</span>的电池，正标签顶点连接电池正极，零标签顶点连接电池负极，每个节点两端的电压就是调和函数值，如下图所示：</p><p><img src="/img/机器学习/期末复习/调和函数电网解释.png" /></p><p>也可以解释为图上的随机游走，想象一个粒子在顶点<spanclass="math inline">\(i\)</span>上，那么这个粒子会随机走到下一个顶点<spanclass="math inline">\(j\)</span>的概率是，随机游走以这种方式继续，直到粒子到达一个有标记的顶点。那么顶点<spanclass="math inline">\(i\)</span>的调和函数值<spanclass="math inline">\(f(x_i)\)</span>就是粒子从<spanclass="math inline">\(i\)</span>顶点出发最终走到一个正标签的顶点的概率，如下图所示：</p><p><img src="/img/机器学习/期末复习/调和函数随机游走解释.png" /></p><h5 id="调和函数的求解">调和函数的求解</h5><p>求解调和函数的过程是迭代的，初始的，我们设定：对于有标签顶点，<spanclass="math inline">\(f(x_i)=y_i\)</span>，对于无标签顶点，<spanclass="math inline">\(f\)</span>为任意值。每一轮迭代都用无标签顶点邻居的权重平均更新该无标签顶点的标签值：</p><p><spanclass="math display">\[f(\mathbf{x}_{i})={\frac{\sum\limits_{j=1}^{l+u}w_{ij}f(\mathbf{x}_{j})}{\sum\limits_{j=1}^{l+u}w_{i j}}}\]</span></p><h4 id="半监督支持向量机s3vmstsvms">半监督支持向量机(S3VMs/TSVMs)</h4><p>Semi-Supervised Support VectorMachines(S3VMs)最初被称为直推式支持向量机(Transductive Support VectorMachines(TSVMs))，因为它的理论是为了给无标记样本提供性能界限(理论保证)。但是由于学习到的函数<spanclass="math inline">\(f\)</span>应用到了无标记的样本中，所以被称为半监督支持向量机S3VMs。</p><p>对于S3VMs的直观理解是使得有标记和无标记样本处于间隔边界之外。但是，对于无标记样本，我们无法得知其是否处于处于正确的分类。这里给出一种方法将无标记样本用到学习中。</p><p>对于样本<span class="math inline">\(x\)</span>,它的预测值<spanclass="math inline">\(\hat{y} =sign(f(x))\)</span>，将该预测值假定为该样本的真实标签，则<spanclass="math inline">\(x\)</span>的hinge损失函数为</p><p><span class="math display">\[\begin{align}c(x, \hat{y}, f(x)) &amp; = \max(1-\hat{y}(w^Tx+b), 0) \\&amp; = \max(1-sign(w^Tx+b)(w^Tx+b), 0) \\&amp; = \max(1- |w^Tx+b|, 0)\end{align}\]</span></p><p>该损失函数与hinge损失的不同之处在于它不需要样本真实的标签，而是由<spanclass="math inline">\(f(x)\)</span>替代。该损失函数由上图中的右图所示。基于该损失函数的图形的形状，将其命名为hatloss。</p><p>虽然假设预测的分类结果都是正确的，但是基于hatloss，有些样本还是会存在惩罚。对于<span class="math inline">\(f(x) \le-1\)</span>或<span class="math inline">\(f(x) \ge1\)</span>的样本，它们处在间隔边界之外，远离决策边界，是不存在惩罚的。但是对于<spanclass="math inline">\(-1 \le f(x) \le 1\)</span>的样本，尤其是<spanclass="math inline">\(f(x) \approx0\)</span>的样本，它们在决策边界内，对于预测值<spanclass="math inline">\(f(x)\)</span>是存在不确定性的，所以存在惩罚。</p><p>将无标记样本<spanclass="math inline">\(\{x_j\}_{j=l+1}^{l+u}\)</span>的hatloss加到SVM的损失函数中，定义S3VMs的损失函数</p><p><span class="math display">\[\min_{w,b} \sum_{i=1}^{l} \max(1 -y_i(w^Tx_i+b), 0) + \lambda_1 ||w||^2  + \lambda_2\sum_{j=l+1}^{l+u}\max(1 - |w^Tx_i+b|, 0)\]</span></p><p>由上式可以看出，S3VMs更希望无标记数据能够在决策边界的外边，也就是决策边界更希望出现在数据的低密度区域。此时，可以将hatloss看做正则化项</p><p><span class="math display">\[\Omega(f) = \lambda_1 ||w||^2  +\lambda_2\sum_{j=l+1}^{l+u} \max(1 - |w^Tx_i+b|, 0)\]</span></p><p>注意，有些时候，无标记数据的预测值只存在一个类，也就是无标记数据都被预测成了同一个类。为了纠正这种不平衡性，一种直接的想法就是限制预测值中各个类的比例。假设无标记数据的预测值中各个类的比例与有标记数据中各个类的比例相同，即</p><p><span class="math display">\[\frac{1}{u}\sum_{j=l+1}^{l+u} \hat{y}_j= \frac{1}{l}\sum_{i=1}^{l} y_i\]</span></p><p>因为<span class="math inline">\(\hat{y}_j =sign(f(x_j))\)</span>不是一个连续函数，所以很难满足上述约束条件。因此放松该约束条件为</p><p><span class="math display">\[\frac{1}{u}\sum_{j=l+1}^{l+u} f(x_j) =\frac{1}{l}\sum_{i=1}^{l} y_i\]</span></p><p>该约束被称为类别的平衡约束。</p><p>所以，带类别平衡约束的S3VMs可以表示为</p><p><span class="math display">\[\begin{align}\min_{w,b}  &amp;  \sum_{i=1}^{l} \max(1 - y_i(w^Tx_i+b), 0) + \lambda_1||w||^2  + \lambda_2\sum_{j=l+1}^{l+u} \max(1 - |w^Tx_i+b|, 0)    \\s.t. &amp; \frac{1}{u}\sum_{j=l+1}^{l+u} f(x_j) =\frac{1}{l}\sum_{i=1}^{l} y_i  \tag{4}\end{align}\]</span></p><p>S3VMs的解是很难计算的，因为它的目标函数是<strong>非凸</strong>的。</p><p>上述S3VMs部分转载自<ahref="https://blog.csdn.net/extremebingo/article/details/79020907">Semi-SupervisedSupport Vector Machines(S3VMs)</a></p><h2 id="第十二章-强化学习">第十二章 强化学习</h2><p>强化学习（Reinforcement Learning, 简称RL）是机器学习的范式和方法论之一，用于描述和解决智能体（Agent）在与环境（Environment）的交互过程中通过学习策略（Policy）以达成奖励或回报（Reward）最大化或实现特定目标的问题。</p><p>强化学习主要涉及<strong>无模型（Model-Free）</strong>和<strong>有模型（Model-based）</strong>两大类算法。Model-Free算法可分为<strong>Q-Learning</strong>和<strong>基于策略优化（PolicyOptimization）</strong>两大类。Model-based算法可分为<strong>模型学习（Learnthe Model）</strong>和<strong>给定模型（Given theModel）</strong>两大类。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2下linux header的安装</title>
    <link href="/2023/05/09/WSL2%E4%B8%8Blinux_header%E5%AE%89%E8%A3%85/"/>
    <url>/2023/05/09/WSL2%E4%B8%8Blinux_header%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl2下linux-header的安装">WSL2下linux header的安装</h1><p>正常的linux发行版执行<code>linux-headers-$(uname -r)</code>命令就能装上内核头文件，但WSL2作为一个不一般的linux发行版，并没有直接给出安装包，要手动安装才能正常使用。</p><h2 id="安装步骤">安装步骤</h2><h3 id="确认kernel版本">确认Kernel版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -r<br></code></pre></td></tr></table></figure><h3 id="安装相应依赖">安装相应依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libelf-dev build-essential pkg-config<br>sudo apt install bison build-essential flex libssl-dev libelf-dev bc<br></code></pre></td></tr></table></figure><h3 id="下载相应版本源码">下载相应版本源码</h3><p>从<ahref="https://github.com/microsoft/WSL2-Linux-Kernel/releases">https://github.com/microsoft/WSL2-Linux-Kernel/releases</a>下载刚才得到对应版本的源码。</p><h3 id="解压刚下载的包并编译">解压刚下载的包并编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zvxf linux-msft-wsl-5.15.90.1.tar.gz<br>cd WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1<br>zcat /proc/config.gz &gt; .config<br>sudo make -j $(nproc) <br>sudo make -j $(nproc) modules_install<br></code></pre></td></tr></table></figure><p>安装过程中出现一下错误：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">BTF:</span> .tmp_vmlinux.btf: pahole (pahole) <span class="hljs-built_in">is</span> <span class="hljs-built_in">not</span> available<br>Failed <span class="hljs-keyword">to</span> generate BTF <span class="hljs-keyword">for</span> vmlinux<br><span class="hljs-keyword">Try</span> <span class="hljs-keyword">to</span> disable CONFIG_DEBUG_INFO_BTF<br><span class="hljs-symbol">make:</span> *** [Makefile:<span class="hljs-number">1218</span>: vmlinux] <span class="hljs-keyword">Error</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>原因是系统缺少dwarves软件包，故我们需要安装相应的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install dwarves<br></code></pre></td></tr></table></figure><h3 id="软链接">软链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s ~/Kernel/WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1 usr/src/linux-<br>headers-5.15.90.1-microsoft-standard-WSL2<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://blog.csdn.net/qq_53928256/article/details/129737658">WSL2下kernelheader的安装</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pair tuple 作为 unordered_map unordered_set 的键值</title>
    <link href="/2023/05/06/Cpp-pair%E6%88%96tuple%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%94%AE%E5%80%BC/"/>
    <url>/2023/05/06/Cpp-pair%E6%88%96tuple%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%94%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="pair-tuple-作为-unordered_map-unordered_set-的键值">pair tuple作为 unordered_map unordered_set 的键值</h1><p>C++STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。网上的大部分实现的hash函数虽然可以用，但是其效率其实相当糟糕，他会导致碰撞严重，从而性能低下。</p><p>这里贴出一个《C++ 标准库（第二版）》中作者给出的绝佳方案，“7.9.2Creating and Controlling UnorderedContainer”，把任意结构hash化的代码搬出来，模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-comment">// from boost (functional/hash):</span><br><span class="hljs-comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span><br><span class="hljs-function"></span>&#123;<br>    seed ^= std::<span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// auxiliary generic functions to create a hash value using a seed</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;<br>    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tuple版本的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> hash_tuple &#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TT&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(TT <span class="hljs-type">const</span> &amp;tt)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;TT&gt;()(tt); &#125;<br>&#125;;<br><br><span class="hljs-comment">// from boost (functional/hash):</span><br><span class="hljs-comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, T <span class="hljs-type">const</span> &amp;v)</span> </span>&#123;<br>    seed ^= hash_tuple::<span class="hljs-built_in">hash</span>&lt;T&gt;()(v) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// Recursive template code derived from Matthieu M.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>, <span class="hljs-type">size_t</span> Index = std::tuple_size&lt;Tuple&gt;::value - <span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">struct</span> HashValueImpl &#123;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()(<span class="hljs-type">size_t</span> &amp;seed, Tuple <span class="hljs-type">const</span> &amp;tuple) <span class="hljs-type">const</span> &#123;<br>        HashValueImpl&lt;Tuple, Index - <span class="hljs-number">1</span>&gt;&#123;&#125;(seed, tuple);<br>        <span class="hljs-built_in">hash_combine</span>(seed, std::<span class="hljs-built_in">get</span>&lt;Index&gt;(tuple));<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashValueImpl</span>&lt;Tuple, <span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, Tuple <span class="hljs-type">const</span> &amp;tuple)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">hash_combine</span>(seed, std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(tuple));<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... TT&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;std::tuple&lt;TT...&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::tuple&lt;TT...&gt; <span class="hljs-type">const</span> &amp;tt)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>        HashValueImpl&lt;std::tuple&lt;TT...&gt;&gt;&#123;&#125;(seed, tt);<br>        <span class="hljs-keyword">return</span> seed;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// auxiliary generic functions to create a hash value using a seed</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);<br>    &#125;<br>&#125;;<br>&#125; <span class="hljs-comment">// namespace hash_tuple</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-comment">// std::unordered_map&lt;std::pair&lt;ll, ll&gt;, ll, hash_tuple::pair_hash&gt;</span><br>    <span class="hljs-comment">// hashmapPair; std::unordered_set&lt;std::pair&lt;ll, ll&gt;, hash_tuple::pair_hash&gt;</span><br>    <span class="hljs-comment">// hashsetPair;</span><br><br>    std::unordered_map&lt;std::pair&lt;ll, ll&gt;, ll, hash_tuple::pair_hash&gt;<br>        hashmapPair;<br>    hashmapPair[&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;] = <span class="hljs-number">10</span>;<br>    std::unordered_set&lt;std::pair&lt;ll, ll&gt;, hash_tuple::pair_hash&gt; hashsetPair;<br>    hashsetPair.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-keyword">using</span> TI = std::tuple&lt;ll, ll, ll, ll&gt;;<br>    std::unordered_map&lt;TI, ll, hash_tuple::hash&lt;TI&gt;&gt; hashmapTuple;<br>    hashmapTuple[&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;] = <span class="hljs-number">10</span>;<br>    std::unordered_set&lt;TI, hash_tuple::hash&lt;TI&gt;&gt; hashsetTuple;<br>    hashsetTuple.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bellman-Ford单源最短路径算法</title>
    <link href="/2023/04/22/Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/22/Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="bellman-ford单源最短路径算法">Bellman-Ford单源最短路径算法</h1><p>Bellman-Ford算法是一种用于计算带权有向图中单源最短路径（SSSP：Single-Source ShortestPath）的算法。该算法由 Richard Bellman 和 Lester Ford 分别发表于 1958年和 1956 年，而实际上 Edward F. Moore 也在 1957年发布了相同的算法，因此，此算法也常被称为 Bellman-Ford-Moore 算法。</p><p>Bellman-Ford 算法和 Dijkstra算法同为解决单源最短路径的算法。对于带权有向图 <spanclass="math inline">\(G = (V, E)\)</span>，Dijkstra 算法要求图 G中边的权值均为非负，而 Bellman-Ford算法能适应一般的情况（即存在负权边的情况）。一个实现的很好的 Dijkstra算法比 Bellman-Ford 算法的运行时间要低。</p><p>Bellman-Ford 算法采用动态规划（DynamicProgramming）进行设计，实现的时间复杂度为<spanclass="math inline">\(O(V*E)\)</span>，其中 <spanclass="math inline">\(V\)</span> 为顶点数量，<spanclass="math inline">\(E\)</span> 为边的数量。Dijkstra算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为<span class="math inline">\(O(V^2)\)</span>，若基于 Fibonacci heap的最小优先队列实现版本则时间复杂度为 <span class="math inline">\(O(E +VlogV)\)</span>。</p><p>Bellman-Ford 算法描述：</p><ol type="1"><li>创建源顶点 v 到图中所有顶点的距离的集合distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为0；</li><li>计算最短路径，执行 V - 1 次遍历；<ul><li>对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v的距离 d，则更新终点 v 的距离值 d；</li></ul></li><li>检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v的距离，如果对于 v 存在更小的距离，则说明存在环；</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><span class="hljs-comment">//用来存边</span><br>&#123;<br>    <span class="hljs-type">int</span> from;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;Edge[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">(<span class="hljs-type">int</span> src, <span class="hljs-type">int</span> destination)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// n是节点个数</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>        dist[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i++)          <span class="hljs-comment">// 查找从源点开始，经过k个节点可以</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++)      <span class="hljs-comment">// m 条边</span><br>        &#123;<br>            <span class="hljs-type">int</span> from = Edge[j].from, to = Edge[j].to, cost = Edge[j].cost;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[i][to], dist[i - <span class="hljs-number">1</span>][from]);<br>        &#125;                          <br>    &#125;<br>    <span class="hljs-comment">// dist[k][n]是刚好经过k步到达节点n的最短路径，若为INT_MAX则表示不能到达</span><br>    <span class="hljs-type">int</span> res = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; ++i)<br>    &#123;<br>        res = <span class="hljs-built_in">min</span>(res, dist[k][destination]);       <span class="hljs-comment">// 查找k步内到达destination的最短路径</span><br>    &#125;<br>    <span class="hljs-comment">// 未考虑负环的存在</span><br>    <span class="hljs-keyword">return</span> res == INT_MAX ? <span class="hljs-number">-1</span> : res;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveCpp-41：了解隐式接口和编译期多态</title>
    <link href="/2023/04/20/EffectiveCpp-41/"/>
    <url>/2023/04/20/EffectiveCpp-41/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-item-41-了解隐式接口和编译期多态">Effective C++ Item41 了解隐式接口和编译期多态</h1><h2 id="显式接口和运行时多态">显式接口和运行时多态</h2><p>面向对象编程的世界围绕着显式接口和运行时多态。举个例子，考虑下面的类（无意义的类）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;                          <span class="hljs-comment">// Item 25</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>考虑下面的函数（同样没有意义）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    &#123;<br>        <span class="hljs-function">Widget <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>        temp.<span class="hljs-built_in">normalize</span>();<br>        temp.<span class="hljs-built_in">swap</span>(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>doProcessing</code>中的<code>w</code>，我们可以这样说：</p><ul><li>因为w被声明为<code>Widget</code>类型，<code>w</code>必须支持<code>Widget</code>接口。我们可以在源码中搜寻这个接口（例如，在<code>Widget</code>的头文件中），以便能够确切的知道它长成什么样子，所以我将其叫做一个显式的接口（explicitinterface）——可以显式的在源码中看到的接口。</li><li>因为<code>Widget</code>中的一些成员函数是虚的，<code>w</code>对这些函数的调用会展示出运行时多态：<code>w</code>具体调用哪个函数会根据运行时<code>w</code>的动态类型来决定。</li></ul><h2 id="隐式接口和编译期多态">隐式接口和编译期多态</h2><p>模板（template）和泛型编程（genericprogramming）的世界从根本上发生了变化。在这个世界中，显式接口和运行时多态继续存在，但是它们不再像以前那么重要。相反，隐式接口和编译时多态被挪到了前台。为了了解这是什么样子的，我们将<code>doProcessing</code>从函数转换为一个函数模板，看看会发生什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    &#123;<br>        <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>        temp.<span class="hljs-built_in">normalize</span>();<br>        temp.<span class="hljs-built_in">swap</span>(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们能对<code>doProcessing</code>中的<code>w</code>说些什么呢？</p><ul><li><code>w</code>必须支持的接口由模板中w需要执行的操作所决定。例如，<code>w</code>的类型<code>T</code>必须支持<code>size</code>，<code>normalize</code>和<code>swap</code>成员函数；拷贝构造函数（来创建<code>temp</code>）；和不等比较（同<code>someNastyWidget</code>进行比较）。我们很快就能发现这也不是很精确的，但是对于现在来说足够了。重要的是，这些表达式必须是<code>T</code>所支持的隐式接口，它们对于模板来说必须是有效的以便能够通过编译。</li><li>对于涉及到<code>w</code>的像<code>operator&gt;</code>和<code>operator!=</code>这样的函数调用，可能涉及到模板的实例化来让这些调用成功。这些实例化在编译期发生。因为用不同的模板参数实例化出来的函数模板会导致不同的函数被调用，这叫做“编译期多态”。</li></ul><h2 id="显示接口和隐式接口的区别">显示接口和隐式接口的区别</h2><h3 id="显示接口的特点">显示接口的特点</h3><p>即使你永远不使用模板，你也应该熟悉运行时多态和编译期多态的区别，因为这同编译期决定调用哪个重载函数以及运行期决定绑定哪个虚函数是类似的。隐式和显式接口的区别对于模板来说是新的概念，然而，一个显式的接口由函数签名组成，也即是函数名字，参数类型，返回值类型等等。<code>Widget</code>类的公共接口，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由一个构造函数，一个析构函数，和函数<code>size</code>，<code>normalize</code>和<code>swap</code>以及参数类型，返回值类型和这些函数的常量性组成。（同样包含编译器生成的拷贝构造函数和拷贝赋值运算符——看Item5）。它同样可以包含<code>typedef</code>和数据成员，如果你够大胆违反Item22的建议的话（将数据成员声明为<code>private</code>）。虽然在这个例子中没有这么做。</p><h3 id="隐式接口的特点">隐式接口的特点</h3><p>一个隐式的接口会有很大的不同。它不是基于函数签名。而是由有效表达式组成。再看一下<code>doProcessing</code>模板开始部分的条件表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T &amp;w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget)<br>    &#123;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>T（<code>w</code>的类型）的隐式接口看上去会有如下限制：</p><ul><li>它必须提供一个名字为<code>size</code>的成员函数并且返回一个整型值。</li><li>它必须支持<code>!=</code>操作符函数，能够对两个<code>T</code>类型的对象进行比较。（这里，我们假设<code>someNastWidget</code>的类型为<code>T</code>。）</li></ul><p>多亏了操作符重载，上面的两个限制都不需要满足。<code>T</code>必须支持一个<code>size</code>成员函数，值得提及的是这个函数可能继承自一个基类。但是这个成员函数没有必要返回一个整型值。甚至不需要返回一个数字类型值。如果这么说的话，它甚至不需要返回<code>operator&gt;</code>定义中所需要的值。他需要的是返回一个类型<code>X</code>的对象，于是可以在一个类型<code>X</code>对象和<code>int</code>（因为<code>10</code>是<code>int</code>型的）型对象上调用<code>operator&gt;</code>。但是<code>Operator&gt;</code>没有必要带一个类型<code>X</code>的参数，因为它也可以带一个类型<code>Y</code>的参数，只要<code>Y</code>可以隐式的转成<code>X</code>就可以了。</p><p>类似的，<code>T</code>也没有必要支持<code>operator!=</code>，因为<code>operator!=</code>带一个类型<code>X</code>的参数和一个类型<code>Y</code>的参数也能接受。只要<code>T</code>能转成<code>X</code>并且<code>someNastyWidget</code>的类型可以转换成<code>Y</code>，那么函数调用就是有效的。</p><p>大多数人当第一次开始考虑这种隐式转换就头疼，你不需要吃阿司匹林。隐式接口只是简单的由一些有效表达式组成。表达式本身看起来复杂，但是加在上面的限制一般来说是简单直接的。例如，考虑下面的条件表达式，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    ...<br></code></pre></td></tr></table></figure><p>很难说要对函数<code>size</code>，<code>operator&gt;</code>,<code>operator&amp;&amp;</code>或者<code>operator!=</code>做什么限制，但是很容易辨认出需要对整个表达式做出的限制。If声明的条件部分必须是一个boolean表达式，所以不管涉及到什么类型，也不管<code>w.size() &gt; 10 &amp;&amp; w != someNastyWidget</code>产生什么，它必须同<code>bool</code>是兼容的。这是模板<code>doProcessing</code>强加在类型参数<code>T</code>上的隐式接口的一部分。剩下的<code>doProcessing</code>所需要的接口就是对拷贝构造函数的调用，还有<code>swap</code>对于类型T来说必须是有效的。</p><p>强加在模板参数上的隐式接口同强加在类对象上的显示接口一样真实，两者都是在编译阶段检查。你不能同一个类提供的显示接口相矛盾的方式使用一个类对象（不会编译通过），你也不能随便在一个模板中尝试使用一个对象，除非这个对象支持模板需要的隐式转换（否则也不能通过编译）</p><h2 id="总结">总结</h2><ul><li>类和模板都支持接口和多态。</li><li>对于类来说，接口是显式的，以函数签名为中心。多态发生在运行时，通过虚函数来实现。</li><li>对于模板参数来说，接口是隐式的，基于有效表达式。模板多态通过模板实例化和函数重载来实现，它发生在编译期。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveCpp-21：必须返回对象时，不要返回reference</title>
    <link href="/2023/04/20/EffectiveCpp-21/"/>
    <url>/2023/04/20/EffectiveCpp-21/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-item-21必须返回对象时不要返回reference">EffectiveC++ Item 21：必须返回对象时，不要返回reference</h1><p>众所周知，C++中函数传参<em>pass-by-value</em>的效率是要低于<em>pass-by-reference</em>的，所以函数传参尽量以<strong><em>pass-by-reference-to-const</em>替换<em>pass-by-value</em></strong>,但是在函数返回的时候，返回一个<em>reference</em>并不一定是一件好事，因为这可能会导致我们<strong>传递一些<em>reference</em>并不存在的对象</strong>。</p><p>考虑一个用于表现有理数的class,内含一个函数用来计算两个有理数的乘积：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n, d;   <span class="hljs-comment">// 分子numerator 和 分母denominator</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类的<code>operator*</code>是以<em>by-value</em>返回其计算结果。如果现在你想节省掉该对象的构造和析构函数成本，而改用传递reference，那么请先回想一下，<strong>所谓reference只是一个名称，代表某个既有对象。任何时候看到一个reference对象声明式，都要立刻提醒自己，它的另一个名称是什么？因为它一定是某物的另一个名称</strong>。如果上面<code>operator*</code>返回reference，那么它一定指向一个既有的<code>Rational</code>对象,内含两个<code>Rational</code>对象的乘积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;   <span class="hljs-comment">// a = 1/2</span><br><span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;   <span class="hljs-comment">// b = 3/5</span><br>Rational c = a * b; <span class="hljs-comment">// c 应该是 3/10</span><br></code></pre></td></tr></table></figure><p>以上面的代码为例，期望一个值为<code>3/10</code>的Rational对象已经存在并不合理，如果<code>operator*</code>返回一个reference指向如此数值，它必须自己创建那个Rational对象。</p><p>创建新对象的方式有两种：在stack空间或者在heap空间创建。如果要定义一个local变量，就是在stack空间上创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这样做有一个很明显的漏洞：函数返回一个reference指向result，但result是一个local对象，而local对象在函数退出之前就已经销毁了。因此这个版本的<code>operator*</code>并未返回reference指向某个Rational，它返回的额reference指向一个已经被销毁的“从前的”Rational。而任何使用到这个返回值的操作都会引发“无定义行为”的报错。所以，<strong>任何函数都不要返回reference指向一个local对象</strong>。</p><p>那么考虑在heap内构建对象，并返回reference指向它，Heap-based对象由new创建，所以写一个heap-based<code>operator*</code>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational* <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>即便如此，我们还是要付出一个“构造函数”的代价，因为分配所得的内存将以一个适当的构造函数并完成初始化操作。但此外你又有了另一个问题：谁该对着这个new出来的对象实施delete？</p><p>即便调用者诚实诚谨，并出于良好意识，他们还是不太能在这样合情合理的用法下阻止内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Rational w, x, y, z;<br>w = x * y * z;      <span class="hljs-comment">// 与 operator* (operator* (x, y), z)相同</span><br></code></pre></td></tr></table></figure><p>这里同一个语句调用了两次<code>operator*</code>，也就需要使用两次new，对应的就需要两次delete。但是却没有合理的方法让<code>operator*</code>的使用者进行那些delete调用，因为没有合理的方法让他们取得<code>operator*</code>返回的reference背后隐藏的那个指针。这一定会导致内存泄露。</p><p>所以不管是on-the-stack或者是on-the-heap的做法，都会因为<code>operator*</code>的返回结果调用构造函数而出错或付出代价。而我们想返回引用的最初目的是<strong>避免构造函数的调用</strong>。</p><p>或许还有一种避免任何构造函数被调用的方法，那就是“让<code>operator*</code>返回的reference指向一个被定义于函数内部的staticRational对象”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-type">static</span> Rational result;<br><br>    result = ...;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这也是一个非常糟糕的设计，看下面这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs);<br><br>Rational a, b, c, d;<br><br><span class="hljs-keyword">if</span>((a * b) == (c * d))      <span class="hljs-comment">// 这个表达式一定为true</span><br>    ...<br><span class="hljs-keyword">else</span><br>    ...<br></code></pre></td></tr></table></figure><p>不管<code>a</code>,<code>b</code>,<code>c</code>,<code>d</code>的值是什么，表达式<code>(a * b) == (c * d)</code>一定为<code>true</code>。上述的<code>if</code>判别式可以写为下面的等价形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">operator</span>* (a, b), <span class="hljs-keyword">operator</span>* (c, d)))<br></code></pre></td></tr></table></figure><p>在<code>operator==</code>被调用之前，两个<code>operator*</code>已经被调用，每个都返回reference指向<code>operator*</code>内部定义的static对象。因此<code>operator==</code>比较的两个对象都是<code>operator*</code>内定义的static对象，所以判别式一定是<code>true</code>。</p><h2 id="总结">总结</h2><p>绝不要返回pointer或reference指向一个localstack对象，或返回有一个reference指向一个heap-allocated对象，或返回pointer或reference指向一个loaclstaic对象而又可能同时需要多个这样的对象。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划的几种实现方式</title>
    <link href="/2023/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划的几种实现方式">动态规划的几种实现方式</h1><p>动态规划又几种不同的实现方式，以leetcode第<ahref="https://leetcode.cn/problems/longest-common-subsequence/description/">1143</a>题为例：</p><p><img src="/img/算法/动态规划实现方式/leetcode1143.png" /></p><p>很明显这是一道动态规划的题，而动态规划有多种不同的实现方式，比如最常见的两种方式是迭代递推法和记忆化搜索法，这两种方法的主要区别在于，迭代递推法是自底向上递推，而记忆化搜索是自顶向下搜索，在搜索过程中保存计算结果，避免重复计算。</p><h2 id="递归搜索-保存计算结果-记忆化搜索">递归搜索 + 保存计算结果 =记忆化搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(text1, len1 - <span class="hljs-number">1</span>, text2, len2 - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;text1, <span class="hljs-type">int</span> end1, <span class="hljs-type">const</span> string &amp;text2, <span class="hljs-type">int</span> end2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(end1 == <span class="hljs-number">-1</span> || end2 == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(memo[end1][end2] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> memo[end1][end2];<br><br>        <span class="hljs-keyword">if</span>(text1[end1] == text2[end2])<br>            memo[end1][end2] = <span class="hljs-built_in">dp</span>(text1, end1 - <span class="hljs-number">1</span>, text2, end2 - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            memo[end1][end2] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dp</span>(text1, end1 - <span class="hljs-number">1</span>, text2, end2), <span class="hljs-built_in">dp</span>(text1, end1, text2, end2 - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> memo[end1][end2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代递推">迭代递推</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        memo[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = memo[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = memo[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = memo[i][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span>    <br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(memo[i][j + <span class="hljs-number">1</span>], memo[i + <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len1][len2];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="空间优化一个数组">空间优化（一个数组）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; ++i)<br>        &#123;   <br>            pre = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 每次++i之后j又从0开始，pre = memo[j] = 二维memo[i][0] = 0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; ++j)<br>            &#123;   <br>                <span class="hljs-type">int</span> tmp = memo[j + <span class="hljs-number">1</span>];      <span class="hljs-comment">// temp == 二维memo[i][j + 1]</span><br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    memo[j + <span class="hljs-number">1</span>] = pre + <span class="hljs-number">1</span>;   <span class="hljs-comment">// memo[j + 1] == 二维memo[i + 1][j + 1]</span><br>                <span class="hljs-keyword">else</span>    <br>                    memo[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(tmp, memo[j]);     <span class="hljs-comment">// memo[j + 1] == 二维memo[i + 1][j + 1]</span><br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len2];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树</title>
    <link href="/2023/04/08/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2023/04/08/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树">前缀树</h1><p>前缀树（又称为字典树或者称为字典映射树、查找树），是一种树形结构。前缀树的作用是：对于一组字符串，找到这组字符串的公共前缀，或者判断一个字符串是否是这组字符串中的某一个串的前缀。</p><p>前缀树的主要性质是：根节点不包含字符,每一个节点的所有子节点包含的字符都不相同。另外，从根节点到某一个节点，路径上经过的字符连接起来，即为该节点对应的字符串。</p><p>以下是前缀树的时间复杂度描述：</p><table><thead><tr class="header"><th>空间复杂度</th><th>时间复杂度</th><th>空间复杂度描述</th><th>时间复杂度描述</th></tr></thead><tbody><tr class="odd"><td>O(字符串总长度)</td><td>O(字符串总长度)</td><td>各字符串的字符数之和</td><td>查找、插入、删除的时间复杂度均为O(字符串长度)</td></tr></tbody></table><p>字典树的应用场景非常广泛，比如字符串的匹配 (Trie),排序、树形统计和信息检索 (eg. 索引, 关键词检索, 模糊查询) 等等。</p><p>前缀树的实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> is_end_;<br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>),  <span class="hljs-built_in">is_end_</span>(<span class="hljs-literal">false</span>)<br>    &#123;   <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span>    <span class="hljs-comment">// 输入字符串</span></span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<br>                node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br><br>            node = node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node -&gt; is_end_ = <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span>    <span class="hljs-comment">// 查找word是否在前缀树中插入过</span></span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-built_in">searchPrefix</span>(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nullptr</span> &amp;&amp; node -&gt; is_end_ == <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span>  <span class="hljs-comment">// 判断是否以word为前缀</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchPrefix</span>(prefix);<br>    &#125;<br><br>    <span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            node = node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈">单调栈</h1><p>单调栈是一种运用栈数据结构来解决一些特定问题的解题技巧。它主要用于解决需要快速寻找<strong>一个元素左(或右)边第一个比它大(或小)的元素</strong>的问题。</p><p>使用单调栈的基本思路是保持栈内的元素单调递增或单调递减，栈顶元素是当前栈内最大或最小的元素，同时记录下每个元素的相关信息，如坐标、面积、数量等，根据这些信息计算出所需的结果。</p><p>单调栈的实现主要有两种，第一种是从前往后遍历数组，第二种是从后往前遍历数组。</p><h2 id="寻找数组右侧第一个比它大的数">寻找数组右侧第一个比它大的数</h2><p><strong>第一种实现方式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它大的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 当前元素大于栈顶元素时，当前元素就是栈顶元素右侧第一个大于栈顶的元素，并将栈顶出栈</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[s.<span class="hljs-built_in">top</span>()])    <br>        &#123;<br>            res[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种实现方式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它大的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)     <br>    &#123;<br>        <span class="hljs-comment">// 栈顶元素在当前元素右侧，当栈顶元素小于或等于当前元素的时候，将其出栈，继续寻找当前元素右侧第一个比它大的元素</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[s.<span class="hljs-built_in">top</span>()] &lt;= nums[i])  <br>            s.<span class="hljs-built_in">pop</span>();<br>        res[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寻找数组右侧第一个比它小的数">寻找数组右侧第一个比它小的数</h2><p><strong>第一种实现方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSmallerElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它小的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)     <br>    &#123;<br>        <br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt;= nums[s.<span class="hljs-built_in">top</span>()])  <br>        &#123;<br>            right[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种实现方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSmallerElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它小的数时对应res为-1，所以初始值全部设置为-1</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt;= nums[s.<span class="hljs-built_in">top</span>()])<br>            s.<span class="hljs-built_in">pop</span>();<br>        right[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="寻找数组右侧第一个满足某个条件的数">寻找数组右侧第一个满足某个条件的数</h2><p>观察上面两个算法的实现，可以发现，以<strong>从前往后遍历</strong>为例，他们的框架其实是一样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[i]满足nums[s.<span class="hljs-built_in">top</span>()]的条件`)    <br>        &#123;<br>            res[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>从后往前遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[s.<span class="hljs-built_in">top</span>()]不满足nums[i]的条件`)<br>            s.<span class="hljs-built_in">pop</span>();<br>        right[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="寻找数组左侧第一个满足某个条件的数">寻找数组左侧第一个满足某个条件的数</h2><p><strong>从前往后遍历</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[s.<span class="hljs-built_in">top</span>()]不满足nums[i]的条件`)<br>            s.<span class="hljs-built_in">pop</span>();<br>        left[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>从后往前遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[i]满足nums[s.<span class="hljs-built_in">top</span>()]的条件`)<br>        &#123;<br>            left[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>寻找左边第一个满足某个条件的数和寻找右边第一个满足条件的数，从前往后遍历和从后往前遍历的循环条件刚好是相反的</p></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/04/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/04/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快排算法">快排算法</h1><p>快速排序是一种常见的排序算法，其核心思想是分治法。下面是快速排序的步骤：</p><ol type="1"><li>选取一个基准数（pivot）</li><li>将序列中比基准数大的元素放在基准数的右边，比基准数小的元素放在基准数的左边。</li><li>递归地对基准数左右两边的序列进行排序，直到序列长度为1或0。</li></ol><p>快速排序中最重要的就是第2步，也就是<code>partation</code>阶段。快速排序有很多不同的实现方式，每次选择最右侧的数作为<code>pivot</code>进行<code>partation</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> pvoit = nums[right];     <span class="hljs-comment">// 选择最右侧的数作为pivot</span><br>   <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>   &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>          <span class="hljs-built_in">swap</span>(nums[++i], nums[j]);<br><br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过上面的代码我们可以看出，每次<code>partation</code>必然会将一个数放到最终的位置，然后再递归处理<code>pivot</code>左右两侧的区间，那么最好的情况就是每次<code>partation</code>都将数组两等分，而最坏的情况是每次<code>partation</code>划分出的区间都在<code>pivot</code>的一侧。</p><p>那么如何避免最坏情况的发生呢？这里可以每次选择一个随机数作为<code>pivot</code>然后进行划分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>   <span class="hljs-built_in">swap</span>(nums[p], nums[right]);      <span class="hljs-comment">// 将随机选出的数与最右侧数交换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">partation</span>(nums, left, right); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pvoit = nums[right];<br>  <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>  &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 快速排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomQuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(left &gt;= right)<br>      <span class="hljs-keyword">return</span> ;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">randomPartation</span>(nums, left, right);<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, left, p - <span class="hljs-number">1</span>);<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, p + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>   <span class="hljs-built_in">swap</span>(nums[p], nums[right]);      <span class="hljs-comment">// 将随机选出的数与最右侧数交换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">partation</span>(nums, left, right); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pvoit = nums[right];<br>  <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>  &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2023/04/04/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2023/04/04/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法">二分法</h1><p>二分法作为一种常见的查找算法，其实不单单可以只寻找某一个数。</p><h2 id="最基本的二分查找">最基本的二分查找</h2><p>搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索一个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 定义target在左闭右开的区间里，即：[left, right)</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;   <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>            right = mid;    <span class="hljs-comment">// target 在左区间，在[left, mid)中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在[mid + 1, right)中</span><br>        <span class="hljs-keyword">else</span>                <span class="hljs-comment">// nums[mid] == target</span><br>            <span class="hljs-keyword">return</span> mid;     <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;              <span class="hljs-comment">// 未找到目标值</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="搜索左侧边界">搜索左侧边界</h2><p><img src="/img/算法/二分法/二分法拓展.png" /></p><p>如上图所示，查找数组中最左侧大于或等于3的数也可以使用二分法。首先对整个数组二分，看中间的数是否满足大于或等于3，若满足继续在左侧二分，否则在右半侧二分，一直到结束，得到的所有满足条件的最小下标就是求得的结果。</p><p><strong>这个问题与普通二分法查找的区别在于</strong>：二分法是使用二分找个一个满足条件的数之后就结果查找，但是这里需要一直二分到最后，然后在所有满足条件的数中比较。</p><p><strong>搜索左侧边界</strong>的二分搜索算法的具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索左侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <br>            right = mid;    <span class="hljs-comment">// 当找到 target 时，收缩右侧边界</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) <br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>            right = mid;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == nums.<span class="hljs-built_in">size</span>())     <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;    <span class="hljs-comment">// nums[left] != target说明没有搜索到，返回-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意在搜索左侧边界的时候并不是一旦发现<code>nums[mid] == target</code>就直接返回，因为要寻找最左侧满足条件的下标。</p><p>简化后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 优化版搜索左侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) <br>            right = mid;  <br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == nums.<span class="hljs-built_in">size</span>())     <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;    <span class="hljs-comment">// nums[left] != target说明没有搜索到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索右侧边界">搜索右侧边界</h2><p>搜索右侧边界其实和搜索左侧边界同理，不同的地方在于，搜索左侧边界时出现<code>nums[mid] == target</code>时<code>right</code>需要向左收缩，而在搜索右侧边界的时候出现<code>nums[mid] == target</code>时是<code>left</code>需要向右收缩。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索右侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            left = mid + <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>; <span class="hljs-comment">// nums[left - 1] != target说明没有搜索到，返回-1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>nums[mid] == target</code>和<code>nums[mid] &lt; target</code>的情况合并之后的简化版为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索右侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)<br>            left = mid + <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">else</span><br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>; <span class="hljs-comment">// nums[left - 1] != target说明没有搜索到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>不管是搜索单个值还是左右侧边界，此模板中<code>left</code>和<code>right</code>收缩的模式是一样的，即<code>left</code>向右收缩时总是<code>left= mid + 1</code>,而<code>right</code>收缩时总是<code>right =mid</code>。为什么 <code>left</code> 的更新必须是 <code>left = mid +1</code>，当然是为了把 <code>nums[mid]</code>排除出搜索区间。记住这一点便很容易记下三种不同的模板。</p><p>另外，搜索左右侧边界时的返回也不一样，搜索左侧边界的时候返回是<code>left</code>，而在搜索右侧边界的时候返回是<code>left- 1</code>，因为我们对 <code>left</code> 的更新必须是 <code>left = mid +1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于<code>target</code> 了，而 <code>nums[left-1]</code> 可能是<code>target</code>。</p></div><h2 id="寻找局部最小值">寻找局部最小值</h2><p>在一个无序数组arr中，相邻的数都不相同，那么如何在这个数组arr中找到一个局部最小值？这里的极小值定义是比左右两侧都小的数，在数组最左侧则只需要满足比它右侧的数小，在数组最右侧的数只需要满足比它左侧的数小即可。</p><p>首先判断<code>arr[0]</code>和<code>arr[n - 1]</code>是否是极小值，若右极小值则直接返回。若都不是极小值那么取最中间的数<code>arr[m]</code>,判断<code>arr[m]</code>是否为局部最小值，若为局部最小值则直接返回。</p><p><img src="/img/算法/二分法/局部最小值-2.png" /></p><p>若不为极小值那么它要么比它左侧的数大，要么比它右侧的数大。假设它比左侧的数大，那么就在左半边进行二分，如此一来，就存在了二分的点，直至找到一个局部最小值为止。</p><p><img src="/img/算法/二分法/局部最小值-1.png" /></p><p><strong>这里可以看出来二分法不只是能用在有序数组，在无序的情况下满足特定条件也可以用二分。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集union-find">并查集（UNION-FIND）</h1><p>并查集（Union-FindSet）是一种用来管理和解决集合分组问题的数据结构，它支持两个操作：</p><ul><li><strong>查找（Find）</strong>：查找一个元素属于哪个集合，即找出其所在的连通块。</li><li><strong>合并（Union）</strong>：将两个不相交的集合合并成一个新的集合。</li></ul><h2 id="并查集模板">并查集模板</h2><p><strong>查找（Find）</strong>：这里用树来表示是否属于同一个数组，使用<strong>查找（Find）</strong>操作返回的是该节点所在树的根节点，如果一个节点<code>x</code>所在树的根节点就是<code>x</code>自己，那么<code>findParent(x)</code>返回的结果就是<code>x</code>。</p><p><strong>合并（Union）</strong>：合并两个节点<code>x</code>和<code>y</code>之前需要先判断<code>x</code>和<code>y</code>是否属于一个集合，如果已经在一个集合里，那么直接返回，否则将<code>x</code>和<code>y</code>的集合合并（在此实现为将<code>x</code>和<code>y</code>的树合并为一个树）。</p><p>合并两个集合最原始的方式就是将一个节点的根节点接到另一个节点的根节点上：</p><p><img src="/img/算法/并查集/原始合并.jpg" /></p><p>其实就是一个树结构，每个节点的祖先节点是其所在的集合，那么就会有一个问题，在最坏的情况下，树会退化为一个链表，这时候的<strong>查找</strong>时间复杂度为<code>O(N)</code>，上面的<code>findParent</code>函数可以在查找过程中将树结构进行压缩，压缩之后的结构如下图所示，每个节点的父亲节点为所在树的根节点：</p><p><img src="/img/算法/并查集/路径压缩.jpg" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x != parent[x])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(parent[x]);<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>其查找过程便是压缩过程，见下面的动图：</p><p><img src="/img/算法/并查集/路径压缩动图.gif" /></p><p>并查集的模板如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UF</span>(<span class="hljs-type">int</span> n)   <span class="hljs-comment">// 构造函数，输入n为节点个数</span><br>    &#123;<br>        parent = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);    <span class="hljs-comment">// n + 1是可以parent[i]为第i个节点的祖先，视情况而定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;      <span class="hljs-comment">// 初始时每个节点都是单独的结合</span><br>        count = n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x != parent[x])      <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = <span class="hljs-built_in">findParent</span>(parent[x]);<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> parent_x = <span class="hljs-built_in">findParent</span>(x);<br>        <span class="hljs-type">int</span> parent_y = <span class="hljs-built_in">findParent</span>(y);<br><br>        <span class="hljs-keyword">if</span>(parent_x == parent_y)  <span class="hljs-comment">// x，y已经属于同一个集合，直接返回     </span><br>            <span class="hljs-keyword">return</span> ;<br>        --count;<br>        parent[parent_y] = parent_x;   <span class="hljs-comment">// 将两个集合合并</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>  <span class="hljs-comment">// 判断两个节点是否属于一个集合</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(x) == <span class="hljs-built_in">findParent</span>(y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;     <span class="hljs-comment">// parent[i]为第i个节点的祖先</span><br>    <span class="hljs-type">int</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考：本文中的图引用自<ahref="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/bing-cha-j-323f3/">labuladong的算法小抄</a>,模板实现是根据其模板修改而来。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法</title>
    <link href="/2023/04/03/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/03/Dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图算法">图算法</h1><h2 id="dijkstra算法">Dijkstra算法</h2><p>输入是一个图<code>graph</code>,返回是一个最短路径权重的数组。</p><p>思路：将<code>dis</code>的初始值出<code>start</code>之外设置为<code>INT_MAX</code>，<code>start</code>设置为<code>0</code>，然后将<code>start</code>加入到优先级队列中，依次将优先级队列中到<code>start</code>距离最小的节点<code>cur</code>弹出，看是否可以更新<code>cur</code>相邻节点<code>next_node</code>的dis值，如果出现下面<code>next_cost &lt; dis[edge.first]</code>的情况，那么就表示<code>next_node</code>的值可以被更新，且新的最短距离是经过<code>cur</code>的，同时将<code>next_node</code>加入到优先级队列中。重复这个过程，最终得到的<code>dis</code>数组就是<code>start</code>到其他节点的距离。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph为输入的图，graph[i]为节点i的邻接表，pair.first为相邻的节点编号,pair.second为该边的权重</span><br><span class="hljs-comment">// start为起点</span><br><span class="hljs-comment">// n为图的节点个数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; &amp;graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;   <span class="hljs-comment">// 距离起点的距离数组,初始设置为INT_MAX,方便以后遍历到之后更新</span><br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p2) &#123;<span class="hljs-keyword">return</span> p1.second &lt; p2.second;&#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);  <span class="hljs-comment">// 使用优先级队列，pair.first为节点编号,pair.second到该节点的最小距离</span><br>    dis[start] = <span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(start, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [id, cost] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cost &gt; dis[id])  <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : graph[id])<br>        &#123;<br>            <span class="hljs-type">int</span> next_cost = edge.second + dis[id];<br>            <span class="hljs-keyword">if</span>(next_cost &lt; dis[edge.first])     <span class="hljs-comment">// 如果下一个节点cost小于dis存储的值，更新dis并将其加入到优先级队列中</span><br>            &#123;<br>                dis[edge.first] = next_cost;<br>                pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, next_cost));   <span class="hljs-comment">// 该节点的cost更新之后，其相邻节点的cost可能也会因此更新</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dis;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="kruskal-最小生成树算法">Kruskal 最小生成树算法</h2><p>思想：从图<code>graph</code>中每次选择一条最短的边<code>e</code>，若加入<code>e</code>之后不构成环，将<code>e</code>加入到最小生成树的结果中；重复上述步骤，一直到有<code>n - 1</code>条边为止（<code>n</code>为图的节点个数，因为<code>n</code>个节点不存在环的连通图中必定有<code>n - 1</code>条边）。</p><p><strong>Kruskal算法步骤</strong>：</p><ol type="1"><li>将所有边按照权重从小到大排序</li><li>初始化一个集合，并且把所有节点分别加入集合，每个节点都是单独一个集合。</li><li>遍历排序后的边，将它们加入树中(如果边的两个节点不在同一个集合中)。</li><li>最后得到的tree就是最小生成树。</li></ol><p>这里实现KRUSKAL使用了并查集，并查集的概念与代码见<ahref="https://gstarmin.github.io/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph[i] = [x, y, cost]，表示节点x和y之间有一条权值为cost的边</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(graph.<span class="hljs-built_in">begin</span>(), graph.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; v2) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> v1[<span class="hljs-number">2</span>] &lt; v2[<span class="hljs-number">2</span>];&#125;);<br>    <span class="hljs-function">UF <span class="hljs-title">my_uf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;      <span class="hljs-comment">// 定义并查集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : graph)<br>    &#123;<br>        <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], cost = edge[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(my_uf.<span class="hljs-built_in">isConnected</span>(x, y))    <span class="hljs-comment">// 若x，y已经连通那么不能把这条边加入到结果中</span><br>            <span class="hljs-keyword">continue</span>;<br>        ++count;<br>        my_uf.<span class="hljs-built_in">unionNode</span>(x, y);<br>        res.<span class="hljs-built_in">emplace_back</span>(edge);     <span class="hljs-comment">// 将这条边添加到结果中，可以根据实际情况执行不同操作</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> count == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="prim-最下生成树算法">Prim 最下生成树算法</h2><p><code>Prim</code>算法与<code>Kruskal</code>的区别在于，<code>Kruskal</code>算法是每次选择一条最短的且不构成环的边，而<code>Prim</code>算法是使用<code>BFS</code>算法思想和<code>visited</code>数组避免成环，保证选出来的边一定是一棵树。</p><p><code>Prim</code>算法步骤：</p><ol type="1"><li>从任意一个节点开始，将该节点加入到已访问节点集合中。</li><li>在未访问节点中找到与已访问节点集合中节点权值最小的边（也就是跨越已访问节点集合和未访问节点中某个节点的边），将该边和对应的节点加入到已访问节点集合中。</li><li>重复第二步操作，直到所有节点都被加入到已访问节点集合中为止。</li></ol><p><code>Prim</code>算法也是一种贪心算法,它的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>，其中<code>n</code>为节点个数。在实际应用中，<code>Prim</code>算法通常用于处理<strong>稠密图</strong>中的最小生成树问题。</p><p>这里<code>Prim</code>算法的实现使用了优先级队列<code>priority_queue</code>,实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph为邻接表graph[i] = [node, cost]，start为Prim算法起始节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(graph[start].<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    visited[start] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p2) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> p1.second &gt; p2.second;&#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);      <span class="hljs-comment">// visited数组判断当前节点是否访问过</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;edge : graph[start])<br>    &#123;<br>        pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, edge.second));<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> cur = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(visited[cur.first])<br>            <span class="hljs-keyword">continue</span>;<br>        visited[cur.first] = <span class="hljs-literal">true</span>;<br>        res += cur.second;      <span class="hljs-comment">// 这里是计算最小生成树边的权值之和，可以根据实际情况调整</span><br>        ++count;<br>        <span class="hljs-keyword">if</span>(count == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;edge : graph[cur.first])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[edge.first])        <span class="hljs-comment">// 将当前节点的邻接节点加入优先级队列</span><br>                pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, edge.second));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓扑排序算法">拓扑排序算法</h2><p>Leetcode上的 <ahref="https://leetcode.cn/problems/course-schedule-ii/description/">210.课程表 II</a> 便是一道典型的拓扑排序题，问题如下：</p><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code>到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code>，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程<code>ai</code> 前 必须 先选修 <code>bi</code> 。</p><p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code>，我们用一个匹配来表示：<code>[0,1]</code> 。返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回<strong>任意一种</strong>就可以了。如果不可能完成所有课程，返回<strong>一个空数组</strong>。</p><p>拓扑排序分为<code>DFS</code>版本和<code>BFS</code>版本。</p><h3 id="dfs版本">DFS版本</h3><p><strong>步骤</strong>：</p><ol type="1"><li>首先，需要先建立一个 DAG（有向无环图），包含顶点和边。</li><li>初始化入度为 0 的顶点队列，将初始顶点加入队列中。</li><li>从队列头部开始处理。</li><li>遍历该顶点的出边，将出边对应的顶点的入度减 1。</li><li>如果入度为 0，则将该顶点加入队列末尾。</li><li>重复步骤 <code>3-5</code> 直到队列为空。</li></ol><p><code>DFS</code>版本实现类似二叉树的前序遍历或者树的<code>DFS</code>遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; visited;    <span class="hljs-comment">// 用于判断节点是否已经访问</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inedges;    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// DFS</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        inedges = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">buildGraph</span>(numCourses, prerequisites, graph, inedges);  <span class="hljs-comment">// 建图</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i)     <span class="hljs-comment">// 确保在图不是连通的情况下也能正确得到拓扑排序</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(graph, path, i, numCourses);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses ? path : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> numCourses)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[s])<br>            <span class="hljs-keyword">return</span> ;<br>        <br>        visited[s] = <span class="hljs-number">1</span>;<br>        path.<span class="hljs-built_in">emplace_back</span>(s);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses)<br>        &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;i : graph[s])<br>        &#123;<br>            --inedges[i];<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(graph, path, i, numCourses);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;prerequisites, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inedges)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : prerequisites)<br>        &#123;<br>            <span class="hljs-type">int</span> from = p[<span class="hljs-number">1</span>], to = p[<span class="hljs-number">0</span>];<br>            graph[from].<span class="hljs-built_in">emplace_back</span>(to);<br>            ++inedges[to];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="bfs版本">BFS版本</h3><p><code>BFS</code>版本和<code>DFS</code>版本的思路其实是一样的，<code>BFS</code>和<code>DFS</code>的区别类似树的遍历，无非是在遍历节点的时候以不同的顺序访问其邻接节点。<code>DFS</code>的实现用到了递归而<code>BFS</code>的实现用到了队列，类似二叉树的层序遍历或树的<code>BFS</code>遍历。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// BFS</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 判断节点是否已经访问</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inedges</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 入度数组</span><br>        <span class="hljs-built_in">buildGraph</span>(numCourses, prerequisites, graph, inedges);      <span class="hljs-comment">// 建图</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">emplace</span>(i);<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            visited[cur] = <span class="hljs-number">1</span>;<br>            path.<span class="hljs-built_in">emplace_back</span>(cur);     <span class="hljs-comment">// 将当前节点加入到拓扑排序结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[cur])<br>            &#123;<br>                --inedges[i];<br>                <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)     <span class="hljs-comment">// 若相邻节点的入度为0，加入到队列中</span><br>                    q.<span class="hljs-built_in">emplace</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses? path : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;prerequisites, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inedges)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : prerequisites)<br>        &#123;<br>            <span class="hljs-type">int</span> from = p[<span class="hljs-number">1</span>], to = p[<span class="hljs-number">0</span>];<br>            graph[from].<span class="hljs-built_in">emplace_back</span>(to);<br>            ++inedges[to];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 右值引用</title>
    <link href="/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="c-右值引用">C++ 右值引用</h1><p>C++11中一个最主要的特性是可以移动而非拷贝对象的能力。我们很多情况下都会发生对象拷贝，而在其中某些情况下，对象拷贝之后就立即背销毁了。这种情况下，移动而非拷贝对象会大幅度提升性能。</p><p>在C++11之前，没有直接的方法移动对象。因此，计时不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如string），进行不必要的拷贝代价非常高。</p><p>为了支持移动操作，C++11中引入了一种新的引用类型————<strong>右值引用(rvaluereference)</strong>。所谓右值引用是就是必须绑定到右值的引用。<strong>我们通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用</strong>。比如我们将要看到的，右值引用有一个重要的性质————<strong>只能绑定到一个将要销毁的对象上</strong>。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。</p><p>如我们所知，对于常规引用（为了与右值引用区分开，我们可以称之为<strong>左值引用</strong>），我们不能将其绑定到要求转换的表达式、字面常量、或者是返回右值的表达式。右值引用有完全相反的特性：我们可以将一个右值绑定到一个左值上，但不能将一个右值引用直接绑定到一个左值上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;         <span class="hljs-comment">// 正确：r引用i</span><br><span class="hljs-type">int</span> &amp;&amp;rr = i;       <span class="hljs-comment">// 错误:不能将一个右值引用绑定到一个左值上</span><br><span class="hljs-type">int</span> &amp;r2 = i * <span class="hljs-number">42</span>;   <span class="hljs-comment">// 错误：i * 42是一个右值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i * <span class="hljs-number">42</span>;     <span class="hljs-comment">// 正确:我们可以将一个const的引用绑定到一个右值上</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = i * <span class="hljs-number">42</span>;         <span class="hljs-comment">// 正确:将rr2绑定到乘法结果上</span><br></code></pre></td></tr></table></figure><p>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。</p><p>返回非引用类型的函数，连同算数、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个右值引用绑定到这类表达式上，但我们可以将一个const的左值引用或一个右值引用绑定到这类表达式上。</p><h2 id="左值持久右值短暂">左值持久；右值短暂</h2><p>考察左值和右值表达式的列表，两者相互区别之处就很明显了：<strong>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong>。</p><p>由于右值引用只能绑定到临时对象，我们得知</p><ul><li>所引用的对象将要别销毁</li><li>该对象没有其他用户</li></ul><p>这两个特性意味着：使用右值引用的diamagnetic可以自由地接管所引用对象的资源.</p><h2 id="变量是左值">变量是左值</h2><p>变量可以看作只有一个变量没有运算符的表达式,虽然我们很少这样看待变量.类似其他任何表达式,变量表达式也有左值/右值属性.变量表达式都是左值,带来的结果就是,<strong>我们不能将一个右值引用绑定一个右值引用类型的变量上</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 正确:字面常量是右值</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = rr1;    <span class="hljs-comment">// 错误:表达式rr1是左值!</span><br></code></pre></td></tr></table></figure><p>其实有了右值表示临时对象这一观察结果,变量是左值这一特性并不令人惊讶.毕竟,变量是持久的,直至离开作用域的时候才被销毁.</p><h2 id="stdmove函数">std::move函数</h2><p>虽然不能将一个右值引用直接绑定到一个左值上,但是我们可以显式地将一个左值转换为对应的右值引用.我们还可以通过调用一个名为<code>move</code>的函数来获得绑定到左值上的右值引用.<strong><code>move</code>函数可以返回给定对象的右值引用</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1);     <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p><code>move</code>调用告诉编译器:我们有一个左值,但我们希望像一个右值一样处理它.调用<code>move</code>就意味着承诺:除了对<code>rr1</code>赋值或销毁它外,我们将不再使用它.在调用<code>move</code>之后,我们不能对移后源对象的值做任何假设.(我们可以销毁一个移后源对象,也可以赋予它新值,但不能使用一个移后源对象的值)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ explicit用法</title>
    <link href="/2023/03/13/Cpp-explicit%E7%94%A8%E6%B3%95/"/>
    <url>/2023/03/13/Cpp-explicit%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="explicit关键字">explicit关键字</h1><h2 id="explicit-作用">explicit 作用</h2><p>在 C++中, explicit 关键字用来修饰类的构造函数, 被修饰的构造函数的类,不能发生相应的隐式类型转换, 只能以显式的方式进行类型转换.</p><p>explicit 使用注意事项:</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上；</li><li>explicit 关键字作用于单个参数的构造函数 (多个参数也适用,但必须只有一个参数需要赋值, 其他的参数要有默认值).</li><li>在 C++ 中, explicit 关键字用来修饰类的构造函数,被修饰的构造函数的类, 不能发生相应的隐式类型转换.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();    <span class="hljs-comment">// default构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>)</span></span>;   <span class="hljs-comment">// default构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;  <span class="hljs-comment">// 不是default构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述的classesB和C的构造函数都被声明为explicit，这可以组织它们被用来执行隐式类型转换，但它们仍然可以被用来进行显式类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(B bObject)</span></span>;    <span class="hljs-comment">// 函数，接受一个为B的对象</span><br><br>B bObj1；         <span class="hljs-comment">//一个类型为B的对象</span><br><span class="hljs-built_in">doSomething</span>(bObj1);     <span class="hljs-comment">// 没问题，传递一个B给doSomething对象</span><br><span class="hljs-function">B <span class="hljs-title">bOBj2</span><span class="hljs-params">(<span class="hljs-number">28</span>)</span></span>;            <span class="hljs-comment">// 没问题，根据int 28建立一个B</span><br><br><span class="hljs-built_in">doSomething</span>(<span class="hljs-number">28</span>);        <span class="hljs-comment">// 错误！doSomething应该接受一个B，不是一个int，而int至B没有隐式转化</span><br><br><span class="hljs-built_in">doSomething</span>(<span class="hljs-built_in">B</span>(<span class="hljs-number">28</span>));     <span class="hljs-comment">// 没问题，使用B构造函数将int显式转换为一个B以促成此调用</span><br></code></pre></td></tr></table></figure><p>被声明为explicit二点构造函数通常比其non-explicit兄弟更受欢迎，因为它们禁止编译器执行非预期（往往不被预期）的类型转换。除非我有一个好的理由允许构造函数被用于隐式转换，否则我会把它声明为explicit。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL优先级队列</title>
    <link href="/2023/03/09/CppSTL%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/09/CppSTL%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="cstl优先级队列">C++STL优先级队列</h1><p>优先级队列是特殊的队列，它与queue的区别在于它可以定义队列中数据的优先级，让优先级高的排在队列前面，可以优先出队，它本质上是由堆实现的。</p><h2 id="定义">定义</h2><p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><ul><li>Type:数据类型</li><li>Container：容器类型(Container必须是用数组实现的容器，比如vector,deque等等，但不能用list。STL里面默认用的是vector)</li><li>Functional:比较的方式，当需要用自定义的数据类型时才需要传入第三个参数，使用基本数据类型时，只需要传入数据类型，其默认是<strong>大根堆</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//升序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<br></code></pre></td></tr></table></figure><p><code>greater</code>和<code>less</code>是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）。</p><h2 id="基本操作">基本操作</h2><p><code>priority_queue</code>的基本操作：</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// pair 先比较first，first相等然后再比较second</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; a;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)</span></span>;<br>    a.<span class="hljs-built_in">push</span>(d);<br>    a.<span class="hljs-built_in">push</span>(c);<br>    a.<span class="hljs-built_in">push</span>(b);<br>    <span class="hljs-keyword">while</span> (!a.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; a.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        a.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="自定义类型">自定义类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp1</span> <span class="hljs-comment">//运算符重载&lt;</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">tmp1</span>(<span class="hljs-type">int</span> a) &#123;x = a;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> tmp1&amp; a) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x &lt; a.x;     <span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-comment">// return x &gt; a.x   // 小根堆</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp2</span> <span class="hljs-comment">//重写仿函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(tmp1 a, tmp1 b)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.x &lt; b.x;    <span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-comment">// return a.x &gt; b.x  // 小根堆</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    priority_queue&lt;tmp1&gt; d;<br>    d.<span class="hljs-built_in">push</span>(b);<br>    d.<span class="hljs-built_in">push</span>(c);<br>    d.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span> (!d.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; d.<span class="hljs-built_in">top</span>().x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        d.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span>&lt;&lt; endl;<br>    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;<br>    f.<span class="hljs-built_in">push</span>(c);<br>    f.<span class="hljs-built_in">push</span>(b);<br>    f.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span> (!f.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; f.<span class="hljs-built_in">top</span>().x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        f.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">3<br>2<br><span class="hljs-section">1</span><br><span class="hljs-section">----</span><br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p>参考:<ahref="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列(priority_queue)用法详解</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算的妙用</title>
    <link href="/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算的妙用">位运算的妙用</h1><h2 id="异或运算实现变量交换">异或运算实现变量交换</h2><p>异或运算可以理解为<strong>无进位相加</strong>，异或运算的性质如下：</p><ul><li>0 ^ N = N</li><li>N ^ N = N</li><li>a ^ b = b ^ a (交换律)</li><li>a ^ b ^ c = a ^ (b ^ c) （结合律）</li></ul><p>异或运算的妙用：交换两个数的值不使用额外变量： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">17</span>, b = <span class="hljs-number">23</span>;<br><span class="hljs-comment">// 交换a，b的值</span><br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure></p><p>但是<strong>需要注意的是，可以这样使用的前提是a和b指向的内存是不同的，但是两个数的值可以相同。</strong>比如在一个数组中对nums[i]和nums[j]进行交换，要使用这种方法，必须要保证i和j相同，否则nums[i]位置上的数会被抹成0。所以一般情况下不推荐这种用法。</p><h2 id="异或运算查找出现奇数次的数">异或运算查找出现奇数次的数</h2><h3 id="只有一种数出现奇数次">只有一种数出现奇数次</h3><p>一个数组中只有一种数出现奇数次，其余的数都出现偶数次，那么如果寻找这个出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>就是出现奇数次的数。因为异或运算满足交换律，出现偶数次的数相互异或的结果为<spanclass="math inline">\(0\)</span>，出现奇数次的数相互异或的结果为这个数的值，所以总的结果就是这个出现奇数次的数。</p><h3 id="有两种数出现奇数次">有两种数出现奇数次</h3><p>一个数组中有两种数出现奇数次，其余的数都出现偶数次，那么如果寻找出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>为a ^b。因为a和b是不同的数，所以必然有a ^ b <spanclass="math inline">\(\ne\)</span> 0,也就是a ^b的二进制至少有一位是1，那么假设a ^ b的二进制第8位为1，让<spanclass="math inline">\(eor\)</span>与数组中第8位为1的数异或，得到的<spanclass="math inline">\(eor^{&#39;}\)</span>就是a或b，再用<spanclass="math inline">\(eor^{&#39;}\)</span>与<spanclass="math inline">\(eor\)</span>异或得到的就是另外一个数。</p><p><img src="/img/算法/异或/查找数组中出现奇数次个数的数图解.png" /></p><p>因为a和b在第8为上的值一定是不一样的，所以肯定在不同的区域里，这样去用<spanclass="math inline">\(eor\)</span>异或第8位为1的数得到的就是a，b其中之一，出现偶数次的数不影响异或的结果。</p><p>那么就有一个问题，<strong>选哪一位的1？如何提取出这一位上的1？</strong>这里选择提取出a^ b最右边一位的1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>) <span class="hljs-comment">// 提取出eor最右侧的1</span><br></code></pre></td></tr></table></figure><p>将<spanclass="math inline">\(eor\)</span>用二进制表示就可以更直观的看出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">             eor = <span class="hljs-number">11001110</span>    <br>        ~eor + <span class="hljs-number">1</span> = <span class="hljs-number">00110010</span><br>eor &amp; (~eor + <span class="hljs-number">1</span>) = <span class="hljs-number">00000010</span> <span class="hljs-comment">// 提取出来最右侧的1</span><br></code></pre></td></tr></table></figure><h2 id="运算消去二进制最低位的1">&amp;运算消去二进制最低位的1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &amp; (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>因为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">    n = <span class="hljs-number">11001110</span><br>n - <span class="hljs-number">1</span> = <span class="hljs-number">11001101</span><br></code></pre></td></tr></table></figure><p>可以看到<code>n</code>的二进制中的高位的<spanclass="math inline">\(1\)</span>其实是不受<strong>减一</strong>操作的影响的，所以<code>n &amp; (n - 1)</code>就可以在不影响其他二进制位的情况下消去其最低位的<spanclass="math inline">\(1\)</span>。</p><p>那么就可以根据这个特性<strong>计算k的二进制1的个数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br>    n &amp;= n - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 每次消去二进制中最低位的1</span><br>    count++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求两个数的均值">求两个数的均值</h2><p>一般的写法是 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>但是这样并不是无懈可击的，可能会出现一个问题，当<code>low</code>和<code>high</code>都很大的时候<code>low + high</code>可能会溢出，这样结果就变成一个负数。更加好的写法是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><code>low</code>和<code>high</code>都没有溢出，那么<code>high - low</code>也不会溢出，这样结果就不会溢出。</p><p>更加简化的写法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++deque和queue</title>
    <link href="/2023/03/07/Cpp-deque%E5%92%8Cqueue/"/>
    <url>/2023/03/07/Cpp-deque%E5%92%8Cqueue/</url>
    
    <content type="html"><![CDATA[<h1 id="c-deque和queue">C++ deque和queue</h1><p>deque是双端队列，queue可以访问两端但是只能修改队头，而deque可以访问两端并且可以在队首和队尾删除和插入元素。</p><p>queue操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q； <span class="hljs-comment">//创建一个int型空队列q</span><br><br>q.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 将变量s从队尾入队</span><br>q.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">// 将队头元素弹出</span><br>q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 只返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();   <span class="hljs-comment">// 只返回队尾元素</span><br>q.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 返回队列中元素个数</span><br></code></pre></td></tr></table></figure><p>deque操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; dq； <span class="hljs-comment">// 创建一个数双端队列dq</span><br><br>dq.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>dq.<span class="hljs-built_in">push_front</span>(s); <span class="hljs-comment">//  将s从队头入队</span><br>dq.<span class="hljs-built_in">push_back</span>(s);    <span class="hljs-comment">// 将s从队尾入队，和普通队列方式一样</span><br>dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 只返回队头元素</span><br>dq.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 只返回队尾元素</span><br>dq.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 将队头元素弹出</span><br>dq.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 将队尾元素弹出</span><br>dq.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 将队列清空</span><br></code></pre></td></tr></table></figure><p>由于deque两端都可以压入，只用个push的话到底是用哪端压入呢？所以有了<code>push_back()</code>和<code>push_front()</code>,同样，<code>pop()</code>是弹出，所以有<code>pop_back()</code>和<code>pop_front()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++函数后冒号的含义</title>
    <link href="/2023/03/06/Cpp-%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2023/03/06/Cpp-%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="c函数后冒号的含义">C++函数后冒号的含义</h1><h2 id="c-函数后面加一个冒号的含义">c++ 函数后面加一个冒号的含义</h2><p>冒号后面跟的是赋值，这种写法是C++的特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb ):<span class="hljs-built_in">a</span>(aa),<span class="hljs-built_in">b</span>(bb)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb )<br>&#123;<br>    a=aa;<br>    b=bb;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c构造函数后面的冒号">C++构造函数后面的冒号</h2><p>在C++类的构造函数中经常会看到如下格式的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><p>上述语句中单冒号(:)的作用是表示后面是初始化列表，一般有三种使用场景。</p><h3 id="对父类进行初始化">对父类进行初始化</h3><p>调用格式为“子类构造函数 :父类构造函数”，如下，其中QMainWindow是MyWindow的父类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><h3 id="对类成员进行初始化">对类成员进行初始化</h3><p>调用格式为“构造函数 :A(初始值),B(初始值),C(初始值)……”，如下，其中A、B、C分别是类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">rectangle</span> <span class="hljs-comment">//头文件中类定义</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">rectangle</span>( <span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length);<br><span class="hljs-keyword">private</span>:<br>    CPoint m_point;<br>    <span class="hljs-type">int</span> m_Width;<br>    <span class="hljs-type">int</span> m_Length;<br>&#125;;<br> <br>rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length) : <span class="hljs-built_in">m_point</span>(pointX,pointY),<span class="hljs-built_in">m_Width</span>(Width),<span class="hljs-built_in">m_Length</span>(Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，上面构造函数的实现与下面的写法等价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    m_point.X = pointX;<br>    m_point.Y = pointY;<br>    m_Width   = Width;<br>    m_Length  = Length;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><h3id="对类的const成员变量进行初始化">对类的const成员变量进行初始化</h3><p>由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值。</p><h3 id="总结">总结</h3><p>对于第2、3种方式的应用场景，有以下两点说明：</p><ol type="1"><li><p>构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关。</p></li><li><p>相对于在构造函数中赋值，初始化列表执行效率更高。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常量、#define、const和constexpr</title>
    <link href="/2023/03/06/Cpp%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/"/>
    <url>/2023/03/06/Cpp%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/</url>
    
    <content type="html"><![CDATA[<h1id="c常量defineconst和constexpr">C++常量、#define、const和constexpr</h1><h2 id="常量">常量</h2><p>常量是固定值，在程序执行期间不会改变，可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值，常量的值在定义后不能进行修改；</p><p>可以使用枚举、#define、const和constexpr等方法定义常量.</p><h2 id="define">#define</h2><p>#define是预处理阶段进行处理，是一种宏定义，所以定义常量的宏是没有类型的，是在编译前即预编译阶段进行字符替换，并且由于是在预处理阶段替换所以不会有类型安全检查，系统也不会为它分配内存，存储在程序的代码段空间，实际就是给出了立即数，在运行过程中，常量在内存中会有若干个拷贝；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br></code></pre></td></tr></table></figure><p>如果只想常量宏只在某段代码起作用，则使用#undef这个常量宏，如果再用到了这个常量宏，编译器就会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r; <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span></span><br><br>S = Pi + <span class="hljs-number">1</span>; <span class="hljs-comment">//编译器报错</span><br></code></pre></td></tr></table></figure><h2 id="const">const</h2><p>const是一种Runtime，const常量会在内存中分配，可以是堆中也可以是栈中。以后在定义的常量调用时，只是使用对应的内存地址，不再开辟新的空间，在内存中只有一个拷贝，因此const相比#define，可以避免反复分配内存，节省空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> doulbe Pi=<span class="hljs-number">3.14159</span>;<br>S = Pi * r * r;<br></code></pre></td></tr></table></figure><h3 id="const修饰指针">const修饰指针</h3><p>const位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* test_ptr = &amp;test;<span class="hljs-comment">//禁止修改test_ptr指向的值, 可以修改test_ptr的值</span><br><span class="hljs-type">int</span> test2 = <span class="hljs-number">2</span>;<br>test_ptr = &amp;test2;<span class="hljs-comment">//指向另一个变量</span><br></code></pre></td></tr></table></figure><p>const位于<code>*</code>的右侧，const就是修饰指针本身，即指针本身是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> test_ptr = &amp;test;<br><br>*test_ptr = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 可以修改test_ptr指向的值, 禁止修改test_ptr的值</span><br></code></pre></td></tr></table></figure><h3 id="const修饰函数">const修饰函数</h3><p>在类中将成员函数修饰为const表明在该函数体内，不能修改对象的数据成员而且不能调用非const函数，由于非const函数可能修改数据成员，const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//fun1函数需要设置i的值，所以不能声明为const</span></span><br><span class="hljs-function">    </span>&#123;<br>i = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-comment">//fun2函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。</span></span><br><span class="hljs-function">    </span>&#123; <br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数参数">const修饰函数参数</h3><p>const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用;const指针可以接收非const和const指针，而非const指针只能接收非const指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> param)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数返回值">const修饰函数返回值</h3><p>const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员变量">const修饰成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> Test:: <span class="hljs-built_in">fun1</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">//i++; i不能修改</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="constexpr">constexpr</h2><p>constexpr与const一样，它可以应用于变量，不同的是可以应用于函数和类构造函数,constexpr指示值或返回值是常量，并且在可能的情况下，在编译时计算</p><h3 id="修饰变量">修饰变量</h3><p>const和constexpr之间的主要区别在于，const的初始化可以在到运行时，而constexpr编译时必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> :<br>        n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-built_in">exp</span>(x * x, n / <span class="hljs-number">2</span>) :<br>        <span class="hljs-built_in">exp</span>(x * x, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰构造函数">修饰构造函数</h3><p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy,<span class="hljs-type">int</span> zz)</span></span><br><span class="hljs-function">        :x(xx),y(yy),z(zz)&#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        :Base(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">constexpr</span> Base pt = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure><p>转载自<a href="https://zhuanlan.zhihu.com/p/473260243">C/C++常量、#define、const和constexpr</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛法:埃氏筛和欧拉筛</title>
    <link href="/2023/03/06/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
    <url>/2023/03/06/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="质数数筛法">质数数筛法</h1><p>本文主要介绍埃氏筛法和欧拉筛法。</p><h2 id="判断单个数是不是质数">判断单个数是不是质数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(num==<span class="hljs-number">2</span> || num==<span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(num%<span class="hljs-number">6</span> != <span class="hljs-number">1</span> &amp;&amp; num%<span class="hljs-number">6</span> != <span class="hljs-number">5</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp = <span class="hljs-built_in">sqrt</span>(num);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">5</span>; i &lt;= tmp; i+=<span class="hljs-number">6</span>)<br><span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span> || num%(i+<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是当有很多个数需要判断的时候，每次都输入num判断是否是质数就很耗时了，这样提前将一个范围的质数算出来可以更节省时间，所以就用到了质数筛法。</p><h2 id="暴力筛法">暴力筛法</h2><p>学习埃氏筛之前，我们先看一下暴力筛法，即对每个数都用试除法判断其是不是质数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">// 初始化为0， 0表示质数，1表示合数</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i / j; j++)&#123;<span class="hljs-comment">//试除法</span><br><span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<br>st[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 合数，标记为1 </span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="埃式筛">埃式筛</h2><p>暴力筛法无疑是最慢的，我们看一下如何加快，换一种思路：一个质数的倍数一定是合数，所以，假设<spanclass="math inline">\(P\)</span>是质数，我们可以筛掉区间<spanclass="math inline">\([1,1e7]\)</span>中所有<spanclass="math inline">\(P\)</span>的倍数。 先看个例子，对于数列1~11：</p><p><img src="/img/算法/素数筛法/数1-11.png" /></p><p>先筛去2的倍数：</p><p><img src="/img/算法/素数筛法/筛去2倍数.png" /></p><p>再筛去3倍数：</p><p><img src="/img/算法/素数筛法/筛去3倍数.png" /></p><p>再筛去5倍数：</p><p><img src="/img/算法/素数筛法/筛去5倍数.png" /></p><p>至此，1~11内的所有合数都被筛完了， 2 3 5 7 11是数列中的质数。</p><p>为什么这样能筛去所有的合数呢，因为<strong>一个合数一定能被分解为几个质数的幂的乘积</strong>，并且这个数的质因子一定是小于它本身的，所以当我们从小到大将每个质数的倍数都筛去的话，当遍历到一个合数时，它一定已经被它的质因子给筛去了。</p><p>埃氏筛代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的时间复杂度为<span class="math inline">\(O(n\log{\log_2 n})\)</span></p><p>我们还可以对其进行优化：</p><ul><li>我们会先筛<spanclass="math inline">\(2\)</span>的所有倍数，然后筛<spanclass="math inline">\(3\)</span>的所有倍数，但筛除<spanclass="math inline">\(3\)</span>的倍数时，我们还是从<spanclass="math inline">\(3\)</span>的<spanclass="math inline">\(2\)</span>倍开始筛，其实<spanclass="math inline">\(3 * 2\)</span> ，已经被<spanclass="math inline">\(2 * 3\)</span>时筛过了。又比如说筛5的倍数时，我们从5的2倍开始筛，但是<spanclass="math inline">\(5 * 2\)</span>会先被<span class="math inline">\(2* 5\)</span>筛去， <span class="math inline">\(5 * 3\)</span>会先被<spanclass="math inline">\(3 * 5\)</span>会筛去，<spanclass="math inline">\(5 * 4\)</span>会先被<span class="math inline">\(2* 10\)</span>筛去，所以我们每一次只需要从<spanclass="math inline">\(i*i\)</span>开始筛，因为<spanclass="math inline">\((2，3,…,i - 1)\)</span>倍已经被筛过了。</li><li>另外，判断一个数 <spanclass="math inline">\(n\)</span>是不是质数，我们只判断<spanclass="math inline">\([2, \sqrt{n}]\)</span>内有没有它的因子。在筛合数的时候，我们也可以这样做，因为一个合数的最小质因子一定小于等于<span class="math inline">\(\sqrt{n}\)</span>。所以对于区间<spanclass="math inline">\([1, 1e7]\)</span>，最大的合数是 <spanclass="math inline">\(1e7\)</span>, 它的最小质因子一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>，区间内其他的合数的最小质因子也一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>的，所以只需要用<spanclass="math inline">\([1, \sqrt{1e7}]\)</span>中的质数就可以筛去 <spanclass="math inline">\([1, 1e7]\)</span>中所有的合数。</li></ul><p>优化后的埃式筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意循环条件i &lt;= n / i，为什么不直接成sqrt(n)?</span><br>    <span class="hljs-comment">// 写成这样的形式当i &gt;= sqrt(n) 时候依然可以停止循环，而且加减法需要几个时钟周期，乘法需要10几个时钟周期，除法需要2、3十个时钟周期，开根号需要8000个时钟周期，这样可以节省时间</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的时间复杂度可以近似看成<spanclass="math inline">\(O(n)\)</span>了。</p><h2 id="欧拉筛">欧拉筛</h2><p>优化后的埃式筛时间复杂度可以<strong>近似</strong>看成<spanclass="math inline">\(O(n)\)</span>，但是欧拉筛可以比它更快，欧拉筛的时间复杂度是<spanclass="math inline">\(O(n)\)</span>，又被称为线性筛。</p><p>埃氏筛是筛去每个质数的倍数，但难免，会有合数会被其不同的质因子多次重复筛去。这就造成了时间浪费。</p><p>比如说： <span class="math inline">\(120 = 2^3 * 3 * 5\)</span>,<spanclass="math inline">\(120\)</span> 会被<spanclass="math inline">\(2\)</span>筛去一次， <spanclass="math inline">\(3\)</span>筛去一次， <spanclass="math inline">\(5\)</span>筛去一次。 多做了两次不必要的操作。</p><p>那么我们如何确保120只被2筛掉呢？在埃氏筛中我们用了一个循环来筛除一个质数的所有倍数，即对于p来说，筛除数列：<span class="math inline">\(2 * p , 3 * p, ... ,k*p\)</span>。另外，我们是从小到大枚举区间中的每个数的，数列是：<spanclass="math inline">\(2,3,4,...,n\)</span>。</p><p>对比两个数列：</p><p><span class="math display">\[\begin{align}    &amp;2 * p , 3 * p, ... , k*p \\    &amp;2,3,4,...,n\end{align}\]</span></p><p>会发现，第二个数列是第一个数列的系数,所以，我们不需要用一个for循环去筛除一个质数的所有倍数，我们将所有质数存储到<code>primes[]</code>中，然后枚举到第i个数时，就筛去所有的<code>primes[j] * i</code>。这样就在每一次遍历中，正好筛除了所有已知素数的<code>i</code>倍。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-comment">//isPrime[i] == 1表示：i是素数</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-comment">//Prime存质数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛到n</span></span><br><span class="hljs-function"></span>&#123;<br>    Prime.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    isPrime.<span class="hljs-built_in">resize</span>(N, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//以“每个数都是素数”为初始状态，逐个删去</span><br>    isPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//1不是素数</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(isPrime[i])<span class="hljs-comment">//没筛掉 </span><br>        &#123;<br>            Prime.<span class="hljs-built_in">push_back</span>(i);<br>            ++cnt;<br>        &#125;<br>            <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n<span class="hljs-comment">/*不超上限*/</span>; j++) <br>        &#123;<br>            <span class="hljs-comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span><br>            <span class="hljs-comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span><br>            isPrime[i * Prime[j]] = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">if</span>(i % Prime[j] == <span class="hljs-number">0</span>)<span class="hljs-comment">//i中也含有Prime[j]这个因子</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//重要步骤。见原理</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意内层循环有一个<code>break</code>的条件<code>i % primes[j] == 0</code>,为什么呢？</p><p><strong>因为</strong>:</p><p>由</p><p><span class="math display">\[i \quad \% \quad primes[j] ==0\]</span></p><p>可得</p><p><span class="math display">\[primes[j] * k = i \tag{1}\]</span></p><p>设</p><p><span class="math display">\[primes[j] * k = X\tag{2}\]</span></p><p>将<span class="math inline">\((1)\)</span>代入到<spanclass="math inline">\((2)\)</span>中可得</p><p><span class="math display">\[primes[j+1] * primes[j] * k =X\]</span></p><p>因为<span class="math inline">\(primes[j+1] &gt;primes[j]\)</span>,所以<span class="math inline">\(primes[j+1] * k &gt;i\)</span>。</p><p>设</p><p><span class="math display">\[primes[j] * k = i^\prime\]</span></p><p>则</p><p><span class="math display">\[primes[j] * i^\prime =X\tag{3}\]</span></p><p>所以如果用<span class="math inline">\((2)\)</span>式筛去<spanclass="math inline">\(X\)</span>的话，当<spanclass="math inline">\(i\)</span>等于<spanclass="math inline">\(i&#39;\)</span>时，<spanclass="math inline">\(X\)</span>又会被<spanclass="math inline">\((3)\)</span>式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的<spanclass="math inline">\(i\)</span>, 所以不能提前筛。</p><p>比如说 <span class="math inline">\(1，2，3，4，5，6，7，8，9，10，11， 12\)</span>,当<code>i == 4</code> 时,<code>primes = &#123;2, 3&#125;</code>,此时 <code>i % 2 == 0</code>,如果不结束内层循环的话， <spanclass="math inline">\(12\)</span>会被<spanclass="math inline">\(3*4\)</span>筛掉， 当<code>i == 6</code>时，<spanclass="math inline">\(12\)</span>又会被<spanclass="math inline">\(2*6\)</span>筛掉。</p><p><strong>欧拉筛的核心思想就是确保每个合数只被最小质因数筛掉。或者说是被合数的最大因子筛掉。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++左值和右值</title>
    <link href="/2023/03/04/Cpp-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2023/03/04/Cpp-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="理解-cc-中的左值和右值">理解 C/C++ 中的左值和右值</h1><p>我们在 C/C++ 编程中并不会经常用到 <em>左值 (lvalue)</em> 和 <em>右值(rvalue)</em>两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用<code>gcc</code> 编译以下代码时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会得到：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">test</span>.c: <span class="hljs-keyword">In</span> function &#x27;main&#x27;:<br><span class="hljs-keyword">test</span>.c:8:5: <span class="hljs-keyword">error</span>: lvalue required <span class="hljs-keyword">as</span> left operand of assignment<br></code></pre></td></tr></table></figure><p>没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值(lvalue)。另一个例子是当你用 <code>g++</code> 编译以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在错误信息是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">testcpp.cpp: <span class="hljs-keyword">In</span> <span class="hljs-keyword">function</span> &#x27;<span class="hljs-title function_">int</span>&amp; <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#x27;:<br>testcpp.cpp:<span class="hljs-number">5</span>:<span class="hljs-number">12</span>: error: invalid initialization <span class="hljs-keyword">of</span> non-<span class="hljs-keyword">const</span> <span class="hljs-keyword">reference</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&amp;&#x27;</span> <span class="hljs-keyword">from</span> an rvalue <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，左值和 右值 到底是什么意思呢？我这篇文章将会详细解释。</p><h2 id="简单的定义">简单的定义</h2><p>这里我故意给出了一个 <strong>左值</strong> 和 <strong>右值</strong>的简化版定义。文章剩下的部分还会进行详细解释。</p><p><strong>左值 (lvalue, locator value)</strong>表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是左值 就是 右值 。那么，右值是一个<strong>不</strong>表示内存中某个可识别位置的对象的表达式。</p><h2 id="举例">举例</h2><p>上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var;<br>var = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。<code>var</code>是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">4</span> = var;       <span class="hljs-comment">// 错误！</span><br>(var + <span class="hljs-number">1</span>) = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误！</span><br></code></pre></td></tr></table></figure><p>常量 <code>4</code> 和表达式 <code>var + 1</code>都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p><p>那么，我们就能理解第一个代码片段中的错误信息的含义了。<code>foo</code>返回的是一个临时的值。它是一个右值，赋值给它是错误的。因此当编译器看到<code>foo() = 2</code> 时，会报错——赋值语句的左边应当是一个左值。</p><p>然而，给函数返回的结果赋值，不一定总是错误的操作。例如，C++的引用让我们可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> globalvar = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> globalvar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>foo</code>返回一个引用。<strong>引用一个左值</strong>，因此可以赋值给它。实际上，C++中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符<code>[]</code>，来实现一些查找访问的操作，如 <code>std::map</code>中的方括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; mymap;<br>mymap[<span class="hljs-number">10</span>] = <span class="hljs-number">5.6</span>;<br></code></pre></td></tr></table></figure><p>之所以能赋值给 <code>mymap[10]</code>，是因为<code>std::map::operator[]</code> 的重载返回的是一个可赋值的引用。</p><h2 id="可修改的左值">可修改的左值</h2><p>左值一开始在 C 中定义为“可以出现在赋值操作左边的值”。然而，当 ISO C加入 <code>const</code> 关键字后，这个定义便不再成立。毕竟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// &#x27;a&#x27; 是左值</span><br>a = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 但不可以赋值给它！</span><br></code></pre></td></tr></table></figure><p>于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为<strong>可修改左值 (modifiable lvalues)</strong>。C99标准定义可修改左值为：</p><blockquote><p>可修改左值是特殊的左值，不含有数组类型、不完整类型、const修饰的类型。如果它是 <code>struct</code> 或<code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p></blockquote><h2 id="左值与右值间的转换">左值与右值间的转换</h2><p>通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符<code>'+'</code> 就需要两个右值参数，并返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;     <span class="hljs-comment">// a 是左值</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;     <span class="hljs-comment">// b 是左值</span><br><span class="hljs-type">int</span> c = a + b; <span class="hljs-comment">// + 需要右值，所以 a 和 b 被转换成右值</span><br>               <span class="hljs-comment">// + 返回右值</span><br></code></pre></td></tr></table></figure><p>在例子中，<code>a</code> 和 <code>b</code>都是左值。因此，在第三行中，它们经历了隐式的<strong>左值到右值转换</strong>。除了数组、函数、不完整类型的所有左值都可以转换为右值。</p><p>那右值能否转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注1：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】</p><p>不过，右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符<code>'*'</code>需要一个右值参数，但返回一个左值结果。考虑这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;arr[<span class="hljs-number">0</span>];<br>*(p + <span class="hljs-number">1</span>) = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span><br></code></pre></td></tr></table></figure><p>相反地，一元取地址操作符 <code>'&amp;'</code>需要一个左值参数，返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* bad_addr = &amp;(var + <span class="hljs-number">1</span>); <span class="hljs-comment">// 错误: 一元 &#x27;&amp;&#x27; 操作符需要左值参数</span><br><span class="hljs-type">int</span>* addr = &amp;var;           <span class="hljs-comment">// 正确: var 是左值</span><br>&amp;var = <span class="hljs-number">40</span>;                  <span class="hljs-comment">// 错误: 赋值操作的左操作数需要是左值</span><br></code></pre></td></tr></table></figure><p>在 C++ 中 <code>'&amp;'</code>符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string&amp; sref = std::<span class="hljs-built_in">string</span>();  <span class="hljs-comment">// 错误: 非常量的引用 &#x27;std::string&amp;&#x27; 错误地使用右值 &#x27;std::string` 初始化</span><br></code></pre></td></tr></table></figure><p><strong>常量的</strong>左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得C++中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p><h2 id="cv-限定的右值">CV 限定的右值</h2><p>如果我们仔细阅读 C++ 标准中关于左值到右值的转换的部分【注2：在新的C++11 标准草稿的第 4.1 节】，我们会发现：</p><blockquote><p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T不是类类型【译注：类类型即 C++中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定CV 的版本 (cv-unqualified version ofT)。其他情况下，转换后的右值类型就是 T 本身。</p></blockquote><p>什么叫做 “未限定 CV” (cv-unqualified) 呢？ <strong>CV 限定符</strong>这个术语指的是 <em>const</em> 和 <em>volatile</em> 两个类型限定符。C++标准的 3.9.3 节写到：</p><blockquote><p>每个类型都有三个对应的 CV-限定类型版本： <em>const 限定</em> 、<em>volatile 限定</em> 和 <em>const-volatile 限定</em> 版本。有或无 CV限定的不同版本的类型是不同的类型，但写法和赋值需求都是相同的。</p></blockquote><p>那么，这些又和右值有什么关系呢？在 C 中，只有左值有 CV限定的类型，而右值从来没有。而在 C++ 中，类右值可以有 CV限定的类型，但内置类型 (如 <code>int</code>)则没有。考虑下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo() const\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">cbar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bar</span>().<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// calls foo</span><br>    <span class="hljs-built_in">cbar</span>().<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// calls foo const</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code>中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是<code>const A</code>，这和 <code>A</code>是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code>的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p><h2 id="c11-的右值引用">C++11 的右值引用</h2><p>C++11 标准中引入的最强有力的特性就是右值引用，以及相关的 <em>移动语义(move semantics)</em>概念。这篇简短的文章没法完全讨论这个特性【注3：搜索 “rvalue references”可以找到很多相关的资料，几个个人认为有用的资料：<ahref="http://www.artima.com/cppsource/rvalue.html">这一篇</a>， <ahref="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x">这一篇</a>，特别是<ahref="http://thbecker.net/articles/rvalue_references/section_01.html">这一篇</a>】，但我想给出一个简单的例子。实际上，对左值和右值的理解可以帮助我们理解一些非平凡的语言概念。</p><p>这篇文章的大部分内容都在解释：左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p><p>假设我们要实现一个“整数的vector”，一些相关的函数可能是这样定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Intvec</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Intvec</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        : m_size(num), m_data(new int[m_size])</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;constructor&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Intvec</span>()<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;destructor&quot;</span>);<br>        <span class="hljs-keyword">if</span> (m_data) &#123;<br>            <span class="hljs-keyword">delete</span>[] m_data;<br>            m_data = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">Intvec</span>(<span class="hljs-type">const</span> Intvec&amp; other)<br>        : <span class="hljs-built_in">m_size</span>(other.m_size), <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size])<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy constructor&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_size; ++i)<br>            m_data[i] = other.m_data[i];<br>    &#125;<br><br>    Intvec&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Intvec&amp; other)<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy assignment operator&quot;</span>);<br>        <span class="hljs-function">Intvec <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>        std::<span class="hljs-built_in">swap</span>(m_size, tmp.m_size);<br>        std::<span class="hljs-built_in">swap</span>(m_data, tmp.m_data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> m_size;<br>    <span class="hljs-type">int</span>* m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样，我们定义了基本的构造器、析构器、拷贝构造器 (copy constructor)和拷贝赋值操作符 (copy assignment operator)【注4：拷贝赋值操作符的实现是在考虑异常安全角度的规范写法。结合使用拷贝构造器和不会抛出异常的<code>std::swap</code>，可以保证在异常发生时不会出现未初始化的内存】。它们都有一个logging 函数，让我们能知道是否调用了它们。</p><p>运行一个将 <code>v1</code> 的内容拷贝到 <code>v2</code> 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Intvec <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>Intvec v2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;assigning lvalue...\n&quot;</span>;<br>v2 = v1;<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning lvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>运行输出的结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">assigning lvalue...<br>[<span class="hljs-number">0</span>x28fef8] <span class="hljs-keyword">copy</span> assignment <span class="hljs-keyword">operator</span><br>[<span class="hljs-number">0</span>x28fec8] <span class="hljs-keyword">copy</span> <span class="hljs-keyword">constructor</span><br>[0<span class="hljs-title function_">x28fec8</span>] <span class="hljs-title function_">destructor</span><br><span class="hljs-title function_">ended</span> <span class="hljs-title function_">assigning</span> <span class="hljs-title function_">lvalue</span>...<br></code></pre></td></tr></table></figure><p>这是正常的结果，准确展示了 <code>operator=</code>的内部过程。但假设我们要将一个右值赋值给 <code>v2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;assigning rvalue...\n&quot;</span>;<br>v2 = <span class="hljs-built_in">Intvec</span>(<span class="hljs-number">33</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning rvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>虽然这里的例子中是赋值一个新创建的vector，但它可以代表更一般的情况——创建了一个临时的右值，然后赋值给<code>v2</code> （例如当一个函数返回 vector的情况）。我们会得到这样的输入：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>这看起来就要很多步骤了。特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。然而，在拷贝赋值操作符中，也创建和销毁了<em>另一个</em> 临时的对象。这完全是多余的没有意义的工作。</p><p>不过现在你不需要多一个临时对象了。C++11引入了右值引用，让我们可以实现“移动语义” (movesemantics)，特别是可以实现“移动赋值操作符” (move assignment operator)【注5：文章中一直将 <code>operator=</code> 叫做 “拷贝赋值操作符” (copyassignment operator)。在 C++11中，区分这两个概念是很重要的】。我们可以为 <code>Intvec</code>加上另一个 <code>operator=</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">Intvec&amp; <span class="hljs-keyword">operator</span>=(Intvec&amp;&amp; other)<br>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;move assignment operator&quot;</span>);<br>    std::<span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>    std::<span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>符号 <code>&amp;&amp;</code> 代表了新的 <strong>右值引用 (rvaluereference)</strong>。顾名思义，右值引用可以让我们创建对右值的引用。而且在调用结束后，右值引用就会被销毁。我们可以利用这个特性将右值的内部内容“偷”过来——因为我们不再需要使用这个右值对象了！这样得到的输出是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">move</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>由于将一个右值赋值给了 <code>v2</code>，移动赋值操作符被调用。虽然<code>Intvec(33)</code>仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。优雅。</p><p>再提醒一遍，这个例子只展示了移动语义和右值引用的冰山一角。你可以猜到，这实际上是一个复杂的话题，要考虑很多特殊情况和陷阱。我是想展示一个C++中左值右值区别的一个很有趣的应用。编译器显然知道哪里是个右值，会在编译时选择调用合适的构造器。</p><h2 id="总结">总结</h2><p>即使不考虑左值和右值的问题，你也可以写很多 C++代码，然后把这些问题看作编译器某些错误警告中奇怪的行话。然而，这篇文章想表明，对这个问题有一些领悟的话，会使你能更深入地理解一些C++ 代码，也更能弄懂一些 C++ 规范和语言专家的讨论。</p><p>另外，在新的 C++ 规范中，因为 C++11引入了右值引用和移动语义，这个话题变得更重要了。要想真正理解这个语言的一些新特性，透彻地理解左值和右值就变得重要了。</p><p>转载自<ahref="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C">理解C/C++ 中的左值和右值</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ auto与decltype:类型推导</title>
    <link href="/2023/03/04/Cpp-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/03/04/Cpp-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="modern-c-之-auto-与-decltype-类型推导">Modern C++ 之 auto 与decltype : 类型推导</h1><h2 id="auto-与-decltype-类型推导"><code>auto</code> 与<code>decltype</code> : 类型推导</h2><p>变量类型推导其实在 C++ 中一直存在,例如我们在使用泛型函数时编译器将帮助我们隐式地推导参数类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(_Type value)</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">114514</span>);  <span class="hljs-comment">// func&lt;int&gt;(114514);</span><br></code></pre></td></tr></table></figure><p>但直到 C++11 起才允许用户主动要求编译器进行类型推导. 现代 C++中提供的主动类型推导功能主要是通过 <code>auto</code> 的<code>decltype</code> 两个关键字实现.</p><h2 id="使用-auto-进行变量类型推导">使用 <code>auto</code>进行变量类型推导</h2><p>当你声明一个变量为 <code>auto</code> 类型时,编译器将自动帮助你推导出合适的数据类型. 这个变量可以是 :</p><ol type="1"><li>声明后立即赋值的普通变量;</li><li>函数的返回值;</li><li>函数的形参 (C++14 起)</li></ol><p>需要注意的是, 使用 <code>auto</code> 进行类型推导时, 将忽略顶层的<code>const</code> , <code>&amp;</code> , <code>*</code> 等修饰符,以便用户更细化的控制推导, 示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">auto</span> var_1 = number;       <span class="hljs-comment">// int var_1 = number;</span><br><span class="hljs-keyword">auto</span> var_2 = <span class="hljs-number">8.0f</span>;         <span class="hljs-comment">// float var_2 = 8.0f;</span><br><span class="hljs-keyword">auto</span> var_3 = var_1;        <span class="hljs-comment">// int var_3 = var_1;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> var_4 = var_2;  <span class="hljs-comment">// const float var_4 = var_2;</span><br><span class="hljs-keyword">auto</span>&amp; var_5 = number;      <span class="hljs-comment">// int&amp; var_5 = number;</span><br></code></pre></td></tr></table></figure><p>这种基础的用法主要是用于省略一些很长的类型名,一定程度上增加代码可读性. 一种经典用法是简写迭代器类型以遍历容器, 传统C++ 中, 我们需要完整写出迭代器的类型或是使用局部的 <code>typedef</code>进行简写, 如下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::unordered_map&lt;std::string, std::string&gt; key_value_map;<br><span class="hljs-comment">// C++98/03, 迭代器遍历容器完整写法</span><br><span class="hljs-keyword">for</span> (std::unordered_map&lt;std::string, std::string&gt;::const_iterator itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++98/03, 使用迭代器别名进行缩写</span><br><span class="hljs-keyword">typedef</span> std::unordered_map&lt;std::string, std::string&gt;::const_iterator unordered_map_const_itor;<br><span class="hljs-keyword">for</span> (unordered_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>而现代 C++ 中, 一方面我们通常使用 <code>using</code> 代替<code>typedef</code>, 但更方便的方式是使用 <code>auto</code>简写迭代器类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, 使用 using 代替 typedef</span><br><span class="hljs-keyword">using</span> hash_map_const_itor = std::unordered_map&lt;std::string, std::string&gt;::const_iterator;<br><span class="hljs-keyword">for</span> (hash_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++11 起, 使用 auto 自动推导迭代器类型</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们稍微引申一下, 在现代 C++ 中迭代一个容器的方式还有很多,具体可见下面的例子 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, auto + 范围 for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++17 起, auto + 范围 for 循环 + 结构化绑定</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++20 起, auto + 范围 for 循环 + 结构化绑定 + range 机制, 细化控制方式 (MSVC /std:c++laest)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::all) <span class="hljs-comment">// 全部遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::reverse) <span class="hljs-comment">// 全部倒序遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::<span class="hljs-built_in">drop</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 顺序遍历忽略前两个</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了普通的变量外, 我们还可以使用 <code>auto</code> 设置函数的返回值,此时需要我们在参数列表后使用 <code>-&gt;</code>符号标注具体的返回值类型. 这种写法被称作"返回类型后置语法",在一些脚本语言中比较常见 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>-&gt;<span class="hljs-type">int</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br><br><span class="hljs-comment">// 引申 : lambda 表达式的书写格式借鉴了返回值后置语法</span><br><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>到了 C++14, 我们甚至可以使用 <code>auto</code> 进行参数类型推导,在传统 C++ 中我们想进行参数类型的推导需要用到泛型机制, 但有了<code>auto</code> 进行推导参数类型后, 我们可以简化一些工作 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(_Type value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br><span class="hljs-comment">// C++20</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p><code>auto</code> 关键字在单独使用时, 大部分是用于简化书写当它与其它机制结合使用时可以衍生出更多的功能, 同样在下文里细说.</p><h2 id="使用-decltype-进行表达式类型推导">使用 <code>decltype</code>进行表达式类型推导</h2><p><code>auto</code> 关键字用于推导变量类型, 与之相对的<code>decltype</code> 则是用来推导表达式结果的类型. 熟悉 GCC的用户可能对这个关键字不陌生, <code>decltype</code> 的标准化提案就是源自GCC 的扩展关键字 <code>__decltype</code>, 而后者又是源自于 GCC一个很古老的扩展关键字 <code>__typeof__</code> .例如你可能需要推导某两个变量相加的结果类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> number_a = <span class="hljs-number">16LL</span>;                                          <span class="hljs-comment">// long long number_a = 16LL;</span><br><span class="hljs-keyword">auto</span> number_b = <span class="hljs-number">16.0F</span>;                                         <span class="hljs-comment">// float number_b = 16.0F;</span><br><span class="hljs-keyword">decltype</span>(number_a + number_b) number_c = number_a + number_b;  <span class="hljs-comment">// float number_c = number_a + number_b;</span><br></code></pre></td></tr></table></figure><p><code>decltype</code> 的推导规则遵循如下几点 :</p><ol type="1"><li>若表达式是一个 <strong>不带括号的标记符表达式</strong> 或<strong>类/结构体成员访问表达式</strong>,那么推导的结果是所代表实体的类型;</li><li>若表达式是一个<strong>函数调用(包括操作符重载)</strong>,那么推导的结果是函数的返回类型, 若返回值是基础类型则抛弃<code>const</code> 限定符;</li><li>若表达式是一个<strong>字符串字面量</strong>, 则推到为<code>const</code> 左值引用;</li><li>上述情况以外, 若表达式结果为左值则推导为左值引用,否则推导为本类型;</li></ol><p>示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> const_number = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> number_array[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span>* number_array_ptr = number_array;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123; <span class="hljs-type">double</span> member; &#125; my_struct;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">bool</span> <span class="hljs-title">func_1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;;<br><span class="hljs-function"><span class="hljs-type">const</span> MyStruct <span class="hljs-title">func_2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyStruct</span>(); &#125;;<br><br><span class="hljs-comment">// 规则 1 : 不带括号的标记符表达式 或 类/结构体成员访问表达式</span><br><span class="hljs-keyword">decltype</span>(number_array) var_1;      <span class="hljs-comment">// int[2] var_1; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number_array_ptr) var_2;  <span class="hljs-comment">// int*   var_2; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(my_struct.member) var_3;  <span class="hljs-comment">// double var_3; 成员访问表达式 =&gt; 本类型</span><br><br><span class="hljs-comment">// 规则 2 : 函数调用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_1</span>(<span class="hljs-number">1</span>)) var_5 = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// bool var_5; 基础类型返回值, 丢弃 const 限定符</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>)) var_7 = <span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// const MyStruct var_7; 类类型返回值, 保留 const 限定符</span><br><br><span class="hljs-comment">// 规则 3 : 字符串字面量</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-string">&quot;hello&quot;</span>) var_8 = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">//const char&amp; var_8[6]; const 左值引用</span><br><br><span class="hljs-comment">// 规则 4 : 其他情况下表达式结果</span><br><span class="hljs-keyword">decltype</span>((number)) var_9 = number;                 <span class="hljs-comment">// int&amp; var_9; 带括号的标记符表达式 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? number : number) var_10 = number;  <span class="hljs-comment">// int&amp; var_10; 条件表达式返回左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(++number) var_11 = number;                <span class="hljs-comment">// int&amp; var_11; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(number_array[<span class="hljs-number">5</span>]) var_12 = number;         <span class="hljs-comment">// int&amp; var_12; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(*number_array_ptr) var_13 = number;       <span class="hljs-comment">// int&amp; var_13; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>) var_14 = <span class="hljs-number">10</span>;                           <span class="hljs-comment">// int var_14; 纯右值字面量 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number++) var_15 = number;                <span class="hljs-comment">// int var_15; 表达式结果为右值 =&gt; 本类型</span><br></code></pre></td></tr></table></figure><p>你可能在部分平台上使用过关键字 <code>typeof</code> ,<code>__typeof__</code> 或 <code>__decltype</code> ,它们同样可用于推导表达式结果类型, 并且可以视作 <code>decltype</code>功能的子集. 但这些关键字从来都不是标准 C++ 的一部分,只是部分编译器支持的功能, 并且它们的推导规则也有很强的平台差异性.相比之下 <code>decltype</code> 的标准化程度和适用面更广. 除此之外<code>typeof</code> 进行类型推导时 <code>&amp;</code>引用符号很可能将不做保留, 至少 GCC 上是这样的, 参考以下示例 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>           var = <span class="hljs-number">1</span>; <br><span class="hljs-type">int</span>&amp;          ref = var; <br><span class="hljs-built_in">typeof</span>(var)   var_1 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-built_in">typeof</span>(ref)   var_2 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-keyword">decltype</span>(var) var_3;      <span class="hljs-comment">// int </span><br><span class="hljs-keyword">decltype</span>(ref) var_4 = a;  <span class="hljs-comment">// int&amp; </span><br></code></pre></td></tr></table></figure><p>总之, 当你的工程所使用的 C++ 版本若是等于或高于 C++11 ,我推荐全盘使用 <code>decltype</code> 代替 <code>typeof</code> .</p><h2 id="结合-auto-与-decltype-进行自动推导返回值类型">结合<code>auto</code> 与 <code>decltype</code> 进行自动推导返回值类型</h2><p><code>auto</code> 与 <code>decltype</code> 单独使用的时候,在功能上的突破本质还是向用户开放了主动要求类型推导的权限.但如果二者结合使用的话, 就可以突破传统 C++ 中一些限制了.在这里我们思考一个问题 : <strong>如何实现一个满足所有类型之间进行<code>+</code> 运算的函数?</strong></p><p>在传统 C++ 中的最优解是这样的 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function">_TypeResult <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法的确可以满足所有类型的 <code>+</code> 运算,但很明显使用上有着很大的局限性. 因为我们必须预知返回值的类型,而题目的隐藏含义是一定要做到通用性的. 那么我们现在已经知道如何使用<code>decltype</code> 可以进行表达式结果的类型推导,那何不直接用其直接推导函数体的结果呢 ?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> <span class="hljs-comment">// 未定义的标识符</span></span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>很遗憾这种行为是无效的, 因为形式参的定义在参数列表里,而处于参数列表左侧的返回值类型是无法获取形参名的.除非我们能将返回值类型放在参数列表的右侧, 实现这个目标的方式就是使用<code>auto</code> 书写返回类型后置语法 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// auto 返回类型后置语法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;_TypeResult </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br><span class="hljs-comment">// auto 返回类型后置语法 结合 decltype 表达式结果类型推导</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>若只是单纯的只用 <code>auto</code> 进行返回类型后置,则只是换了种语法. 但如果将 <code>auto</code> 与 <code>decltype</code>相结合, 就可以突破传统 C++ 的限制了. 到此,我们已经完全实现了题目里的需求. 但还有继续优化的空间,首先是上文中提到的, 自 C++14 起, 我们可以利用 <code>auto</code>进行参数类型的推导 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>其次是由于这种二者结合的模式被大量的使用, 自 C++14 起, 我们在使用<code>auto</code> 描述返回类型时无需在参数列表后写上返回类型,编译器将自动通过函数体进行推导, 因此这个方法最终将演化成这种形式 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p><strong>引申 : 上例中的 "最终版本" 真的完美吗?</strong></p><blockquote><p>返回类型后置这种语法看似只是语法上的一些取巧手法,但实则通过这种方式可以突破编译器的桎梏,因为编译器始终是由上至下由左至右理解代码的.</p></blockquote><p>正如上文中所说, <code>auto</code> 与 <code>decltype</code>的功能并不是现代 C++ 才出现的,而且在它们单独使用时更多的时候是一种简化代码书写的方式.但当二者结合起来时, 将可以做出一些语言功能上的突破.</p><h2 id="auto-与-decltype-的演化"><code>auto</code> 与<code>decltype</code> 的演化</h2><p>传统 C++ 里, 类型推导一般是在模板传参时进行隐式类型推导, 而<code>auto</code> 的出现是将类型推导的控制权开放给用户进行显示类型推导;而传统 C++ 里表达式结果类型的推导通常由不同平台上各种<code>typeof</code> 非标准扩展关键字实现, 而 <code>decltype</code>的出现则是这个功能的标准化. 当 <code>auto</code> 与<code>decltype</code> 相结合后, 由衍生出许多新的功能, 它们二者构成了现代C++ 类型推导功能的核心. 以下的 <code>auto</code> 与<code>decltype</code> 的发展历程简述 :</p><ol type="1"><li>C++11 :<ul><li>允许使用 <code>auto</code> 进行普通变量的主动类型推导;</li><li>允许使用 <code>auto</code> 书写返回值后置语法;</li><li>使用标准 <code>decltype</code> 进行表达式结果类型推导以替代各平台的<code>typeof</code> 扩展关键字;</li></ul></li><li>C++14 :<ul><li>允许使用 <code>auto</code> 进行形参类型推导;</li><li>允许使用 <code>auto</code> 进行返回值类型推导(书写返回值后置语法时不适用类型标识符表面返回类型);</li></ul></li></ol><p>内容转载自 <ahref="http://brabbit.xyz/blog/NoteModernCpp/p3_auto_deltype.html">ModernC++ 之 auto 与 decltype : 类型推导</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="详解-c-11-中的智能指针">详解 C++ 11 中的智能指针</h2><p>C/C++语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在C/C++语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如boost，智能指针技术应运而生。</p><h4 id="c-9803-的尝试stdauto_ptr">C++ 98/03 的尝试——std::auto_ptr</h4><p>在 2022 年讨论 <strong>std::auto_ptr</strong>不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11标准的出现（最新标准是 C++20），<strong>std::auto_ptr</strong>已经被彻底废弃了，取而代之是<strong>std::unique_ptr</strong>。然而，我之所以还向你介绍一下<strong>std::auto_ptr</strong> 的用法以及它的设计不足之处是想让你了解C++语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它，不是吗？</p><p><strong>std::auto_ptr</strong> 的基本用法如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化方式1</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-comment">//初始化方式2</span><br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">8</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针对象 <strong>sp1</strong> 和 <strong>sp2</strong>均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在<strong>sp1</strong> 和 <strong>sp2</strong> 释放时得到释放。这是<strong>std::auto_ptr</strong> 的基本用法。</p><div class="admonition info"><p class="admonition-title">info</p><p>sp 是 smart pointer（智能指针）的简写。</p></div><p><strong>std::auto_ptr</strong>真正让人容易误用的地方是其不常用的复制语义，即当复制一个<strong>std::auto_ptr</strong> 对象时（拷贝复制或 operator =复制），原对象所持有的堆内存对象也会转移给复制出来的对象。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试拷贝构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    <span class="hljs-keyword">if</span> (sp1.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp2.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">//测试赋值构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp4;<br>    sp4 = sp3;<br>    <span class="hljs-keyword">if</span> (sp3.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp4.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中分别利用拷贝构造（sp1 =&gt; sp2）和 赋值构造（sp3 =&gt;sp4）来创建新的 std::auto_ptr 对象，因此 sp1 持有的堆对象被转移给sp2，sp3 持有的堆对象被转移给 sp4。我们得到程序执行结果如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[root@iZ238vnojlyZ testx]<span class="hljs-comment"># g++ -g -o test_auto_ptr test_auto_ptr.cpp</span><br>[root@iZ238vnojlyZ testx]<span class="hljs-comment"># ./test_auto_ptr </span><br>sp1 <span class="hljs-keyword">is</span> empty.<br>sp2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br>sp3 <span class="hljs-keyword">is</span> empty.<br>sp4 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br></code></pre></td></tr></table></figure><p>由于 <strong>std::auto_ptr</strong>这种不常用的复制语义，我们应该避免在 stl 容器中使用<strong>std::auto_ptr</strong>，例如我们绝不应该写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; myvectors;<br></code></pre></td></tr></table></figure><p>当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误。</p><p>以史为鉴，作为 <strong>std::auto_ptr</strong> 的替代者<strong>std::unique_ptr</strong>吸取了这个经验教训。下文会来详细介绍。</p><p>正因为 <strong>std::auto_ptr</strong> 的设计存在如此重大缺陷，C++11标准在充分借鉴和吸收了 boost库中智能指针的设计思想，引入了三种类型的智能指针，即<strong>std::unique_ptr</strong>、<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong>。</p><div class="admonition info"><p class="admonition-title">info</p><p>boost 还有 scoped_ptr，C++11并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。</p></div><p>所有的智能指针类（包括 std::unique_ptr）均包含于头文件<strong>memery</strong> 中。</p><div class="admonition info"><p class="admonition-title">info</p><p>正因为存在上述设计上的缺陷，在 C++11及后续语言规范中 std::auto_ptr已经被废弃，你的代码不应该再使用它。</p></div><h4 id="stdunique_ptr">std::unique_ptr</h4><p><strong>std::unique_ptr</strong>对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是1，<strong>std::unique_ptr</strong>对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个<strong>std::unique_ptr</strong> 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>你应该尽量使用初始化方式 3 的方式去创建一个<strong>std::unique_ptr</strong> 而不是方式 1 和 2，因为形式 3更安全，原因 Scott Meyers 在其《Effective ModernC++》中已经解释过了，有兴趣的读者可以阅读此书相关章节。</p><div class="admonition info"><p class="admonition-title">info</p><p>令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared()方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique()方法创建一个 std::unique_ptr 对象，这个方法直到 C++14才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp; ...params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></td></tr></table></figure><p>鉴于 <strong>std::auto_ptr</strong>的前车之鉴，<strong>std::unique_ptr</strong>禁止复制语义，为了达到这个效果，<strong>std::unique_ptr</strong>类的拷贝构造函数和赋值运算符（operator =）被标记为<strong>delete</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//省略其他代码...</span><br><br>    <span class="hljs-comment">//拷贝构造函数和赋值运算符被标记为delete</span><br>    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，下列代码是无法通过编译的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;;<br><br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//std::unique_ptr&lt;int&gt; sp2(sp1);</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//sp3 = sp1;</span><br></code></pre></td></tr></table></figure><p>禁止复制语义也存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(val))</span></span>;<br>    <span class="hljs-keyword">return</span> up;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp1 = <span class="hljs-built_in">func</span>(<span class="hljs-number">123</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码从 func 函数中得到一个 <strong>std::unique_ptr</strong>对象，然后返回给 sp1。</p><p>既然 <strong>std::unique_ptr</strong> 不能复制，那么如何将一个<strong>std::unique_ptr</strong>对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;<br><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(std::move(sp1))</span></span>;<br><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>    sp3 = std::<span class="hljs-built_in">move</span>(sp2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2不再持有堆内存的引用，变成一个空的智能指针对象。并不是所有的对象的std::move 操作都有意义，只有实现了移动构造函数（MoveConstructor）或移动赋值运算符（operator =）的类才行，而<strong>std::unique_ptr</strong> 正好实现了这二者，以下是实现伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Deletor&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//其他函数省略...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T*    m_pT;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是 <strong>std::unique_ptr</strong>具有移动语义的原因，希望读者可以理解之。关于移动构造和<strong>std::move</strong>，我们将在后面章节详细介绍。</p><p><strong>std::unique_ptr</strong>不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建10个int类型的堆对象</span><br>    <span class="hljs-comment">//形式1</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br>    <span class="hljs-comment">//形式2</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]);<br>    <span class="hljs-comment">//形式3</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">10</span>))</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        sp1[i] = i;<br>        sp2[i] = i;<br>        sp3[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        std::cout &lt;&lt; sp1[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp2[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp3[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># g++ -g -o test_unique_ptr_with_array test_unique_ptr_with_array.cpp -std=c++17</span><br>[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># ./test_unique_ptr_with_array </span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span><br><span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br><span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span><br><span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span><br><span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span><br><span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span><br><span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>也可以持有一组堆对象，用法与 <strong>std::unique_ptr</strong>相同，下文不再赘述。</p><p><strong>自定义智能指针对象持有的资源的释放函数</strong></p><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete或者delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个Socket类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以<strong>std::unique_ptr</strong> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    ~<span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//关闭资源句柄</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> deletor = [](Socket* pSocket) &#123;<br>        <span class="hljs-comment">//关闭句柄</span><br>        pSocket-&gt;<span class="hljs-built_in">close</span>();<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span><br>        <span class="hljs-keyword">delete</span> pSocket;<br>    &#125;;<br><br>    <span class="hljs-function">std::unique_ptr&lt;Socket, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(Socket * pSocket)</span>&gt; <span class="hljs-title">spSocket</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Socket(), deletor)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义 <strong>std::unique_ptr</strong> 的资源释放函数其规则是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;T, DeletorFuncPtr&gt;<br></code></pre></td></tr></table></figure><p>其中 T 是你要释放的对象类型，DeletorPtr是一个自定义函数指针。上述代码 <strong>33</strong> 行表示 DeletorPtr有点复杂，我们可以使用 <strong>decltype(deletor)</strong>让编译器自己推导 deletor 的类型，因此可以将 <strong>33</strong>行代码修改为：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">std</span>::unique_ptr&lt;<span class="hljs-type">Socket</span>, decl<span class="hljs-keyword">type</span>(deletor)&gt; spSocket(new <span class="hljs-type">Socket</span>(), deletor);<br></code></pre></td></tr></table></figure><h4 id="stdshared_ptr">std::shared_ptr</h4><p><strong>std::unique_ptr</strong> 对其持有的资源具有独占性，而<strong>std::shared_ptr</strong> 持有的资源可以在多个<strong>std::shared_ptr</strong> 之间共享，每多一个<strong>std::shared_ptr</strong> 对资源的引用，资源引用计数将增加1，每一个指向该资源的 <strong>std::shared_ptr</strong>对象析构时，资源引用计数减 1，最后一个 <strong>std::shared_ptr</strong>对象析构时，发现资源计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作<strong>std::shared_ptr</strong>引用的对象是安全的）。<strong>std::shared_ptr</strong> 提供了一个<strong>use_count()</strong>方法来获取当前持有资源的引用计数。除了上面描述的，<strong>std::shared_ptr</strong>用法和 <strong>std::unique_ptr</strong> 基本相同。</p><p>下面是一个初始化 <strong>std::shared_ptr</strong> 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>sp3 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>和 <strong>std::unique_ptr</strong> 一样，你应该优先使用<strong>std::make_shared</strong> 去初始化一个<strong>std::shared_ptr</strong> 对象。</p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//初始化方式1</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//初始化方式2</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        sp2.<span class="hljs-built_in">reset</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        &#123;<br>            std::shared_ptr&lt;A&gt; sp3 = sp1;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码 <strong>22</strong> 行 sp1 构造时，同时触发对象 A的构造，因此 A 的构造函数会执行；</li><li>此时只有一个 sp1 对象引用 <strong>22</strong> 行 new 出来的 A对象（为了叙述方便，下文统一称之为<strong>资源对象A</strong>），因此代码 <strong>24</strong> 行打印出来的引用计数值为<strong>1</strong>；</li><li>代码 <strong>27</strong> 行，利用 sp1 拷贝一份 sp2，导致代码<strong>28</strong> 行打印出来的引用计数为 <strong>2</strong>；</li><li>代码 <strong>30</strong> 行调用 sp2 的 reset() 方法，sp2释放对资源对象 A 的引用，因此代码 <strong>31</strong>行打印的引用计数值再次变为 <strong>1</strong>；</li><li>代码 <strong>34</strong> 行 利用 sp1 再次 创建 sp3，因此代码<strong>35</strong> 行打印的引用计数变为 <strong>2</strong>；</li><li>程序执行到 <strong>36</strong> 行以后，sp3 出了其作用域被析构，资源A 的引用计数递减 1，因此 代码 <strong>38</strong> 行打印的引用计数为<strong>1</strong>；</li><li>程序执行到 <strong>39</strong> 行以后，sp1出了其作用域被析构，在其析构时递减资源 A 的引用计数至<strong>0</strong>，并析构资源 A 对象，因此类 A 的析构函数被调用。</li></ul><p>所以整个程序的执行结果如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# ./test_shared_ptr_use_count <br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">use</span> <span class="hljs-title">count</span>:</span> <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>A <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure><p><strong>std::enable_shared_from_this</strong></p><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个<strong>std::shared_ptr</strong> 对象给外部使用，C++新标准也为我们考虑到了这一点，有如此需求的类只要继承自<strong>std::enable_shared_from_this</strong>模板对象即可。用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">getSelf</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，类 A 的继承 <strong>std::enable_shared_from_this</strong>并提供一个 <strong>getSelf()</strong> 方法返回自身的<strong>std::shared_ptr</strong> 对象，在 <strong>getSelf()</strong>中调用 <strong>shared_from_this()</strong> 即可。</p><p><strong>std::enable_shared_from_this</strong>用起来比较方便，但是也存在很多不易察觉的陷阱。</p><p><strong>陷阱一：不应该共享栈对象的 this 给智能指针对象</strong></p><p>假设我们将上面代码 main 函数 <strong>25</strong> 行生成 A对象的方式改成一个栈变量，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//其他相同代码省略...</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br><br>    std::shared_ptr&lt;A&gt; sp2 = a.<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行修改后的代码会发现程序在<code>std::shared_ptr sp2 = a.getSelf();</code>产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过<strong>shared_from_this()</strong>将该对象交由智能指针对象管理。切记：<strong>智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</strong>。</p><p><strong>陷阱二：避免 std::enable_shared_from_this的循环引用问题</strong></p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// test_std_enable_shared_from_this.cpp : This file contains the &#x27;main&#x27; function. Program execution begins and ends there.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">9</span>;<br>        <span class="hljs-comment">//注意:</span><br>        <span class="hljs-comment">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span><br>        <span class="hljs-comment">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">0</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_SelfPtr = <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>                 m_i;<br>    std::shared_ptr&lt;A&gt;  m_SelfPtr;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">spa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        spa-&gt;<span class="hljs-built_in">func</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# g++ -g -o test_std_enable_shared_from_this_problem test_std_enable_shared_from_this_problem.cpp<br>[root@myaliyun testmybook]# ./test_std_enable_shared_from_this_problem<br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br></code></pre></td></tr></table></figure><p>我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏了！</p><p>我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到<strong>42</strong> 行后，spa出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁A。这就是所谓的 std::enable_shared_from_this的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。也就是说一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理。</p><h4 id="stdweak_ptr">std::weak_ptr</h4><p><strong>std::weak_ptr</strong>是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助<strong>std::shared_ptr</strong> 工作。</p><p><strong>std::weak_ptr</strong> 可以从一个<strong>std::shared_ptr</strong> 或另一个 <strong>std::weak_ptr</strong>对象构造，<strong>std::shared_ptr</strong> 可以直接赋值给<strong>std::weak_ptr</strong> ，也可以通过<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 函数来获得<strong>std::shared_ptr</strong>。它的构造和析构不会引起引用计数的增加或减少。<strong>std::weak_ptr</strong>可用来解决 <strong>std::shared_ptr</strong>相互引用时的死锁问题（即两个<strong>std::shared_ptr</strong>相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放）。</p><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个std::shared_ptr对象</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过构造函数得到一个std::weak_ptr对象</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过赋值运算符得到一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = sp1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp4 = sp2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># g++ -g -o test_weak_ptr test_weak_ptr.cpp </span><br>[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># ./test_weak_ptr</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>无论通过何种方式创建 <strong>std::weak_ptr</strong>都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。</p><p>既然，<strong>std::weak_ptr</strong>不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？<strong>std::weak_ptr</strong>提供了一个 <strong>expired()</strong> 方法来做这一项检测，返回true，说明其引用的资源已经不存在了；返回false，说明该资源仍然存在，这个时候可以使用<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 方法得到一个<strong>std::shared_ptr</strong>对象然后继续操作资源，以下代码演示了该用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span><br><span class="hljs-comment">//tmpConn_引用的TcpConnection已经销毁，直接返回</span><br><span class="hljs-keyword">if</span> (tmpConn_.<span class="hljs-built_in">expired</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (conn)<br>&#123;<br>    <span class="hljs-comment">//对conn进行操作，省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有读者可能对上述代码产生疑问，既然使用了<strong>std::weak_ptr</strong> 的 <strong>expired()</strong>方法判断了对象是否存在，为什么不直接使用 <strong>std::weak_ptr</strong>对象对引用资源进行操作呢？实际上这是行不通的，<strong>std::weak_ptr</strong>类没有重写 <strong>operator-&gt;</strong> 和 <strong>operator</strong>*方法，因此不能像 <strong>std::shared_ptr</strong> 或<strong>std::unique_ptr</strong> 一样直接操作对象，同时<strong>std::weak_ptr</strong> 类也没有重写 <strong>operator!</strong>操作，因此也不能通过 <strong>std::weak_ptr</strong>对象直接判断其引用的资源是否存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    <span class="hljs-function">std::weak_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (sp1)<br>    &#123;<br>        <span class="hljs-comment">//正确代码</span><br>        sp1 -&gt; <span class="hljs-built_in">doSomething</span>();<br>        (*sp1).<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (!sp1)<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    //错误代码，无法编译通过</span><br>    <span class="hljs-comment">//    sp2-&gt;doSomething();</span><br>    <span class="hljs-comment">//    (*sp2).doSomething();</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (!sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以 <strong>std::weak_ptr</strong>不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦。</p><p>因此，<strong>std::weak_ptr</strong>的正确使用场景是那些资源如果可用就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时Session 对象如果强行持有 Connection 对象与事实矛盾。</p><p><strong>std::weak_ptr</strong>的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeManager</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publish</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; iter : m_subscribers)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!iter.<span class="hljs-built_in">expired</span>())<br>            &#123;<br>                <span class="hljs-comment">//TODO：给订阅者发送消息</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt;   m_subscribers;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="智能指针对象的大小">智能指针对象的大小</h4><p>一个 <strong>std::unique_ptr</strong> 对象大小与裸指针大小相同（即sizeof(std::unique_ptr<T>) == sizeof(void*)），而<strong>std::shared_ptr</strong> 的大小是<strong>std::unique_ptr</strong> 的两倍。以下是我分别在 Visual Studio2019 和 gcc/g++ 4.8 上（二者都编译成 x64 程序）的测试结果：</p><p><strong>测试代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp0;<br>    std::shared_ptr&lt;std::string&gt; sp1;<br>    sp1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>());<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp0 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp0) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp1) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp3) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Visual Studio 2019 运行结果：</p><p><img src="/img/C++/智能指针/sp1.webp" /></p><p>gcc/g++ 运行结果：</p><p><img src="/img/C++/智能指针/sp2.webp" /></p><p>在 32 位机器上，<strong>std_unique_ptr</strong> 占 4字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 8 字节；在 64 位机器上，<strong>std_unique_ptr</strong> 占 8字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 16 字节。也就是说，<strong>std_unique_ptr</strong>的大小总是和原始指针大小一样，<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong> 大小是原始指针的两倍。</p><h4 id="智能指针使用注意事项">智能指针使用注意事项</h4><p>C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++新标准中的各种智能指针是如此的实用与强大，在现代 C++项目开发中，读者应该尽量去使用它们。智能指针虽然好用，但稍不注意，也可能存在许多难以发现的bug，这里我根据经验总结了几条：</p><ul><li><p>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</p><p>看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-keyword">delete</span> pSubscriber;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针spSubscriber去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象<strong>spSubscriber</strong> 情何以堪啊？</p><p>记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。当然，除了<strong>std::weak_ptr</strong>，<strong>std::unique_ptr</strong> 和<strong>std::shared_ptr</strong>都提供了获取原始指针的方法——<strong>get()</strong> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span><br>  Subscriber* pTheSameSubscriber= spSubscriber.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分清楚场合应该使用哪种类型的智能指针；</p><p>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用<strong>std::unique_ptr</strong>，反之使用<strong>std::shared_ptr</strong>，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用<strong>std::weak_ptr</strong>。</p></li><li><p>认真考虑，避免操作某个引用资源已经释放的智能指针；</p><p>前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;T do something...&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> m_i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; sp2 = sp1;<br><br>  sp1.<span class="hljs-built_in">reset</span>();<br><br>  <span class="hljs-comment">//由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为</span><br>  sp2-&gt;<span class="hljs-built_in">doSomething</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即<strong>operator-&gt;</strong>）在内部会调用 <strong>get()</strong>方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用doSomething() 导致程序崩溃。</p><p>你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//连接断开</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MonitorServer::OnClose</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;TcpConnection&gt;&amp; conn)</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(m_sessionMutex)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = m_sessions.<span class="hljs-built_in">begin</span>(); iter != m_sessions.<span class="hljs-built_in">end</span>(); ++iter)<br>  &#123;<br>      <span class="hljs-comment">//通过比对connection对象找到对应的session</span><br>      <span class="hljs-keyword">if</span> ((*iter)-&gt;<span class="hljs-built_in">GetConnectionPtr</span>() == conn)<br>      &#123;<br>          m_sessions.<span class="hljs-built_in">erase</span>(iter);<br>          <span class="hljs-comment">//注意这里：程序在此处崩溃</span><br>          <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;monitor client disconnected: %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码不是我杜撰的，而是来自于我实际的一个商业项目中。注意代码中我提醒注意的地方，该段程序会在代码<strong>12</strong> 行处崩溃，崩溃原因是调用了<code>conn-&gt;peerAddress()</code>方法。为什么这个方法的调用可能会引起崩溃？现在可以一目了然地看出了吗？</p><p>崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个<strong>std::shared_ptr</strong> 的引用，当连接断开时，对应的TcpConnection 对象可能早已被销毁，而 conn引用就会变成空指针（严格来说是不再拥有一个 TcpConnection对象），此时调用 TcpConnection 的 peerAddress()方法就会产生和上一个示例一样的错误。</p></li><li><p>作为类成员变量时，应该优先使用前置声明（forwarddeclarations）</p><p>我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++项目中一般在 *.h文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:<br>  A*      m_pA;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:  <br>  std::unique_ptr&lt;A&gt;  m_spA;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>C++ 新标准中的智能指针我想介绍的就这么多了，Modern C/C++ 已经变为C/C++开发的趋势，希望读者能善用和熟练使用本节介绍的后三种智能指针对象。</p><p>转载自 <ahref="https://github.com/balloonwj/CppGuide/blob/master/articles/C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AF%A6%E8%A7%A3C++11%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md">详解C++11中的智能指针</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL 容器以及常用操作</title>
    <link href="/2023/03/02/CppSTL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/03/02/CppSTL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="vector容器">vector容器</h2><p>C++ STL vector是一个动态数组容器，它可以在运行时调整大小，并且支持随机访问。以下是vector 常用的基本操作：</p><h3 id="创建vector">创建vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;             <span class="hljs-comment">// 创建一个空 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size)</span></span>;       <span class="hljs-comment">// 创建一个大小为 size 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size, value)</span></span>;<span class="hljs-comment">// 创建一个大小为 size，并且所有元素都初始化为 value 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;        <span class="hljs-comment">// 创建一个副本 vector，v2 和 v1 中的元素相同</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v3 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 创建一个初始元素分别为1 2 3的vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3.begin() + <span class="hljs-number">1</span>, ilist.end() - <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 用v3的某个范围元素初始化v4</span><br></code></pre></td></tr></table></figure><h3 id="访问-vector-元素">访问 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index];                 <span class="hljs-comment">// 访问第 index 个元素</span><br>v.<span class="hljs-built_in">at</span>(index);              <span class="hljs-comment">// 访问第 index 个元素，并且进行边界检查</span><br>v.<span class="hljs-built_in">front</span>();                <span class="hljs-comment">// 访问第一个元素</span><br>v.<span class="hljs-built_in">back</span>();                 <span class="hljs-comment">// 访问最后一个元素</span><br>v.<span class="hljs-built_in">data</span>();                 <span class="hljs-comment">// 返回指向 vector 数据的指针</span><br></code></pre></td></tr></table></figure><h3 id="修改-vector-元素">修改 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index] = value;         <span class="hljs-comment">// 修改第 index 个元素为 value</span><br>v.<span class="hljs-built_in">at</span>(index) = value;      <span class="hljs-comment">// 修改第 index 个元素为 value，并且进行边界检查</span><br>v.<span class="hljs-built_in">emplace_back</span>(value);       <span class="hljs-comment">// 在 vector 的末尾插入一个元素</span><br>v.<span class="hljs-built_in">pop_back</span>();             <span class="hljs-comment">// 删除 vector 的末尾元素</span><br>v.<span class="hljs-built_in">insert</span>(iterator, value);<span class="hljs-comment">// 在 iterator 指定的位置插入 value</span><br>v.<span class="hljs-built_in">erase</span>(iterator);        <span class="hljs-comment">// 删除 iterator 指定的元素</span><br>v.<span class="hljs-built_in">clear</span>();                <span class="hljs-comment">// 删除 vector 中所有的元素</span><br>v.<span class="hljs-built_in">resize</span>(size);           <span class="hljs-comment">// 修改 vector 的大小为 size，如果原来的大小比 size 大，则删除后面的元素，否则增加默认值的元素</span><br>v.<span class="hljs-built_in">resize</span>(size, value);    <span class="hljs-comment">// 修改 vector 的大小为 size，并且用 value 进行初始化，如果原来的大小比 size 大，则删除后面的元素，否则增加 value 的元素</span><br></code></pre></td></tr></table></figure><h3 id="vector-容量操作">vector 容量操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v.<span class="hljs-built_in">size</span>();                 <span class="hljs-comment">// 返回 vector 中元素的个数</span><br>v.<span class="hljs-built_in">capacity</span>();             <span class="hljs-comment">// 返回 vector 可以存储的元素的数量，也就是预留的空间</span><br>v.<span class="hljs-built_in">empty</span>();                <span class="hljs-comment">// 如果 vector 为空，返回 true，否则返回 false</span><br>v.<span class="hljs-built_in">reserve</span>(capacity);      <span class="hljs-comment">// 预留 capacity 的存储空间</span><br>v.<span class="hljs-built_in">shrink_to_fit</span>();        <span class="hljs-comment">// 释放 vector 多余的存储空间</span><br></code></pre></td></tr></table></figure><h3 id="vector-遍历操作">vector 遍历操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="两个元素之间的范围">两个元素之间的范围</h3><p>我们知道，作用于同一容器的 2个同类型迭代器可以有效指定一个区间范围。在此基础上，如果想获取该指定范围内包含元素的个数，就可以借助distance() 函数。</p><p>distance()函数用于计算两个迭代器表示的范围内包含元素的个数，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>&gt;<br>  <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="hljs-function">difference_type <span class="hljs-title">distance</span> <span class="hljs-params">(InputIterator first, InputIterator last)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，first 和 last都为<strong>迭代器</strong>，其类型可以是输入迭代器、前向迭代器、双向迭代器以及随机访问迭代器；该函数会返回[first,last)范围内包含的元素的个数。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// distance</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span>         <span class="hljs-comment">// list</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">//创建一个空 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist;<br><span class="hljs-comment">//向空 list 容器中添加元素 0~9</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>mylist.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//指定 2 个双向迭代器，用于执行某个区间</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator first = mylist.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//指向元素 0</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator last = mylist.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//指向元素 9 之后的位置</span><br><span class="hljs-comment">//获取 [first,last) 范围内包含元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;distance() = &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(first, last);<br></code></pre></td></tr></table></figure><h3 id="查找某个值所在位置">查找某个值所在位置</h3><p>使用 std::find()方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-type">int</span> key = <span class="hljs-number">6</span>;<br> <br>    std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = std::<span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), key);<br> <br>    <span class="hljs-keyword">if</span> (itr != v.<span class="hljs-built_in">cend</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element present at index &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(v.<span class="hljs-built_in">begin</span>(), itr);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找最大元素和最小元素">查找最大元素和最小元素</h3><p><code>max_element()</code>函数是算法标头的库函数，用于查找范围中的最大元素，它接受容器范围[start，end]，并返回一个迭代器，该迭代器指向给定范围中具有最大值的元素。</p><p><strong>参数</strong>：</p><ul><li>iterator start, iterator end,容器开始和结束位置;</li><li>[compare comp]，可选参数，可以与给定范围内的元素进行比较。</li></ul><p><strong>返回值</strong>:</p><p>iterator -返回一个迭代器，该迭代器指向给定范围内具有最大值的元素。</p><p><code>min_element()</code>同理，参数用法也相同，不同的是它返回的是最小元素的迭代器。</p><h2 id="stack容器">stack容器</h2><p>C++ STL 标准库中的 stack是一个后进先出（LIFO）的容器适配器，它可以使用不同的底层容器（默认使用deque）实现。以下是 stack 常用的基本操作：</p><h3 id="创建-stack">创建 stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>std::stack&lt;<span class="hljs-type">int</span>&gt; s;       <span class="hljs-comment">// 创建一个空 stack</span><br><span class="hljs-function">std::stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;   <span class="hljs-comment">// 创建一个副本 stack，s1 和 s 中的元素相同</span><br>std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; s2; <span class="hljs-comment">// 创建一个底层容器为 vector 的 stack</span><br></code></pre></td></tr></table></figure><h3 id="stack-元素操作">stack 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">emplace</span>(value);       <span class="hljs-comment">// 将 value 压入 stack 顶部</span><br>s.<span class="hljs-built_in">pop</span>();                <span class="hljs-comment">// 弹出 stack 顶部的元素</span><br>s.<span class="hljs-built_in">top</span>();                <span class="hljs-comment">// 返回 stack 顶部的元素</span><br>s.<span class="hljs-built_in">empty</span>();              <span class="hljs-comment">// 如果 stack 为空，返回 true，否则返回 false</span><br>s.<span class="hljs-built_in">size</span>();               <span class="hljs-comment">// 返回 stack 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-stack">遍历 stack</h3><p>stack 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历stack。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = s.<span class="hljs-built_in">top</span>();<br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 stack 时，一定要判断 stack 是否为空，否则会发生undefined behavior。</p><h2 id="queue容器">queue容器</h2><p>C++ STL 标准库中的 queue是一个先进先出（FIFO）的容器适配器，它也可以使用不同的底层容器（默认使用deque）实现。以下是 queue 常用的基本操作：</p><h3 id="创建-queue">创建 queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;           <span class="hljs-comment">// 创建一个空 queue</span><br><span class="hljs-function">std::queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q1</span><span class="hljs-params">(q)</span></span>;       <span class="hljs-comment">// 创建一个副本 queue，q1 和 q 中的元素相同</span><br>std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q2;  <span class="hljs-comment">// 创建一个底层容器为 list 的 queue</span><br></code></pre></td></tr></table></figure><h3 id="queue-元素操作">queue 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">q.<span class="hljs-built_in">emplace</span>(value);           <span class="hljs-comment">// 将 value 插入 queue 尾部</span><br>q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-comment">// 弹出 queue 头部的元素</span><br>q.<span class="hljs-built_in">front</span>();                  <span class="hljs-comment">// 返回 queue 头部的元素</span><br>q.<span class="hljs-built_in">back</span>();                   <span class="hljs-comment">// 返回 queue 尾部的元素</span><br>q.<span class="hljs-built_in">empty</span>();                  <span class="hljs-comment">// 如果 queue 为空，返回 true，否则返回 false</span><br>q.<span class="hljs-built_in">size</span>();                   <span class="hljs-comment">// 返回 queue 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-queue">遍历 queue</h3><p>queue 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历queue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 queue 时，一定要判断 queue 是否为空，否则会发生undefined behavior。</p><h2 id="unordered_map容器">unordered_map容器</h2><p>unordered_map定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = std::hash&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Pred = std::equal_to&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, Ty&gt; &gt; &gt;<br>    <span class="hljs-keyword">class</span> unordered_map;<br>    &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">unordered_map</span><br></code></pre></td></tr></table></figure><ul><li><strong>第1个参数</strong>:存储key值。</li><li><strong>第2个参数</strong>:存储mapped value。</li><li><strong>第3个参数</strong>:为哈希函数的函数对象。它将key作为参数，并利用函数对象中的哈希函数返回类型为size_t的唯一哈希值。默认值为std::hash&lt;key &gt;。</li><li><strong>第4个参数</strong>:为等比函数的函数对象。它内部通过等比操作符’=='来判断两个key是否相等，返回值为bool类型。默认值是std::equal_to&lt;key &gt;。</li></ul><p>基本操作</p><h3 id="插入元素">插入元素</h3><p>一种插入的特殊情况是，unordered_map插入的<strong>值</strong>是int类型(key的类型无所谓)，这时候可以用第二种方式插入:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="删除元素">删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-comment">// 删除</span><br>    mymap.<span class="hljs-built_in">erase</span>(mymap.<span class="hljs-built_in">begin</span>());    <br>    mymap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>    mymap.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找元素">查找元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">if</span>(hash_map.<span class="hljs-built_in">find</span>(key) != hash_map.<span class="hljs-built_in">end</span>())       <span class="hljs-comment">// 查找</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;True&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;False&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="unordered_set容器">unordered_set容器</h2><p>C++ STL 中的 unordered_set是一个关联容器，它提供了一种存储唯一元素的无序集合。与 set不同，unordered_set内部的元素是无序的，因此在插入和查找时，它的性能通常比有序的关联容器 set更快。</p><p>以下是一些 unordered_set 的基本用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个 unordered_set 对象</span><br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 使用 find() 方法查找元素</span><br>    <span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (it != mySet.<span class="hljs-built_in">end</span>())<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 count() 方法检查元素是否在 unordered_set 中</span><br>    <span class="hljs-keyword">if</span> (mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">4</span>) &gt; <span class="hljs-number">0</span>) <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;4 is in the set&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历 unordered_set 中的所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; element : mySet)<br>        std::cout &lt;&lt; element &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Found <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the <span class="hljs-built_in">set</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在 unordered_set中，元素的顺序是不确定的，因此输出的结果可能与上面的示例不完全一致。</p><h2 id="stl中emplace和push的区别">STL中emplace和push的区别</h2><p>在 C++ STL 标准库中，容器中的 <code>emplace()</code> 和<code>push()</code>都可以用来向容器中添加新元素。但是它们的底层实现和作用不同。</p><h3 id="push">push()</h3><p><code>push()</code>是一个成员函数，用于将一个已经构造好的元素加入到容器的尾部，即将元素的副本或引用添加到容器中。因此，需要将元素先构造出来，再将其加入容器中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这里的 <code>push_back()</code> 函数首先构造了一个 int类型的元素，然后将其加入到了 vector 的尾部。</p><h3 id="emplace">emplace()</h3><p><code>emplace()</code>是一个可变参数模板函数，它在容器的尾部直接构造一个新的元素，而不需要将元素构造出来再加入容器。因此，它比<code>push()</code> 更加高效。</p><p>例如，对于 vector 容器来说，下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt; v;<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure><p>将直接在 vector 的尾部构造一个 <code>pair&lt;int, double&gt;</code>类型的元素，而不需要先构造一个 <code>pair&lt;int, double&gt;</code>对象，然后再将其加入到 vector 中。</p><h3 id="总结">总结</h3><ul><li><code>emplace()</code> 可以直接在容器中构造新的元素，而<code>push()</code> 需要先将元素构造出来，再加入到容器中。</li><li><code>emplace()</code> 更加高效，因为它省去了元素构造的过程，而<code>push()</code> 则需要先构造元素，再将其加入容器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉树">什么是二叉树</h2><p>二叉树是一种常见的数据结构，它是每个节点至多有两棵子树的树。</p><p>二叉树有两种特殊的形式，满二叉树和完全二叉树。</p><p><strong>满⼆叉树</strong>：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆叉树为满⼆叉树。一棵深度为k的满二叉树节点个数为<spanclass="math inline">\(2^k -1\)</span>。</p><p><strong>完全⼆叉树</strong>：至多只有最下面的两层结点的度数可以小于2,并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。</p><p><img src="/img/算法/二叉树/完全二叉树和满二叉树.png" /></p><p>我们可以看出满二叉树是完全二叉树， 但完全二叉树不一定是满二叉树。</p><h2 id="二叉搜索树二叉排序树">二叉搜索树（二叉排序树）</h2><p>二叉排序树虽然名叫排序树，但是它其实是用来搜索的，是一种有序的二叉树。它遵循着左小右大的规则：</p><ul><li>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；</li><li>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；</li><li>它的左、右⼦树也分别为⼆叉搜索树。</li></ul><p><img src="/img/算法/二叉树/二叉排序树.jpg" /></p><h2 id="平衡二叉树">平衡二叉树</h2><p>二叉搜索树有一个缺点，在插入数据是有序的序列（包括升序和降序），会导致二叉树退化成链表，从而导致在查找，删除，添加时的性能均从O（logN）降低为O（N），这是不能接受的。</p><p>究其原因，是因为二叉搜索树退化成链表的时候，树的高度与节点的个数相等，也就是成正比，所以为了优化这种情况，就出现了具有平衡能力的二叉搜索树，其中AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O（logN）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G.M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm forthe organization of information》中公开了这一数据结构。</p><p><strong>平衡二叉树的性质</strong></p><p>平衡二叉树本质上是特殊的二叉搜索树（二叉排序树），它具有二叉搜索树所有的特点，此外它有自己的特别的性质，如下：</p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>平衡二叉树的左右两个子树都是一棵平衡二叉树。</li></ul><p>平衡因子指的是，平衡二叉树在保持平衡的时候，是通过平衡因子来判断的</p><p><span class="math display">\[节点的平衡因子 = 该节点的左子树的高度 -该节点右子树的高度\]</span></p><p>只有当值等于-1（右子树的高度大），0（左右子树的高度相等），1（左子树的高度大）的时候，能够代表该子树是平衡的除此之外，就认为该节点已经失衡了，需要旋转来维持平衡。</p><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的遍历是对于理解二叉树以及应对二叉树问题必不可少的因素，甚至有很多算法问题都是基于二叉树的不同遍历算法来做的。</p><p>二叉树的遍历有多种实现方式，不同的方式这里都要熟练掌握，只有熟练掌握不同的遍历方式才能以不变应万变来应对不同的问题。</p><h3 id="递归法">递归法</h3><p>很简单，不需要多说，二叉树的前序、中序、后序遍历其实都是一个模板，区别在于它们将当前节点值添加到结果数组<code>res</code>的时间不一样，而这种区别是由不同遍历方式下父节点与子节点的遍历次序导致的。</p><h4 id="前序遍历">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">oreOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    res.<span class="hljs-built_in">emplace_back</span>(res -&gt; val, res);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; left);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">inOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; left, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历">后序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">postOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; left, res);<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; right, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="迭代法">迭代法</h3><h4 id="前序遍历-1">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历-1">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历-1">后序遍历</h4><p>迭代法的后序遍历相比较前序遍历和中序遍历是要麻烦一些的。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// stk.emplace(cur);</span><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; cur -&gt; right != pre)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);   <span class="hljs-comment">// 若右孩子存在且没有遍历过那么将cur重新压栈，访问右子树</span><br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            pre = cur;<br>            cur = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="morris法">Morris法</h3><p>Morris法只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979年的论文「Traversing Binary Trees Simply andCheaply」中首次提出，因此被称为 Morris 遍历。</p><h4 id="前序遍历-2">前序遍历</h4><p>Morris遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下（假设当前遍历到的节点为<code>cur</code>）:</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>,然后将<code>cur</code>加入答案。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树。<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>这样我们利用 Morris遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)      <span class="hljs-comment">// 左子节点为空直接将val加入res中</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;  <br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h4 id="中序遍历-2">中序遍历</h4><p>Morris法的中序遍历与前序遍历的思想是相同的，不同的是在当前节点的左孩子存在时的处理方式不同，思路如下（假设当前遍历到的节点为<code>cur</code>）：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空，然后将当<code>cur</code>加入答案。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root,* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左子节点为空直接遍历右子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            pre = cur -&gt; left;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>其中 <span class="math inline">\(n\)</span>为二叉搜索树的节点个数。Morris遍历中每个节点会被访问两次，因此总时间复杂度为 <spanclass="math inline">\(O(2n)=O(n)\)</span>。</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>。</li></ul><h4 id="后序遍历-2">后序遍历</h4><p>后续遍历思路依然同上，不同的仍然是把<code>cur</code>加入答案的时机，思路如下：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>        root = root -&gt; right;<br>        count++;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">end</span>() - count, res.<span class="hljs-built_in">end</span>());<br> &#125;<br><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br><br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左孩子不空寻找cur左子树的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">// 为空说明左子树尚未遍历，将pre的右孩子更新为cur</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明左子树已经遍历，将pre右孩子重新置空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-built_in">addPath</span>(res, cur -&gt; left);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左孩子为空直接访问右子树</span><br>            cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-built_in">addPath</span>(res, root); <span class="hljs-comment">// root节点没有parent，所以root需要单独addPath</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，所以由于root节点没有parent，最后要再单独对root节点调用<code>addPath</code>。</strong></p><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><p>上面这种解法是leetcode的官方解法，这里我还有另外一种思路，如上面所说，<strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，那么是否可以采用Morris的方法将输出顺序改为<code>cur</code>、<code>cur</code>的右孩子、<code>cur</code>的左孩子，在输出完之后再统一对<code>res</code>进行翻转？</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) <br>    &#123;<br>        <br>        pre = cur -&gt; right;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// cur右孩子为空，直接将cur加入答案并访问左子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则寻找 `父右左` 遍历模式下的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; left != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; left != cur)<br>                pre = pre -&gt; left;<br>            <span class="hljs-keyword">if</span>(pre -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 为空说明右子树尚未遍历</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; left = cur;<br>                cur = cur -&gt; right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;       <br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明右子树已经遍历</span><br>            &#123;<br>                pre -&gt; left = <span class="hljs-literal">nullptr</span>;<br>                cur = cur -&gt; left;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 翻转数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有右子树的节点只被访问一次，有右子树的节点被访问两次，最后翻转数组。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h2 id="二叉树问题的小trick">二叉树问题的小trick</h2><p>二叉树中有一类问题其实套路是固定的，虽然不同问题要求的东西不一样，但是仔细分析会发现，其实它们用到的套路是一样的。<strong>当一个问题的结果需要树的左右子树也满足条件，且每层子树需要返回的参数一样时，便可以用到递归套路。</strong></p><h3id="一棵子树上的点在深度优先搜索序列即先序遍历中是连续的">一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的</h3><p>可以采用这个套路来求解一个树是否是另一个树的子树，但是但从一个树<code>s</code>的dfs遍历是否是另一个树<code>t</code>的dfs遍历的字串并不能判断出是否是子树，所以想要通过dfs的序列判断s是否是t的子树，还需要做一些额外的处理。</p><p>可以通过引入两个空值 <code>lNull</code> 和<code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<code>s</code>的深度优先搜索序列包含<code>t</code>的深度优先搜索序列」来判断<code>s</code>是否是<code>t</code>的子树。</p><p>这里判断<code>s</code>的遍历序列是否是<code>t</code>遍历序列的子串可以用KMP算法或Rabin-Karp算法</p><h3 id="后序遍历迭代法">后序遍历迭代法</h3><p>采用迭代法的后序遍历，即上边用栈的方法，当遍历到节点 <spanclass="math inline">\(p\)</span> 时，栈中的节点刚好是 <spanclass="math inline">\(p\)</span>的祖先节点，所以此时将栈中节点依次弹出便得到 <spanclass="math inline">\(p\)</span> 的祖先节点的倒序。</p><h3 id="验证二叉搜索树">验证二叉搜索树</h3><p><strong>问题</strong>：给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>分析</strong>：如何判断一个二叉树是否是二叉搜索树？它需要满足两个条件：</p><ol type="1"><li>它的左子树和右子树都是二叉搜索树；</li><li>它的节点值大于左子树的最大值且小于右子树的最小值。</li></ol><p>那么从以上两点出发，就可以构造一个递归套路，每层需要向上层返回自己这颗树是否是二叉搜索树，如果不是那么整个树一定不是二叉搜索树；同时还要向上层返回自己这颗子树的最大值和最小值。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root, LONG_MIN, LONG_MAX);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBST</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= upper || root -&gt; val &lt;= lower)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root -&gt; left, lower, root -&gt; val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root -&gt; right, root -&gt; val, upper);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是反向思维，若<code>cur</code>的值需要大于左子树最大值并且小于右子树最小值，那么就等价于让它的左子树判断其最大值是否小于<code>cur</code>值以及<code>cur</code>右子树判断其最小值是否大于<code>cur</code>值.</p><h3 id="验证平衡二叉树">验证平衡二叉树</h3><p><strong>问题</strong>:给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p><strong>分析</strong>:一个二叉树是平衡二叉树,那么它必然满足它的左右子树都是平衡二叉树,且左右子树的高度差的绝对值不大于1.那么就又可以以相似的方式构造递归,每次需要向上层返回的参数有:</p><ul><li>当前子树是否是平衡二叉树</li><li>当前子树的深度</li></ul><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> is_balance;<br>    <span class="hljs-built_in">isBalancedTree</span>(root, is_balance, height);<br>    <span class="hljs-keyword">return</span> is_balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isBalancedTree</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">bool</span> &amp;is_balance, <span class="hljs-type">int</span> &amp;height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        is_balance = <span class="hljs-literal">true</span>;<br>        height = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">bool</span> left_balance, right_balance;<br>    <span class="hljs-type">int</span> left_height, right_height;<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; left, left_balance, left_height);<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; right, right_balance, right_height);<br>    <span class="hljs-keyword">if</span>(!left_balance || !right_balance || <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)<br>        is_balance = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        is_balance = <span class="hljs-literal">true</span>;<br>    height = <span class="hljs-built_in">max</span>(left_height, right_height) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全二叉树的第k个节点">完全二叉树的第k个节点</h3><p>规定根节点位于第 <span class="math inline">\(0\)</span>层，完全二叉树的最大层数为 <spanclass="math inline">\(h\)</span>。根据完全二叉树的特性可知，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数<span class="math inline">\(h\)</span>。</p><p>当 <span class="math inline">\(0 \le i &lt; h\)</span> 时，第 <spanclass="math inline">\(i\)</span> 层包含 <spanclass="math inline">\(2^i\)</span> 个节点，最底层包含的节点数最少为<span class="math inline">\(1\)</span>，最多为 <spanclass="math inline">\(2^h\)</span>。</p><p>因此对于最大层数为 hhh 的完全二叉树，节点个数一定在 <spanclass="math inline">\([2^h,2^{h+1}-1]\)</span>的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。</p><p>如何判断第 <span class="math inline">\(k\)</span>个节点是否存在呢？如果第 <span class="math inline">\(k\)</span>个节点位于第 <span class="math inline">\(h\)</span> 层，则 <spanclass="math inline">\(k\)</span> 的二进制表示包含 <spanclass="math inline">\(h+1\)</span> 位，其中最高位是 <spanclass="math inline">\(1\)</span>，其余各位从高到低表示从根节点到第 <spanclass="math inline">\(k\)</span> 个节点的路径，<spanclass="math inline">\(0\)</span> 表示移动到左子节点，<spanclass="math inline">\(1\)</span> 表示移动到右子节点。通过位运算得到第<span class="math inline">\(k\)</span>个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 <spanclass="math inline">\(k\)</span> 个节点是否存在。</p><p><img src="/img/算法/二叉树/完全二叉树第k个节点.png" /></p><p>那么如何依次判断k的各个二进制位是否为1呢？这里需要一个<spanclass="math inline">\(bits = 2^{h-1}\)</span>，<spanclass="math inline">\(h\)</span>为要查找节点所在层数(注意根节点是0层),比如现在要查找<spanclass="math inline">\(8\)</span>这个节点，那么<spanclass="math inline">\(bits = 2^{3 - 1} = 0100\)</span>,而<spanclass="math inline">\(8\)</span>的二进制表示是<spanclass="math inline">\(1000\)</span>,用<spanclass="math inline">\(bits\)</span> &amp; <spanclass="math inline">\(1000 = 0\)</span>，所以向左子树走，然后将<spanclass="math inline">\(bits\)</span>左移一位，再与<spanclass="math inline">\(8\)</span>（也就是<spanclass="math inline">\(1000\)</span>）相与得到<spanclass="math inline">\(0010 \&amp; 1000 =0\)</span>,继续向左子树移动，重复上面操作，一直到<spanclass="math inline">\(bits\)</span>为<spanclass="math inline">\(0\)</span>为止，此时节点若不为空，那么就是第<spanclass="math inline">\(8\)</span>个节点。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL-unordered_map中自定义哈希函数</title>
    <link href="/2023/02/24/Cpp-STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2023/02/24/Cpp-STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2id="unordered_map中自定义哈希函数">unordered_map中自定义哈希函数</h2><p>内容转载自<ahref="https://blog.csdn.net/qq_34525916/article/details/115896842">c++unordered_set，unordered_map中自定义哈希函数</a></p><p>如果想用哈希的时候，但是哈希的目标又不再STL标准的类型内，比如一个自定义的class，就不太方便使用STL默认的哈希函数，比较函数，那么就需要重写了。</p><p><strong>将自定义类型作为unordered_map的键值，需如下两个步骤</strong>：</p><ol type="1"><li>定义自定义key的哈希函数的函数对象，告知此容器如何生成hash的值；</li><li>定义等比函数的函数对象或者在自定义类里重载operator==()，告知容器当出现hash冲突的时候，如何区分hash值相同的不同对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">Line</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2)&#123;<br>       k = d1;<br>       b = d2;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Line&amp; other)<span class="hljs-type">const</span>&#123;<span class="hljs-comment">//重载operator==(),若没有重载==则定义 unordered_map 时需要isEqual</span><br>        <span class="hljs-keyword">return</span> other.k ==k &amp;&amp; other.b == b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">createhash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span>  Line l)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// size_t</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//return size_t(l.k ^ l.b);//自定义哈希</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.k) ^  <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.b);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">isEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span> Line l1, <span class="hljs-type">const</span> Line l2)</span> <span class="hljs-type">const</span><span class="hljs-comment">//最后的const不能少</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//unordered_map&lt;Line ,int , createhash, isEqual&gt; mm;//若使用这种方式,Line类中不需要重载==</span><br>    unordered_map&lt;Line ,<span class="hljs-type">int</span> , createhash&gt; mm; <br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">1</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">auto</span> success = mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">if</span>(success.second == <span class="hljs-literal">false</span>)<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;mm insert failed &quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : mm)<br>    &#123;<br>        std::cout&lt;&lt; ele.first.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.first.b&lt;&lt;std::endl; <br><br>    &#125;<br><br>    <span class="hljs-comment">//unordered_set&lt;Line, createhash&gt; ms;</span><br>    unordered_set&lt;Line, createhash, isEqual&gt; ms;<span class="hljs-comment">//若使用这种方式,Line类中不需要重载==</span><br>    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">auto</span> it = ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">if</span>(it.second == <span class="hljs-literal">false</span>)<br>       std::cout&lt;&lt;<span class="hljs-string">&quot;ms insert failed &quot;</span>&lt;&lt;std::endl; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : ms)<br>    &#123;<br>        std::cout&lt;&lt; ele.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.b&lt;&lt;std::endl; <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表内部传递方式和内存占用">哈希表内部传递方式和内存占用</h3><ol type="1"><li>放入哈希表的key，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。</li><li>放入哈希表的key，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ lambda函数用法</title>
    <link href="/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Lambda表达式（也叫lambda函数，或简称lambda），是从C++11开始引入并不断完善的，是能够捕获作用域中变量的匿名函数对象。因为C++是不能嵌套定义函数的，所以lambda就成了我们构造闭包的主要手段，不过在对象的生命周期上还是有点不同。</p><h2 id="lambda基本语法">Lambda基本语法</h2><figure><img src="/img/C++/lambda/lambda基本语法.png" alt="lambda基本语法" /><figcaption aria-hidden="true">lambda基本语法</figcaption></figure><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。下面对重要的组成部分进行说明：</p><h3 id="捕获列表">捕获列表</h3><p><strong>值捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=100,因为i是创建时拷贝的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [&amp;i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=0, 因为传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（隐式捕获），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p><p><strong>lambda捕获列表：</strong></p><ul><li>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</li><li>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>[this]。函数体内可以使用Lambda所在类中的成员变量。</li><li>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>[&amp;a]。将a按引用进行传递。</li><li>[=，&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>悬垂引用：</strong></p><p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p><h3 id="形参列表">形参列表</h3><p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C++14前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C++14起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> &amp;b) &#123;<br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//输出：10  20</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(i,j);<br><span class="hljs-comment">//输出：1 20</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>) &#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">f</span>(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明符">说明符</h3><ul><li>mutable：允许函数体修改各个复制捕获的对象，以及调用其非 const成员函数;</li><li>constexpr：显式指定函数调用运算符为 constexpr函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr函数的所有要求，则它也会是 constexpr； (C++17 起)</li><li>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和constexpr。(C++20 起)</li></ul><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span><br><span class="hljs-keyword">auto</span> f = [i, &amp;j]() <span class="hljs-keyword">mutable</span> &#123;<br>i = <span class="hljs-number">100</span>, j = <span class="hljs-number">100</span>;<br>&#125;;<br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//输出:0 100</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回类型--">返回类型 -&gt;</h3><p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的return语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = []() -&gt; <span class="hljs-type">double</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p><h3 id="函数体">函数体 <span class="math inline">\(\{ \}\)</span></h3><p>略，同普通函数的函数体。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::accumulate函数用法</title>
    <link href="/2023/02/24/Cpp-accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/Cpp-accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>accumulate定义在#include<numeric>中，有两种用法，一个是累加求和，另一个是自定义类型数据的处理</p><h2 id="默认累加求和">默认累加求和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="自定义对数据的处理">自定义对数据的处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> BinaryOperation &gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init,</span></span><br><span class="hljs-params"><span class="hljs-function">                        BinaryOperation op )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><p><strong>first, last</strong>: 要求和的元素范围</p><p><strong>init</strong>：和的初值</p><p><strong>op</strong>:被使用的二元函数对象。接收当前积累值 a （初始化为init ）和当前元素 b 的二元运算符。</p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// accumulate example</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">// std::minus</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>      <span class="hljs-comment">// std::accumulate</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">2</span>*y;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myclass</span> &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>*y;&#125;<br>&#125; myobject;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> init = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> numbers[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using default accumulate: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers,numbers+<span class="hljs-number">3</span>,init);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using functional minus: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom function: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers, numbers + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, [](<span class="hljs-type">int</span> a, Grade b)&#123;<span class="hljs-keyword">return</span> a + b * <span class="hljs-number">2</span>; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom object: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, myobject);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">using</span> <span class="hljs-keyword">default</span> accumulate: <span class="hljs-number">160</span><br><span class="hljs-keyword">using</span> functional minus: <span class="hljs-number">40</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-keyword">function</span>: <span class="hljs-number">120</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-type">object</span>: <span class="hljs-number">280</span><br></code></pre></td></tr></table></figure><p>转载自<ahref="https://blog.csdn.net/gongjianbo1992/article/details/105128849">C++Lambda表达式的基本使用</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中数学公式换行问题</title>
    <link href="/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-书写-latex-公式时的一些问题及解决方法">Hexo 书写 LaTeX公式时的一些问题及解决方法</h2><p>使用hexo撰写博客的时候难免会用到数学公式，，如果公式过长，我们通常希望把方程分成多行显示，这时候就需要用到换行符号<code>\\</code>，但是写出来的Markdown 经过 Hexo 的处理以后显示不正确，这与 Hexo的渲染引擎有关系。</p><p>Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax支持，因此首先要启用 MathJax 才能渲染 LaTeX公式.但是它并不支持MathJax换行，这是因为我们的markdown文件首先会被hexo-theme-marked的marked.js解析，这就会使得使用Latex语法所写的MathJax公式中的_和，最后轮到MathJax来对公式进行解析就出错了。</p><h3 id="安装hexo-renderer-pandoc">安装hexo-renderer-pandoc</h3><p>为了使用pandoc作为Hexo的渲染引擎，我们需要安装插件hexo-renderer-pandoc，步骤如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载默认渲染插件</span><br><span class="hljs-built_in">npm</span> install hexo-renderer-pandoc --svae <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p>但是在安装pandoc之后发现，公式中使用<code>\\</code>仍然不能换行，经过一番折腾之后发现了一个曲线救国的方法：在需要换行的公式加上align对齐：</p><p>例如</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>在显示的时候会发现并没有换行</p><p><img src="/img/latex/错误用法.png" /></p><p>而加上aligin之后就可以正常换行</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br><span class="hljs-built_in">&amp;</span>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> <span class="hljs-built_in">&amp;</span>B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]  <br><span class="hljs-keyword">\end</span>&#123;align&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p><img src="/img/latex/正确用法.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的随机过程</title>
    <link href="/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="正态过程">正态过程</h2><h3id="多维正态分布的概率密度和特征函数">多维正态分布的概率密度和特征函数</h3><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数.png" /></p><p>记 <imgsrc="/img/随机过程/常见随机过程/正态概率密度符号替换.png" /></p><p>则<span class="math inline">\((X,Y)\)</span>的联合概率密度为</p><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-新.png" /><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-注.png" /></p><h3 id="证明随机过程xt是正态过程">证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程</h3><p>要证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程，即证对<spanclass="math inline">\(\forall t_1,t_2,\dots\)</span> , <spanclass="math inline">\(t_n，(X(t_1),X(t_2),\dots,X(t_n))\)</span>是<spanclass="math inline">\(n\)</span>维正态分布。</p><h4 id="方法1用特征函数">方法1：用特征函数</h4><h4 id="方法2正态分布的线性不变性">方法2：正态分布的线性不变性</h4><p><strong>正态分布的线性不变性</strong>:</p><p><img src="/img/随机过程/常见随机过程/正态分布线性不变性.png" /></p><p><strong>正态分布的线性变换不变性</strong>:</p><p><imgsrc="/img/随机过程/常见随机过程/正态分布的线性变换不变性.png" /></p><h2 id="维纳过程">维纳过程</h2><p><img src="/img/随机过程/常见随机过程/维纳过程条件.png" /> <imgsrc="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><h3 id="维纳过程的分布">维纳过程的分布</h3><p><img src="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><p>设<span class="math inline">\(t&gt;s\)</span>，因<spanclass="math inline">\(W(0)=0\)</span>,且<spanclass="math inline">\(W(t)\)</span>是平稳独立增量过程，故</p><p><span class="math display">\[W(t) - W(s) = W(t-s+s)-W(s)\]</span></p><p>与</p><p><span class="math display">\[W(t-s) - W(0) = W(t-s)\]</span>有相同分布<span class="math inline">\(N(0,\sigma^2 (t-s))\)</span>。</p><p><strong>维纳过程是正态过程</strong>。</p><h3 id="维纳过程的数字特征">维纳过程的数字特征</h3><p><strong>维纳过程是平稳独立增量过程</strong>，其数字特征如下。</p><p><img src="/img/随机过程/常见随机过程/维纳过程的数字特征.png" /></p><h2 id="计数过程和泊松过程">计数过程和泊松过程</h2><h3 id="定义">定义</h3><p><strong>计数过程</strong>：</p><p><img src="/img/随机过程/常见随机过程/计数过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/计数过程定义2.png" /></p><p><strong>Poisson过程是一类很重要的计数过程</strong>。</p><p><strong>Poisson过程数学模型</strong>：</p><p><img src="/img/随机过程/常见随机过程/泊松过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程定义2.png" /></p><h3 id="齐次泊松过程">齐次泊松过程</h3><p><img src="/img/随机过程/常见随机过程/齐次泊松过程定义.png" /></p><h3 id="泊松过程的等价定义">泊松过程的等价定义</h3><p><img src="/img/随机过程/常见随机过程/泊松过程等价定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程等价定义2.png" /></p><h3 id="齐次泊松过程的有关结论">齐次泊松过程的有关结论</h3><h4 id="数字特征">数字特征</h4><p><strong>均值函数</strong>： <spanclass="math inline">\(m(t)=E\{N(t)\}=\lambda t\)</span></p><p><strong>方差函数</strong>: <span class="math inline">\(D(t)=\lambdat\)</span></p><p><strong>协方差函数</strong>: <spanclass="math inline">\(C(s,t)=\lambda min(s,t)\)</span></p><p><strong>相关函数</strong>： <spanclass="math inline">\(R(s,t)=\lambda min(s,t)+\lambda^2 st\)</span></p><p>故有<spanclass="math inline">\(\lambda=\frac{E\{N(t)\}}{t}\)</span>,称<spanclass="math inline">\(\lambda\)</span>为<strong>事件的到达率</strong>或<strong>单位时间内事件出现的平均次数</strong>。</p><h3 id="时间间隔与等待时间的分布">时间间隔与等待时间的分布</h3><p>如下图所示，<spanclass="math inline">\(N(t)\)</span>是轨道是跃度为<spanclass="math inline">\(1\)</span>的阶梯函数。</p><p><img src="/img/随机过程/常见随机过程/N（t）的分布函数.png" /></p><p>用<span class="math inline">\(T_n\)</span>表示事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n-1\)</span>次出现与第<spanclass="math inline">\(n\)</span>次出现的时间间隔。<spanclass="math inline">\(W_n\)</span>为事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n\)</span>次出现的<strong>等待时间(到达时间)</strong>，则有：</p><p><span class="math display">\[W_n=\sum\limits_{i=1}^nT_i\]</span></p><p>和</p><p><span class="math display">\[T_n=W_n - W_{n-1}\]</span></p><p><img src="/img/随机过程/常见随机过程/时间间隔序列分布定理.png" /></p><h3 id="到达时间的条件分布">到达时间的条件分布</h3><p><img src="/img/随机过程/常见随机过程/引理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理2.png" /> <imgsrc="/img/随机过程/常见随机过程/注1.png" /> <imgsrc="/img/随机过程/常见随机过程/注2.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性空间</title>
    <link href="/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="线性空间">线性空间</h2><p><strong>线性空间定义</strong>： <imgsrc="/img/矩阵论/线性空间/线性空间定义.jpg" /></p><p><strong>线性子空间定义</strong>：</p><p><img src="/img/矩阵论/线性空间/线性子空间定义.png" /></p><p><strong>平凡子空间</strong>：<spanclass="math inline">\(V\)</span>空间的平凡子空间指<spanclass="math inline">\(0\)</span>空间和<spanclass="math inline">\(V\)</span>空间本身，其他维数的空间都是非平凡子空间。</p><p><strong>线性空间的和</strong>：</p><p><img src="/img/矩阵论/线性空间/线性空间的和.jpg" /></p><h3 id="维数定理">维数定理</h3><p><img src="/img/矩阵论/线性空间/维数定理.png" /></p><h3 id="直和">直和</h3><p><img src="/img/矩阵论/线性空间/直和定义.png" /></p><h4id="判断线性空间v的两个子空间v_1和v_2是否是直和的方法">判断线性空间V的两个子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>是否是直和的方法</h4><p>判断<span class="math inline">\(V_1 \cap V_2 =\{0\}\)</span>是否成立，若成立，就是直和；否则不是直和。</p><p>将子空间的概念推广到多个子空间，于是在多个子空间中就可以定义这样的直和关系：</p><p><img src="/img/矩阵论/线性空间/多个子空间的直和.jpg" /></p><h3 id="酉空间">酉空间</h3><p>欧几里得空间：定义了内积的实线性空间。</p><p>欧几里得空间的定义推广到复线性空间就是酉空间。</p><h3 id="正交补子空间">正交补子空间</h3><p><img src="/img/矩阵论/线性空间/正交补子空间定义.png" /></p><p>这里的<spanclass="math inline">\(V_n(C)\)</span>指的是酉空间。这里的<spanclass="math inline">\(n\)</span>表示维数，<spanclass="math inline">\(C\)</span>表示复数空间。这个定义指的是复数域内的<spanclass="math inline">\(n\)</span>维空间，即是酉空间。</p><p>也就是说，一个空间V的子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>不仅要满足直和的关系，还要相互正交。<strong>这样的空间我们称<spanclass="math inline">\(V_2\)</span>为<spanclass="math inline">\(V_1\)</span>的正交补子空间（或简称正交补）</strong>。显然，二者是互为正交补的。<strong>正交补分解实际上就是在分正交基。直和分解实际上就是在分解基向量</strong>。</p><p><strong>定理</strong>：<spanclass="math inline">\(V_n(C)\)</span>的任意子空间<spanclass="math inline">\(V_1\)</span>都有唯一的正交补。</p><h3 id="kronecker积">Kronecker积</h3><h4 id="kronecker积-1">Kronecker积</h4><p><img src="/img/矩阵论/线性空间/Kronecker积.png" /></p><p>其中<span class="math inline">\(a_{ij}\)</span>为矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列的元素，对于<spanclass="math inline">\(A \in \mathbb{R^{m × n}}\)</span> 和 <spanclass="math inline">\(B \in \mathbb{R^{p × q}}\)</span>,<spanclass="math inline">\(A \otimes B \in \mathbb{R^{(mp) ×(nq)}}\)</span>。</p><p><strong>Kronecker积的性质如下</strong>：</p><p><img src="/img/矩阵论/线性空间/Kronecker积性质1.png" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质2.jpg" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质3.png" /></p><p>这些性质中前4条与矩阵运算完全相同，从第5条开始是Kronecker积独有的性质。</p><p>给出一些定义和定理：</p><p><img src="/img/矩阵论/线性空间/Kronecker积定理.jpg" /></p><p>Kronecker积的特征值：</p><p><img src="/img/矩阵论/线性空间/Kronecker积的特征值.jpg" /></p><h4 id="kronecker和">Kronecker和</h4><p><img src="/img/矩阵论/线性空间/Kronecker和.jpg" /></p><p>由定义2我们可以看到，对于Kronecker积而言，m阶矩阵和n阶矩阵之间是无法直接求和的，所以，我们通过对单位阵的Kronecker积运算，同时把他们化为<spanclass="math inline">\((m ×n)\)</span>阶方阵，这样就可以对矩阵进行求和运算了。</p><h4 id="向量化算符">向量化算符</h4><p><img src="/img/矩阵论/线性空间/向量化算符.png" /></p><p>性质：</p><p><img src="/img/矩阵论/线性空间/向量化算符性质.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题的一些心得</title>
    <link href="/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>记录一下在刷题的时候的一些小trick以及踩的一些坑。</p><!-- ### string.size()`string.size()`返回的是一个无符号数，所以在循环中如果需要对使用`s.size()`的话，需要使用`(int)s.size()`。 --><h2 id="滑动窗口">滑动窗口</h2><p>滑动窗口就是<strong>不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。它通常用于字符串或者数组特定长度下内容是否相同，也可以查找在内容相同情况下的最短长度(一般来说需要查找的数组或者字符串是连续的)。</p><h2 id="时间复杂度master公式">时间复杂度（Master公式）</h2><p>若有<span class="math inline">\(T(N)=a * T(\frac{N}{b})+O(N^d)\)</span>，则说明这个算法满足<strong>Master公式</strong>。也就是说只要是<strong>满足子问题等规模的递归都可以用Master公式</strong>。a，b，d的值可能会有三种情况。</p><ol type="1"><li><span class="math inline">\(\log_b a &lt;d\)</span>,则算法时间复杂度为<spanclass="math inline">\(O(N^d)\)</span>。</li><li><span class="math inline">\(\log_b a &gt;d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^{\log_ba})\)</span>。</li><li><span class="math inline">\(\log_b a =d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^d * \logn)\)</span>。</li></ol><h2 id="链表">链表</h2><h3 id="重要技巧">重要技巧</h3><h4 id="额外数据结构记录哈希表等">额外数据结构记录（哈希表等）</h4><p>此技巧一般只适用于笔试做题，面试一般不适用。</p><p>设置额外的数据结构，比如数组、哈希表或者栈等来辅助做题。</p><h4 id="快慢指针">快慢指针</h4><p>有一些问题诸如寻找链表的中点，最简单暴力的方法是遍历一遍链表然后得到链表长度，然后根据长度得到其最中间的节点。这样做有一个问题，就是需要遍历一遍半的链表。而使用快慢指针就可以少遍历一遍链表。</p><p>它的思想是设置一个<code>fast</code>节点和一个<code>slow</code>节点，每次<code>fast</code>节点往后走两步，而<code>slow</code>节点往后走一步。这样当<code>fast</code>节点走完整个链表的时候，<code>slow</code>节点就在链表的中间。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点。偶数长度返回上中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">nullptr</span>)<br>            fast = fast -&gt; next;<br>      <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>&#125;<br></code></pre></td></tr></table></figure><p>需要特别注意的是，<strong>不要死记这代码，实际上在做题或者应用中的不同情况是是有很多细微的差别的，比如若链表长度是偶数，有的时候需要中间靠前的节点，有的时候需要中间靠后的节点，还有的时候需要中间靠前节点的前驱节点，不同情况要做对应的调整，同时还要注意边界条件，比如节点为空或者只有一个节点的情况。</strong></p><p>链表长度为偶数情况下，寻找中间靠后的那个节点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点，偶数长度返回下中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>      fast = fast -&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><!-- - 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点后一个 --><h3 id="面试时链表解题方法论">面试时链表解题方法论</h3><ol type="1"><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。比如可以直接把链表copy到数组。</li><li>对于面试，时间复杂度仍然放在第一位，但是要找到空间复杂度最省的方法。</li></ol><h2 id="打表法">打表法</h2><p>在刷题过程中经常会遇到一类题，这类题的特点是：<strong>输入简单，可能是一个或几个数或数组，输出也简单，可能只让你返回一个整形的结果。</strong>当然，一般的方法是根据题目的要求编写对应的算法求解。但是有时候这种方法并不那么容易实现或者并不那么容易想，这个时候可以考虑一种比较取巧的方法：打表法。</p><p>打表法就是用暴力方法先求出前面几十个或一百个解，从中找出其规律，然后根据规律直接编写对应方法求解。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平稳过程</title>
    <link href="/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="严平稳过程">严平稳过程</h2><p><img src="/img/随机过程/平稳过程/严平稳过程定义.png" /> <imgsrc="/img/随机过程/平稳过程/严平稳过程定义-2.png"alt="严平稳过程定义" /></p><p>严平稳过程有限维分布不随时间的推移而改变，，它的当前变化情况与过去的情况有不可忽视的联系。</p><p>严平稳过程的一维分布与时间无关，而二维分布仅与<spanclass="math inline">\(t_1\)</span>和<spanclass="math inline">\(t_2\)</span>的时间间隔有关，与时间起点无关。</p><h2 id="宽平稳过程">宽平稳过程</h2><p>由于</p><ul><li>工程中确定一个过程的有限维分布函数族,进而判定过程的严平稳性十分困难；</li><li>部分随机过程(如正态过程)的概率特征主要由一阶和二阶矩函数确定；</li><li>工程实际中,通常仅需在相关理论范畴内考虑平稳过程,即只限于研究一、二阶矩（均值、相关函数等）理论.</li></ul><p>所以有了宽平稳过程。</p><p>定义： <img src="/img/随机过程/平稳过程/宽平稳过程定义.png"alt="宽平稳过程定义" /></p><p>其中<span class="math inline">\(R_x(\tau)\)</span>为<spanclass="math inline">\(\{X(t),t \inT\}\)</span>的自相关函数。其协方差函数为 <spanclass="math display">\[C_X(s,t)=R_X(s,t)-|m_X|^2=R_X(\tau)-|m_X|^2\]</span></p><p>自协方差函数与自相关函数都仅依赖于<spanclass="math inline">\(t－s\)</span></p><p><strong>维纳过程不是宽平稳过程，但是维纳过程是增量宽平稳过程，即</strong><span class="math display">\[X(t)=W(t+a)-W(t), t \ge 0, \quad(a&gt;0)\]</span></p><p>是宽平稳过程</p><h2 id="两种平稳性的关系">两种平稳性的关系</h2><ul><li>严平稳过程不一定是宽平稳的;</li></ul><p>因宽平稳过程一定是二阶矩过程, 而严平稳过程未必是二阶矩过程.</p><ul><li>宽平稳不一定 严平稳;</li><li>严平稳过程是宽平稳过程的充要条件是其二阶矩存在.</li><li>对于正态过程, 宽平稳性与严平稳性等价.</li></ul><h2 id="平稳过程的自相关函数">平稳过程的自相关函数</h2><p><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-1.png" /><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-2.png" /></p><p>证明:</p><ol type="1"><li><img src="/img/随机过程/平稳过程/自相关证明1.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明2.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明3.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明4.png" /></li></ol><p>推论： <img src="/img/随机过程/平稳过程/自相关函数推论.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.2.png" /></p><p>证明： <img src="/img/随机过程/平稳过程/5.2.2证明.png" /></p><p>定理: <img src="/img/随机过程/平稳过程/定理5.2.3.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.4.png" /></p><p>推论： <img src="/img/随机过程/平稳过程/定理5.2.4推论1.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广义逆矩阵</title>
    <link href="/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="单边逆">单边逆</h2><p>所谓矩阵的单边逆就是指矩阵的左逆和右逆。</p><figure><img src="/img/矩阵论/单边逆定义.png" alt="矩阵的单边逆" /><figcaption aria-hidden="true">矩阵的单边逆</figcaption></figure><p><strong>定理1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(A\)</span>为列满秩矩阵</li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(A\)</span>为行满秩矩阵</li></ul><p><strong>推论1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(N(A)=\{0\}\)</span></li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(R(A)=\mathbb{C}^m\)</span></li></ul><h3 id="单边逆的求法">单边逆的求法</h3><p><strong>例1</strong>: <img src="/img/矩阵论/例1-1.png" /> <imgsrc="/img/矩阵论/例1-2.png" /></p><p><strong>例2</strong>: <img src="/img/矩阵论/例2-1.png" /> <imgsrc="/img/矩阵论/例2-2.png" /></p><p>需要注意的是例1求左逆矩阵进行的是初等行变换,例2求右逆矩阵是进行的初等列变换，初等行变换我们在线性代数中常用，比较熟悉，但是要求右逆矩阵一定要进行初等列变换。</p><h2 id="广义逆矩阵">广义逆矩阵</h2><p><strong>定义</strong>: <img src="/img/矩阵论/广义逆定义.png" /></p><p><strong>性质</strong>: <img src="/img/矩阵论/广义逆定理1.png" /></p><p>推论: <img src="/img/矩阵论/广义逆推论1.png" /></p><p>需要注意的是，同线性代数中的矩阵的逆不同的是，这里求的广义逆一般不唯一。既然不唯一，有许多解的话，我们就考虑是否有一个通解可以将所有的广义逆全部表示呢？的确有，下面我们就介绍定理2，该定理表示的就是全部的广义逆：</p><p><img src="/img/矩阵论/全部广义逆集合定义.png" /></p><p><strong>定理2</strong>(不常考): <imgsrc="/img/矩阵论/广义逆定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆定理2-2.png" /></p><p><strong>定理3</strong>: <img src="/img/矩阵论/广义逆定理3-1.png" /><img src="/img/矩阵论/广义逆定理3-2.png" /></p><ul><li>(i)是逆矩阵性质在广义逆的推广</li><li>(ii)说的是一个矩阵乘以他的广义矩阵是幂等矩阵，且他们矩阵的秩相等</li><li>(iii)可以看出0矩阵的广义逆矩阵可以是任何矩阵（包括0矩阵）</li><li>(v)说的是<span class="math inline">\(AA^{-1}\)</span>与<spanclass="math inline">\(A\)</span>的值域相同,<spanclass="math inline">\(A^{-1}A\)</span>与<spanclass="math inline">\(A\)</span>的零空间相同,证明如下:</li></ul><p><img src="/img/矩阵论/定理3(v)证明.png" /></p><h2 id="自反广义逆矩阵">自反广义逆矩阵</h2><p>自反广义逆矩阵是广义逆矩阵里的一类特殊矩阵,其定义如下: <imgsrc="/img/矩阵论/自反广义逆矩阵定义.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/自反广义逆矩阵定理1.png" /></p><p>需要注意的是，自反广义逆矩阵并不唯一。事实上，对于 <imgsrc="/img/矩阵论/广义逆矩阵/图1.png" /></p><p>构造这样的矩阵 <img src="/img/矩阵论/广义逆矩阵/图2.png" /></p><p>所有满足这样条件的矩阵G，就是A的自反广义逆。所以自反广义逆并不唯一.</p><p><strong>定理2</strong>(考试不要求): <imgsrc="/img/矩阵论/广义逆矩阵/定理2.png" /></p><p>定理2给出了自反广义逆矩阵的一种具体的构造方法,</p><p><strong>定理3</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/定理3.png" /></p><p>定理3给出了在广义逆矩阵中，区分自反广义逆的一种有效方法。当广义逆矩阵的秩等于矩阵A的秩的时候是自反广义逆。当广义逆的秩大于矩阵A的秩的时候是广义逆矩阵而不是自反广义逆矩阵。</p><h2 id="m-p广义逆矩阵">M-P广义逆矩阵</h2><p>M-P广义逆矩阵（Moore-Penrose）矩阵是在自反广义逆矩阵之上又加了两个条件形成的矩阵，要求更加苛刻。我们一般用<span class="math inline">\(A^+\)</span> 来表示M-P广义逆矩阵。 <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定义.png" /></p><p>这四个条件，共同保证了 <span class="math inline">\(A^+\)</span>的<strong>唯一性</strong>。</p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理1.png" /></p><p>该定理给出了<span class="math inline">\(A^+\)</span>的具体计算方法。定理的证明直接用该式子验证定义中的四个式子即可.</p><p><strong>定理2</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则 <spanclass="math inline">\(A^+\)</span>是唯一的.</p><p>这一点已经在上面提到过了,定义中的四个式子保证了<spanclass="math inline">\(A^+\)</span>的唯一.</p><h3 id="m-p广义逆的性质">M-P广义逆的性质</h3><p><img src="/img/矩阵论/广义逆矩阵/M-P广义逆定理3.png" /></p><p><strong>定理5</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理5.png" /></p><h3 id="m-p广义逆的计算">M-P广义逆的计算</h3><h4 id="最大秩分解">最大秩分解</h4><p><img src="/img/矩阵论/广义逆矩阵/引理1.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆的计算定理1.png" /></p><p><strong>例1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-2.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-3.png" /></p><h4 id="奇异值分解法">奇异值分解法</h4><p><strong>定理2</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-2.png" /></p><h3 id="m-p广义逆的应用">M-P广义逆的应用</h3><h4 id="判断方程有没有解">判断方程有没有解</h4><p>求出<span class="math inline">\(A^+\)</span>,判断<spanclass="math inline">\(AA^+b\)</span>是否等于<spanclass="math inline">\(b\)</span>,若不等于则没有解，否则有解。</p><h4id="求方程的最佳逼近解最小范数解最小二乘解">求方程的最佳逼近解/最小范数解/最小二乘解</h4><p>当方程有解的时候，可以求得最小范数解为<spanclass="math inline">\(A^+b\)</span>；当方程没有解的时候，可以求出最佳逼近解为<spanclass="math inline">\(A^+b\)</span>，最小二乘通解为<spanclass="math inline">\(A^+ b+(I-A^+ A)u, \forall u \in\mathbb{C}^n\)</span>,其中<span class="math inline">\(A\)</span>为<spanclass="math inline">\(n\)</span>阶矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    <url>/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"> --><h2id="三角分解qr分解需要是非奇异矩阵">三角分解(QR分解)(需要是非奇异矩阵)</h2><h3id="正交三角分解通过schmidt正交化">正交三角分解(通过Schmidt正交化)</h3><p>若 <span class="math inline">\(n\)</span> 阶实矩阵 <spanclass="math inline">\(A\in \mathbb {C}^{n\times n}\)</span> 满秩，且<span class="math display">\[A = [\alpha_1,...,\alpha_n]\]</span></p><p>其中 <span class="math inline">\(\alpha_1,...,\alpha_n\)</span> 是<span class="math inline">\(\mathbb {C}^{n\times n}\)</span>中线性无关向量组</p><p><strong>正交化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned} \beta_1&amp;=\alpha_1\\\beta_2&amp;=\alpha_2 -\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1\\ \vdots \\ \beta_n &amp;= \alpha_n -\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}\end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \alpha_1 &amp;=\beta_1\\ \alpha_2 &amp;=\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1+ \beta_2\\ \vdots \\ \alpha_n &amp;=\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}+ \beta_n \end{aligned} \]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\alpha_1,\alpha_2,...,\alpha_n\end{bmatrix} &amp;=\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;\triangleqB\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix} \end{aligned}\]</span></p><p><strong>单位化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned}q_1=&amp;\frac{\beta_1}{||\beta_1||} \\ &amp;\vdots \\ q_n =&amp; \frac{\beta_n}{||\beta_n||} \end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \beta_1 =&amp;q_1||\beta_1|| \\ &amp;\vdots \\ \beta_n =&amp; q_n ||\beta_n||\end{aligned}\]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix} &amp;=\begin{bmatrix}q_1,q_2,...,q_n\end{bmatrix}\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\end{aligned} \]</span></p><p>综上，结合正交化和单位化可得</p><p><span class="math display">\[ \begin{aligned} A &amp;=B\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp;||\beta_n||\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;||\beta_2||&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq QR \end{aligned} \]</span></p><p><strong>QR 分解定理</strong> : <span class="math inline">\(A\in\mathbb {C}^{n\times n}\)</span> ,则存在酉矩阵 <spanclass="math inline">\(Q\)</span> 和正线上三角阵 <spanclass="math inline">\(R\)</span> ，使 <spanclass="math display">\[A=QR\]</span></p><p>且分解唯一</p><p><strong>正交三角分解的求法</strong> 1. 取矩阵 <spanclass="math inline">\(A=(A_1,A_2,...,A_n)\)</span> 的列向量，进行<strong>Schmidt 标准正交化</strong>,得 <spanclass="math inline">\(v_1,v_2,...,v_n\)</span> ，有 <spanclass="math display">\[Q=(v_1,v_2,...,v_n)\]</span> 2. 再由 <spanclass="math inline">\(R=Q^HA\)</span> 得到 <spanclass="math inline">\(R\)</span> , 于是 <spanclass="math inline">\(A=QR\)</span></p><h3 id="householder变换分解">HouseHolder变换分解</h3><p>将矩阵A按列划分为 <spanclass="math inline">\((\alpha_1,\alpha_2,\dots,\alpha_n)\)</span>,以4阶方阵为例，</p><p>第一步 令 <spanclass="math display">\[\omega_1=\frac{\alpha_1-a_1*e_1}{||\alpha_1-a_1*e_1||_2}，a_1=||\alpha_1||_2\]</span></p><p>于是 <spanclass="math display">\[H_1A=(H_1\alpha_1,H_1\alpha_2，...，H_1\alpha_n)=\left\{\begin{matrix} a_1 &amp; * &amp; \cdots &amp; * \\                   0      &amp; \\                   \vdots &amp; &amp;B_1 \\0\end{matrix}\right\}\]</span></p><p>第二步</p><p>从第一步中得到 <spanclass="math inline">\(B_1=(\beta_2,\beta_2,\cdots,\beta_n)\inR^{n-1}\)</span></p><p>取 <spanclass="math display">\[\omega_2=\frac{\beta_2-b_2*e_1}{||\beta_2-b_2*e_1||_2}，b_1=||\beta_2||_2\]</span></p><p>则 <spanclass="math display">\[\widehat{H_2}=I-2*\omega_2*\omega_2^T,H_2=\left\{\begin{matrix}1 &amp; 0^T \\                                                              0 &amp;\widehat{H_2}，                                              \end{matrix}\right\}\]</span></p><p>得到 <span class="math display">\[H_2(H_1*A) = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp;* \\                                       0 &amp; a_2 &amp; * &amp; \cdots&amp;* \\                                       0 &amp; 0 &amp;  &amp;\\                                       \vdots &amp; \vdots&amp;  &amp;C_2&amp; \\                                       0 &amp; 0\end{bmatrix} , C_2\in R^{n-2}\]</span></p><p>依次类推，进行第n步时，得到第n-1个 <spanclass="math inline">\(H_{n-1}\)</span>阵,使得 <spanclass="math display">\[H_{n-1} \cdots H_2H_1*A = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp; * \\                                                   0 &amp; a_2 &amp; *&amp; \cdots &amp; * \\                                                   0 &amp; 0 &amp; a_3&amp; \cdots &amp; *\\                                                  \vdots &amp; \vdots&amp; &amp;\ddots \\                                                    0 &amp; 0 &amp; 0&amp; \cdots &amp;a_n\end{bmatrix}=R\]</span></p><p>其中 <span class="math inline">\(H_{n-1} \cdotsH_2H_1*A=H\)</span>也称为HouseHolder矩阵，也为自逆矩阵 <spanclass="math inline">\(H=H^{-1}\)</span></p><p><span class="math display">\[H_{n-1} \cdots H_2H_1*A=R\]</span> <spanclass="math display">\[\Rightarrow (H_{n-1} \cdots H_2*H_1)^{-1}*H_{n-1}\cdots H_2H_1*A=(H_{n-1} \cdots H_2*H_1)^{-1}*R\]</span> <spanclass="math display">\[\Rightarrow A=H_1^{-1} \cdotsH_{n-1}^{-1}*R\]</span> <span class="math display">\[\RightarrowA=H_1\cdots H_{n-1}*R\]</span></p><p>得到 <span class="math inline">\(A=QR\)</span>,其中 <spanclass="math inline">\(Q\)</span>为正交矩阵， <spanclass="math inline">\(R\)</span>为上三角矩阵 <spanclass="math display">\[\begin{cases}Q = H_1\cdots H_{n-1}\\R = Q^{-1}A=QA\end{cases}\]</span></p><h3 id="三角分解的性质">三角分解的性质</h3><p><strong>定理1</strong>:设 <span class="math inline">\(A\in \mathbb{C}_r^{m\times n}\)</span>，则 <span class="math inline">\(A\)</span>可以唯一地分解为 <span class="math display">\[A=U_1 R\]</span></p><p>其中 <span class="math inline">\(U_1\)</span>是酉矩阵， <spanclass="math inline">\(R\)</span> 是正线上三角复矩阵，或 <spanclass="math inline">\(A\)</span> 可以唯一地分解为 <spanclass="math display">\[A=L U_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角复矩阵， <spanclass="math inline">\(U_2\)</span>是酉矩阵</p><p><strong>推论1</strong>：设 <span class="math inline">\(A \in \mathbb{R}^{n × n}_n\)</span>,则 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=Q_1 R\]</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是则正交矩阵，<spanclass="math inline">\(R\)</span>是正线上三角实矩阵，或 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=L Q_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角实矩阵， <spanclass="math inline">\(Q_2\)</span>是正交矩阵。</p><p><strong>推论2</strong>：设A是实对称正定矩阵，则存在唯一正线上三角实矩阵<span class="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^T R\]</span></p><p><strong>推论3</strong>：设 <spanclass="math inline">\(A\)</span>是正定Hermite矩阵，则存在唯一正线上三角复矩阵<spanclass="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^H R\]</span></p><h2 id="矩阵的满秩分解">矩阵的满秩分解</h2><p>设 <span class="math inline">\(A\in \mathbb {C}_r^{m\timesn}\)</span>，则存在 <span class="math inline">\(B\in \mathbb{C}_r^{m\times r}, C\in \mathbb {C}_r^{r\times n}\)</span>，满足 <spanclass="math display">\[ A = BC \]</span></p><p><span class="math inline">\(\mathbb {C}_r\)</span> 表示矩阵的秩为<span class="math inline">\(r\)</span></p><p>实际上上述定理用文字描述就是，一个亏秩的矩阵可以分解成一个列满秩与行满秩矩阵的乘积</p><p>证明：因为 <span class="math inline">\(rank(A)=r\)</span>，所以一定可以找到与 <spanclass="math inline">\(A\)</span> 相似的一个矩阵</p><p><span class="math display">\[ A \simeq\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\\0_{(m-r)\timesr}&amp;0_{(m-r)\times(n-r)}\end{bmatrix}=\begin{bmatrix}E_r\\0_{(m-r)\timesr}\end{bmatrix}\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\end{bmatrix}\]</span></p><p>因此存在两个可逆矩阵 <span class="math inline">\(P,Q\)</span>，使<span class="math inline">\(PAQ=\begin {bmatrix} E_r&amp;0\\0&amp;0\end{bmatrix}\)</span>，则</p><p><span class="math display">\[ \begin{aligned} A &amp;=P^{-1}\begin{bmatrix}E_r\\0\end{bmatrix}\begin{bmatrix}E_r&amp;0\end{bmatrix}Q^{-1}\\&amp;\triangleq BC \end{aligned} \]</span></p><p>因为 <span class="math inline">\(P^{-1}\)</span> 是可逆矩阵，<spanclass="math inline">\(\begin {bmatrix} E_r\\0\end {bmatrix}\)</span>是一个列满秩矩阵，所以 <span class="math inline">\(B=P^{-1}\begin{bmatrix} E_r\\0\end {bmatrix}\)</span> 仍是一个列满秩矩阵；同理，<spanclass="math inline">\(C=\begin {bmatrix} E_r&amp;0\end {bmatrix}Q^{-1}\)</span> 是一个行满秩矩阵</p><h3 id="矩阵满秩分解的计算">矩阵满秩分解的计算</h3><p>如何在给定矩阵 <span class="math inline">\(A\)</span>的情况下，求出矩阵 <span class="math inline">\(B,C\)</span> 呢？</p><p>设</p><p><span class="math display">\[\begin{align}&amp;A = [\alpha_1,\alpha_2,...,\alpha_n]\\ &amp;B =[\beta_1,\beta_2,...,\beta_r]  \end{align}\]</span></p><p>其中 <span class="math inline">\(\beta_1,...,\beta_r\)</span>线性无关</p><p>所以 <span class="math display">\[ \begin{aligned} &amp;A=BC\\&amp;\Rightarrow[\alpha_1,\alpha_2,...,\alpha_n]=[\beta_1,...,\beta_r]\begin{bmatrix}c_{11}&amp;\cdots&amp;c_{1n}\\\vdots &amp;\ddots&amp;\vdots\\c_{r1}&amp;\cdots&amp;c_{rn}\end{bmatrix} \end{aligned} \]</span></p><p>实际上我们可以取 <spanclass="math inline">\(\beta_1,...,\beta_r\)</span> 为 <spanclass="math inline">\(\alpha_1,...,\alpha_n\)</span>的一个极大线性无关组，因此 <span class="math inline">\(B\)</span>就是矩阵 <span class="math inline">\(A\)</span>列向量组的一个极大线性无关组，<span class="math inline">\(C\)</span>就是用该线性无关组去表示 <span class="math inline">\(A\)</span>时的系数</p><h4 id="例-1">例 1</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换 <span class="math display">\[A=\begin{bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\\0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}1&amp;4&amp;-1\\2&amp;0&amp;0\\-1&amp;2&amp;-4\\2&amp;6&amp;-5\end{bmatrix}，C=\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\end{bmatrix}\]</span></p><h4 id="例-2">例 2</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换</p><p><span class="math display">\[A=\begin{bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}2&amp;1&amp;-2\\2&amp;5&amp;-1\\1&amp;3&amp;-1\end{bmatrix},C=\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><h2 id="矩阵的lu分解">矩阵的LU分解</h2><p>LU 分解（LUDecomposition）是矩阵分解的一种，可以将一个矩阵分解为一个单位下三角矩阵和一个上三角矩阵的乘积，以四阶矩阵为例<span class="math display">\[ L = \begin{bmatrix}1&amp;0&amp;0&amp;0 \\*&amp;1&amp;0&amp;0\\ *&amp;*&amp;1&amp;0\\*&amp;*&amp;*&amp;1\end{bmatrix},U=\begin{bmatrix}*&amp;*&amp;*&amp;*\\0&amp;*&amp;*&amp;*\\0&amp;0&amp;*&amp;*\\0&amp;0&amp;0&amp;*\end{bmatrix}\]</span></p><p>LU 矩阵是否一定存在？答案是否，具体看下面的例子</p><p>设 <span class="math inline">\(\begin {bmatrix} 0&amp;1 \\1&amp;0\end{bmatrix}=\begin {bmatrix} a&amp;0\\b&amp;c\end {bmatrix}\begin{bmatrix} l&amp;m\\0&amp;n\end {bmatrix}\)</span>，则应该满足如下 4个式子</p><p><span class="math display">\[ \begin{cases} al=0\\ am=1\\ bl=1\\bm+cn=0 \end{cases} \]</span></p><p>由 <span class="math inline">\(al=0\)</span> 得 <spanclass="math inline">\(a=0\)</span> 或 <spanclass="math inline">\(l=0\)</span>，但实际上这两种情况带入上面的式子都会推出矛盾，因此不是所有情况LU 分解都存在</p><p><strong>LU 分解定理</strong> ：设 <span class="math inline">\(A\in\mathbb {C}_n^{n\times n}\)</span>，<spanclass="math inline">\(A\)</span> 有唯一的 LU 分解 <spanclass="math inline">\(\Leftrightarrow A\)</span> 的各阶顺序主子式 <spanclass="math inline">\(\Delta k \neq 0,\ k=1,2...,n\)</span></p><p><span class="math inline">\(k\)</span> 阶顺序主子式指的是矩阵左上角<span class="math inline">\(k\times k\)</span> 个元素组成的行列式</p><p>将矩阵 <span class="math inline">\(A\)</span> 分解为 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span> 之后，解方程组 <spanclass="math inline">\(Ax=b\)</span> 就变得简单了，因为 <spanclass="math inline">\(A=LU\)</span>，所以 <spanclass="math inline">\((LU) x=b\Rightarrow L (Ux)=b\Rightarrow \begin{cases} Ly=b\\Ux=y\end {cases}\)</span></p><p>所以 <span class="math inline">\(x=U^{-1} y=U^{-1} L^{-1}b\)</span></p><h3 id="lu-矩阵的求法">LU 矩阵的求法</h3><p>实际上 LU 矩阵有非常多的求法，这里列举一种比较简单的待定系数法</p><p>设 <span class="math inline">\(A = \begin {bmatrix}2&amp;3&amp;4\\1&amp;1&amp;9\\1&amp;2&amp;-6\end{bmatrix}\)</span>，求矩阵 <span class="math inline">\(A\)</span> 的 LU分解矩阵 <span class="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span></p><p><strong>解</strong>：令 <span class="math display">\[L=\begin{bmatrix}1&amp;0&amp;0\\l_1&amp;1&amp;0\\l_2&amp;l_3&amp;1\end{bmatrix},U=\begin{bmatrix}u_1&amp;u_2&amp;u_3\\0&amp;u_4&amp;u_5\\0&amp;0&amp;u_6\end{bmatrix}\]</span></p><p>由于 <span class="math inline">\(A=LU\)</span>，所以有</p><p><span class="math display">\[ \begin{cases} u_1=2\\ u_2=3\\ u_3=4\\l_1u_1=1\\ l_1u_2+u_4=1\\ l_1u_3+u_5=9\\ l_2u_1=1\\ l_2u_2+l_3u_4=2\\l_2u_3+l_3u_5+u_6=-6 \end{cases} \]</span></p><p>上面的方程组非常容易解，最后求出</p><p><span class="math display">\[ L =\begin{bmatrix}1&amp;0&amp;0\\\frac{1}{2}&amp;1&amp;0\\\frac{1}{2}&amp;-1&amp;1\end{bmatrix},U=\begin{bmatrix}2&amp;3&amp;4\\0&amp;-\frac{1}{2}&amp;7\\0&amp;0&amp;-1\end{bmatrix}\]</span></p><h2 id="奇异值分解">奇异值分解</h2><p><strong>奇异值</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{m × n}_r,AA^H\)</span> 的特征值为 <spanclass="math display">\[\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_n =0\]</span></p><p>则称 <span class="math inline">\(\sigma_i=\sqrt{\lambda_i}\)</span>为矩阵A的正奇异值。<strong><span class="math inline">\(A\)</span>和<span class="math inline">\(A^H\)</span>相同的奇异值</strong>。</p><p><strong>奇异值分解</strong>：当给定一个大小为<spanclass="math inline">\(m × n\)</span>的矩阵<spanclass="math inline">\(A\)</span>,虽然矩阵<spanclass="math inline">\(A\)</span>不一定是方阵，但大小为<spanclass="math inline">\(m × m\)</span>的<spanclass="math inline">\(AA^T\)</span>和<span class="math inline">\(n ×n\)</span>的<span class="math inline">\(AA^T\)</span>是对称矩阵,若<spanclass="math inline">\(AA^T=P \Lambda_1 Q^T\)</span>,<spanclass="math inline">\(A^T A=Q\Lambda_2Q^T\)</span>,则矩阵A的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T\]</span></p><p>其中，矩阵<span class="math inline">\(P=(\overrightarrow{p_1},\overrightarrow{p_2}, \dots, \overrightarrow{p_m})\)</span>的大小为<span class="math inline">\(m × m\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{p_1}, \overrightarrow{p_2}, \dots,\overrightarrow{p_m}\)</span>是 <spanclass="math inline">\(AA^T\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的左奇异向量（left singularvector）；矩阵<span class="math inline">\(Q=(\overrightarrow{q_1},\overrightarrow{q_2}, \dots, \overrightarrow{q_m})\)</span>的大小为<span class="math inline">\(n × n\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{q_1}, \overrightarrow{q_2}, \dots,\overrightarrow{q_m}\)</span>是 <spanclass="math inline">\(A^TA\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的右奇异向量（left singularvector）；矩阵<spanclass="math inline">\(\Lambda_1\)</span>的大小为<spanclass="math inline">\(m × m\)</span>，矩阵<spanclass="math inline">\(\Lambda_2\)</span>的大小为<spanclass="math inline">\(n ×n\)</span>，两个矩阵对角线上的非零元素相同（即矩阵<spanclass="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的非零特征值相同）；矩阵<spanclass="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(m ×n\)</span>，位于对角线上的元素被称为<strong>奇异值</strong>（singularvalue）。</p><p>设<span class="math inline">\(A\)</span>的秩为r，当 <spanclass="math inline">\(m \ne n\)</span>时，矩阵<spanclass="math inline">\(\Lambda_1\)</span>和<spanclass="math inline">\(\Lambda_2\)</span>的大小显然是不同的，但是他们对角线上的非零元素是相同的，记矩阵<spanclass="math inline">\(\Lambda_1\)</span>(或<spanclass="math inline">\(\Lambda_2\)</span>)对角线上的非零元素为<spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_r\)</span>，这些数皆为非负数，又记矩阵<spanclass="math inline">\(\Sigma\)</span>对角线上的非零元素分别为<spanclass="math inline">\(\sigma_1,\sigma_2,\dots,\sigma_r\)</span>，则<spanclass="math display">\[\sigma_1=\sqrt{\lambda_1},\sigma_2=\sqrt{\lambda_2},\dots,\sigma_r=\sqrt{\lambda_r}\]</span></p><p>即非零奇异值的平方对应着矩阵<spanclass="math inline">\(\Lambda_1\)</span>（或矩阵<spanclass="math inline">\(\Lambda_2\)</span>）的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。</p><p><strong>例1</strong>：一个<spanclass="math inline">\(3×2\)</span>的矩阵<spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\)</span>，求其奇异值分解。</p><p>由 <span class="math display">\[AA^T=\begin{bmatrix}    5&amp;0&amp;0 \\ 0&amp;0&amp;0 \\ 0&amp;0&amp;0\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=\lambda_3=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{p_1}=(1,0,0)^T,\overrightarrow{p_2}=(0,1,0)^T,\overrightarrow{p_3}=(0,0,1)^T\)</span></p><p>由 <span class="math display">\[A^TA=\begin{bmatrix}    1&amp;2 \\ 2&amp;4\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{q_1}=(\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T,\overrightarrow{q_2}=(-\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T\)</span></p><p>令 <span class="math display">\[\Sigma=\begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p>注意矩阵<span class="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(3 × 2\)</span>，此时，矩阵<spanclass="math inline">\(A\)</span>的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T=(\overrightarrow{p_1},\overrightarrow{p_2}, \overrightarrow{p_3})\Sigma (\overrightarrow{q_1},\overrightarrow{q_2})^T \\ =\begin{bmatrix}    1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix} \begin{bmatrix}    \frac{\sqrt{5}}{5}&amp;\frac{2\sqrt{5}}{5} \\\frac{-2\sqrt{5}}{5}&amp;\frac{\sqrt{5}}{5}\end{bmatrix} = \begin{bmatrix}    1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p><strong>例2</strong>：求对称矩阵<spanclass="math inline">\(A=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}\)</span>的奇异值分解。</p><p>经计算可以发现<spanclass="math inline">\(A^TA=AA^T=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix} \begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}=\begin{bmatrix}  5&amp;4 \\ 4&amp;5\end{bmatrix}\)</span>，左奇异向量和右奇异向量构成的矩阵也是相等的，即<span class="math display">\[P=Q=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p>则其奇异值分解为 <span class="math display">\[A=P\SigmaQ^T=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2}&amp; \frac{\sqrt{2}}{2}\end{bmatrix}\begin{bmatrix}    3&amp;0 \\ 0&amp;1\end{bmatrix}\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p><strong>注</strong>：这是由于当矩阵<spanclass="math inline">\(A\)</span>为对称矩阵时，其可以被正交对角化，这时奇异值分解等于正交对角化分解。</p><h2 id="谱分解">谱分解</h2><p><strong>谱分解</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{n × n}\)</span>是单纯矩阵，则 <spanclass="math inline">\(A\)</span>可以分解为一系列幂等矩阵 <spanclass="math inline">\(A_i(i=1,2, \dots,n)\)</span>的加权和 <spanclass="math display">\[A=\sum_{i=1}^n \lambda_i A_i\]</span></p><p>其中 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span>是A的特征值。</p><p><strong>单纯矩阵</strong>：若矩阵 <spanclass="math inline">\(A\)</span>的<strong>代数重数</strong>等于<strong>几何重数</strong>，则称<spanclass="math inline">\(A\)</span>为单纯矩阵。<strong>代数重数</strong>为矩阵<spanclass="math inline">\(A\)</span>特征值的重数，<strong>几何重数</strong>为齐次方程组<spanclass="math inline">\(Ax=\lambda_ix(i=1,2,\dots,k)\)</span>的解空间<spanclass="math inline">\(V_{\lambda_i}\)</span>的维数，也即特征值对应的最多无关特征向量数。</p><p><strong>幂等矩阵</strong>：若 <spanclass="math inline">\(A\)</span>为方阵，且 <spanclass="math inline">\(A^2=A\)</span>，则称<spanclass="math inline">\(A\)</span>为幂等矩阵。所有幂等矩阵都相似与对角元全为0或1的对角阵。</p><p><strong>更一般的单纯矩阵谱分解定理</strong>：设 <spanclass="math inline">\(A \in \mathbb{C}^{n × n}\)</span>，他有 <spanclass="math inline">\(k\)</span>个相异特征值 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,k)\)</span>，则 <spanclass="math inline">\(A\)</span>是单纯矩阵的充要条件是存在<spanclass="math inline">\(k\)</span>个矩阵<spanclass="math inline">\(A_i(i=1,2,\dots,k)\)</span>满足</p><ol type="1"><li><span class="math inline">\(A_i A_j = \begin{cases}  A_i, i=j \\ 0,i\ne j \end{cases}\)</span></li><li><span class="math inline">\(\sum_{i=1}^k A_i = E_n\)</span></li><li><span class="math inline">\(A=\sum_{i=1}^k \lambda_iA_i\)</span></li></ol><p>该定理比定理3要求放宽了，不再要求必须要有n个特征值了，这里的k可以小于等于n。</p><p><strong>例1</strong>：求正规矩阵 <span class="math inline">\(A =\begin{bmatrix}  0&amp;1&amp;1&amp;1 \\ 1&amp;0&amp;-1&amp;1 \\1&amp;-1&amp;0&amp;1 \\ -1&amp;1&amp;1&amp;0\end{bmatrix}\)</span>的谱分解表达式。</p><p><strong>解</strong>：首先计算 <spanclass="math inline">\(A\)</span>的特征值和特征向量 <spanclass="math display">\[|\lambda_ I - A |=(\lambda - 1)^3 (\lambda +3)\]</span></p><p>从而 <span class="math inline">\(A\)</span>的特征值为 <spanclass="math display">\[\lambda_1=\lambda_2=\lambda_3=1,\lambda_4=-3\]</span></p><p>当<spanclass="math inline">\(\lambda=1\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_1=(1,1,0,0)^T \\ \alpha_2=(1,0,1,0)^T \\\alpha_3=(-1,0,0,1)^T\]</span></p><p>当<spanclass="math inline">\(\lambda=-3\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_4=(1,-1,-1,1)^T\]</span></p><p>将 <spanclass="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交化并单位化得<spanclass="math display">\[\eta_1=(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0,0)^T\\\eta_2=(\frac{1}{\sqrt{6}},\frac{1}{\sqrt{6}},\frac{2}{\sqrt{6}},0)^T \\\eta_3=(-\frac{1}{2\sqrt{3}},\frac{1}{2\sqrt{3}},\frac{1}{\sqrt{3}},\frac{3}{2\sqrt{3}})^T\]</span></p><p>将<span class="math inline">\(\alpha_4\)</span>单位话得 <spanclass="math display">\[\eta_4=(\frac{1}{2},-\frac{1}{2},-\frac{1}{2},\frac{1}{2})\]</span></p><p>故有 <span class="math display">\[G_1=\eta_1 \eta_1^H+\eta_2 \eta_2^H+\eta_3 \eta_3^H \\= \begin{bmatrix}    \frac{3}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;\frac{3}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{3}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{3}{4}    \end{bmatrix}\]</span></p><p><span class="math display">\[G_2=\eta_4 \eta_4^H \\=\begin{bmatrix}    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4}\end{bmatrix}\]</span></p><p>这样其谱分解表达式为 <span class="math display">\[A=G_1 -3G_2\]</span></p><p>注意<span class="math inline">\(G_1\)</span>和<spanclass="math inline">\(G_2\)</span>的系数<spanclass="math inline">\(\lambda_i\)</span>为其对应的特征值。<!-- https://www.cnblogs.com/blairgrowing/p/15800825.html --></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>范数</title>
    <link href="/2022/12/05/%E8%8C%83%E6%95%B0/"/>
    <url>/2022/12/05/%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>不管向量范数、矩阵范数还是算子范数，都需要满足三个特性:</p><ul><li>正定性</li><li>齐次性</li><li>三角不等式</li></ul><h2 id="向量范数">向量范数</h2><p><strong>1 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_1=\sum\limits_{i=1}^N|x_i|\)</span>，即向量元素绝对值之和</p><p><strong>2 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_2=(\sum\limits_{i=1}^N (x_i)^2)^{\frac{1}{2}}\)</span>，也叫欧几里得范数，常用于计算向量长度，即向量元素的平方和再开方</p><p><strong><span class="math inline">\(\infty\)</span>-范数</strong>:<span class="math inline">\(\Vert \boldsymbol{x}\Vert_{\infty}=\max\limits_{i}|x_i|\)</span>，即所有向量元素中绝对值的最大值</p><!-- **-$\infty$- 范数**:$\Vert \boldsymbol {x}\Vert_{-\infty}=\min\limits_{i} |x_i|$，即所有向量元素绝对值中的最小值 --><p><strong>P - 范数</strong>:<span class="math inline">\(\Vert\boldsymbol {x}\Vert_p=(\sum\limits_{i=1}^N (x_i)^p)^{\frac{1}{p}}\)</span>，即向量元素的 p 次方和再开 p 次方</p><h2 id="矩阵范数">矩阵范数</h2><p>设<span class="math inline">\(A \in \mathbb{C}^{m ×n}\)</span>，则</p><p><span class="math inline">\({||A||}_{m_1} = \sum\limits^{n}_{j=1}\sum\limits^{m}_{i=1} |a_{ij}|\)</span></p><p><span class="math inline">\(||A||_{m_2} = {||A||}_{F}=\sqrt{\sum\limits^{n}_{j=1} \sum\limits^{m}_{i=1} |a_{ij}^2|} =\sqrt{tr(A^HA)} = \sqrt{tr(AA^H)}\)</span></p><p><spanclass="math inline">\(||A||_{m_\infty}=\max\limits_{i,j}\{|a_{ij}|\},1\le i \le m, 1 \le j \le n\)</span></p><h3 id="矩阵范数的性质">矩阵范数的性质</h3><p><img src="/img/矩阵论/矩阵范数性质-定理1.png" /> <imgsrc="/img/矩阵论/矩阵范数性质-定理1-2.png" /></p><ul><li><span class="math inline">\({||A||}_{m_1}\)</span>范数与向量范数<span class="math inline">\(||x||_1\)</span>相容</li><li><span class="math inline">\({||A||}_{m_2}\)</span>范数与向量范数<span class="math inline">\(||x||_2\)</span>相容</li><li><spanclass="math inline">\({||A||}_{m_{\infty}}\)</span>范数与向量范数 <spanclass="math inline">\(||x||_\infty\)</span> 不相容</li></ul><h3 id="证明一个范数是矩阵范数流程">证明一个范数是矩阵范数流程</h3><ul><li>证明非负性、齐次性、三角不等式</li><li>看他定义是哪种类型的范数，若是相容的需要证明相容性</li></ul><h2 id="算子范数">算子范数</h2><p>算子范数定义1： <img src="/img/矩阵论/算子范数定义1.png" /></p><p>注意：并不是所以的矩阵范数都与向量范数相容。只有满足该条件的矩阵范数才与向量范数是相容的。</p><p>算子范数定义2： <img src="/img/矩阵论/算子范数定义2.png" /></p><p><strong>则称此矩阵范数为从属于向量范数 <spanclass="math inline">\(||x||\)</span>的算子范数</strong>。这里的x可是n维空间的任意取向。</p><p><strong>算子范数表示</strong>：</p><p><span class="math inline">\({||A||}_1=\max\limits_{1 \le j \len}\{\sum\limits^{s}_{j=1}|a_{ij}|\}\)</span>,列模和范数，即所有矩阵列向量绝对值之和的最大值</p><p><span class="math inline">\(||A||_2=\sqrt{\rho(A^HA)}\)</span>，谱范数</p><p><span class="math inline">\(||A||_\infty=\max\limits_{1 \le i \les}\{\sum^n_{j=1}|a_{ij}|\}\)</span>,行模和范数,即所有矩阵行向量绝对值之和的最大值</p><h3 id="算子范数性质">算子范数性质</h3><ul><li><span class="math inline">\({||A||}_{1}\)</span> 范数与向量范数<span class="math inline">\(||x||_1\)</span> 相容</li><li><span class="math inline">\({||A||}_{2}\)</span> 范数与向量范数<span class="math inline">\(||x||_2\)</span> 相容</li><li><span class="math inline">\(||·||_a\)</span>是算子范数 <spanclass="math inline">\(\Rightarrow ||E||_a = 1\)</span></li><li>设<span class="math inline">\(A \in \mathbb{C}^{n × n}，||A||_a\)</span>是从属向量范数<spanclass="math inline">\(||x||\)</span>的算子范数，若<spanclass="math inline">\(||A||_a &lt; 1\)</span>,则 <spanclass="math inline">\(E \pm A\)</span> 可逆，且<spanclass="math inline">\(||(E \pm A)^{-1}||_a \le (1 -||A||_a)^{-1}\)</span></li></ul><p><img src="/img/矩阵论/算子范数性质-定理3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jordan标准型</title>
    <link href="/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <url>/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="jordan标准型">Jordan标准型</h2><figure><img src="/img/矩阵论/Jordan标准型定义.png" alt="Jordan标准型定义" /><figcaption aria-hidden="true">Jordan标准型定义</figcaption></figure><p>其中 <spanclass="math inline">\(J_1(\lambda_1),J_2(\lambda_2)\)</span>分别构成Jardon块。</p><p>即对任意矩阵 <spanclass="math inline">\(A\)</span>，比存在n阶可逆矩阵<spanclass="math inline">\(P\)</span>，使 <spanclass="math display">\[P^{-1}AP=\begin{bmatrix}    J_1 &amp; &amp; &amp; \\ &amp; J_2 &amp; &amp; \\ &amp; &amp; \ddots&amp; \\ &amp; &amp; &amp; J_n\end{bmatrix} = J\]</span></p><p>每一个 <span class="math inline">\(J\)</span> 都是Jardon块 <spanclass="math display">\[J_i=\begin{bmatrix}    \lambda_i &amp; 1 &amp; &amp; \\ &amp; \lambda_i &amp; \ddots &amp;&amp; \\ &amp; &amp; \ddots &amp;1 \\ &amp; &amp; &amp; \lambda_i\end{bmatrix}\]</span></p><h3 id="jordan标准型的结构与结论">Jordan标准型的结构与结论</h3><ul><li>Jordan标准型的个数<spanclass="math inline">\(k\)</span>是线性无关特征向量的个数</li><li>矩阵可对角化当且仅当<span class="math inline">\(k=n\)</span></li><li>相应于一个已知特征值的Jordan块的个数是该特征值的几何重数，它是相应的特征子空间的维数，相应于一个已知特征值的所有Jordan的阶数之和，是该特征值的代数重数</li><li>特征值的几何重数 &lt; 代数重数</li><li>矩阵不同特征值对应的特征向量线性无关</li></ul><figure><img src="/img/矩阵论/Jordan标准型定理2.png" alt="定理2" /><figcaption aria-hidden="true">定理2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征值估计</title>
    <link href="/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>shur不等式</strong> <imgsrc="/img/矩阵论/特征值估计-shur不等式.png" /></p><p>证明如下： <img src="/img/矩阵论/shur不等式证明.png" /></p><p><strong>行盖尔圆盘和列盖尔圆盘</strong>： <imgsrc="/img/矩阵论/盖尔圆盘.png" /></p><p><strong>圆盘定理</strong>： <img src="/img/矩阵论/圆盘定理1.png" /><img src="/img/矩阵论/圆盘定理2.png" /></p><p>推论1：设<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>相似于对角阵.</p><p>推论2： 设<span class="math inline">\(n\)</span>阶实阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>特征值全为实数.</p><p><strong>对角占优矩阵</strong>：</p><p><img src="/img/矩阵论/对角占优矩阵.png" /></p><p><strong>Rayleigh商</strong>：设<span class="math inline">\(A \in\mathbb{C}^{n \times n}\)</span>为Hermite矩阵，<spanclass="math inline">\(x \in \mathbb{C}\)</span>，称 <spanclass="math display">\[R(x)=\frac{x^HAx}{x^Hx}, x \ne 0\]</span></p><p>为<span class="math inline">\(A\)</span>的Rayleigh商。</p><p><strong>定理（Rayleigh-Ritz）</strong>: <imgsrc="/img/矩阵论/Rayleigh-Ritz定理.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵函数</title>
    <link href="/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数">矩阵函数</h2><p><strong>定义</strong>： 设幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty} c_kz^k\)</span>收敛半径为<span class="math inline">\(r\)</span>，且当<spanclass="math inline">\(|z|&lt;r\)</span>的时候，幂级数收敛于<spanclass="math inline">\(f(z)\)</span>，即</p><p><span class="math display">\[f(z)=\sum\limits_{k=0}^{\infty} c_kz^k,|z|&lt;r\]</span></p><p>如果<span class="math inline">\(A \in\mathbb{C}^{n×n}\)</span>满足<spanclass="math inline">\(r(A)&lt;r\)</span>,则收敛的矩阵幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty}a_kA^k\)</span>的和为矩阵函数，记为<spanclass="math inline">\(f(A)\)</span>，即</p><p><span class="math display">\[f(A)=\sum\limits_{k=0}^{\infty} c_kA^k\]</span></p><p>把<span class="math inline">\(f(A)\)</span>的方阵换为<spanclass="math inline">\(At\)</span>,<spanclass="math inline">\(t\)</span>为参数，得到</p><p><span class="math display">\[f(At)=\sum\limits_{k=0}^{\infty}c_k(At)^k\]</span></p><p>常见的矩阵级数有：</p><p><img src="/img/矩阵论/矩阵函数/常见矩阵函数1.png" /> <imgsrc="/img/矩阵论/矩阵函数/常见矩阵函数2.png" alt="常见矩阵函数" /></p><h3 id="矩阵函数的计算方法">矩阵函数的计算方法</h3><h4 id="利用相似对角化">利用相似对角化</h4><p>设<span class="math inline">\(P^{-1}AP= diag(\lambda_1,\lambda_2,\dots, \lambda_3) = D\)</span></p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算2.png" /></p><p><strong>例1</strong>：</p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-3.png" /></p><h4 id="jordan标准型法">Jordan标准型法</h4><p><img src="/img/矩阵论/矩阵函数/Jordan法-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-4.png" /></p><p><strong>例2</strong>：</p><p><img src="/img/矩阵论/矩阵函数/Jordan法-例2-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例2-2.png" /></p><h4 id="数项级数求和法">数项级数求和法</h4><p><img src="/img/矩阵论/矩阵函数/数项级数求和法.png" /></p><p>由哈密尔顿-凯莱定理于是我们有：</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-2.png" /></p><p>由该定理，我们可以实现降次的目的。</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/数项级数求和法-4.png" /></p><h3 id="矩阵函数的性质">矩阵函数的性质</h3><p><img src="/img/矩阵论/矩阵函数/矩阵函数性质.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近似算法</title>
    <link href="/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="近似算法">近似算法</h2><p>假设现在需要解决一个NP-Hard问题，但是又不太可能在多项式时间内求解，但是我们可以退而求其次，那么就必须要牺牲下面的其中一项：</p><ul><li>求得最优解</li><li>在多项式时间内完成</li><li>覆盖问题的所有例子</li></ul><p>而牺牲第二条是不能接受的，当我们选择满足后两者（也就是牺牲第一项），即对解的优越性放宽要求时，设计出的算法被称为<strong>近似算法</strong>。</p><h2 id="load-balancing问题">Load Balancing问题</h2><p>给定<span class="math inline">\(m\)</span>台相同的机器，<spanclass="math inline">\(n\)</span>个任务，任务<spanclass="math inline">\(j\)</span>需要的处理时间为<spanclass="math inline">\(t_j\)</span>,且每个任务<spanclass="math inline">\(j\)</span>必须在一台机器上连续完成。</p><p>令<span class="math inline">\(J(i)\)</span>为分配给机器<spanclass="math inline">\(i\)</span>的任务子集，机器<spanclass="math inline">\(i\)</span>的负载为<spanclass="math inline">\(L_i=\sum\limits_{j \inJ(i)}t_j\)</span>,该问题的时间跨度(makespan)为所有机器上的结束时间最大值<spanclass="math inline">\(L=\max\limits_i L_i\)</span>。</p><p><strong>LoadBalancing</strong>：求上述问题中的任务分配使得时间跨度最小。</p><h3 id="贪心算法">贪心算法</h3><p>每次将任务<spanclass="math inline">\(j\)</span>分配在当前负载最小的机器上： <imgsrc="/img/近似算法/LoadBalancing贪心算法.png" /></p><p><strong>引理1</strong>：最优解makespan<span class="math inline">\(L^*\ge \max\limits_j t_j\)</span>。</p><p>用时最长的这个任务总需要分配到一个机器上完成.</p><p><strong>引理2</strong>:最优解makespan <span class="math inline">\(L^*\ge \frac{1}{m} \sum\limits_j t_j\)</span></p><p>所有任务的总运行时间为<span class="math inline">\(\sum\limits_jt_j\)</span>,那么<spanclass="math inline">\(L^*\)</span>的时间跨度必然选自<spanclass="math inline">\(m\)</span>个机器中最大的一个,而<spanclass="math inline">\(m\)</span>个机器中的最大时间跨度一定不小于<spanclass="math inline">\(\frac{1}{m}\)</span>的总运行时间.</p><p><strong>定理:贪心算法是LoadBalancing问题的二倍近似算法。</strong></p><p>证明:</p><p>假设负载<span class="math inline">\(L_i\)</span>为问题的平静,令<spanclass="math inline">\(j\)</span>为最后一个分配到该机器的任务,由贪心算法,在任务<spanclass="math inline">\(j\)</span>分配之前,机器<spanclass="math inline">\(i\)</span>的负载是最小的.<spanclass="math inline">\(j\)</span>分配之前机器<spanclass="math inline">\(i\)</span>的负载为<span class="math inline">\(L_i- t_j\)</span>,也就是说在准备分配<spanclass="math inline">\(j\)</span>的时候有<span class="math inline">\(L_i- t_j\)</span>小于或等于所有机器上的负载<span class="math inline">\(L_k,1 \le k \le m\)</span></p><p><img src="/img/近似算法/LoadBalancing贪心算法证明-1.png" /></p><p>分配任务<span class="math inline">\(j\)</span>之前,由引理1: <spanclass="math display">\[  \begin{aligned}    L_i - t_j &amp;\le \frac{1}{m}\sum\limits_k L_k \\        &amp;=  \frac{1}{m} \sum\limits_k t_k \\        &amp;\le L^*    \end{aligned}\]</span></p><p>分配任务<span class="math inline">\(j\)</span>后,由上式以及引理2:<span class="math display">\[L_i = (L_i -t_i) + t_j \le L^* +\max\limits_j t_j \le L^* + L^* = 2L^*\]</span></p><p>那么贪心算法是Load Balancing的紧2倍近似算法吗?判断<spanclass="math inline">\(\rho\)</span>-近似算法是否紧的要看该算法相比于最优解有比<spanclass="math inline">\(\rho\)</span>更低的近似率吗?若有则说明其并不是紧的。</p><p>答:大致是的,考虑下面的一个Load Balancing的实例,有<spanclass="math inline">\(m\)</span>个机器,<spanclass="math inline">\(m^2\)</span>个任务,其中有<spanclass="math inline">\(m(m-1)\)</span>个任务运行时间为1,一个任务的运行时间为<spanclass="math inline">\(m\)</span>.贪心算法的结果如下图所示:</p><p><img src="/img/近似算法/LoadBalancing实例-贪心算法.png" /></p><p>而最优解的结果为:</p><p><img src="/img/近似算法/LoadBalancing实例-最优解.png" /></p><p>这个实例里贪心算法的时间跨度为19,而最优解的时间跨度为10.</p><h3 id="lptlongest-processing-time算法">LPT(longest ProcessingTime)算法</h3><p>LPT算法是在上面的贪心算法基础之上,先对<spanclass="math inline">\(n\)</span>个任务按时间降序排序,然后再按照上面的贪心算法执行.</p><p><img src="/img/近似算法/LoadBalancingLPT算法.png" /></p><p>通过观察可以得出,当任务数小于或等于机器数的时候,LRT算法就是最优解.这时候只需要把任务<spanclass="math inline">\(i\)</span>分配给机器<spanclass="math inline">\(i\)</span>.</p><p><strong>引理3</strong>:如果任务数多于机器数<spanclass="math inline">\(m\)</span>,有<span class="math inline">\(L^* \ge2t_{m+1}\)</span>.</p><p>设前<spanclass="math inline">\(m+1\)</span>个任务的运行时间分别为<spanclass="math inline">\(t_1,\dots,t_{m+1}\)</span>,由于运行时间<spanclass="math inline">\(t_i\)</span>是按照降序排列,所以前<spanclass="math inline">\(m+1\)</span>个任务的运行时间都不小于<spanclass="math inline">\(t_{m+1}\)</span>,且由于鸽笼原则,至少有一个机器会被分配两个任务.</p><p><strong>定理:LPT算法是Load Balancing的一个<spanclass="math inline">\(\frac{3}{2}\)</span>近似算法.</strong></p><p>证明:与证明贪心算法相同的方法 <span class="math display">\[L_i=(L_i -t_j) + t_j \le L^* + \frac{1}{2}L^* = \frac{3}{2}L\]</span></p><p>那么LPT算法是Load Balancing的紧<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似算法吗?不是;LPT算法是LoadBalancing的紧<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似算法吗?很可能是.</p><h2 id="centrer-selection-problem中心选址问题">Centrer SelectionProblem(中心选址问题)</h2><p>定义:给定一个大小为<spanclass="math inline">\(n\)</span>个地址集合<spanclass="math inline">\(s_1,s_2,\dots,s_n\)</span>以及一个整数<spanclass="math inline">\(k&gt;0\)</span>,选择<spanclass="math inline">\(k\)</span>个中心使所有地址到离它最近的中心距离的最大值最短.</p><p><img src="/img/近似算法/CentrerSelectionProblem.png" /></p><p>几个概念:</p><ul><li><span class="math inline">\(dist(x, y)\)</span>:<spanclass="math inline">\(x,y\)</span>的距离.</li><li><span class="math inline">\(dist(s_i, C)=\min\limits_{c \inC}\)</span>:<spanclass="math inline">\(s_i\)</span>到离它最近的中心的距离,这里采用欧式距离.</li><li><span class="math inline">\(r(C)=\max\limits_{i}dist(s_i,C)\)</span>:最小的覆盖半径.</li></ul><p>中心选址问题的目标便是找到一个中心集合<spanclass="math inline">\(C\)</span>使覆盖半径<spanclass="math inline">\(r(C)\)</span>最小,其中中心的数量等于<spanclass="math inline">\(k\)</span>.</p><p>距离的一些性质: <span class="math display">\[dist(x,x)=0\tag{同一性}\]</span> <span class="math display">\[dist(x,y)=dist(y,x)\tag{对称性}\]</span> <span class="math display">\[dist(x,y) \ledist(x,z) + dist(z,y) \tag{三角不等式}\]</span></p><h3 id="贪心算法-1">贪心算法</h3><p>开始时我们任意选取一个地址作为中心，接着选择离第一个中心最远的那个地址作为第二个中心，如此的重复进行,直到选了<spanclass="math inline">\(k\)</span>个中心为止。</p><p><img src="/img/近似算法/CentrerSelectionProblem贪心算法.png" /></p><p><strong>定理：贪心算法是中心选址问题的2倍近似解</strong></p><p>证明(反证法)：</p><p>假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span></p><ul><li>对近似解集合<span class="math inline">\(C\)</span>的中心<spanclass="math inline">\(c_i\)</span>，总有一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>在<spanclass="math inline">\(c_i\)</span>的圆中(任意一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>的圆里最少有一个地址<spanclass="math inline">\(s\)</span>,而贪心算法选址都是在地址集合中选的，并且<spanclass="math inline">\(c_i\)</span>的半径 <spanclass="math inline">\(&gt;\)</span> <spanclass="math inline">\(c_i^*\)</span>的半径，所以<spanclass="math inline">\(c_i^*\)</span>必然在某一个中心<spanclass="math inline">\(c_i\)</span>的圆里)</li><li>令<span class="math inline">\(c_i\)</span>是与<spanclass="math inline">\(c_i^*\)</span>对应的中心</li><li>对于任意一个离最优解<spanclass="math inline">\(c_i^*\)</span>最近的地址<spanclass="math inline">\(s\)</span>,有</li></ul><p><span class="math display">\[dist(s,C) \le dist(s, c_i) \le dist(s,c_i^*) + dist(c_i^*, c_i) \le r(C^*) + r(C^*) = 2r(C^*)\]</span></p><p>上式与假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span>相违背，故有<spanclass="math inline">\(r(C^*) \ge\frac{1}{2}r(C)\)</span>,即贪心算法是中心选址问题的2倍近似解。</p><p>中心选址问题有没有<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似解或者<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似解？</p><p>答：没有，除非P＝NP，否则中心选址问题没有倍率比2小的近似算法。</p><h2 id="weighted-vertex-cover">Weighted Vertex Cover</h2><p>带权值的顶点覆盖：对于给出的一个顶点带权值的图<spanclass="math inline">\(G\)</span>，找到一个顶点覆盖，使它们的权值之和最小。（这里我们主要解决的是：求图<spanclass="math inline">\(G=(V,E)\)</span>的顶点覆盖<spanclass="math inline">\(S\)</span>，要使顶点集合<spanclass="math inline">\(S\)</span>中所有顶点的权值之和最小。</p><p><img src="/img/近似算法/WeightedVertexCover.png" /></p><h3 id="pricing-method">Pricing Method</h3><p><strong>定价法</strong>：因为顶点覆盖要求每条边至少有一个顶点在集合<spanclass="math inline">\(S\)</span>里,每条边必须被一些顶点所覆盖，根据顶点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>，给边<span class="math inline">\(e =(i, j)\)</span> 标上价格<span class="math inline">\(P_e\)</span>。</p><p>公平性：与顶点<spanclass="math inline">\(i\)</span>所连接的所有边的价格（权值）之和必须小于顶点<spanclass="math inline">\(i\)</span>的权值。</p><p>引理：：图<spanclass="math inline">\(G\)</span>的所有边的价格（权值）之和 <spanclass="math inline">\(\le\)</span> 顶点覆盖<spanclass="math inline">\(S\)</span>中所有顶点的权值之和（两个简单的缩放）。</p><p><img src="/img/近似算法/WeightedVertexCover-不等式放缩.png" /></p><p>上面第一个<spanclass="math inline">\(\le\)</span>不能写成等号，等号只在每条边都恰好只有一个顶点在<spanclass="math inline">\(S\)</span>中时才成立，若有边的两个顶点都在<spanclass="math inline">\(S\)</span>中，那么这条边就会被计算两次。</p><p>求解过程：边的价格设置与找寻顶点覆盖同时进行</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-求解过程.png" /></p><p>例子：</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-例子.png" /></p><p><strong>Pricing Method是Weighted VertexCover</strong>的一个2倍近似算法。</p><p>证明：</p><p>首先证明<span class="math inline">\(S\)</span>是一个点覆盖：</p><p>算法结束条件：在while循环的每次迭代结束之后，至少有一个顶点会是紧致的（除非图没有边），所以在算法结束的时候每条边的两个顶点中至少有一个是紧的，即每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，而VertexCover要求每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，所以<spanclass="math inline">\(S\)</span>必然是一个点覆盖，否则循环就不会停止。</p><p>然后再证明<spanclass="math inline">\(S\)</span>是最优解的一个2倍近似解：</p><p><img src="/img/近似算法/证明PricingMethod2倍近似解.png" /></p><p>第一处放缩很容易得出，<spanclass="math inline">\(S\)</span>肯定为顶点集<spanclass="math inline">\(V\)</span>的一个子集；<spanclass="math inline">\(\sum\limits_{i \in V} \sum\limits_{e=(i,j)} p_e =2 \sum\limits_{e \in E} p_e\)</span>是因为计算与<spanclass="math inline">\(V\)</span>中所有顶点相连的边时，每条边会被计算两次；最右边一个放缩为引理的结论。</p><h2id="线性规划解决最小带权点覆盖问题">线性规划解决最小带权点覆盖问题</h2><h3 id="整数规划">整数规划</h3><p>对于图<spanclass="math inline">\(G=(V,E)\)</span>,对图中的每个点<spanclass="math inline">\(v \in V\)</span>，定义函数<spanclass="math inline">\(x(v) \in {0, 1}\)</span>,且 <spanclass="math inline">\(x(v)=0\)</span>，表示顶点 <spanclass="math inline">\(v\)</span>不在点覆盖集合里。</p><p>对图中任意一条边 <span class="math inline">\((u,v) \inE\)</span>,由点覆盖定义，顶点<spanclass="math inline">\(u\)</span>、顶点<spanclass="math inline">\(v\)</span> 至少有一个必须在点覆盖中 ，因此：<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>.</p><p>因而得到最小权值点覆盖的规划模型：其中<spanclass="math inline">\(w(v)\)</span> 表示顶点<spanclass="math inline">\(v\)</span>的权值。</p><p><img src="/img/近似算法/整数规划.png" /></p><h3 id="线性规划">线性规划</h3><p>线性规划在整数规划的基础之上不再限定<spanclass="math inline">\(x(v)\)</span>只为0或1，而是有一个范围 <spanclass="math inline">\(x(v) \in [0, 1]\)</span> 这样在整数规划中的<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>仍然成立.这是可以的。因为：前者是后者的一个特例。前者称为0-1整数规划，后者为普通的线性规划。因此，线性规划中的最优解是0-1整数规划最优解的一个下界（因为线性规划最优解包含了0-1整数规划最优解）。</p><p><img src="/img/近似算法/点覆盖-LP规划.png" /></p><p><strong>用线性规划的解来构造最小权值点覆盖问题的近似解算法</strong>:</p><p>对于每一个顶点<spanclass="math inline">\(v\)</span>，都会求得一个<spanclass="math inline">\(x(v)\)</span>的值。若，<spanclass="math inline">\(x(v) \ge 1/2\)</span>,则将该顶点加入到点覆盖集合中，否则舍去顶点<spanclass="math inline">\(v\)</span>，直至图G中所有的顶点都处理完毕。此时得到的顶点集合<spanclass="math inline">\(C\)</span>即为最小权值点覆盖问题的近似解的点覆盖集合。</p><p><strong>线性规划求得的顶点集合C是最小权值点覆盖问题的二倍近似解</strong>:</p><p>设 <span class="math inline">\(C^*\)</span>是最小权值点覆盖问题的一个最优解，<span class="math inline">\(Z\)</span>是线性规划的一个最优解， <spanclass="math inline">\(C\)</span>是最小权值点覆盖问题的近似解.</p><ol type="1"><li>由于最小权值点覆盖问题的一个最优解是线性规划的一个可行解，故：<spanclass="math inline">\(Z \le W(C^*)\)</span>(<spanclass="math inline">\(W\)</span>为求权值的函数)</li><li>为什么求得的集合<spanclass="math inline">\(C\)</span>就是一个点覆盖呢？因为对任意边<spanclass="math inline">\((u,v) \in E\)</span>,有<spanclass="math inline">\(x(u)+x(v)\ge 1\)</span>，即在<spanclass="math inline">\(x(u)\)</span>和<spanclass="math inline">\(x(v)\)</span>中至少有一个的值大于1/2。因此，顶点<spanclass="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>至少有一个会被加入到集合<spanclass="math inline">\(C\)</span>中，从而使得图<spanclass="math inline">\(G\)</span>中的每一条边都会被覆盖。</li><li>由下式</li></ol><p><img src="/img/近似算法/证明线性规划是2倍近似解.png" /></p><p>以及<span class="math inline">\(Z \le W(C^*)\)</span>,知:<spanclass="math inline">\(W(C) \le 2Z &lt;=2W(C^*)\)</span>,即近似解<spanclass="math inline">\(C\)</span>的权值<span class="math inline">\(W(C)\le\)</span> 二倍最优解<spanclass="math inline">\(C^*\)</span>的权值.</p><p>那么是否有比2倍近似解更小的近似解?最小的近似解倍率是多少?</p><p>答:有.</p><p><strong>定理</strong>: 若 P <span class="math inline">\(\ne\)</span>NP,那么没有比<span class="math inline">\(\rho = 1.3607(10\sqrt{5} -21)\)</span>更小的<span class="math inline">\(\rho\)</span>-近似解.</p><h2id="多项式时间逼近算法polynomial-time-approximation-scheme">多项式时间逼近算法(PolynomialTime Approximation Scheme)</h2><p>上面的<spanclass="math inline">\(\rho\)</span>-近似算法是通过牺牲最优解来换取时间和例子,多项式时间逼近算法可以产生任意高质量的解决方案，但以精度换取时间。</p><p>以背包问题为例:物品<spanclass="math inline">\(i\)</span>的价值为<spanclass="math inline">\(v_i\)</span> ,重量为<spanclass="math inline">\(w_i\)</span>;背包最多可以拿的物品重量为<spanclass="math inline">\(W\)</span>.现在求最大可以拿取的物品价值。</p><p><img src="/img/近似算法/背包问题-例子.png" /></p><h3 id="方法1动态规划-1">方法1：动态规划-1</h3><p>定义<spanclass="math inline">\(OPT(i,w)=\)</span>所有物品中可以拿到的<strong>最大价值</strong>。</p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>新的容量为<span class="math inline">\(w-w_i\)</span></li><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w-w_i\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划1.png" /></p><p>运行时间：<span class="math inline">\(O(n W)\)</span></p><ul><li><span class="math inline">\(W=\)</span>重量限制</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="方法2动态规划2">方法2：动态规划2</h3><p>定义<span class="math inline">\(OPT(i,v)=\)</span>物品<spanclass="math inline">\(1,2,\dots,i\)</span>中拿取且得到的物品价值为<spanclass="math inline">\(v\)</span>所消耗的<strong>最小重量</strong></p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>消耗重量<span class="math inline">\(w_i\)</span>,且新的价值为<spanclass="math inline">\(v-v_i\)</span></li><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划2.png" /></p><p>运行时间：<span class="math inline">\(O(n V^*)=O(n^2v_{max})\)</span></p><ul><li><span class="math inline">\(V^*\)</span>为在<spanclass="math inline">\(OPT(n, v) \leW\)</span>的情况下可以选取的最大价值</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="多项式时间逼近算法">多项式时间逼近算法</h3><p>以上的动态规划都可以得到最优解，但是考虑一个问题：若所有物品的价值远大于重量的时候，上面的动态规划还可行吗？</p><p>这时候问题的输入不是多项式的（物品的价值，因为在计算机内数据都要转化为2进制再处理），这时候为了使求解时间更快，引入了新的算法<strong>多项式时间逼近算法（PolynomialTime Approximation Scheme）</strong>。它的大致思想是：</p><ul><li>将所有的价值向上舍入到一个较小的范围里</li><li>在向上舍入后的实力上运行动态规划算法</li><li>得到向上舍入实例的最优解</li></ul><p>注：这里一定要是向上舍入而不能是四舍五入，虽然全部向上舍入可能会在原来的问题中丢失一些较为优质的解，但是若四舍五入的时候，若有向下舍去的价值，可能在新的实例中找到的解在原问题中是不可行解。</p><p><img src="/img/近似算法/背包问题-四舍五入.png" /></p><p>首先对所有价值向上舍入：</p><p><img src="/img/近似算法/向上舍入.png" /></p><ul><li><spanclass="math inline">\(v_{max}\)</span>为原始例子里的最大价值</li><li><span class="math inline">\(\varepsilon\)</span>为精确参数</li><li><span class="math inline">\(\theta\)</span>为放缩因子</li></ul><p>对于放缩之后的例子，复杂度<span class="math inline">\(O(n^3 /\varepsilon)\)</span>,使用上面的动态规划-2方法的运行时间为<spanclass="math inline">\(0(n^2 \hat{v}_{max})\)</span>.</p><p>其中</p><p><img src="/img/近似算法/公式1.png" /></p><p><strong>定理</strong>：若<spanclass="math inline">\(S\)</span>为多项式时间逼近算法找到的一个解，同时<spanclass="math inline">\(S^*\)</span>为另一个可行解，那么有 <spanclass="math inline">\((1+\varepsilon) \sum\limits_{i \in S}v_i \ge\sum\limits_{i \in S^*}v_i\)</span></p><p>证明：</p><p><img src="/img/近似算法/多项式时间逼近算法-证明.png" /></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NP问题以及常见多项式规约</title>
    <link href="/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="pnpnpcnph问题">P、NP、NPC、NPH问题</h2><p><strong>P问题</strong>：存在多项式时间算法的决策问题。</p><p><strong>NP问题</strong>：能在多项式时间内验证某个猜想答案的正确性，但问题求解可能在无法在多项式时间内完成。比如Composite问题、3-Satisfiability、HamiltonianCycle，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。</p><p><strong>结论1</strong>：P <spanclass="math inline">\(\subseteq\)</span> NP</p><p><strong>结论2</strong>：NP <spanclass="math inline">\(\subseteq\)</span> EXP</p><p><strong>EXP问题</strong>：存在指数时间算法的决策问题。</p><p><strong>NPC问题</strong>: 需要满足两个条件</p><ul><li>它是一个NP问题</li><li>所有的NP问题都可以规约到NP-complete</li></ul><p><strong>定理</strong>：若Y是一个NPC问题，那么Y可以在多项式时间内求解<strong>当且仅当</strong>P<spanclass="math inline">\(=\)</span>NP</p><p>证明：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若P <span class="math inline">\(=\)</span>NP，那么Y可以在多项式时间求解，因为Y是NP（NPC的第一个条件：它要先是一个NP）</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若Y可以在多项式时间求解： - 令X为任意一个NP问题，因为X <spanclass="math inline">\(\le_p\)</span>Y，而Y可以在多项式时间求解，故X也可以在多项式时间求解。NP <spanclass="math inline">\(\subseteq\)</span> P - 又已知P <spanclass="math inline">\(\subseteq\)</span> NP,所以 P <spanclass="math inline">\(=\)</span> NP</p><p><strong>如果</strong>我们给NPC问题找到了一个多项式时间复杂度的算法，那么也就意味着我们给所有的NP问题找到了多项式时间复杂度的算法，从而NP=P，因为P=NP，所以“P对NP问题”就可以被解决。但给NPC问题找一个多项式时间复杂度的算法太难了，所以现在人们普遍相信P≠NP。</p><p><strong>NPH问题</strong>：满足上面NPC问题的第二个条件，但不一定要满足第一个条件，所以NPH的范围比HPC更大。</p><h3 id="证明一个问题是npc问题的步骤">证明一个问题是NPC问题的步骤</h3><ul><li>证明这个问题Y属于NP</li><li>选择一个NPC问题X</li><li>证明X可以多项式规约到Y</li></ul><h3 id="证明一个问题是nph问题的步骤">证明一个问题是NPH问题的步骤</h3><p>要证明一个问题是NP-hard，通常是找到一个已被证明了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC<span class="math inline">\(\le\)</span> NP-hard）,简单来说就是：</p><ul><li>对问题A给定限制条件得到一个特例B问题</li><li>证明问题B是NPC问题</li></ul><h2 id="npc之间规约的例子">NPC之间规约的例子</h2><h3 id="sat-le_p-independent-set">3-SAT <spanclass="math inline">\(\le_p\)</span> Independent Set</h3><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造:</p><ul><li>3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点</li><li>连接句子里的点连接形成三角形</li><li>连接不同Clause里每个Literal和它对应的非</li></ul><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h3 id="hamiltonian-cycle-problem">Hamiltonian Cycle problem</h3><p><strong>Hamiltonian Cycle</strong>:给定一个无向图 <spanclass="math inline">\(G=(V,E)\)</span>，是否存在一个简单的环 <spanclass="math inline">\(\Gamma\)</span> 包含 <spanclass="math inline">\(V\)</span> 中所有的点。</p><figure><img src="/img/多项式规约/HamiltonianCycle定义.png"alt="有奇数个节点的Hamiltonian Cycle" /><figcaption aria-hidden="true">有奇数个节点的HamiltonianCycle</figcaption></figure><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p><strong>DIR-HAM-CYCL <span class="math inline">\(\le_p\)</span>Ham-Cycle</strong>: 证明：给定一个有向图<spanclass="math inline">\(G=(V,E)\)</span>,构造一个有<spanclass="math inline">\(3n\)</span>个节点的无向图<spanclass="math inline">\(G&#39;\)</span>，则<spanclass="math inline">\(G\)</span>有Hamiltonian Cycle当且仅当<spanclass="math inline">\(G&#39;\)</span>有Hamiltonian Cycle。</p><p><img src="/img/多项式规约/DIR-HAM-CYC2Ham-Cycle.png" /></p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若<span class="math inline">\(G\)</span>中有一个有向的HamiltonianCycle，则<spanclass="math inline">\(G&#39;\)</span>中肯定也有一个HamiltonianCycle，且顺序与有向图的节点顺序相同。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若<spanclass="math inline">\(G&#39;\)</span>中有一个无向的HamiltonianCycle，则从蓝色节点出发，节点的颜色出现顺序必然是两种中的一种 -B,G,R,B,G,R,<span class="math inline">\(\dots\)</span> -B,R,G,B,R,G,<span class="math inline">\(\dots\)</span></p><p>若<span class="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第一种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相同；若<spanclass="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第二种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相反。</p><h3 id="sat-le_p-hamiltonian-cycle-problem">3SAT <spanclass="math inline">\(\le_p\)</span> Hamiltonian Cycle problem</h3><!-- **Vertex Cover**：一组顶点的集合，使得图的每条边至少与集合中的一个顶点相连接。在这里Vertex Cover问题是给定图$G$和点集的个数$k$，要找到图$G$的一个大小为$k$的点覆盖。（也就是常说的最小点覆盖） --><p><strong>构造思路:有<spanclass="math inline">\(n\)</span>个变量的3-SAT有<spanclass="math inline">\(2^n\)</span>种可能的分配，要将其规约到HamiltonianCycle，其对应的Hamiltonian Cycle应该也有<spanclass="math inline">\(2^n\)</span>种可能的分配方式。</strong></p><p>构造方法：对一个有<span class="math inline">\(n\)</span>个变量和<spanclass="math inline">\(k\)</span>个句子的3-SAT,构造<spanclass="math inline">\(3k+3\)</span>个节点的HamiltonianCycle，其中每个变量<span class="math inline">\(x_i\)</span>对应<spanclass="math inline">\(3k+3\)</span>个节点，令外再增加一个源点<spanclass="math inline">\(s\)</span>、一个汇点<spanclass="math inline">\(t\)</span>。</p><p><img src="/img/多项式规约/3-SAT2Ham-Cycle构造.png" /></p><p>如果 <spanclass="math inline">\(x_i=1\)</span>，则形成从左向右的一个路径；如果<spanclass="math inline">\(x_i=0\)</span>，则形成从右向左的一个路径。</p><p>对于每一个clause <span class="math inline">\(c_j=z_1 z_2z_3\)</span>，若<span class="math inline">\(z=x_i\)</span>,则添加有向边<spanclass="math inline">\((v_{i,3j},c_j)和(c_j,v_{i,3j+1})\)</span>;若<spanclass="math inline">\(z=\bar{x}_i\)</span>,则添加有向边<spanclass="math inline">\((c_j,v_{i,3j})和(v_{i,3j+1},c_j)\)</span>，这里<spanclass="math inline">\(1\le j\le m, 1\le i\len\)</span>。如上图所示（即若<spanclass="math inline">\(z=x_i\)</span>,该节点与<spanclass="math inline">\(c\)</span>节点的连接顺序是从左边进入<spanclass="math inline">\(c\)</span>节点，然后从右边出<spanclass="math inline">\(c\)</span>节点；反之顺序相反）。</p><p>如果选择子句<span class="math inline">\(C_1\)</span>中<spanclass="math inline">\(x_1=1\)</span>,则<spanclass="math inline">\(x_1\)</span>对应的路径为从左向右;同理<spanclass="math inline">\(x_2=0\)</span>,则<spanclass="math inline">\(x_2\)</span>对应的路径为从右向左；<spanclass="math inline">\(x_3=1\)</span>,则<spanclass="math inline">\(x_3\)</span>对应的路径为从左向右。其余句子同理，这样就得到了最终的图<spanclass="math inline">\(G\)</span>。</p><p><strong>证明</strong>:</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>假设3-SAT有一个可满足的分配<spanclass="math inline">\(x^*\)</span>：</p><ul><li>对于<span class="math inline">\(x_i\)</span>,若其为1，则第<spanclass="math inline">\(i\)</span>行从左往右遍历；反之，若其为0，则第<spanclass="math inline">\(i\)</span>行从右往左遍历</li><li>且对于每个句子节点<spanclass="math inline">\(c_i\)</span>，至少会有一行便利的时候会经过<spanclass="math inline">\(c_i\)</span>，否则便不满足每个句子都为真的条件，也就是该分配并不是可满足的。</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>假设构造的图<spanclass="math inline">\(G\)</span>有一个Ham-Cycle，那么</p><ul><li>若Ham-Cycle进入句子节点<spanclass="math inline">\(c_i\)</span>，那么它一定会返回相同的行，否则便不存在简单环。</li><li>这样Ham-Cycle里的句子节点<spanclass="math inline">\(c_i\)</span>与同一行的两个相邻节点相连，记这两个相邻节点之间的边为<spanclass="math inline">\(e_i\)</span></li><li>去掉句子节点<span class="math inline">\(c_i\)</span>，同时用<spanclass="math inline">\(e_i\)</span>替换与<spanclass="math inline">\(c_i\)</span>相连的两条边。</li><li>按上面的方法去掉所有的句子节点得到图也必然存在Ham-Cycle，且节点的顺序是相同的。</li><li>若Ham-Cycle的第<spanclass="math inline">\(i\)</span>行是从左往右遍历的，便令<spanclass="math inline">\(x_i=1\)</span>;反之则令<spanclass="math inline">\(x_i=0\)</span>，这样便得到一个分配方案，且其是可满足的。</li></ul><p>这样便得到一个分配方式，且每个句子都是可满足的。</p><h3 id="ham-cycle-le_p-tsptraveling-saleperson-problem">HAM-CYCLE <spanclass="math inline">\(\le_p\)</span> TSP(Traveling SalepersonProblem)</h3><p><strong>TSP(Traveling Saleperson Problem)</strong>：给定一个<spanclass="math inline">\(n\)</span>个城市的集合以及城市之间的距离<spanclass="math inline">\(d(u,v)\)</span>,是否存在一个旅行的路线使行走的距离<spanclass="math inline">\(\le n\)</span>?</p><p>旅行者问题与HAM-CYCLE的区别在于：旅行者问题并不限定简单路径，也就是说一个节点可以通过多次，只需要考虑最后的路径长度。</p><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p>$HAM-CYCLE <span class="math inline">\(\le_p\)</span> TSP(TravelingSaleperson Problem)$</p><p><strong>构造</strong>：给定一个HAM-CYCLE的实例<spanclass="math inline">\(G=(V,E)\)</span>,<spanclass="math inline">\(V\)</span>中的每个节点构造一个城市节点，城市之间的距离根据<spanclass="math inline">\(E\)</span>进行赋值: <spanclass="math display">\[d(u,v)= \begin{cases}    1, (u,v) \in E  \\    2, (u,v) \notin E\end{cases}\]</span></p><p>则TSP中有一个旅行路径<span class="math inline">\(\len\)</span>当且仅当<spanclass="math inline">\(G\)</span>中存在HAM-CYCLE</p><h3 id="sat-le_p-3-colorable">3-SAT <spanclass="math inline">\(\le_p\)</span> 3-Colorable</h3><p><strong>3-Colorable</strong>:给定一个无向图<spanclass="math inline">\(G\)</span>，并给图中的每个节点染上红、蓝、绿的其中一种颜色，那么是否存在一种染色方式使相邻的节点都有不同的颜色？</p><p>3-SAT <span class="math inline">\(\le_p\)</span> 3-Colorable</p><p><strong>构造</strong>：</p><ul><li>对每个Literal，构造一个节点</li><li>同时添加三个节点<spanclass="math inline">\(T、F、B\)</span>，连接这三个节点形成一个三角形</li><li>对每个literal节点，创建一个它的"非"并与它相连</li><li>所有的Literal节点都与<span class="math inline">\(B\)</span>相连</li></ul><p>如下图所示： <imgsrc="/img/多项式规约/3-SAT23-COLOLABLE-1.png" /></p><p>这样构造保证了下面的每个Literal节点都是绿色或红色，且它的“非”与它的颜色刚好相反。</p><p>继续接上面：</p><ul><li>对每个Clause，假设<span class="math inline">\(C_i=x_1 \vee\overline{x_2} \vee x_3\)</span>,则对<span class="math inline">\(x_1 ,\overline{x_2} , x_3\)</span>添加6个节点以及13条边</li></ul><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-2.png" /></p><p>即<span class="math inline">\(x_1 , \overline{x_2} ,x_3\)</span>下方的两行一共6个节点，并将左下角的节点、第一行的节点与之前构造的<spanclass="math inline">\(T\)</span>节点相连，右下角的节点与之前的<spanclass="math inline">\(F\)</span>节点相连。</p><p>这样构造是为了保证当三个Literal节点全为红色的时候，是不满足三着色的，如下图所示：当三个Literal节点全为红色的时候，他们下面那行节点必须为蓝色，这样最后一行从左到右着色，最后一个节点冲突。</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-3.png" /></p><p><strong>3-SAT <span class="math inline">\(\le_p\)</span>3-Colorable</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若图3-Colorable：</p><ul><li>将所有为绿色的Literal节点设为真</li><li>由上面可知，当图3-Colorable的时候三个Literal节点至少有一个是绿色的，那么该句子的输出为真</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>若3-SAT是可满足的：则 - 三个Literal节点至少有一个为真 -将为真的Literal节点染为绿色，然后将该节点下面的节点染为红色（否则会冲突），再继续将下面的节点染为蓝色-对中间一行没有染红的节点染为蓝色，然后它们下面一行没有染色的节点可唯一确定颜色</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-4.png" /></p><p>上面没有染色的Literal节点绿色、红色皆可。</p><h3 id="color搜索问题-le_p-3-color判断问题自规约">3-COLOR搜索问题 <spanclass="math inline">\(\le_p\)</span> 3-COLOR判断问题（自规约）</h3><p><strong>方法1</strong>：</p><p>将3-COLOR图中不相邻的点合并，合并后的点表示之前所有合并过来点的集合，如下图所示：</p><p><img src="/img/多项式规约/3-color自规约.png" /></p><p>然后一直重复上述步骤，若图可以进行3着色，那么到最后图必然会合并为一个三角形。染色是对最后的三角形三个点所代表的点的集合染成不同的颜色，便为最后的3着色。</p><p><strong>方法2</strong>：</p><p>设判定算法为<span class="math inline">\(D\)</span></p><ol type="1"><li>调用算法<spanclass="math inline">\(D\)</span>判断原图是否有解，若无解，则返回NO。</li><li>任意选择一对边<span class="math inline">\((u,v)\)</span>，满足<spanclass="math inline">\((u,v) \notin E\)</span><ol type="1"><li>考虑图<span class="math inline">\(G&#39; = G +(u,v)\)</span>，调用<spanclass="math inline">\(D\)</span>判断是否有解。</li><li>若<span class="math inline">\(G&#39;\)</span>无解，标记点对<spanclass="math inline">\((u,v)\)</span>；若有解，添加边<spanclass="math inline">\((u,v)\)</span>到<spanclass="math inline">\(G\)</span>中。</li></ol></li><li>返回步骤2，继续选择一对未标记点对。</li><li>若图<spanclass="math inline">\(G\)</span>构成一个三部完全图，每一部选择一个颜色，输出颜色方案。### 点覆盖搜索问题 <span class="math inline">\(\le_p\)</span>点覆盖判断问题</li></ol><ul><li>从1开始，依次查找该图有没有<spanclass="math inline">\(k^*\)</span>个顶点的顶点覆盖(这样得到的第一次满足的<spanclass="math inline">\(k^*\)</span> 的值就是该图最小顶点覆盖的数目)</li><li>从图中选出一个点<span class="math inline">\(v\)</span>，若去除该点后图的顶点覆盖数目变为<span class="math inline">\(k^* −1\)</span>，则<spanclass="math inline">\(v\)</span>是原图顶点覆盖中的一员，反之则不是</li><li>在<span class="math inline">\(G −v\)</span>中递归执行上述两步。</li></ul><h3 id="ham-cycle搜索问题-le_p-ham-cycle判断问题">Ham-Cycle搜索问题<span class="math inline">\(\le_p\)</span> Ham-Cycle判断问题</h3><p>证明：若可以在多项式时间内给出判定一个图是否存在哈密尔顿圈，则可以在多项式时间内找到一个图的哈密尔顿圈（如果存在的话）</p><p>首先判断<spanclass="math inline">\(G\)</span>中是否存在Ham-Cycle,若不存在则算法结束，如果存在则继续寻找Ham-Cycle:<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">对G中的每条边e<br>&#123;<br>    若G-e不存在Ham-<span class="hljs-keyword">Cycle</span>，将e加入S中；<br>    否则令G=G-e<br>&#125;<br>最后所得的集合便是一个Ham-<span class="hljs-keyword">Cycle</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式规约</title>
    <link href="/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="多项式规约">多项式规约</h2><p>定义：若问题X 的任意实例可以由下面两条之和解决</p><ul><li>问题X可以通过多项式时间的基本运算步骤转换为问题Y；</li><li>问题X多项式次调用求解问题Y的算法，且问题Y可以在多项式时间内被求解。</li></ul><p>那么称问题X可以多项式规约到问题Y，记为 $ X _{p} Y$。需要注意的是，问题X转换为问题Y之后，问题Y的运行时间是建立在问题Y的输入上。</p><p>多项式规约的几个性质：</p><ul><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若Y能在多项式时间内求解，那么X也能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若X不能在多项式时间内求解，那么Y也不能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p} Y\)</span> 且 <spanclass="math inline">\(Y \le_{p} X\)</span>，那么X和Y是等价的。</li></ul><h3 id="基本的规约方法">基本的规约方法</h3><ul><li>简单的恒等归约：比如最大独立集和最小点覆盖。</li><li>从特殊例子到一般例子：比如 <span class="math inline">\(点覆盖\le_{p} 集合覆盖\)</span>。<br /></li><li>通过一些小技巧规约。比如 <span class="math inline">\(3-SAT \le_{p}独立集\)</span></li></ul><h3 id="简单的恒等规约">简单的恒等规约</h3><h4 id="独立集问题independent-set">独立集问题（Independent Set）</h4><p><strong>定义</strong>：给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k(V为顶点集，E为边集)，是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \gek\)</span>并且图中每条边至多有一个顶点在S中？</p><figure><img src="/img/多项式规约/独立集.png" alt="独立集" /><figcaption aria-hidden="true">独立集</figcaption></figure><h4 id="点覆盖问题vertex-cover">点覆盖问题（Vertex Cover）</h4><p><strong>定义</strong>:给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k,是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \lek\)</span>并且图中的每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中？</p><figure><img src="/img/多项式规约/点覆盖.png" alt="点覆盖" /><figcaption aria-hidden="true">点覆盖</figcaption></figure><h4 id="vertex-cover和independent-set的关系">Vertex Cover和IndependentSet的关系</h4><p><strong>定理： <span class="math inline">\(点覆盖 \equiv_p独立集\)</span></strong></p><p>证明如下：</p><p><span class="math inline">\(\Rightarrow\)</span></p><ul><li>令<span class="math inline">\(S\)</span>为任意独立集</li><li>对任意的边 <span class="math inline">\((u,v)\)</span></li><li><span class="math inline">\(S\)</span>是独立集 <spanclass="math inline">\(\Rightarrow\)</span> <span class="math inline">\(u\notin S\)</span> 或 <span class="math inline">\(v \notin S \Rightarrowu \in V - S\)</span> 或 <span class="math inline">\(v \in V -S\)</span></li><li>所以 <span class="math inline">\(V-S\)</span> 是一个点覆盖</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><ul><li>令 <span class="math inline">\(V-S\)</span>是一个点覆盖</li><li>对两个顶点 <span class="math inline">\(u \in S\)</span> 及 <spanclass="math inline">\(v \in S\)</span></li><li>若 <span class="math inline">\(V-S\)</span> 是一个点覆盖,那么 <spanclass="math inline">\((u, v) \notin E\)</span></li><li>因此，没有相邻的顶点在 <span class="math inline">\(S\)</span> 中<span class="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(S\)</span>是独立集</li></ul><h3 id="从特殊例子到一般例子">从特殊例子到一般例子</h3><h4 id="集合覆盖set-cover">集合覆盖（Set Cover）</h4><p><strong>定义</strong>：给定一个集合<spanclass="math inline">\(U\)</span>，以及<spanclass="math inline">\(U\)</span>的子集<spanclass="math inline">\(S_1,S_2,\dots,S_m\)</span>以及一个整数<spanclass="math inline">\(k\)</span>，是否存在小于或等于<spanclass="math inline">\(k\)</span>个子集<spanclass="math inline">\(S_i\)</span>的并等于<spanclass="math inline">\(U\)</span>?</p><p><strong>例子</strong>:</p><figure><img src="/img/多项式规约/集合覆盖例子.png" alt="几何覆盖例子" /><figcaption aria-hidden="true">几何覆盖例子</figcaption></figure><h4 id="vertex-cover归约到set-cover">Vertex Cover归约到Set Cover</h4><p><strong>证明：给定一个Vertex-Cover的实例<spanclass="math inline">\(G=(V,E),k\)</span>,可以构造一个与VertexCover大小相等的Set Cover的实例。（从特殊例子到一般例子）</strong></p><ul><li>创建一个Set Cover的实例<span class="math inline">\(k = k,U=E,S_v=\{e\in E: 与V相连的边\}\)</span></li><li>可以看到Set Cover的<span class="math inline">\(size \lek\)</span>当且仅当Vertex Cover的<span class="math inline">\(size \lek\)</span></li></ul><p><strong>例子</strong>：有如下点覆盖</p><p><img src="/img/多项式规约/VertexCover归约到SetCover例子.png" /></p><p>构造Set Cover的<span class="math inline">\(U\)</span>为VertexCover的边集，即<span class="math inline">\(U=(1,2,3,4,5,6)\)</span>，SetCover的每个子集<span class="math inline">\(S_i\)</span>为VertexCover中对应顶点所连的边,故有 <span class="math display">\[    S_a=\{3,7\}， \\    S_b=\{2,4\}， \\    S_c=\{3,4,5,6\}， \\    S_d=\{5\}，  \\    S_e=\{1\}， \\    S_f=\{1,2,6,7\}    \]</span></p><p>可以看到<span class="math inline">\(S_c\)</span>和<spanclass="math inline">\(S_f\)</span>构成一个SetCover的实例，而这两个子集对应的顶点恰好组成一个Vertex Cover的实例。</p><h3 id="通过小技巧规约">通过"小技巧"规约</h3><h4 id="sat问题">3-SAT问题</h4><p><strong>Literal（字）</strong>：一个布尔变量或者它的非<spanclass="math inline">\(x_i \quad or \quad \overline{x_i}\)</span></p><p><strong>Clause（句子）</strong>：Literal的析取 <spanclass="math inline">\(C_j = x_1 \vee \overline{x_2} \veex_3\)</span></p><p><strong>Formula（式子）</strong>：Clause的合取 <spanclass="math inline">\(\Phi=C_1 \wedge C_2 \wedge C_3 \wedgeC_4\)</span></p><p><strong>SAT</strong>:给定CNF式子<spanclass="math inline">\(\Phi\)</span>，是否存在一个满足结果是True的分配<spanclass="math inline">\(x_1,\dots,x_n\)</span>？若有则称式子<spanclass="math inline">\(\Phi\)</span>是<strong>可满足</strong>的。</p><p><strong>3-SAT</strong>:每个Clause只有三个Literals。</p><p><strong>例子</strong>：</p><p><img src="/img/多项式规约/3-SAT例子.png" /></p><h4id="satisfiability3-sat归约到independent-set">3-Satisfiability（3-SAT）归约到IndependentSet</h4><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造: -3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点 -连接句子里的点连接形成三角形 -连接不同Clause里每个Literal和它对应的非</p><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h2 id="自规约重要">自规约（重要）</h2><p><strong>决策问题（Decision Problem）</strong>：诸如"是否存在一个<spanclass="math inline">\(size \ge k\)</span>的点覆盖"</p><p><strong>求解问题（SearchProblem）</strong>：诸如"寻找一个最小的点覆盖"</p><p><strong>自规约（Self-Reducibility）</strong>：Search Problem <spanclass="math inline">\(\le_p\)</span> Decision Problem</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大流最小割</title>
    <link href="/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <url>/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小割">最小割</h2><p>在图论中，去掉其中所有边能使一张网络流图不再连通（即分成两个子图）的边集称为图的割。一个$st-cut $即去掉的边把源点s和汇点t划分在两个不同的部分。</p><figure><img src="/img/最大流最小割/最小割定义.png" alt="最小割定义" /><figcaption aria-hidden="true">最小割定义</figcaption></figure><p>一般来说，一张图中有多个不同的<spanclass="math inline">\(st-cut\)</span>，如下图便为其中一个 <spanclass="math inline">\(st-cut\)</span> 。</p><figure><img src="/img/最大流最小割/一个割例子.png" alt="一个割例子" /><figcaption aria-hidden="true">一个割例子</figcaption></figure><p>但是在实际应用中，我们去掉每条边往往都是有代价的，以边的容量作为权值，一个割中去掉的边的权值之和为这个割的值，那么最小割就是这张图上最小的割。</p><h2 id="最大流">最大流</h2><p>为了求解最小割，需要引入最大流的概念。用边的权值表示边的最大流量，一个<span class="math inline">\(st-flow\)</span>是从源点s到汇点t的流量。通俗的讲，最大流就是从源点s到汇点t的最大流量。</p><figure><img src="/img/最大流最小割/最大流.png" alt="最大流" /><figcaption aria-hidden="true">最大流</figcaption></figure><h2 id="求解最大流">求解最大流</h2><h3 id="贪心算法">贪心算法</h3><ul><li>开始时对每条边e令<span class="math inline">\(f(e)=0\)</span></li><li>找到一条从源点s到汇点t的路径 <span class="math inline">\(s\rightarrow t\)</span> 使路径上的每条边e满足 <spanclass="math inline">\(f(e)&lt;c(e)\)</span> ,其中 <spanclass="math inline">\(c(e)\)</span> 为边e的权值</li><li><span class="math inline">\(flow = flow + 路径上的流量\)</span></li><li>重复上述步骤直至找不到新的路径</li></ul><h3 id="ford-fulkerson算法">Ford-Fulkerson算法</h3><h4 id="残留图residual-graph">残留图(Residual Graph)</h4><p>在另一个图中，额外构造一个反向边，权值是实际流过该边的流量 <spanclass="math inline">\(f(e)\)</span> 。</p><figure><img src="/img/最大流最小割/残余图.png" alt="残余图" /><figcaption aria-hidden="true">残余图</figcaption></figure><p>剩余图有以下性质： - <strong>增广路径(AugmentingPath)</strong>:一个增广路径P是从残余图中的一条简单路径 <spanclass="math inline">\(s \rightarrow t\)</span> -增广路径的容量是该条路径所有边中的最小权值</p><h4 id="算法说明">算法说明</h4><ul><li>每次找到一条从s到t的增广路径，并调整flow和残留图，不断调整直到没有增广路径</li><li>当残留图中不存在从s到t的增广路径时，该图已经达到最大流</li></ul><h4 id="例子">例子</h4><p>初始时没有反向边,此时残留图等于原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子1.png" /></p><p>从中选取一条增广路径,并更新残留图和原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子2.png" /></p><p>重复上面的步骤,注意<strong>增广路径一定要从残留图中找</strong>,且可以使用残留图中的反向边.</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子3.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子4.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子5.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子6.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>此时,没有新的增广路径,则最大流的值等于流进s的流量,即 <spanclass="math inline">\(flow = s_{in}\)</span></p><h2 id="最大流与最小割的关系">最大流与最小割的关系</h2><p><strong>最大流最小割定理：最大流=最小割。</strong>最大流-最小割定理用来证明Ford-Fulkson方法的确达到了最大流.</p><figure><img src="/img/最大流最小割/最大流最小割定理.png"alt="最大流最小割定理" /><figcaption aria-hidden="true">最大流最小割定理</figcaption></figure><p>证明:</p><ul><li><span class="math inline">\((i) \Rightarrow (ii)\)</span>:弱对偶性法则的推论</li><li><span class="math inline">\((ii) \Rightarrow (iii)\)</span>:反证法<br />若f是一个最大流,且仍存在增广路径,那么可以让f加上增广路径的流量,与f是一个最大流相悖.故<spanclass="math inline">\((ii) \Rightarrow (iii)\)</span>成立</li><li><span class="math inline">\((iii) \Rightarrow (i)\)</span></li></ul><p>设f是一个流,且没有增广路径,令A等于s的可达顶点集,则</p><p><img src="/img/最大流最小割/iii到i.png" /></p><h2 id="求出最大流之后如何求最小割">求出最大流之后如何求最小割</h2><p>求完最大流之后，在残留图中用BFS遍历，结束后可得到一个从<spanclass="math inline">\(s\)</span>出发可达的集合，将原图分为两个子集合，<spanclass="math inline">\(s\)</span>可达的集合<spanclass="math inline">\(X\)</span>以及<spanclass="math inline">\(s\)</span>不可达的集合<spanclass="math inline">\(Y\)</span>,其中<spanclass="math inline">\(Y\)</span>中必然包含汇点<spanclass="math inline">\(t\)</span>。</p><p>连接两个集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的边有两种情况</p><ul><li>已被占满的前向边</li><li>没有流量的反向边(即从<span class="math inline">\(Y\)</span>到<spanclass="math inline">\(X\)</span>的边)</li></ul><p>其中被占满的前向边集合就是所求的最小割</p><p>还是用上面的例子 <imgsrc="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>在<span class="math inline">\(G_f\)</span>中,用BFS遍历可得<spanclass="math inline">\(s\)</span>可达的顶点集合为<spanclass="math inline">\(\{s, 3\}\)</span>，在<spanclass="math inline">\(G\)</span>中查看<span class="math inline">\(\{s,3\}\)</span>与图中剩余顶点集合的关系。</p><ul><li>已被占满的前向边:<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span></li><li>没有流量的反向边:<span class="math inline">\(2 \rightarrow3\)</span></li></ul><p>所以图中的一个最小割为<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git撤销commit命令">Git撤销commit命令</h2><p>当要撤销的提交不是最开始的提交时 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD~<br></code></pre></td></tr></table></figure>当要撤销的提交时最开始的提交时 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">update</span> <span class="hljs-operator">-</span><span class="hljs-keyword">ref</span> <span class="hljs-operator">-</span>d HEAD<br></code></pre></td></tr></table></figure> ## Git连接远程仓库<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>url<br></code></pre></td></tr></table></figure> 注：url为github仓库链接 ## Git删除已经add的文件1.要删除的文件少时 一种是 <code>git rm --cached</code>"文件路径"，不删除物理文件，仅将该文件从缓存中删除； 一种是<code>git rm --f</code>"文件路径"，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。</p><p>2.要删除的文件多时 <code>git rm -r --cached</code> . 清空缓存区然后将本地文件删除，再次<code>add</code></p><h2 id="git创建远程新分支">Git创建远程新分支</h2><p>git无法直接通过命令方式创建远程新分支，需要间接来创建,这里我创建的远程新分支名叫vedio</p><p>首先</p><p><code>git checkout --orphan 分支名</code> <imgsrc="https://img-blog.csdnimg.cn/20210403164118752.png" /> <strong>gitrm -rf .</strong> （这一步很关键）然后创建一个文件readme.md（其实任何文件都可以），add并commit，然后</p><p><code>git push origin 分支名</code></p><p>就可以啦~如下图红框圈注的命令 <imgsrc="https://img-blog.csdnimg.cn/20210403164816128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTQyMQ==,size_16,color_FFFFFF,t_70" /></p><h2id="git强制提交本地分支覆盖远程分支">git强制提交本地分支覆盖远程分支</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> localBranchName:remoteBranchName --force<br></code></pre></td></tr></table></figure><h2 id="git从远程仓库拉取">Git从远程仓库拉取</h2><p><code>git pull origin main</code></p><h2 id="git创建与切换分支">Git创建与切换分支</h2><p>创建分支 <code>git branch branch_name</code> 切换分支<code>git checkout branch_name</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Latex常用表示</title>
    <link href="/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th>小写字母</th><th>语法</th><th>大写字母</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(A\)</span></td><td><code>A</code></td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td><td><span class="math inline">\(B\)</span></td><td><code>B</code></td></tr><tr class="odd"><td><span class="math inline">\(\gamma\)</span></td><td><code>\gamma</code></td><td><span class="math inline">\(\Gamma\)</span></td><td><code>\Gamma</code></td></tr><tr class="even"><td><span class="math inline">\(\delta\)</span></td><td><code>\delta</code></td><td><span class="math inline">\(\Delta\)</span></td><td><code>\Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td><td><span class="math inline">\(E\)</span></td><td><code>E</code></td></tr><tr class="even"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(Z\)</span></td><td><code>Z</code></td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td><td><span class="math inline">\(H\)</span></td><td><code>H</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span></td><td><code>\theta</code></td><td><span class="math inline">\(\Theta\)</span></td><td><code>\Theta</code></td></tr><tr class="even"><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(I\)</span></td><td><code>I</code></td></tr><tr class="even"><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td><td><span class="math inline">\(K\)</span></td><td><code>K</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span></td><td><code>\lambda</code></td><td><span class="math inline">\(\Lambda\)</span></td><td><code>\Lambda</code></td></tr><tr class="even"><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td><td><span class="math inline">\(M\)</span></td><td><code>M</code></td></tr><tr class="odd"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(N\)</span></td><td><code>N</code></td></tr><tr class="even"><td><span class="math inline">\(\xi\)</span></td><td><code>\xi</code></td><td><span class="math inline">\(\Xi\)</span></td><td><code>\Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(O\)</span></td><td><code>O</code></td></tr><tr class="even"><td><span class="math inline">\(\pi\)</span></td><td><code>\pi</code></td><td><span class="math inline">\(\Pi\)</span></td><td><code>\Pi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td><td><span class="math inline">\(R\)</span></td><td><code>R</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\sigma\)</span></td><td><code>\sigma</code></td><td><span class="math inline">\(\Sigma\)</span></td><td><code>\Sigma</code></td></tr><tr class="odd"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td><td><span class="math inline">\(T\)</span></td><td><code>T</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td><code>\upsilon</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span></td><td><code>\phi</code></td><td><span class="math inline">\(\Phi\)</span></td><td><code>\Phi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td><td><span class="math inline">\(X\)</span></td><td><code>X</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span></td><td><code>\psi</code></td><td><span class="math inline">\(\Psi\)</span></td><td><code>\Psi</code></td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span></td><td><code>\omega</code></td><td><span class="math inline">\(\Omega\)</span></td><td><code>\Omega</code></td></tr></tbody></table><p>var开头的只有小写希腊字母，没有大写。</p><h2 id="运算符符号">运算符符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td></tr><tr class="even"><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="odd"><td><span class="math inline">\(\int\)</span></td><td><code>\int</code></td></tr><tr class="even"><td><span class="math inline">\(\oplus\)</span></td><td><code>\oplus</code></td></tr><tr class="odd"><td><span class="math inline">\(\otimes\)</span></td><td><code>\otimes</code></td></tr><tr class="even"><td><span class="math inline">\(\times\)</span></td><td><code>\times</code></td></tr><tr class="odd"><td><span class="math inline">\(\cdot\)</span></td><td><code>\codt</code></td></tr><tr class="even"><td><span class="math inline">\(\cap\)</span></td><td><code>\cap</code></td></tr><tr class="odd"><td><span class="math inline">\(\cup\)</span></td><td><code>\cup</code></td></tr></tbody></table><h2 id="关系符号">关系符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\le\)</span></td><td><code>\le</code></td></tr><tr class="even"><td><span class="math inline">\(\ge\)</span></td><td><code>\ge</code></td></tr><tr class="odd"><td><span class="math inline">\(\ll\)</span></td><td><code>\ll</code></td></tr><tr class="even"><td><span class="math inline">\(\gg\)</span></td><td><code>\gg</code></td></tr><tr class="odd"><td><span class="math inline">\(\equiv\)</span></td><td><code>\equiv</code></td></tr><tr class="even"><td><span class="math inline">\(\subseteq\)</span></td><td><code>\subseteq</code></td></tr><tr class="odd"><td><span class="math inline">\(\supseteq\)</span></td><td><code>\supseteq</code></td></tr><tr class="even"><td><span class="math inline">\(\subset\)</span></td><td><code>\subset</code></td></tr><tr class="odd"><td><span class="math inline">\(\supset\)</span></td><td><code>\supset</code></td></tr></tbody></table><h2 id="箭头符号">箭头符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Leftarrow\)</span></td><td><code>\Leftarrow</code></td></tr><tr class="even"><td><span class="math inline">\(\Rightarrow\)</span></td><td><code>\Rightarrow</code></td></tr><tr class="odd"><td><span class="math inline">\(\Longleftrightarrow\)</span></td><td><code>\Longleftrightarrow</code></td></tr></tbody></table><h2 id="其他符号">其他符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\infty\)</span></td><td><code>\infty</code></td><td>无穷</td></tr><tr class="even"><td><span class="math inline">\(\exists\)</span></td><td><code>\exists</code></td><td>存在</td></tr><tr class="odd"><td><span class="math inline">\(\forall\)</span></td><td><code>\forall</code></td><td>任取</td></tr><tr class="even"><td><span class="math inline">\(\ldots\)</span></td><td><code>\ldots</code></td><td>下三连点</td></tr><tr class="odd"><td><span class="math inline">\(\cdots\)</span></td><td><code>\cdots</code></td><td>中三连点</td></tr><tr class="even"><td><span class="math inline">\(\vdots\)</span></td><td><code>\vdots</code></td><td>竖三连点</td></tr><tr class="odd"><td><span class="math inline">\(\ddots\)</span></td><td><code>\ddots</code></td><td>斜三连点</td></tr><tr class="even"><td><span class="math inline">\(\overline{x}\)</span></td><td><code>\overline&#123;x&#125;</code></td><td>平均</td></tr><tr class="odd"><td><span class="math inline">\(\quad\)</span></td><td><code>\quad</code></td><td>空格</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>本文大部分转载自知乎<ahref="https://www.zhihu.com/people/ruan-xing-zhi"><span class="citation"data-cites="阮行止">@阮行止</span></a>，后添加了自己的一些思考。</p><h2 id="从一个生活问题谈起">1. 从一个生活问题谈起</h2><p>先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，<strong>需要用到尽量少的钞票</strong>。</p><p>依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。</p><p>这种策略称为“<strong>贪心</strong>”：假设我们面对的局面是“需要凑出w”，贪心策略会<strong>尽快</strong>让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。</p><p>但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：<br />　　15=1×11+4×1 （贪心策略使用了5张钞票）<br />　　15=3×5 （正确的策略，只用3张钞票）<br />　　为什么会这样呢？贪心策略错在了哪里？</p><p><strong>鼠目寸光</strong>。</p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。</p><p>在这里我们发现，贪心是一种<strong>只考虑眼前情况</strong>的策略。</p><p>那么，现在我们怎样才能避免鼠目寸光呢？</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。</p><p>重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。</p><p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？</p><p>明显<strong>cost=f(4)+1=4+1=5</strong>，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。</p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1=2+1=3</strong>。</p><p>那么，现在w=15的时候，我们该取那种钞票呢？<strong>当然是各种方案中，cost值最低的那一个！</strong></p><ul><li>取11：cost=f(4)+1=4+1=5</li><li>取5:cost=f(10)+1=2+1=3</li><li>取1:cost=f(14)+1=4+1=5</li></ul><p>显而易见，cost值最低的是取5的方案。<strong>我们通过上面三个式子，做出了正确的决策！</strong></p><p>这给了我们一个<strong>至关重要</strong>的启示——f(n)只与f(n-1),f(n-5),f(n-11) 相关；更确切地说：</p><blockquote><p>f(n)=min{f(n-1),f(n-5),f(n-11)}+1</p></blockquote><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><figure><img src="/img/动态规划/解决方案.jpg" alt="pic1" /><figcaption aria-hidden="true">pic1</figcaption></figure><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：</p><ul><li>f(n)只与f(n-1),f(n-5),f(n-11)的值有关。</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。<strong>其他信息并不需要</strong>。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。<strong>我们将求解f(c)称作求解f(n)的“子问题”</strong>。</p><p><strong>这就是DP（动态规划，dynamic programming）</strong>.</p><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</strong></p><h2 id="几个简单的概念">2. 几个简单的概念</h2><ul><li><strong>无后效性</strong><br />一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</li></ul><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p><p>“<strong>未来与过去无关</strong>”，这就是<strong>无后效性</strong>。</p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><ul><li>最优子结构</li></ul><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).</p><p>f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的最优解，我们即可算出w=15的最优解。</p><p>大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“最优子结构性质”。</p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="dp的典型应用dag最短路">3. DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><figure><img src="/img/动态规划/最短路径.png" alt="最短路径" /><figcaption aria-hidden="true">最短路径</figcaption></figure><p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).</p><p>想要到T，要么经过C，要么经过D。从而<spanclass="math inline">\(f(T)=min\{f(C)+20,f(D)+10\}\)</span>.</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是<spanclass="math inline">\(S \rightarrow P\rightarrow Q \rightarrowT\)</span>,那肯定S走到Q的最优路径是<span class="math inline">\(S\rightarrow P\rightarrowQ\)</span>。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><blockquote><p>f(P)=min{f(R)+W<sub><span class="math inline">\(R \rightarrowP\)</span></sub>}</p></blockquote><p>其中R为有路通到P的所有的点， [公式] 为R到P的过路费。</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="对dp原理的一点讨论">4. 对DP原理的一点讨论</h2><ul><li>DP的核心思想</li></ul><p>DP为什么会快？</p><p>无论是DP还是暴力，我们的算法都是在<strong>可能解空间</strong>内，寻找<strong>最优解</strong>。</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。</p><p>DP是枚举<strong>有希望成为答案的解</strong>。这个空间比暴力的小得多。</p><p>也就是说：<strong>DP自带剪枝</strong>。</p><p>DP舍弃了一大堆不可能成为最优解的答案。譬如：<br />　　15 = 5+5+5 被考虑了。<br />　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。</p><p>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><ul><li>DP的操作过程</li></ul><p>一言以蔽之：<strong>大事化小，小事化了</strong>。</p><p>将一个大问题转化成几个小问题；<br />　　求解小问题；<br />　　推出大问题的解。</p><ul><li>如何设计DP算法</li></ul><p>下面介绍比较通用的设计DP算法的步骤。</p><p>首先，把我们面对的局面表示为x。这一步称为设计状态。</p><p>对于状态x，记我们要求出的答案(e.g.最小费用)为f(x).我们的目标是求出f(T).<strong>找出f(x)与哪些局面有关（记为p）</strong>，写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><ul><li>DP三连</li></ul><p>设计DP算法，往往可以遵循DP三连：</p><p>我是谁？ ——设计状态，表示局面</p><p>我从哪里来？</p><p>我要到哪里去？ ——设计转移</p><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，<strong>更新能从x走到的一些解</strong>。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><blockquote><p>思考题：如何把钞票问题的代码改写成“我到哪里去”的形式？<br />提示：求出f(x)之后，更新f(x+1),f(x+5),f(x+11).</p></blockquote><h2 id="例题最长上升子序列">5. 例题：最长上升子序列</h2><p>扯了这么多形而上的内容，还是做一道例题吧。</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。<br />　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p><p>如何设计状态（我是谁）？</p><p>我们记<spanclass="math inline">\(f(x)\)</span>为以a<sub>x</sub>结尾的LIS长度，那么答案就是<span class="math inline">\(max\{f(x)\}\)</span></p><p>状态x从哪里推过来（我从哪里来）？</p><p>考虑比x小的每一个p：如果 a<sub>x</sub> &gt; a<sub>p</sub>，那么<spanclass="math inline">\(f(x)\)</span>可以取<spanclass="math inline">\(f(p)+1\)</span>.</p><p>解释：我们把 a<sub>x</sub> 接在 a<sub>p</sub>的后面，肯定能构造一个以 a<sub>x</sub> 结尾的上升子序列，长度比以a<sub>p</sub> 结尾的LIS大1.那么，我们可以写出状态转移方程了：</p><figure><img src="/img/动态规划/状态转移方程.svg" alt="状态转移方程" /><figcaption aria-hidden="true">状态转移方程</figcaption></figure><p>至此解决问题。两层for循环，复杂度O(n<sup>2</sup>) 。</p><figure><img src="/img/动态规划/最长上升子序列代码.jpg"alt="最长上升子序列代码" /><figcaption aria-hidden="true">最长上升子序列代码</figcaption></figure><p>从这三个例题中可以看出，DP是一种思想，一种“大事化小，小事化了”的思想。带着这种思想，DP将会成为我们解决问题的利器。</p><h2 id="习题">6. 习题</h2><p>如果读者有兴趣，可以试着完成下面几个习题：</p><ol type="1"><li>请采取一些优化手段，以 O(n log<sub>2</sub> n)的复杂度解决LIS问题。</li></ol><p>提示：可以参考这篇博客 <ahref="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">JuniorDynamic Programming--动态规划初步·各种子序列问题</a></p><ol start="2" type="1"><li>“按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成<ahref="https://www.luogu.com.cn/problem/P1541">P1541 乌龟棋 - 洛谷</a>。</li><li>01背包问题是一种常见的DP模型。请完成<ahref="https://www.luogu.com.cn/problem/P1048">P1048 采药 -洛谷</a>。</li></ol><h2 id="读后思考动态规划和分治法的区别与共同点">7.读后思考：动态规划和分治法的区别与共同点？</h2><h3 id="分治法">1. 分治法</h3><p>分治法(Divide-and-Conquer) :将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治模式在每一层递归上都有三个步骤：</p><ul><li>分解(Divide)：将原问题分解成一系列子问题；</li><li>解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。</li><li>合并(Combine)：将子问题的结果合并成原问题的解。</li></ul><p>合并排序(MergeSort)是一个典型分治法的例子。其对应的直观的操作如下:</p><p>分解： 将n个元素分成各含n/2个元素的子序列；</p><p>解决：用合并排序法对两个子序列递归地排序；</p><p>合并：合并两个已排序的子序列以得到排序结果。</p><h3 id="动态规划法">2. 动态规划法</h3><p>动态规划算法的设计可以分为如下4个步骤：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><p><strong>分治法是指将问题划分成一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。</strong></p><p>适合采用动态规划方法的最优化问题中的两个要素：<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p><p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p><p>In a word, <strong>分治法 —— 各子问题独立；动态规划 ——各子问题重叠</strong>。</p><p>算法导论：<strong>动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><h2 id="红黑树的性质">红黑树的性质</h2><ol type="1"><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</li></ol><p>由性质5我们可以推出：<br />性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</p><h2 id="红黑树和avl的区别">红黑树和AVL的区别</h2><ol type="1"><li><p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p></li><li><p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p></li><li><p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胜者树与败者树</title>
    <link href="/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    <url>/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>胜者树与败者树是完全二叉树。就像是参加比赛一样，每个选手有不同的实力，两个选手PK,实力决定胜负，晋级下一轮，经过几轮之后，就能得到冠军。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。在k路归并排序中经常用到。</p><h2 id="胜者树">胜者树</h2><p>胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p><figure><img src="/img/胜者树败者树/fig1.jpg" alt="fig1" /><figcaption aria-hidden="true">fig1</figcaption></figure><p>上图是一个胜者树的示例。规定数值小者胜。 1. b3 PKb4，b3胜b4负，内部结点ls[4]的值为3； 2. b3 PKb0，b3胜b0负，内部结点ls[2]的值为3； 3. b1 PKb2，b1胜b2负，内部结点ls[3]的值为1； 4. b3 PKb1，b3胜b1负，内部结点ls[1]的值为3。</p><p>取出胜者b3之后，叶子结点b3的值变为11时，重构的胜者树如下:</p><figure><img src="/img/胜者树败者树/fig2.jpg" alt="fig2" /><figcaption aria-hidden="true">fig2</figcaption></figure><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。</li></ol><p>用胜者树对n个节点实现排序操作，构建胜者树和构建堆比较相似，区别在于胜者树只有叶子节点存放了数据，中间节点记录的是叶子节点间的关系。</p><p>胜者树在每次重构时只需与其兄弟结点比较，一直到根节点选出胜者为止。</p><h2 id="败者树">败者树</h2><p>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p><figure><img src="/img/胜者树败者树/fig3.jpg" alt="fig3" /><figcaption aria-hidden="true">fig3</figcaption></figure><p>上图是一棵败者树。规定数大者败。</p><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；</li></ol><p>败者树重构过程如下： -将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。-比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。</p><figure><img src="/img/胜者树败者树/fig4.jpg" alt="fig4" /><figcaption aria-hidden="true">fig4</figcaption></figure><h2 id="胜者树败者树堆比较">胜者树、败者树、堆比较</h2><h3 id="相同点">相同点</h3><p>这三者空间和时间复杂度都是一样的。调整一次的时间复杂度都是O(logN)的。</p><h3 id="不同点">不同点</h3><p>一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，<strong>调整堆的时候，每次都要选出父结点的两个孩子节点的最小值，然后再用孩子结点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了胜者树。这样<strong>每次比较只用跟自己的兄弟结点进行比较就好</strong>，所以用胜者树可以比堆少一半的比较次数。</p><p>而<strong>胜者树想要比较兄弟结点首先要获得其父结点，也就是说需要访存两次</strong>，这时人们又想能否再次减少比较次数，于是就有了败者树。败者树每个新元素上升时，<strong>只需要获得父节点并比较即可</strong>。</p><p>总的来说，败者树与胜者树相比减少了访存时间。<strong>现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了</strong>。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html#:~:text=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91%E9%83%BD%E6%98%AF%E5%AE%8C%E5%85%A8,%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BE%E5%88%B0%E6%9C%80%E5%80%BC%E3%80%82">胜者树和败者树</a></li><li><ahref="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
