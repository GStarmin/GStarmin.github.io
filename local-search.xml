<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>位运算的妙用</title>
    <link href="/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算的妙用">位运算的妙用</h1><h2 id="异或运算实现变量交换">异或运算实现变量交换</h2><p>异或运算可以理解为<strong>无进位相加</strong>，异或运算的性质如下：</p><ul><li>0 ^ N = N</li><li>N ^ N = N</li><li>a ^ b = b ^ a (交换律)</li><li>a ^ b ^ c = a ^ (b ^ c) （结合律）</li></ul><p>异或运算的妙用：交换两个数的值不使用额外变量： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">17</span>, b = <span class="hljs-number">23</span>;<br><span class="hljs-comment">// 交换a，b的值</span><br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure></p><p>但是<strong>需要注意的是，可以这样使用的前提是a和b指向的内存是不同的，但是两个数的值可以相同。</strong>比如在一个数组中对nums[i]和nums[j]进行交换，要使用这种方法，必须要保证i和j相同，否则nums[i]位置上的数会被抹成0。所以一般情况下不推荐这种用法。</p><h2 id="异或运算查找出现奇数次的数">异或运算查找出现奇数次的数</h2><h3 id="只有一种数出现奇数次">只有一种数出现奇数次</h3><p>一个数组中只有一种数出现奇数次，其余的数都出现偶数次，那么如果寻找这个出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>就是出现奇数次的数。因为异或运算满足交换律，出现偶数次的数相互异或的结果为<spanclass="math inline">\(0\)</span>，出现奇数次的数相互异或的结果为这个数的值，所以总的结果就是这个出现奇数次的数。</p><h3 id="有两种数出现奇数次">有两种数出现奇数次</h3><p>一个数组中有两种数出现奇数次，其余的数都出现偶数次，那么如果寻找出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>为a ^b。因为a和b是不同的数，所以必然有a ^ b <spanclass="math inline">\(\ne\)</span> 0,也就是a ^b的二进制至少有一位是1，那么假设a ^ b的二进制第8位为1，让<spanclass="math inline">\(eor\)</span>与数组中第8位为1的数异或，得到的<spanclass="math inline">\(eor^{&#39;}\)</span>就是a或b，再用<spanclass="math inline">\(eor^{&#39;}\)</span>与<spanclass="math inline">\(eor\)</span>异或得到的就是另外一个数。</p><p><img src="/img/算法/异或/查找数组中出现奇数次个数的数图解.png" /></p><p>因为a和b在第8为上的值一定是不一样的，所以肯定在不同的区域里，这样去用<spanclass="math inline">\(eor\)</span>异或第8位为1的数得到的就是a，b其中之一，出现偶数次的数不影响异或的结果。</p><p>那么就有一个问题，<strong>选哪一位的1？如何提取出这一位上的1？</strong>这里选择提取出a^ b最右边一位的1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>) <span class="hljs-comment">// 提取出eor最右侧的1</span><br></code></pre></td></tr></table></figure><p>将<spanclass="math inline">\(eor\)</span>用二进制表示就可以更直观的看出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">             eor = <span class="hljs-number">11001110</span>    <br>        ~eor + <span class="hljs-number">1</span> = <span class="hljs-number">00110010</span><br>eor &amp; (~eor + <span class="hljs-number">1</span>) = <span class="hljs-number">00000010</span> <span class="hljs-comment">// 提取出来最右侧的1</span><br></code></pre></td></tr></table></figure><h2 id="运算消去二进制最低位的1">&amp;运算消去二进制最低位的1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &amp; (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>因为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">    n = <span class="hljs-number">11001110</span><br>n - <span class="hljs-number">1</span> = <span class="hljs-number">11001101</span><br></code></pre></td></tr></table></figure><p>可以看到<code>n</code>的二进制中的高位的<spanclass="math inline">\(1\)</span>其实是不受<strong>减一</strong>操作的影响的，所以<code>n &amp; (n - 1)</code>就可以在不影响其他二进制位的情况下消去其最低位的<spanclass="math inline">\(1\)</span>。</p><p>那么就可以根据这个特性<strong>计算k的二进制1的个数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br>    n &amp;= n - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 每次消去二进制中最低位的1</span><br>    count++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++deque和queue</title>
    <link href="/2023/03/07/C++deque%E5%92%8Cqueue/"/>
    <url>/2023/03/07/C++deque%E5%92%8Cqueue/</url>
    
    <content type="html"><![CDATA[<h1 id="c-deque和queue">C++ deque和queue</h1><p>deque是双端队列，queue可以访问两端但是只能修改队头，而deque可以访问两端并且可以在队首和队尾删除和插入元素。</p><p>queue操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q； <span class="hljs-comment">//创建一个int型空队列q</span><br><br>q.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 将变量s从队尾入队</span><br>q.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">// 将队头元素弹出</span><br>q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 只返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();   <span class="hljs-comment">// 只返回队尾元素</span><br>q.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 返回队列中元素个数</span><br></code></pre></td></tr></table></figure><p>deque操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; dq； <span class="hljs-comment">// 创建一个数双端队列dq</span><br><br>dq.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>dq.<span class="hljs-built_in">push_front</span>(s); <span class="hljs-comment">//  将s从队头入队</span><br>dq.<span class="hljs-built_in">push_back</span>(s);    <span class="hljs-comment">// 将s从队尾入队，和普通队列方式一样</span><br>dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 只返回队头元素</span><br>dq.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 只返回队尾元素</span><br>dq.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 将队头元素弹出</span><br>dq.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 将队尾元素弹出</span><br>dq.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 将队列清空</span><br></code></pre></td></tr></table></figure><p>由于deque两端都可以压入，只用个push的话到底是用哪端压入呢？所以有了<code>push_back()</code>和<code>push_front()</code>,同样，<code>pop()</code>是弹出，所以有<code>pop_back()</code>和<code>pop_front()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++函数后冒号的含义</title>
    <link href="/2023/03/06/C++%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2023/03/06/C++%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="c函数后冒号的含义">C++函数后冒号的含义</h1><h2 id="c-函数后面加一个冒号的含义">c++ 函数后面加一个冒号的含义</h2><p>冒号后面跟的是赋值，这种写法是C++的特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb ):<span class="hljs-built_in">a</span>(aa),<span class="hljs-built_in">b</span>(bb)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb )<br>&#123;<br>    a=aa;<br>    b=bb;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c构造函数后面的冒号">C++构造函数后面的冒号</h2><p>在C++类的构造函数中经常会看到如下格式的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><p>上述语句中单冒号(:)的作用是表示后面是初始化列表，一般有三种使用场景。</p><h3 id="对父类进行初始化">对父类进行初始化</h3><p>调用格式为“子类构造函数 :父类构造函数”，如下，其中QMainWindow是MyWindow的父类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><h3 id="对类成员进行初始化">对类成员进行初始化</h3><p>调用格式为“构造函数 :A(初始值),B(初始值),C(初始值)……”，如下，其中A、B、C分别是类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">rectangle</span> <span class="hljs-comment">//头文件中类定义</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">rectangle</span>( <span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length);<br><span class="hljs-keyword">private</span>:<br>    CPoint m_point;<br>    <span class="hljs-type">int</span> m_Width;<br>    <span class="hljs-type">int</span> m_Length;<br>&#125;;<br> <br>rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length) : <span class="hljs-built_in">m_point</span>(pointX,pointY),<span class="hljs-built_in">m_Width</span>(Width),<span class="hljs-built_in">m_Length</span>(Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，上面构造函数的实现与下面的写法等价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    m_point.X = pointX;<br>    m_point.Y = pointY;<br>    m_Width   = Width;<br>    m_Length  = Length;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><h3id="对类的const成员变量进行初始化">对类的const成员变量进行初始化</h3><p>由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值。</p><h3 id="总结">总结</h3><p>对于第2、3种方式的应用场景，有以下两点说明：</p><ol type="1"><li><p>构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关。</p></li><li><p>相对于在构造函数中赋值，初始化列表执行效率更高。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常量、#define、const和constexpr</title>
    <link href="/2023/03/06/C++%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/"/>
    <url>/2023/03/06/C++%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/</url>
    
    <content type="html"><![CDATA[<h1id="c常量defineconst和constexpr">C++常量、#define、const和constexpr</h1><h2 id="常量">常量</h2><p>常量是固定值，在程序执行期间不会改变，可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值，常量的值在定义后不能进行修改；</p><p>可以使用枚举、#define、const和constexpr等方法定义常量.</p><h2 id="define">#define</h2><p>#define是预处理阶段进行处理，是一种宏定义，所以定义常量的宏是没有类型的，是在编译前即预编译阶段进行字符替换，并且由于是在预处理阶段替换所以不会有类型安全检查，系统也不会为它分配内存，存储在程序的代码段空间，实际就是给出了立即数，在运行过程中，常量在内存中会有若干个拷贝；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br></code></pre></td></tr></table></figure><p>如果只想常量宏只在某段代码起作用，则使用#undef这个常量宏，如果再用到了这个常量宏，编译器就会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r; <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span></span><br><br>S = Pi + <span class="hljs-number">1</span>; <span class="hljs-comment">//编译器报错</span><br></code></pre></td></tr></table></figure><h2 id="const">const</h2><p>const是一种Runtime，const常量会在内存中分配，可以是堆中也可以是栈中。以后在定义的常量调用时，只是使用对应的内存地址，不再开辟新的空间，在内存中只有一个拷贝，因此const相比#define，可以避免反复分配内存，节省空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> doulbe Pi=<span class="hljs-number">3.14159</span>;<br>S = Pi * r * r;<br></code></pre></td></tr></table></figure><h3 id="const修饰指针">const修饰指针</h3><p>const位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* test_ptr = &amp;test;<span class="hljs-comment">//禁止修改test_ptr指向的值, 可以修改test_ptr的值</span><br><span class="hljs-type">int</span> test2 = <span class="hljs-number">2</span>;<br>test_ptr = &amp;test2;<span class="hljs-comment">//指向另一个变量</span><br></code></pre></td></tr></table></figure><p>const位于<code>*</code>的右侧，const就是修饰指针本身，即指针本身是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> test_ptr = &amp;test;<br><br>*test_ptr = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 可以修改test_ptr指向的值, 禁止修改test_ptr的值</span><br></code></pre></td></tr></table></figure><h3 id="const修饰函数">const修饰函数</h3><p>在类中将成员函数修饰为const表明在该函数体内，不能修改对象的数据成员而且不能调用非const函数，由于非const函数可能修改数据成员，const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//fun1函数需要设置i的值，所以不能声明为const</span></span><br><span class="hljs-function">    </span>&#123;<br>i = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-comment">//fun2函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。</span></span><br><span class="hljs-function">    </span>&#123; <br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数参数">const修饰函数参数</h3><p>const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用;const指针可以接收非const和const指针，而非const指针只能接收非const指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> param)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数返回值">const修饰函数返回值</h3><p>const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员变量">const修饰成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> Test:: <span class="hljs-built_in">fun1</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">//i++; i不能修改</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="constexpr">constexpr</h2><p>constexpr与const一样，它可以应用于变量，不同的是可以应用于函数和类构造函数,constexpr指示值或返回值是常量，并且在可能的情况下，在编译时计算</p><h3 id="修饰变量">修饰变量</h3><p>const和constexpr之间的主要区别在于，const的初始化可以在到运行时，而constexpr编译时必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> :<br>        n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-built_in">exp</span>(x * x, n / <span class="hljs-number">2</span>) :<br>        <span class="hljs-built_in">exp</span>(x * x, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰构造函数">修饰构造函数</h3><p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy,<span class="hljs-type">int</span> zz)</span></span><br><span class="hljs-function">        :x(xx),y(yy),z(zz)&#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        :Base(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">constexpr</span> Base pt = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure><p>转载自<a href="https://zhuanlan.zhihu.com/p/473260243">C/C++常量、#define、const和constexpr</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛法:埃氏筛和欧拉筛</title>
    <link href="/2023/03/06/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
    <url>/2023/03/06/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="素数筛法">素数筛法</h1><p>本文主要介绍埃氏筛法和欧拉筛法。</p><h2 id="暴力筛法">暴力筛法</h2><p>学习埃氏筛之前，我们先看一下暴力筛法，即对每个数都用试除法判断其是不是质数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">// 初始化为0， 0表示质数，1表示合数</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i / j; j++)&#123;<span class="hljs-comment">//试除法</span><br><span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<br>st[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 合数，标记为1 </span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="埃式筛">埃式筛</h2><p>暴力筛法无疑是最慢的，我们看一下如何加快，换一种思路：一个质数的倍数一定是合数，所以，假设<spanclass="math inline">\(P\)</span>是质数，我们可以筛掉区间<spanclass="math inline">\([1,1e7]\)</span>中所有<spanclass="math inline">\(P\)</span>的倍数。 先看个例子，对于数列1~11：</p><p><img src="/img/算法/素数筛法/数1-11.png" /></p><p>先筛去2的倍数：</p><p><img src="/img/算法/素数筛法/筛去2倍数.png" /></p><p>再筛去3倍数：</p><p><img src="/img/算法/素数筛法/筛去3倍数.png" /></p><p>再筛去5倍数：</p><p><img src="/img/算法/素数筛法/筛去5倍数.png" /></p><p>至此，1~11内的所有合数都被筛完了， 2 3 5 7 11是数列中的质数。</p><p>为什么这样能筛去所有的合数呢，因为<strong>一个合数一定能被分解为几个质数的幂的乘积</strong>，并且这个数的质因子一定是小于它本身的，所以当我们从小到大将每个质数的倍数都筛去的话，当遍历到一个合数时，它一定已经被它的质因子给筛去了。</p><p>埃氏筛代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的时间复杂度为<span class="math inline">\(O(n\log{\log_2 n})\)</span></p><p>我们还可以对其进行优化：</p><ul><li>我们会先筛<spanclass="math inline">\(2\)</span>的所有倍数，然后筛<spanclass="math inline">\(3\)</span>的所有倍数，但筛除<spanclass="math inline">\(3\)</span>的倍数时，我们还是从<spanclass="math inline">\(3\)</span>的<spanclass="math inline">\(2\)</span>倍开始筛，其实<spanclass="math inline">\(3 * 2\)</span> ，已经被<spanclass="math inline">\(2 * 3\)</span>时筛过了。又比如说筛5的倍数时，我们从5的2倍开始筛，但是<spanclass="math inline">\(5 * 2\)</span>会先被<span class="math inline">\(2* 5\)</span>筛去， <span class="math inline">\(5 * 3\)</span>会先被<spanclass="math inline">\(3 * 5\)</span>会筛去，<spanclass="math inline">\(5 * 4\)</span>会先被<span class="math inline">\(2* 10\)</span>筛去，所以我们每一次只需要从<spanclass="math inline">\(i*i\)</span>开始筛，因为<spanclass="math inline">\((2，3,…,i - 1)\)</span>倍已经被筛过了。</li><li>另外，判断一个数 <spanclass="math inline">\(n\)</span>是不是质数，我们只判断<spanclass="math inline">\([2, \sqrt{n}]\)</span>内有没有它的因子。在筛合数的时候，我们也可以这样做，因为一个合数的最小质因子一定小于等于<span class="math inline">\(\sqrt{n}\)</span>。所以对于区间<spanclass="math inline">\([1, 1e7]\)</span>，最大的合数是 <spanclass="math inline">\(1e7\)</span>, 它的最小质因子一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>，区间内其他的合数的最小质因子也一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>的，所以只需要用<spanclass="math inline">\([1, \sqrt{1e7}]\)</span>中的质数就可以筛去 <spanclass="math inline">\([1, 1e7]\)</span>中所有的合数。</li></ul><p>优化后的埃式筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意循环条件i &lt;= n / i，为什么不直接成sqrt(n)?</span><br>    <span class="hljs-comment">// 写成这样的形式当i &gt;= sqrt(n) 时候依然可以停止循环，而且加减法需要几个时钟周期，乘法需要10几个时钟周期，除法需要2、3十个时钟周期，开根号需要8000个时钟周期，这样可以节省时间</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的时间复杂度可以近似看成<spanclass="math inline">\(O(n)\)</span>了。</p><h2 id="欧拉筛">欧拉筛</h2><p>优化后的埃式筛时间复杂度可以<strong>近似</strong>看成<spanclass="math inline">\(O(n)\)</span>，但是欧拉筛可以比它更快，欧拉筛的时间复杂度是<spanclass="math inline">\(O(n)\)</span>，又被称为线性筛。</p><p>埃氏筛是筛去每个质数的倍数，但难免，会有合数会被其不同的质因子多次重复筛去。这就造成了时间浪费。</p><p>比如说： <span class="math inline">\(120 = 2^3 * 3 * 5\)</span>,<spanclass="math inline">\(120\)</span> 会被<spanclass="math inline">\(2\)</span>筛去一次， <spanclass="math inline">\(3\)</span>筛去一次， <spanclass="math inline">\(5\)</span>筛去一次。 多做了两次不必要的操作。</p><p>那么我们如何确保120只被2筛掉呢？在埃氏筛中我们用了一个循环来筛除一个质数的所有倍数，即对于p来说，筛除数列：<span class="math inline">\(2 * p , 3 * p, ... ,k*p\)</span>。另外，我们是从小到大枚举区间中的每个数的，数列是：<spanclass="math inline">\(2,3,4,...,n\)</span>。</p><p>对比两个数列：</p><p><span class="math display">\[\begin{align}    &amp;2 * p , 3 * p, ... , k*p \\    &amp;2,3,4,...,n\end{align}\]</span></p><p>会发现，第二个数列是第一个数列的系数,所以，我们不需要用一个for循环去筛除一个质数的所有倍数，我们将所有质数存储到<code>primes[]</code>中，然后枚举到第i个数时，就筛去所有的<code>primes[j] * i</code>。这样就在每一次遍历中，正好筛除了所有已知素数的<code>i</code>倍。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N], primes = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ola</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-number">0</span>) primes[cnt++] = i;<span class="hljs-comment">//将质数存到primes中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= cnt &amp;&amp; primes[j] &lt;= n / i; j ++ )<span class="hljs-comment">//要确保质数的第i倍是小于等于n的。</span><br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意内层循环有一个<code>break</code>的条件<code>i % primes[j] == 0</code>,为什么呢？</p><p><strong>因为</strong>:</p><p>由</p><p><span class="math display">\[i \quad \% \quad primes[j] ==0\]</span></p><p>可得</p><p><span class="math display">\[primes[j] * k = i \tag{1}\]</span></p><p>设</p><p><span class="math display">\[primes[j] * k = X\tag{2}\]</span></p><p>将<span class="math inline">\((1)\)</span>代入到<spanclass="math inline">\((2)\)</span>中可得</p><p><span class="math display">\[primes[j+1] * primes[j] * k =X\]</span></p><p>因为<span class="math inline">\(primes[j+1] &gt;primes[j]\)</span>,所以<span class="math inline">\(primes[j+1] * k &gt;i\)</span>。</p><p>设</p><p><span class="math display">\[primes[j] * k = i^\prime\]</span></p><p>则</p><p><span class="math display">\[primes[j] * i^\prime =X\tag{3}\]</span></p><p>所以如果用<span class="math inline">\((2)\)</span>式筛去<spanclass="math inline">\(X\)</span>的话，当<spanclass="math inline">\(i\)</span>等于<spanclass="math inline">\(i&#39;\)</span>时，<spanclass="math inline">\(X\)</span>又会被<spanclass="math inline">\((3)\)</span>式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的<spanclass="math inline">\(i\)</span>, 所以不能提前筛。</p><p>比如说 <span class="math inline">\(1，2，3，4，5，6，7，8，9，10，11， 12\)</span>,当<code>i == 4</code> 时,<code>primes = &#123;2, 3&#125;</code>,此时 <code>i % 2 == 0</code>,如果不结束内层循环的话， <spanclass="math inline">\(12\)</span>会被<spanclass="math inline">\(3*4\)</span>筛掉， 当<code>i == 6</code>时，<spanclass="math inline">\(12\)</span>又会被<spanclass="math inline">\(2*6\)</span>筛掉。</p><p><strong>欧拉筛的核心思想就是确保每个合数只被最小质因数筛掉。或者说是被合数的最大因子筛掉。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++左值和右值</title>
    <link href="/2023/03/04/C++-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2023/03/04/C++-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="理解-cc-中的左值和右值">理解 C/C++ 中的左值和右值</h1><p>我们在 C/C++ 编程中并不会经常用到 <em>左值 (lvalue)</em> 和 <em>右值(rvalue)</em>两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用<code>gcc</code> 编译以下代码时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会得到：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">test</span>.c: <span class="hljs-keyword">In</span> function &#x27;main&#x27;:<br><span class="hljs-keyword">test</span>.c:8:5: <span class="hljs-keyword">error</span>: lvalue required <span class="hljs-keyword">as</span> left operand of assignment<br></code></pre></td></tr></table></figure><p>没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值(lvalue)。另一个例子是当你用 <code>g++</code> 编译以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在错误信息是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">testcpp.cpp: <span class="hljs-keyword">In</span> <span class="hljs-keyword">function</span> &#x27;<span class="hljs-title function_">int</span>&amp; <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#x27;:<br>testcpp.cpp:<span class="hljs-number">5</span>:<span class="hljs-number">12</span>: error: invalid initialization <span class="hljs-keyword">of</span> non-<span class="hljs-keyword">const</span> <span class="hljs-keyword">reference</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&amp;&#x27;</span> <span class="hljs-keyword">from</span> an rvalue <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，左值和 右值 到底是什么意思呢？我这篇文章将会详细解释。</p><h2 id="简单的定义">简单的定义</h2><p>这里我故意给出了一个 <strong>左值</strong> 和 <strong>右值</strong>的简化版定义。文章剩下的部分还会进行详细解释。</p><p><strong>左值 (lvalue, locator value)</strong>表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是左值 就是 右值 。那么，右值是一个<strong>不</strong>表示内存中某个可识别位置的对象的表达式。</p><h2 id="举例">举例</h2><p>上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var;<br>var = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。<code>var</code>是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">4</span> = var;       <span class="hljs-comment">// 错误！</span><br>(var + <span class="hljs-number">1</span>) = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误！</span><br></code></pre></td></tr></table></figure><p>常量 <code>4</code> 和表达式 <code>var + 1</code>都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p><p>那么，我们就能理解第一个代码片段中的错误信息的含义了。<code>foo</code>返回的是一个临时的值。它是一个右值，赋值给它是错误的。因此当编译器看到<code>foo() = 2</code> 时，会报错——赋值语句的左边应当是一个左值。</p><p>然而，给函数返回的结果赋值，不一定总是错误的操作。例如，C++的引用让我们可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> globalvar = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> globalvar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>foo</code>返回一个引用。<strong>引用一个左值</strong>，因此可以赋值给它。实际上，C++中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符<code>[]</code>，来实现一些查找访问的操作，如 <code>std::map</code>中的方括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; mymap;<br>mymap[<span class="hljs-number">10</span>] = <span class="hljs-number">5.6</span>;<br></code></pre></td></tr></table></figure><p>之所以能赋值给 <code>mymap[10]</code>，是因为<code>std::map::operator[]</code> 的重载返回的是一个可赋值的引用。</p><h2 id="可修改的左值">可修改的左值</h2><p>左值一开始在 C 中定义为“可以出现在赋值操作左边的值”。然而，当 ISO C加入 <code>const</code> 关键字后，这个定义便不再成立。毕竟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// &#x27;a&#x27; 是左值</span><br>a = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 但不可以赋值给它！</span><br></code></pre></td></tr></table></figure><p>于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为<strong>可修改左值 (modifiable lvalues)</strong>。C99标准定义可修改左值为：</p><blockquote><p>可修改左值是特殊的左值，不含有数组类型、不完整类型、const修饰的类型。如果它是 <code>struct</code> 或<code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p></blockquote><h2 id="左值与右值间的转换">左值与右值间的转换</h2><p>通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符<code>'+'</code> 就需要两个右值参数，并返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;     <span class="hljs-comment">// a 是左值</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;     <span class="hljs-comment">// b 是左值</span><br><span class="hljs-type">int</span> c = a + b; <span class="hljs-comment">// + 需要右值，所以 a 和 b 被转换成右值</span><br>               <span class="hljs-comment">// + 返回右值</span><br></code></pre></td></tr></table></figure><p>在例子中，<code>a</code> 和 <code>b</code>都是左值。因此，在第三行中，它们经历了隐式的<strong>左值到右值转换</strong>。除了数组、函数、不完整类型的所有左值都可以转换为右值。</p><p>那右值能否转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注1：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】</p><p>不过，右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符<code>'*'</code>需要一个右值参数，但返回一个左值结果。考虑这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;arr[<span class="hljs-number">0</span>];<br>*(p + <span class="hljs-number">1</span>) = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span><br></code></pre></td></tr></table></figure><p>相反地，一元取地址操作符 <code>'&amp;'</code>需要一个左值参数，返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* bad_addr = &amp;(var + <span class="hljs-number">1</span>); <span class="hljs-comment">// 错误: 一元 &#x27;&amp;&#x27; 操作符需要左值参数</span><br><span class="hljs-type">int</span>* addr = &amp;var;           <span class="hljs-comment">// 正确: var 是左值</span><br>&amp;var = <span class="hljs-number">40</span>;                  <span class="hljs-comment">// 错误: 赋值操作的左操作数需要是左值</span><br></code></pre></td></tr></table></figure><p>在 C++ 中 <code>'&amp;'</code>符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string&amp; sref = std::<span class="hljs-built_in">string</span>();  <span class="hljs-comment">// 错误: 非常量的引用 &#x27;std::string&amp;&#x27; 错误地使用右值 &#x27;std::string` 初始化</span><br></code></pre></td></tr></table></figure><p><strong>常量的</strong>左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得C++中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p><h2 id="cv-限定的右值">CV 限定的右值</h2><p>如果我们仔细阅读 C++ 标准中关于左值到右值的转换的部分【注2：在新的C++11 标准草稿的第 4.1 节】，我们会发现：</p><blockquote><p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T不是类类型【译注：类类型即 C++中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定CV 的版本 (cv-unqualified version ofT)。其他情况下，转换后的右值类型就是 T 本身。</p></blockquote><p>什么叫做 “未限定 CV” (cv-unqualified) 呢？ <strong>CV 限定符</strong>这个术语指的是 <em>const</em> 和 <em>volatile</em> 两个类型限定符。C++标准的 3.9.3 节写到：</p><blockquote><p>每个类型都有三个对应的 CV-限定类型版本： <em>const 限定</em> 、<em>volatile 限定</em> 和 <em>const-volatile 限定</em> 版本。有或无 CV限定的不同版本的类型是不同的类型，但写法和赋值需求都是相同的。</p></blockquote><p>那么，这些又和右值有什么关系呢？在 C 中，只有左值有 CV限定的类型，而右值从来没有。而在 C++ 中，类右值可以有 CV限定的类型，但内置类型 (如 <code>int</code>)则没有。考虑下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo() const\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">cbar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bar</span>().<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// calls foo</span><br>    <span class="hljs-built_in">cbar</span>().<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// calls foo const</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code>中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是<code>const A</code>，这和 <code>A</code>是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code>的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p><h2 id="c11-的右值引用">C++11 的右值引用</h2><p>C++11 标准中引入的最强有力的特性就是右值引用，以及相关的 <em>移动语义(move semantics)</em>概念。这篇简短的文章没法完全讨论这个特性【注3：搜索 “rvalue references”可以找到很多相关的资料，几个个人认为有用的资料：<ahref="http://www.artima.com/cppsource/rvalue.html">这一篇</a>， <ahref="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x">这一篇</a>，特别是<ahref="http://thbecker.net/articles/rvalue_references/section_01.html">这一篇</a>】，但我想给出一个简单的例子。实际上，对左值和右值的理解可以帮助我们理解一些非平凡的语言概念。</p><p>这篇文章的大部分内容都在解释：左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p><p>假设我们要实现一个“整数的vector”，一些相关的函数可能是这样定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Intvec</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Intvec</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        : m_size(num), m_data(new int[m_size])</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;constructor&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Intvec</span>()<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;destructor&quot;</span>);<br>        <span class="hljs-keyword">if</span> (m_data) &#123;<br>            <span class="hljs-keyword">delete</span>[] m_data;<br>            m_data = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">Intvec</span>(<span class="hljs-type">const</span> Intvec&amp; other)<br>        : <span class="hljs-built_in">m_size</span>(other.m_size), <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size])<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy constructor&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_size; ++i)<br>            m_data[i] = other.m_data[i];<br>    &#125;<br><br>    Intvec&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Intvec&amp; other)<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy assignment operator&quot;</span>);<br>        <span class="hljs-function">Intvec <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>        std::<span class="hljs-built_in">swap</span>(m_size, tmp.m_size);<br>        std::<span class="hljs-built_in">swap</span>(m_data, tmp.m_data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> m_size;<br>    <span class="hljs-type">int</span>* m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样，我们定义了基本的构造器、析构器、拷贝构造器 (copy constructor)和拷贝赋值操作符 (copy assignment operator)【注4：拷贝赋值操作符的实现是在考虑异常安全角度的规范写法。结合使用拷贝构造器和不会抛出异常的<code>std::swap</code>，可以保证在异常发生时不会出现未初始化的内存】。它们都有一个logging 函数，让我们能知道是否调用了它们。</p><p>运行一个将 <code>v1</code> 的内容拷贝到 <code>v2</code> 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Intvec <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>Intvec v2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;assigning lvalue...\n&quot;</span>;<br>v2 = v1;<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning lvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>运行输出的结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">assigning lvalue...<br>[<span class="hljs-number">0</span>x28fef8] <span class="hljs-keyword">copy</span> assignment <span class="hljs-keyword">operator</span><br>[<span class="hljs-number">0</span>x28fec8] <span class="hljs-keyword">copy</span> <span class="hljs-keyword">constructor</span><br>[0<span class="hljs-title function_">x28fec8</span>] <span class="hljs-title function_">destructor</span><br><span class="hljs-title function_">ended</span> <span class="hljs-title function_">assigning</span> <span class="hljs-title function_">lvalue</span>...<br></code></pre></td></tr></table></figure><p>这是正常的结果，准确展示了 <code>operator=</code>的内部过程。但假设我们要将一个右值赋值给 <code>v2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;assigning rvalue...\n&quot;</span>;<br>v2 = <span class="hljs-built_in">Intvec</span>(<span class="hljs-number">33</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning rvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>虽然这里的例子中是赋值一个新创建的vector，但它可以代表更一般的情况——创建了一个临时的右值，然后赋值给<code>v2</code> （例如当一个函数返回 vector的情况）。我们会得到这样的输入：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>这看起来就要很多步骤了。特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。然而，在拷贝赋值操作符中，也创建和销毁了<em>另一个</em> 临时的对象。这完全是多余的没有意义的工作。</p><p>不过现在你不需要多一个临时对象了。C++11引入了右值引用，让我们可以实现“移动语义” (movesemantics)，特别是可以实现“移动赋值操作符” (move assignment operator)【注5：文章中一直将 <code>operator=</code> 叫做 “拷贝赋值操作符” (copyassignment operator)。在 C++11中，区分这两个概念是很重要的】。我们可以为 <code>Intvec</code>加上另一个 <code>operator=</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">Intvec&amp; <span class="hljs-keyword">operator</span>=(Intvec&amp;&amp; other)<br>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;move assignment operator&quot;</span>);<br>    std::<span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>    std::<span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>符号 <code>&amp;&amp;</code> 代表了新的 <strong>右值引用 (rvaluereference)</strong>。顾名思义，右值引用可以让我们创建对右值的引用。而且在调用结束后，右值引用就会被销毁。我们可以利用这个特性将右值的内部内容“偷”过来——因为我们不再需要使用这个右值对象了！这样得到的输出是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">move</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>由于将一个右值赋值给了 <code>v2</code>，移动赋值操作符被调用。虽然<code>Intvec(33)</code>仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。优雅。</p><p>再提醒一遍，这个例子只展示了移动语义和右值引用的冰山一角。你可以猜到，这实际上是一个复杂的话题，要考虑很多特殊情况和陷阱。我是想展示一个C++中左值右值区别的一个很有趣的应用。编译器显然知道哪里是个右值，会在编译时选择调用合适的构造器。</p><h2 id="总结">总结</h2><p>即使不考虑左值和右值的问题，你也可以写很多 C++代码，然后把这些问题看作编译器某些错误警告中奇怪的行话。然而，这篇文章想表明，对这个问题有一些领悟的话，会使你能更深入地理解一些C++ 代码，也更能弄懂一些 C++ 规范和语言专家的讨论。</p><p>另外，在新的 C++ 规范中，因为 C++11引入了右值引用和移动语义，这个话题变得更重要了。要想真正理解这个语言的一些新特性，透彻地理解左值和右值就变得重要了。</p><p>转载自<ahref="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C">理解C/C++ 中的左值和右值</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ auto与decltype:类型推导</title>
    <link href="/2023/03/04/C++-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/03/04/C++-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="modern-c-之-auto-与-decltype-类型推导">Modern C++ 之 auto 与decltype : 类型推导</h1><h2 id="auto-与-decltype-类型推导"><code>auto</code> 与<code>decltype</code> : 类型推导</h2><p>变量类型推导其实在 C++ 中一直存在,例如我们在使用泛型函数时编译器将帮助我们隐式地推导参数类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(_Type value)</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">114514</span>);  <span class="hljs-comment">// func&lt;int&gt;(114514);</span><br></code></pre></td></tr></table></figure><p>但直到 C++11 起才允许用户主动要求编译器进行类型推导. 现代 C++中提供的主动类型推导功能主要是通过 <code>auto</code> 的<code>decltype</code> 两个关键字实现.</p><h2 id="使用-auto-进行变量类型推导">使用 <code>auto</code>进行变量类型推导</h2><p>当你声明一个变量为 <code>auto</code> 类型时,编译器将自动帮助你推导出合适的数据类型. 这个变量可以是 :</p><ol type="1"><li>声明后立即赋值的普通变量;</li><li>函数的返回值;</li><li>函数的形参 (C++14 起)</li></ol><p>需要注意的是, 使用 <code>auto</code> 进行类型推导时, 将忽略顶层的<code>const</code> , <code>&amp;</code> , <code>*</code> 等修饰符,以便用户更细化的控制推导, 示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">auto</span> var_1 = number;       <span class="hljs-comment">// int var_1 = number;</span><br><span class="hljs-keyword">auto</span> var_2 = <span class="hljs-number">8.0f</span>;         <span class="hljs-comment">// float var_2 = 8.0f;</span><br><span class="hljs-keyword">auto</span> var_3 = var_1;        <span class="hljs-comment">// int var_3 = var_1;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> var_4 = var_2;  <span class="hljs-comment">// const float var_4 = var_2;</span><br><span class="hljs-keyword">auto</span>&amp; var_5 = number;      <span class="hljs-comment">// int&amp; var_5 = number;</span><br></code></pre></td></tr></table></figure><p>这种基础的用法主要是用于省略一些很长的类型名,一定程度上增加代码可读性. 一种经典用法是简写迭代器类型以遍历容器, 传统C++ 中, 我们需要完整写出迭代器的类型或是使用局部的 <code>typedef</code>进行简写, 如下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::unordered_map&lt;std::string, std::string&gt; key_value_map;<br><span class="hljs-comment">// C++98/03, 迭代器遍历容器完整写法</span><br><span class="hljs-keyword">for</span> (std::unordered_map&lt;std::string, std::string&gt;::const_iterator itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++98/03, 使用迭代器别名进行缩写</span><br><span class="hljs-keyword">typedef</span> std::unordered_map&lt;std::string, std::string&gt;::const_iterator unordered_map_const_itor;<br><span class="hljs-keyword">for</span> (unordered_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>而现代 C++ 中, 一方面我们通常使用 <code>using</code> 代替<code>typedef</code>, 但更方便的方式是使用 <code>auto</code>简写迭代器类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, 使用 using 代替 typedef</span><br><span class="hljs-keyword">using</span> hash_map_const_itor = std::unordered_map&lt;std::string, std::string&gt;::const_iterator;<br><span class="hljs-keyword">for</span> (hash_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++11 起, 使用 auto 自动推导迭代器类型</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们稍微引申一下, 在现代 C++ 中迭代一个容器的方式还有很多,具体可见下面的例子 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, auto + 范围 for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++17 起, auto + 范围 for 循环 + 结构化绑定</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++20 起, auto + 范围 for 循环 + 结构化绑定 + range 机制, 细化控制方式 (MSVC /std:c++laest)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::all) <span class="hljs-comment">// 全部遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::reverse) <span class="hljs-comment">// 全部倒序遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::<span class="hljs-built_in">drop</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 顺序遍历忽略前两个</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了普通的变量外, 我们还可以使用 <code>auto</code> 设置函数的返回值,此时需要我们在参数列表后使用 <code>-&gt;</code>符号标注具体的返回值类型. 这种写法被称作"返回类型后置语法",在一些脚本语言中比较常见 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>-&gt;<span class="hljs-type">int</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br><br><span class="hljs-comment">// 引申 : lambda 表达式的书写格式借鉴了返回值后置语法</span><br><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>到了 C++14, 我们甚至可以使用 <code>auto</code> 进行参数类型推导,在传统 C++ 中我们想进行参数类型的推导需要用到泛型机制, 但有了<code>auto</code> 进行推导参数类型后, 我们可以简化一些工作 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(_Type value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br><span class="hljs-comment">// C++20</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p><code>auto</code> 关键字在单独使用时, 大部分是用于简化书写当它与其它机制结合使用时可以衍生出更多的功能, 同样在下文里细说.</p><h2 id="使用-decltype-进行表达式类型推导">使用 <code>decltype</code>进行表达式类型推导</h2><p><code>auto</code> 关键字用于推导变量类型, 与之相对的<code>decltype</code> 则是用来推导表达式结果的类型. 熟悉 GCC的用户可能对这个关键字不陌生, <code>decltype</code> 的标准化提案就是源自GCC 的扩展关键字 <code>__decltype</code>, 而后者又是源自于 GCC一个很古老的扩展关键字 <code>__typeof__</code> .例如你可能需要推导某两个变量相加的结果类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> number_a = <span class="hljs-number">16LL</span>;                                          <span class="hljs-comment">// long long number_a = 16LL;</span><br><span class="hljs-keyword">auto</span> number_b = <span class="hljs-number">16.0F</span>;                                         <span class="hljs-comment">// float number_b = 16.0F;</span><br><span class="hljs-keyword">decltype</span>(number_a + number_b) number_c = number_a + number_b;  <span class="hljs-comment">// float number_c = number_a + number_b;</span><br></code></pre></td></tr></table></figure><p><code>decltype</code> 的推导规则遵循如下几点 :</p><ol type="1"><li>若表达式是一个 <strong>不带括号的标记符表达式</strong> 或<strong>类/结构体成员访问表达式</strong>,那么推导的结果是所代表实体的类型;</li><li>若表达式是一个<strong>函数调用(包括操作符重载)</strong>,那么推导的结果是函数的返回类型, 若返回值是基础类型则抛弃<code>const</code> 限定符;</li><li>若表达式是一个<strong>字符串字面量</strong>, 则推到为<code>const</code> 左值引用;</li><li>上述情况以外, 若表达式结果为左值则推导为左值引用,否则推导为本类型;</li></ol><p>示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> const_number = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> number_array[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span>* number_array_ptr = number_array;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123; <span class="hljs-type">double</span> member; &#125; my_struct;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">bool</span> <span class="hljs-title">func_1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;;<br><span class="hljs-function"><span class="hljs-type">const</span> MyStruct <span class="hljs-title">func_2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyStruct</span>(); &#125;;<br><br><span class="hljs-comment">// 规则 1 : 不带括号的标记符表达式 或 类/结构体成员访问表达式</span><br><span class="hljs-keyword">decltype</span>(number_array) var_1;      <span class="hljs-comment">// int[2] var_1; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number_array_ptr) var_2;  <span class="hljs-comment">// int*   var_2; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(my_struct.member) var_3;  <span class="hljs-comment">// double var_3; 成员访问表达式 =&gt; 本类型</span><br><br><span class="hljs-comment">// 规则 2 : 函数调用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_1</span>(<span class="hljs-number">1</span>)) var_5 = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// bool var_5; 基础类型返回值, 丢弃 const 限定符</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>)) var_7 = <span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// const MyStruct var_7; 类类型返回值, 保留 const 限定符</span><br><br><span class="hljs-comment">// 规则 3 : 字符串字面量</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-string">&quot;hello&quot;</span>) var_8 = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">//const char&amp; var_8[6]; const 左值引用</span><br><br><span class="hljs-comment">// 规则 4 : 其他情况下表达式结果</span><br><span class="hljs-keyword">decltype</span>((number)) var_9 = number;                 <span class="hljs-comment">// int&amp; var_9; 带括号的标记符表达式 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? number : number) var_10 = number;  <span class="hljs-comment">// int&amp; var_10; 条件表达式返回左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(++number) var_11 = number;                <span class="hljs-comment">// int&amp; var_11; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(number_array[<span class="hljs-number">5</span>]) var_12 = number;         <span class="hljs-comment">// int&amp; var_12; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(*number_array_ptr) var_13 = number;       <span class="hljs-comment">// int&amp; var_13; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>) var_14 = <span class="hljs-number">10</span>;                           <span class="hljs-comment">// int var_14; 纯右值字面量 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number++) var_15 = number;                <span class="hljs-comment">// int var_15; 表达式结果为右值 =&gt; 本类型</span><br></code></pre></td></tr></table></figure><p>你可能在部分平台上使用过关键字 <code>typeof</code> ,<code>__typeof__</code> 或 <code>__decltype</code> ,它们同样可用于推导表达式结果类型, 并且可以视作 <code>decltype</code>功能的子集. 但这些关键字从来都不是标准 C++ 的一部分,只是部分编译器支持的功能, 并且它们的推导规则也有很强的平台差异性.相比之下 <code>decltype</code> 的标准化程度和适用面更广. 除此之外<code>typeof</code> 进行类型推导时 <code>&amp;</code>引用符号很可能将不做保留, 至少 GCC 上是这样的, 参考以下示例 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>           var = <span class="hljs-number">1</span>; <br><span class="hljs-type">int</span>&amp;          ref = var; <br><span class="hljs-built_in">typeof</span>(var)   var_1 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-built_in">typeof</span>(ref)   var_2 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-keyword">decltype</span>(var) var_3;      <span class="hljs-comment">// int </span><br><span class="hljs-keyword">decltype</span>(ref) var_4 = a;  <span class="hljs-comment">// int&amp; </span><br></code></pre></td></tr></table></figure><p>总之, 当你的工程所使用的 C++ 版本若是等于或高于 C++11 ,我推荐全盘使用 <code>decltype</code> 代替 <code>typeof</code> .</p><h2 id="结合-auto-与-decltype-进行自动推导返回值类型">结合<code>auto</code> 与 <code>decltype</code> 进行自动推导返回值类型</h2><p><code>auto</code> 与 <code>decltype</code> 单独使用的时候,在功能上的突破本质还是向用户开放了主动要求类型推导的权限.但如果二者结合使用的话, 就可以突破传统 C++ 中一些限制了.在这里我们思考一个问题 : <strong>如何实现一个满足所有类型之间进行<code>+</code> 运算的函数?</strong></p><p>在传统 C++ 中的最优解是这样的 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function">_TypeResult <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法的确可以满足所有类型的 <code>+</code> 运算,但很明显使用上有着很大的局限性. 因为我们必须预知返回值的类型,而题目的隐藏含义是一定要做到通用性的. 那么我们现在已经知道如何使用<code>decltype</code> 可以进行表达式结果的类型推导,那何不直接用其直接推导函数体的结果呢 ?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> <span class="hljs-comment">// 未定义的标识符</span></span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>很遗憾这种行为是无效的, 因为形式参的定义在参数列表里,而处于参数列表左侧的返回值类型是无法获取形参名的.除非我们能将返回值类型放在参数列表的右侧, 实现这个目标的方式就是使用<code>auto</code> 书写返回类型后置语法 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// auto 返回类型后置语法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;_TypeResult </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br><span class="hljs-comment">// auto 返回类型后置语法 结合 decltype 表达式结果类型推导</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>若只是单纯的只用 <code>auto</code> 进行返回类型后置,则只是换了种语法. 但如果将 <code>auto</code> 与 <code>decltype</code>相结合, 就可以突破传统 C++ 的限制了. 到此,我们已经完全实现了题目里的需求. 但还有继续优化的空间,首先是上文中提到的, 自 C++14 起, 我们可以利用 <code>auto</code>进行参数类型的推导 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>其次是由于这种二者结合的模式被大量的使用, 自 C++14 起, 我们在使用<code>auto</code> 描述返回类型时无需在参数列表后写上返回类型,编译器将自动通过函数体进行推导, 因此这个方法最终将演化成这种形式 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p><strong>引申 : 上例中的 "最终版本" 真的完美吗?</strong></p><blockquote><p>返回类型后置这种语法看似只是语法上的一些取巧手法,但实则通过这种方式可以突破编译器的桎梏,因为编译器始终是由上至下由左至右理解代码的.</p></blockquote><p>正如上文中所说, <code>auto</code> 与 <code>decltype</code>的功能并不是现代 C++ 才出现的,而且在它们单独使用时更多的时候是一种简化代码书写的方式.但当二者结合起来时, 将可以做出一些语言功能上的突破.</p><h2 id="auto-与-decltype-的演化"><code>auto</code> 与<code>decltype</code> 的演化</h2><p>传统 C++ 里, 类型推导一般是在模板传参时进行隐式类型推导, 而<code>auto</code> 的出现是将类型推导的控制权开放给用户进行显示类型推导;而传统 C++ 里表达式结果类型的推导通常由不同平台上各种<code>typeof</code> 非标准扩展关键字实现, 而 <code>decltype</code>的出现则是这个功能的标准化. 当 <code>auto</code> 与<code>decltype</code> 相结合后, 由衍生出许多新的功能, 它们二者构成了现代C++ 类型推导功能的核心. 以下的 <code>auto</code> 与<code>decltype</code> 的发展历程简述 :</p><ol type="1"><li>C++11 :<ul><li>允许使用 <code>auto</code> 进行普通变量的主动类型推导;</li><li>允许使用 <code>auto</code> 书写返回值后置语法;</li><li>使用标准 <code>decltype</code> 进行表达式结果类型推导以替代各平台的<code>typeof</code> 扩展关键字;</li></ul></li><li>C++14 :<ul><li>允许使用 <code>auto</code> 进行形参类型推导;</li><li>允许使用 <code>auto</code> 进行返回值类型推导(书写返回值后置语法时不适用类型标识符表面返回类型);</li></ul></li></ol><p>内容转载自 <ahref="http://brabbit.xyz/blog/NoteModernCpp/p3_auto_deltype.html">ModernC++ 之 auto 与 decltype : 类型推导</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2023/03/04/C++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/03/04/C++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="详解-c-11-中的智能指针">详解 C++ 11 中的智能指针</h2><p>C/C++语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在C/C++语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如boost，智能指针技术应运而生。</p><h4 id="c-9803-的尝试stdauto_ptr">C++ 98/03 的尝试——std::auto_ptr</h4><p>在 2022 年讨论 <strong>std::auto_ptr</strong>不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11标准的出现（最新标准是 C++20），<strong>std::auto_ptr</strong>已经被彻底废弃了，取而代之是<strong>std::unique_ptr</strong>。然而，我之所以还向你介绍一下<strong>std::auto_ptr</strong> 的用法以及它的设计不足之处是想让你了解C++语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它，不是吗？</p><p><strong>std::auto_ptr</strong> 的基本用法如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化方式1</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-comment">//初始化方式2</span><br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">8</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针对象 <strong>sp1</strong> 和 <strong>sp2</strong>均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在<strong>sp1</strong> 和 <strong>sp2</strong> 释放时得到释放。这是<strong>std::auto_ptr</strong> 的基本用法。</p><blockquote><p>sp 是 smart pointer（智能指针）的简写。</p></blockquote><p><strong>std::auto_ptr</strong>真正让人容易误用的地方是其不常用的复制语义，即当复制一个<strong>std::auto_ptr</strong> 对象时（拷贝复制或 operator =复制），原对象所持有的堆内存对象也会转移给复制出来的对象。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试拷贝构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    <span class="hljs-keyword">if</span> (sp1.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp2.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">//测试赋值构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp4;<br>    sp4 = sp3;<br>    <span class="hljs-keyword">if</span> (sp3.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp4.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中分别利用拷贝构造（sp1 =&gt; sp2）和 赋值构造（sp3 =&gt;sp4）来创建新的 std::auto_ptr 对象，因此 sp1 持有的堆对象被转移给sp2，sp3 持有的堆对象被转移给 sp4。我们得到程序执行结果如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[root@iZ238vnojlyZ testx]<span class="hljs-comment"># g++ -g -o test_auto_ptr test_auto_ptr.cpp</span><br>[root@iZ238vnojlyZ testx]<span class="hljs-comment"># ./test_auto_ptr </span><br>sp1 <span class="hljs-keyword">is</span> empty.<br>sp2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br>sp3 <span class="hljs-keyword">is</span> empty.<br>sp4 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br></code></pre></td></tr></table></figure><p>由于 <strong>std::auto_ptr</strong>这种不常用的复制语义，我们应该避免在 stl 容器中使用<strong>std::auto_ptr</strong>，例如我们绝不应该写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; myvectors;<br></code></pre></td></tr></table></figure><p>当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误。</p><p>以史为鉴，作为 <strong>std::auto_ptr</strong> 的替代者<strong>std::unique_ptr</strong>吸取了这个经验教训。下文会来详细介绍。</p><p>正因为 <strong>std::auto_ptr</strong> 的设计存在如此重大缺陷，C++11标准在充分借鉴和吸收了 boost库中智能指针的设计思想，引入了三种类型的智能指针，即<strong>std::unique_ptr</strong>、<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong>。</p><blockquote><p>boost 还有 scoped_ptr，C++11并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。</p></blockquote><p>所有的智能指针类（包括 std::unique_ptr）均包含于头文件 **** 中。</p><blockquote><p>正因为存在上述设计上的缺陷，在 C++11及后续语言规范中 std::auto_ptr已经被废弃，你的代码不应该再使用它。</p></blockquote><h4 id="stdunique_ptr">std::unique_ptr</h4><p><strong>std::unique_ptr</strong>对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是1，<strong>std::unique_ptr</strong>对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个<strong>std::unique_ptr</strong> 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>你应该尽量使用初始化方式 3 的方式去创建一个<strong>std::unique_ptr</strong> 而不是方式 1 和 2，因为形式 3更安全，原因 Scott Meyers 在其《Effective ModernC++》中已经解释过了，有兴趣的读者可以阅读此书相关章节。</p><blockquote><p>令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared()方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique()方法创建一个 std::unique_ptr 对象，这个方法直到 C++14才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp; ...params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></td></tr></table></figure><p>鉴于 <strong>std::auto_ptr</strong>的前车之鉴，<strong>std::unique_ptr</strong>禁止复制语义，为了达到这个效果，<strong>std::unique_ptr</strong>类的拷贝构造函数和赋值运算符（operator =）被标记为<strong>delete</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//省略其他代码...</span><br><br>    <span class="hljs-comment">//拷贝构造函数和赋值运算符被标记为delete</span><br>    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，下列代码是无法通过编译的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;;<br><br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//std::unique_ptr&lt;int&gt; sp2(sp1);</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//sp3 = sp1;</span><br></code></pre></td></tr></table></figure><p>禁止复制语义也存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(val))</span></span>;<br>    <span class="hljs-keyword">return</span> up;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp1 = <span class="hljs-built_in">func</span>(<span class="hljs-number">123</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码从 func 函数中得到一个 <strong>std::unique_ptr</strong>对象，然后返回给 sp1。</p><p>既然 <strong>std::unique_ptr</strong> 不能复制，那么如何将一个<strong>std::unique_ptr</strong>对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;<br><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(std::move(sp1))</span></span>;<br><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>    sp3 = std::<span class="hljs-built_in">move</span>(sp2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2不再持有堆内存的引用，变成一个空的智能指针对象。并不是所有的对象的std::move 操作都有意义，只有实现了移动构造函数（MoveConstructor）或移动赋值运算符（operator =）的类才行，而<strong>std::unique_ptr</strong> 正好实现了这二者，以下是实现伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Deletor&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//其他函数省略...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T*    m_pT;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是 <strong>std::unique_ptr</strong>具有移动语义的原因，希望读者可以理解之。关于移动构造和<strong>std::move</strong>，我们将在后面章节详细介绍。</p><p><strong>std::unique_ptr</strong>不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建10个int类型的堆对象</span><br>    <span class="hljs-comment">//形式1</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br>    <span class="hljs-comment">//形式2</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]);<br>    <span class="hljs-comment">//形式3</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">10</span>))</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        sp1[i] = i;<br>        sp2[i] = i;<br>        sp3[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        std::cout &lt;&lt; sp1[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp2[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp3[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># g++ -g -o test_unique_ptr_with_array test_unique_ptr_with_array.cpp -std=c++17</span><br>[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># ./test_unique_ptr_with_array </span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span><br><span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br><span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span><br><span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span><br><span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span><br><span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span><br><span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>也可以持有一组堆对象，用法与 <strong>std::unique_ptr</strong>相同，下文不再赘述。</p><p><strong>自定义智能指针对象持有的资源的释放函数</strong></p><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete或者delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个Socket类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以<strong>std::unique_ptr</strong> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    ~<span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//关闭资源句柄</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> deletor = [](Socket* pSocket) &#123;<br>        <span class="hljs-comment">//关闭句柄</span><br>        pSocket-&gt;<span class="hljs-built_in">close</span>();<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span><br>        <span class="hljs-keyword">delete</span> pSocket;<br>    &#125;;<br><br>    <span class="hljs-function">std::unique_ptr&lt;Socket, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(Socket * pSocket)</span>&gt; <span class="hljs-title">spSocket</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Socket(), deletor)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义 <strong>std::unique_ptr</strong> 的资源释放函数其规则是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;T, DeletorFuncPtr&gt;<br></code></pre></td></tr></table></figure><p>其中 T 是你要释放的对象类型，DeletorPtr是一个自定义函数指针。上述代码 <strong>33</strong> 行表示 DeletorPtr有点复杂，我们可以使用 <strong>decltype(deletor)</strong>让编译器自己推导 deletor 的类型，因此可以将 <strong>33</strong>行代码修改为：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">std</span>::unique_ptr&lt;<span class="hljs-type">Socket</span>, decl<span class="hljs-keyword">type</span>(deletor)&gt; spSocket(new <span class="hljs-type">Socket</span>(), deletor);<br></code></pre></td></tr></table></figure><h4 id="stdshared_ptr">std::shared_ptr</h4><p><strong>std::unique_ptr</strong> 对其持有的资源具有独占性，而<strong>std::shared_ptr</strong> 持有的资源可以在多个<strong>std::shared_ptr</strong> 之间共享，每多一个<strong>std::shared_ptr</strong> 对资源的引用，资源引用计数将增加1，每一个指向该资源的 <strong>std::shared_ptr</strong>对象析构时，资源引用计数减 1，最后一个 <strong>std::shared_ptr</strong>对象析构时，发现资源计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作<strong>std::shared_ptr</strong>引用的对象是安全的）。<strong>std::shared_ptr</strong> 提供了一个<strong>use_count()</strong>方法来获取当前持有资源的引用计数。除了上面描述的，<strong>std::shared_ptr</strong>用法和 <strong>std::unique_ptr</strong> 基本相同。</p><p>下面是一个初始化 <strong>std::shared_ptr</strong> 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>sp3 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>和 <strong>std::unique_ptr</strong> 一样，你应该优先使用<strong>std::make_shared</strong> 去初始化一个<strong>std::shared_ptr</strong> 对象。</p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//初始化方式1</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//初始化方式2</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        sp2.<span class="hljs-built_in">reset</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        &#123;<br>            std::shared_ptr&lt;A&gt; sp3 = sp1;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码 <strong>22</strong> 行 sp1 构造时，同时触发对象 A的构造，因此 A 的构造函数会执行；</li><li>此时只有一个 sp1 对象引用 <strong>22</strong> 行 new 出来的 A对象（为了叙述方便，下文统一称之为<strong>资源对象A</strong>），因此代码 <strong>24</strong> 行打印出来的引用计数值为<strong>1</strong>；</li><li>代码 <strong>27</strong> 行，利用 sp1 拷贝一份 sp2，导致代码<strong>28</strong> 行打印出来的引用计数为 <strong>2</strong>；</li><li>代码 <strong>30</strong> 行调用 sp2 的 reset() 方法，sp2释放对资源对象 A 的引用，因此代码 <strong>31</strong>行打印的引用计数值再次变为 <strong>1</strong>；</li><li>代码 <strong>34</strong> 行 利用 sp1 再次 创建 sp3，因此代码<strong>35</strong> 行打印的引用计数变为 <strong>2</strong>；</li><li>程序执行到 <strong>36</strong> 行以后，sp3 出了其作用域被析构，资源A 的引用计数递减 1，因此 代码 <strong>38</strong> 行打印的引用计数为<strong>1</strong>；</li><li>程序执行到 <strong>39</strong> 行以后，sp1出了其作用域被析构，在其析构时递减资源 A 的引用计数至<strong>0</strong>，并析构资源 A 对象，因此类 A 的析构函数被调用。</li></ul><p>所以整个程序的执行结果如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# ./test_shared_ptr_use_count <br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">use</span> <span class="hljs-title">count</span>:</span> <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>A <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure><p><strong>std::enable_shared_from_this</strong></p><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个<strong>std::shared_ptr</strong> 对象给外部使用，C++新标准也为我们考虑到了这一点，有如此需求的类只要继承自<strong>std::enable_shared_from_this</strong>模板对象即可。用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">getSelf</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，类 A 的继承 <strong>std::enable_shared_from_this</strong>并提供一个 <strong>getSelf()</strong> 方法返回自身的<strong>std::shared_ptr</strong> 对象，在 <strong>getSelf()</strong>中调用 <strong>shared_from_this()</strong> 即可。</p><p><strong>std::enable_shared_from_this</strong>用起来比较方便，但是也存在很多不易察觉的陷阱。</p><p><strong>陷阱一：不应该共享栈对象的 this 给智能指针对象</strong></p><p>假设我们将上面代码 main 函数 <strong>25</strong> 行生成 A对象的方式改成一个栈变量，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//其他相同代码省略...</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br><br>    std::shared_ptr&lt;A&gt; sp2 = a.<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行修改后的代码会发现程序在<code>std::shared_ptr sp2 = a.getSelf();</code>产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过<strong>shared_from_this()</strong>将该对象交由智能指针对象管理。切记：<strong>智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</strong>。</p><p><strong>陷阱二：避免 std::enable_shared_from_this的循环引用问题</strong></p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// test_std_enable_shared_from_this.cpp : This file contains the &#x27;main&#x27; function. Program execution begins and ends there.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">9</span>;<br>        <span class="hljs-comment">//注意:</span><br>        <span class="hljs-comment">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span><br>        <span class="hljs-comment">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">0</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_SelfPtr = <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>                 m_i;<br>    std::shared_ptr&lt;A&gt;  m_SelfPtr;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">spa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        spa-&gt;<span class="hljs-built_in">func</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# g++ -g -o test_std_enable_shared_from_this_problem test_std_enable_shared_from_this_problem.cpp<br>[root@myaliyun testmybook]# ./test_std_enable_shared_from_this_problem<br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br></code></pre></td></tr></table></figure><p>我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏了！</p><p>我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到<strong>42</strong> 行后，spa出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁A。这就是所谓的 std::enable_shared_from_this的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。也就是说一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理。</p><h4 id="stdweak_ptr">std::weak_ptr</h4><p><strong>std::weak_ptr</strong>是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助<strong>std::shared_ptr</strong> 工作。</p><p><strong>std::weak_ptr</strong> 可以从一个<strong>std::shared_ptr</strong> 或另一个 <strong>std::weak_ptr</strong>对象构造，<strong>std::shared_ptr</strong> 可以直接赋值给<strong>std::weak_ptr</strong> ，也可以通过<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 函数来获得<strong>std::shared_ptr</strong>。它的构造和析构不会引起引用计数的增加或减少。<strong>std::weak_ptr</strong>可用来解决 <strong>std::shared_ptr</strong>相互引用时的死锁问题（即两个<strong>std::shared_ptr</strong>相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放）。</p><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个std::shared_ptr对象</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过构造函数得到一个std::weak_ptr对象</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过赋值运算符得到一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = sp1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp4 = sp2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># g++ -g -o test_weak_ptr test_weak_ptr.cpp </span><br>[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># ./test_weak_ptr</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>无论通过何种方式创建 <strong>std::weak_ptr</strong>都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。</p><p>既然，<strong>std::weak_ptr</strong>不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？<strong>std::weak_ptr</strong>提供了一个 <strong>expired()</strong> 方法来做这一项检测，返回true，说明其引用的资源已经不存在了；返回false，说明该资源仍然存在，这个时候可以使用<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 方法得到一个<strong>std::shared_ptr</strong>对象然后继续操作资源，以下代码演示了该用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span><br><span class="hljs-comment">//tmpConn_引用的TcpConnection已经销毁，直接返回</span><br><span class="hljs-keyword">if</span> (tmpConn_.<span class="hljs-built_in">expired</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (conn)<br>&#123;<br>    <span class="hljs-comment">//对conn进行操作，省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有读者可能对上述代码产生疑问，既然使用了<strong>std::weak_ptr</strong> 的 <strong>expired()</strong>方法判断了对象是否存在，为什么不直接使用 <strong>std::weak_ptr</strong>对象对引用资源进行操作呢？实际上这是行不通的，<strong>std::weak_ptr</strong>类没有重写 <strong>operator-&gt;</strong> 和 <strong>operator</strong>*方法，因此不能像 <strong>std::shared_ptr</strong> 或<strong>std::unique_ptr</strong> 一样直接操作对象，同时<strong>std::weak_ptr</strong> 类也没有重写 <strong>operator!</strong>操作，因此也不能通过 <strong>std::weak_ptr</strong>对象直接判断其引用的资源是否存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    <span class="hljs-function">std::weak_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (sp1)<br>    &#123;<br>        <span class="hljs-comment">//正确代码</span><br>        sp1 -&gt; <span class="hljs-built_in">doSomething</span>();<br>        (*sp1).<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (!sp1)<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    //错误代码，无法编译通过</span><br>    <span class="hljs-comment">//    sp2-&gt;doSomething();</span><br>    <span class="hljs-comment">//    (*sp2).doSomething();</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (!sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以 <strong>std::weak_ptr</strong>不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦。</p><p>因此，<strong>std::weak_ptr</strong>的正确使用场景是那些资源如果可用就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时Session 对象如果强行持有 Connection 对象与事实矛盾。</p><p><strong>std::weak_ptr</strong>的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeManager</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publish</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; iter : m_subscribers)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!iter.<span class="hljs-built_in">expired</span>())<br>            &#123;<br>                <span class="hljs-comment">//TODO：给订阅者发送消息</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt;   m_subscribers;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="智能指针对象的大小">智能指针对象的大小</h4><p>一个 <strong>std::unique_ptr</strong> 对象大小与裸指针大小相同（即sizeof(std::unique_ptr<T>) == sizeof(void*)），而<strong>std::shared_ptr</strong> 的大小是<strong>std::unique_ptr</strong> 的两倍。以下是我分别在 Visual Studio2019 和 gcc/g++ 4.8 上（二者都编译成 x64 程序）的测试结果：</p><p><strong>测试代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp0;<br>    std::shared_ptr&lt;std::string&gt; sp1;<br>    sp1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>());<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp0 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp0) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp1) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp3) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Visual Studio 2019 运行结果：</p><p><img src="/img/C++/智能指针/sp1.webp" /></p><p>gcc/g++ 运行结果：</p><p><img src="/img/C++/智能指针/sp2.webp" /></p><p>在 32 位机器上，<strong>std_unique_ptr</strong> 占 4字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 8 字节；在 64 位机器上，<strong>std_unique_ptr</strong> 占 8字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 16 字节。也就是说，<strong>std_unique_ptr</strong>的大小总是和原始指针大小一样，<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong> 大小是原始指针的两倍。</p><h4 id="智能指针使用注意事项">智能指针使用注意事项</h4><p>C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++新标准中的各种智能指针是如此的实用与强大，在现代 C++项目开发中，读者应该尽量去使用它们。智能指针虽然好用，但稍不注意，也可能存在许多难以发现的bug，这里我根据经验总结了几条：</p><ul><li><p>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</p><p>看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-keyword">delete</span> pSubscriber;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针spSubscriber去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象<strong>spSubscriber</strong> 情何以堪啊？</p><p>记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。当然，除了<strong>std::weak_ptr</strong>，<strong>std::unique_ptr</strong> 和<strong>std::shared_ptr</strong>都提供了获取原始指针的方法——<strong>get()</strong> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span><br>  Subscriber* pTheSameSubscriber= spSubscriber.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分清楚场合应该使用哪种类型的智能指针；</p><p>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用<strong>std::unique_ptr</strong>，反之使用<strong>std::shared_ptr</strong>，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用<strong>std::weak_ptr</strong>。</p></li><li><p>认真考虑，避免操作某个引用资源已经释放的智能指针；</p><p>前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;T do something...&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> m_i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; sp2 = sp1;<br><br>  sp1.<span class="hljs-built_in">reset</span>();<br><br>  <span class="hljs-comment">//由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为</span><br>  sp2-&gt;<span class="hljs-built_in">doSomething</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即<strong>operator-&gt;</strong>）在内部会调用 <strong>get()</strong>方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用doSomething() 导致程序崩溃。</p><p>你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//连接断开</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MonitorServer::OnClose</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;TcpConnection&gt;&amp; conn)</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(m_sessionMutex)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = m_sessions.<span class="hljs-built_in">begin</span>(); iter != m_sessions.<span class="hljs-built_in">end</span>(); ++iter)<br>  &#123;<br>      <span class="hljs-comment">//通过比对connection对象找到对应的session</span><br>      <span class="hljs-keyword">if</span> ((*iter)-&gt;<span class="hljs-built_in">GetConnectionPtr</span>() == conn)<br>      &#123;<br>          m_sessions.<span class="hljs-built_in">erase</span>(iter);<br>          <span class="hljs-comment">//注意这里：程序在此处崩溃</span><br>          <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;monitor client disconnected: %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码不是我杜撰的，而是来自于我实际的一个商业项目中。注意代码中我提醒注意的地方，该段程序会在代码<strong>12</strong> 行处崩溃，崩溃原因是调用了<code>conn-&gt;peerAddress()</code>方法。为什么这个方法的调用可能会引起崩溃？现在可以一目了然地看出了吗？</p><p>崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个<strong>std::shared_ptr</strong> 的引用，当连接断开时，对应的TcpConnection 对象可能早已被销毁，而 conn引用就会变成空指针（严格来说是不再拥有一个 TcpConnection对象），此时调用 TcpConnection 的 peerAddress()方法就会产生和上一个示例一样的错误。</p></li><li><p>作为类成员变量时，应该优先使用前置声明（forwarddeclarations）</p><p>我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++项目中一般在 *.h文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:<br>  A*      m_pA;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:  <br>  std::unique_ptr&lt;A&gt;  m_spA;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>C++ 新标准中的智能指针我想介绍的就这么多了，Modern C/C++ 已经变为C/C++开发的趋势，希望读者能善用和熟练使用本节介绍的后三种智能指针对象。</p><p>转载自 <ahref="https://github.com/balloonwj/CppGuide/blob/master/articles/C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AF%A6%E8%A7%A3C++11%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md">详解C++11中的智能指针</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL 容器以及常用操作</title>
    <link href="/2023/03/02/C++STL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/03/02/C++STL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="vector容器">vector容器</h2><p>C++ STL vector是一个动态数组容器，它可以在运行时调整大小，并且支持随机访问。以下是vector 常用的基本操作：</p><h3 id="创建vector">创建vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;             <span class="hljs-comment">// 创建一个空 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size)</span></span>;       <span class="hljs-comment">// 创建一个大小为 size 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size, value)</span></span>;<span class="hljs-comment">// 创建一个大小为 size，并且所有元素都初始化为 value 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;        <span class="hljs-comment">// 创建一个副本 vector，v2 和 v1 中的元素相同</span><br></code></pre></td></tr></table></figure><h3 id="访问-vector-元素">访问 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index];                 <span class="hljs-comment">// 访问第 index 个元素</span><br>v.<span class="hljs-built_in">at</span>(index);              <span class="hljs-comment">// 访问第 index 个元素，并且进行边界检查</span><br>v.<span class="hljs-built_in">front</span>();                <span class="hljs-comment">// 访问第一个元素</span><br>v.<span class="hljs-built_in">back</span>();                 <span class="hljs-comment">// 访问最后一个元素</span><br>v.<span class="hljs-built_in">data</span>();                 <span class="hljs-comment">// 返回指向 vector 数据的指针</span><br></code></pre></td></tr></table></figure><h3 id="修改-vector-元素">修改 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index] = value;         <span class="hljs-comment">// 修改第 index 个元素为 value</span><br>v.<span class="hljs-built_in">at</span>(index) = value;      <span class="hljs-comment">// 修改第 index 个元素为 value，并且进行边界检查</span><br>v.<span class="hljs-built_in">emplace_back</span>(value);       <span class="hljs-comment">// 在 vector 的末尾插入一个元素</span><br>v.<span class="hljs-built_in">pop_back</span>();             <span class="hljs-comment">// 删除 vector 的末尾元素</span><br>v.<span class="hljs-built_in">insert</span>(iterator, value);<span class="hljs-comment">// 在 iterator 指定的位置插入 value</span><br>v.<span class="hljs-built_in">erase</span>(iterator);        <span class="hljs-comment">// 删除 iterator 指定的元素</span><br>v.<span class="hljs-built_in">clear</span>();                <span class="hljs-comment">// 删除 vector 中所有的元素</span><br>v.<span class="hljs-built_in">resize</span>(size);           <span class="hljs-comment">// 修改 vector 的大小为 size，如果原来的大小比 size 大，则删除后面的元素，否则增加默认值的元素</span><br>v.<span class="hljs-built_in">resize</span>(size, value);    <span class="hljs-comment">// 修改 vector 的大小为 size，并且用 value 进行初始化，如果原来的大小比 size 大，则删除后面的元素，否则增加 value 的元素</span><br></code></pre></td></tr></table></figure><h3 id="vector-容量操作">vector 容量操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v.<span class="hljs-built_in">size</span>();                 <span class="hljs-comment">// 返回 vector 中元素的个数</span><br>v.<span class="hljs-built_in">capacity</span>();             <span class="hljs-comment">// 返回 vector 可以存储的元素的数量，也就是预留的空间</span><br>v.<span class="hljs-built_in">empty</span>();                <span class="hljs-comment">// 如果 vector 为空，返回 true，否则返回 false</span><br>v.<span class="hljs-built_in">reserve</span>(capacity);      <span class="hljs-comment">// 预留 capacity 的存储空间</span><br>v.<span class="hljs-built_in">shrink_to_fit</span>();        <span class="hljs-comment">// 释放 vector 多余的存储空间</span><br></code></pre></td></tr></table></figure><h3 id="vector-遍历操作">vector 遍历操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="查找最大元素和最小元素">查找最大元素和最小元素</h3><p><code>max_element()</code>函数是算法标头的库函数，用于查找范围中的最大元素，它接受容器范围[start，end]，并返回一个迭代器，该迭代器指向给定范围中具有最大值的元素。</p><p><strong>参数</strong>：</p><ul><li>iterator start, iterator end,容器开始和结束位置;</li><li>[compare comp]，可选参数，可以与给定范围内的元素进行比较。</li></ul><p><strong>返回值</strong>:</p><p>iterator -返回一个迭代器，该迭代器指向给定范围内具有最大值的元素。</p><p><code>min_element()</code>同理，参数用法也相同，不同的是它返回的是最小元素的迭代器。</p><h3 id="两个元素之间的范围">两个元素之间的范围</h3><p>我们知道，作用于同一容器的 2个同类型迭代器可以有效指定一个区间范围。在此基础上，如果想获取该指定范围内包含元素的个数，就可以借助distance() 函数。</p><p>distance()函数用于计算两个迭代器表示的范围内包含元素的个数，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>&gt;<br>  <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="hljs-function">difference_type <span class="hljs-title">distance</span> <span class="hljs-params">(InputIterator first, InputIterator last)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，first 和 last都为<strong>迭代器</strong>，其类型可以是输入迭代器、前向迭代器、双向迭代器以及随机访问迭代器；该函数会返回[first,last)范围内包含的元素的个数。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// distance</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span>         <span class="hljs-comment">// list</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">//创建一个空 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist;<br><span class="hljs-comment">//向空 list 容器中添加元素 0~9</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>mylist.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//指定 2 个双向迭代器，用于执行某个区间</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator first = mylist.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//指向元素 0</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator last = mylist.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//指向元素 9 之后的位置</span><br><span class="hljs-comment">//获取 [first,last) 范围内包含元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;distance() = &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(first, last);<br></code></pre></td></tr></table></figure><h2 id="stack容器">stack容器</h2><p>C++ STL 标准库中的 stack是一个后进先出（LIFO）的容器适配器，它可以使用不同的底层容器（默认使用deque）实现。以下是 stack 常用的基本操作：</p><h3 id="创建-stack">创建 stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>std::stack&lt;<span class="hljs-type">int</span>&gt; s;       <span class="hljs-comment">// 创建一个空 stack</span><br><span class="hljs-function">std::stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;   <span class="hljs-comment">// 创建一个副本 stack，s1 和 s 中的元素相同</span><br>std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; s2; <span class="hljs-comment">// 创建一个底层容器为 vector 的 stack</span><br></code></pre></td></tr></table></figure><h3 id="stack-元素操作">stack 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">emplace</span>(value);       <span class="hljs-comment">// 将 value 压入 stack 顶部</span><br>s.<span class="hljs-built_in">pop</span>();                <span class="hljs-comment">// 弹出 stack 顶部的元素</span><br>s.<span class="hljs-built_in">top</span>();                <span class="hljs-comment">// 返回 stack 顶部的元素</span><br>s.<span class="hljs-built_in">empty</span>();              <span class="hljs-comment">// 如果 stack 为空，返回 true，否则返回 false</span><br>s.<span class="hljs-built_in">size</span>();               <span class="hljs-comment">// 返回 stack 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-stack">遍历 stack</h3><p>stack 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历stack。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = s.<span class="hljs-built_in">top</span>();<br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 stack 时，一定要判断 stack 是否为空，否则会发生undefined behavior。</p><h2 id="queue容器">queue容器</h2><p>C++ STL 标准库中的 queue是一个先进先出（FIFO）的容器适配器，它也可以使用不同的底层容器（默认使用deque）实现。以下是 queue 常用的基本操作：</p><h3 id="创建-queue">创建 queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;           <span class="hljs-comment">// 创建一个空 queue</span><br><span class="hljs-function">std::queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q1</span><span class="hljs-params">(q)</span></span>;       <span class="hljs-comment">// 创建一个副本 queue，q1 和 q 中的元素相同</span><br>std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q2;  <span class="hljs-comment">// 创建一个底层容器为 list 的 queue</span><br></code></pre></td></tr></table></figure><h3 id="queue-元素操作">queue 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">q.<span class="hljs-built_in">emplace</span>(value);           <span class="hljs-comment">// 将 value 插入 queue 尾部</span><br>q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-comment">// 弹出 queue 头部的元素</span><br>q.<span class="hljs-built_in">front</span>();                  <span class="hljs-comment">// 返回 queue 头部的元素</span><br>q.<span class="hljs-built_in">back</span>();                   <span class="hljs-comment">// 返回 queue 尾部的元素</span><br>q.<span class="hljs-built_in">empty</span>();                  <span class="hljs-comment">// 如果 queue 为空，返回 true，否则返回 false</span><br>q.<span class="hljs-built_in">size</span>();                   <span class="hljs-comment">// 返回 queue 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-queue">遍历 queue</h3><p>queue 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历queue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 queue 时，一定要判断 queue 是否为空，否则会发生undefined behavior。</p><h2 id="unordered_map容器">unordered_map容器</h2><p>unordered_map定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = std::hash&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Pred = std::equal_to&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, Ty&gt; &gt; &gt;<br>    <span class="hljs-keyword">class</span> unordered_map;<br>    &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">unordered_map</span><br></code></pre></td></tr></table></figure><ul><li><strong>第1个参数</strong>:存储key值。</li><li><strong>第2个参数</strong>:存储mapped value。</li><li><strong>第3个参数</strong>:为哈希函数的函数对象。它将key作为参数，并利用函数对象中的哈希函数返回类型为size_t的唯一哈希值。默认值为std::hash&lt;key &gt;。</li><li><strong>第4个参数</strong>:为等比函数的函数对象。它内部通过等比操作符’=='来判断两个key是否相等，返回值为bool类型。默认值是std::equal_to&lt;key &gt;。</li></ul><p>基本操作</p><h3 id="插入元素">插入元素</h3><p>一种插入的特殊情况是，unordered_map插入的<strong>值</strong>是int类型(key的类型无所谓)，这时候可以用第二种方式插入:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="删除元素">删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-comment">// 删除</span><br>    mymap.<span class="hljs-built_in">erase</span>(mymap.<span class="hljs-built_in">begin</span>());    <br>    mymap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>    mymap.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找元素">查找元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">if</span>(hash_map.<span class="hljs-built_in">find</span>(key) != hash_map.<span class="hljs-built_in">end</span>())       <span class="hljs-comment">// 查找</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;True&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;False&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="unordered_set容器">unordered_set容器</h2><p>C++ STL 中的 unordered_set是一个关联容器，它提供了一种存储唯一元素的无序集合。与 set不同，unordered_set内部的元素是无序的，因此在插入和查找时，它的性能通常比有序的关联容器 set更快。</p><p>以下是一些 unordered_set 的基本用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个 unordered_set 对象</span><br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 使用 find() 方法查找元素</span><br>    <span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (it != mySet.<span class="hljs-built_in">end</span>())<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 count() 方法检查元素是否在 unordered_set 中</span><br>    <span class="hljs-keyword">if</span> (mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">4</span>) &gt; <span class="hljs-number">0</span>) <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;4 is in the set&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历 unordered_set 中的所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; element : mySet)<br>        std::cout &lt;&lt; element &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Found <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the <span class="hljs-built_in">set</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在 unordered_set中，元素的顺序是不确定的，因此输出的结果可能与上面的示例不完全一致。</p><h2 id="stl中emplace和push的区别">STL中emplace和push的区别</h2><p>在 C++ STL 标准库中，容器中的 <code>emplace()</code> 和<code>push()</code>都可以用来向容器中添加新元素。但是它们的底层实现和作用不同。</p><h3 id="push">push()</h3><p><code>push()</code>是一个成员函数，用于将一个已经构造好的元素加入到容器的尾部，即将元素的副本或引用添加到容器中。因此，需要将元素先构造出来，再将其加入容器中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这里的 <code>push_back()</code> 函数首先构造了一个 int类型的元素，然后将其加入到了 vector 的尾部。</p><h3 id="emplace">emplace()</h3><p><code>emplace()</code>是一个可变参数模板函数，它在容器的尾部直接构造一个新的元素，而不需要将元素构造出来再加入容器。因此，它比<code>push()</code> 更加高效。</p><p>例如，对于 vector 容器来说，下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt; v;<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure><p>将直接在 vector 的尾部构造一个 <code>pair&lt;int, double&gt;</code>类型的元素，而不需要先构造一个 <code>pair&lt;int, double&gt;</code>对象，然后再将其加入到 vector 中。</p><h3 id="总结">总结</h3><ul><li><code>emplace()</code> 可以直接在容器中构造新的元素，而<code>push()</code> 需要先将元素构造出来，再加入到容器中。</li><li><code>emplace()</code> 更加高效，因为它省去了元素构造的过程，而<code>push()</code> 则需要先构造元素，再将其加入容器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉树">什么是二叉树</h2><p>二叉树是一种常见的数据结构，它是每个节点至多有两棵子树的树。</p><p>二叉树有两种特殊的形式，满二叉树和完全二叉树。</p><p><strong>满⼆叉树</strong>：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆叉树为满⼆叉树。一棵深度为k的满二叉树节点个数为<spanclass="math inline">\(2^k -1\)</span>。</p><p><strong>完全⼆叉树</strong>：至多只有最下面的两层结点的度数可以小于2,并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。</p><p><img src="/img/算法/二叉树/完全二叉树和满二叉树.png" /></p><p>我们可以看出满二叉树是完全二叉树， 但完全二叉树不一定是满二叉树。</p><h2 id="二叉搜索树二叉排序树">二叉搜索树（二叉排序树）</h2><p>二叉排序树虽然名叫排序树，但是它其实是用来搜索的，是一种有序的二叉树。它遵循着左小右大的规则：</p><ul><li>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；</li><li>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；</li><li>它的左、右⼦树也分别为⼆叉搜索树。</li></ul><p><img src="/img/算法/二叉树/二叉排序树.jpg" /></p><h2 id="平衡二叉树">平衡二叉树</h2><p>二叉搜索树有一个缺点，在插入数据是有序的序列（包括升序和降序），会导致二叉树退化成链表，从而导致在查找，删除，添加时的性能均从O（logN）降低为O（N），这是不能接受的。</p><p>究其原因，是因为二叉搜索树退化成链表的时候，树的高度与节点的个数相等，也就是成正比，所以为了优化这种情况，就出现了具有平衡能力的二叉搜索树，其中AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O（logN）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G.M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm forthe organization of information》中公开了这一数据结构。</p><p><strong>平衡二叉树的性质</strong></p><p>平衡二叉树本质上是特殊的二叉搜索树（二叉排序树），它具有二叉搜索树所有的特点，此外它有自己的特别的性质，如下：</p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>平衡二叉树的左右两个子树都是一棵平衡二叉树。</li></ul><p>平衡因子指的是，平衡二叉树在保持平衡的时候，是通过平衡因子来判断的</p><p><span class="math display">\[节点的平衡因子 = 该节点的左子树的高度 -该节点右子树的高度\]</span></p><p>只有当值等于-1（右子树的高度大），0（左右子树的高度相等），1（左子树的高度大）的时候，能够代表该子树是平衡的除此之外，就认为该节点已经失衡了，需要旋转来维持平衡。</p><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的遍历是对于理解二叉树以及应对二叉树问题必不可少的因素，甚至有很多算法问题都是基于二叉树的不同遍历算法来做的。</p><p>二叉树的遍历有多种实现方式，不同的方式这里都要熟练掌握，只有熟练掌握不同的遍历方式才能以不变应万变来应对不同的问题。</p><h3 id="递归法">递归法</h3><p>很简单，不需要多说，二叉树的前序、中序、后序遍历其实都是一个模板，区别在于它们将当前节点值添加到结果数组<code>res</code>的时间不一样，而这种区别是由不同遍历方式下父节点与子节点的遍历次序导致的。</p><h4 id="前序遍历">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">oreOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    res.<span class="hljs-built_in">emplace_back</span>(res -&gt; val, res);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; left);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">inOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; left, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历">后序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">postOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; left, res);<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; right, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="迭代法">迭代法</h3><h4 id="前序遍历-1">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历-1">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历-1">后序遍历</h4><p>迭代法的后序遍历相比较前序遍历和中序遍历是要麻烦一些的。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// stk.emplace(cur);</span><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; cur -&gt; right != pre)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);   <span class="hljs-comment">// 若右孩子存在且没有遍历过那么将cur重新压栈，访问右子树</span><br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            pre = cur;<br>            cur = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="morris法">Morris法</h3><p>Morris法只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979年的论文「Traversing Binary Trees Simply andCheaply」中首次提出，因此被称为 Morris 遍历。</p><h4 id="前序遍历-2">前序遍历</h4><p>Morris遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下（假设当前遍历到的节点为<code>cur</code>）:</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>,然后将<code>cur</code>加入答案。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树。<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>这样我们利用 Morris遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)      <span class="hljs-comment">// 左子节点为空直接将val加入res中</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;  <br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h4 id="中序遍历-2">中序遍历</h4><p>Morris法的中序遍历与前序遍历的思想是相同的，不同的是在当前节点的左孩子存在时的处理方式不同，思路如下（假设当前遍历到的节点为<code>cur</code>）：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空，然后将当<code>cur</code>加入答案。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root,* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左子节点为空直接遍历右子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            pre = cur -&gt; left;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>其中 <span class="math inline">\(n\)</span>为二叉搜索树的节点个数。Morris遍历中每个节点会被访问两次，因此总时间复杂度为 <spanclass="math inline">\(O(2n)=O(n)\)</span>。</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>。</li></ul><h4 id="后序遍历-2">后序遍历</h4><p>后续遍历思路依然同上，不同的仍然是把<code>cur</code>加入答案的时机，思路如下：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>        root = root -&gt; right;<br>        count++;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">end</span>() - count, res.<span class="hljs-built_in">end</span>());<br> &#125;<br><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br><br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左孩子不空寻找cur左子树的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">// 为空说明左子树尚未遍历，将pre的右孩子更新为cur</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明左子树已经遍历，将pre右孩子重新置空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-built_in">addPath</span>(res, cur -&gt; left);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左孩子为空直接访问右子树</span><br>            cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-built_in">addPath</span>(res, root); <span class="hljs-comment">// root节点没有parent，所以root需要单独addPath</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，所以由于root节点没有parent，最后要再单独对root节点调用<code>addPath</code>。</strong></p><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><p>上面这种解法是leetcode的官方解法，这里我还有另外一种思路，如上面所说，<strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，那么是否可以采用Morris的方法将输出顺序改为<code>cur</code>、<code>cur</code>的右孩子、<code>cur</code>的左孩子，在输出完之后再统一对<code>res</code>进行翻转？</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) <br>    &#123;<br>        <br>        pre = cur -&gt; right;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// cur右孩子为空，直接将cur加入答案并访问左子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则寻找 `父右左` 遍历模式下的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; left != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; left != cur)<br>                pre = pre -&gt; left;<br>            <span class="hljs-keyword">if</span>(pre -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 为空说明右子树尚未遍历</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; left = cur;<br>                cur = cur -&gt; right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;       <br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明右子树已经遍历</span><br>            &#123;<br>                pre -&gt; left = <span class="hljs-literal">nullptr</span>;<br>                cur = cur -&gt; left;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 翻转数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有右子树的节点只被访问一次，有右子树的节点被访问两次，最后翻转数组。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h2 id="二叉树问题的小trick">二叉树问题的小trick</h2><p>二叉树中有一类问题其实套路是固定的，虽然不同问题要求的东西不一样，但是仔细分析会发现，其实它们用到的套路是一样的。<strong>当一个问题的结果需要树的左右子树也满足条件，且每层子树需要返回的参数一样时，便可以用到递归套路。</strong></p><h3id="一棵子树上的点在深度优先搜索序列即先序遍历中是连续的">一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的</h3><p>可以采用这个套路来求解一个树是否是另一个树的子树，但是但从一个树<code>s</code>的dfs遍历是否是另一个树<code>t</code>的dfs遍历的字串并不能判断出是否是子树，所以想要通过dfs的序列判断s是否是t的子树，还需要做一些额外的处理。</p><p>可以通过引入两个空值 <code>lNull</code> 和<code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<code>s</code>的深度优先搜索序列包含<code>t</code>的深度优先搜索序列」来判断<code>s</code>是否是<code>t</code>的子树。</p><p>这里判断<code>s</code>的遍历序列是否是<code>t</code>遍历序列的子串可以用KMP算法或Rabin-Karp算法</p><h3 id="后序遍历迭代法">后序遍历迭代法</h3><p>采用迭代法的后序遍历，即上边用栈的方法，当遍历到节点 <spanclass="math inline">\(p\)</span> 时，栈中的节点刚好是 <spanclass="math inline">\(p\)</span>的祖先节点，所以此时将栈中节点依次弹出便得到 <spanclass="math inline">\(p\)</span> 的祖先节点的倒序。</p><h3 id="验证二叉搜索树">验证二叉搜索树</h3><p><strong>问题</strong>：给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>分析</strong>：如何判断一个二叉树是否是二叉搜索树？它需要满足两个条件：</p><ol type="1"><li>它的左子树和右子树都是二叉搜索树；</li><li>它的节点值大于左子树的最大值且小于右子树的最小值。</li></ol><p>那么从以上两点出发，就可以构造一个递归套路，每层需要向上层返回自己这颗树是否是二叉搜索树，如果不是那么整个树一定不是二叉搜索树；同时还要向上层返回自己这颗子树的最大值和最小值。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root, LONG_MIN, LONG_MAX);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBST</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= upper || root -&gt; val &lt;= lower)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root -&gt; left, lower, root -&gt; val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root -&gt; right, root -&gt; val, upper);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是反向思维，若<code>cur</code>的值需要大于左子树最大值并且小于右子树最小值，那么就等价于让它的左子树判断其最大值是否小于<code>cur</code>值以及<code>cur</code>右子树判断其最小值是否大于<code>cur</code>值.</p><h3 id="验证平衡二叉树">验证平衡二叉树</h3><p><strong>问题</strong>:给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p><strong>分析</strong>:一个二叉树是平衡二叉树,那么它必然满足它的左右子树都是平衡二叉树,且左右子树的高度差的绝对值不大于1.那么就又可以以相似的方式构造递归,每次需要向上层返回的参数有:</p><ul><li>当前子树是否是平衡二叉树</li><li>当前子树的深度</li></ul><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> is_balance;<br>    <span class="hljs-built_in">isBalancedTree</span>(root, is_balance, height);<br>    <span class="hljs-keyword">return</span> is_balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isBalancedTree</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">bool</span> &amp;is_balance, <span class="hljs-type">int</span> &amp;height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        is_balance = <span class="hljs-literal">true</span>;<br>        height = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">bool</span> left_balance, right_balance;<br>    <span class="hljs-type">int</span> left_height, right_height;<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; left, left_balance, left_height);<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; right, right_balance, right_height);<br>    <span class="hljs-keyword">if</span>(!left_balance || !right_balance || <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)<br>        is_balance = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        is_balance = <span class="hljs-literal">true</span>;<br>    height = <span class="hljs-built_in">max</span>(left_height, right_height) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全二叉树的第k个节点">完全二叉树的第k个节点</h3><p>规定根节点位于第 <span class="math inline">\(0\)</span>层，完全二叉树的最大层数为 <spanclass="math inline">\(h\)</span>。根据完全二叉树的特性可知，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数<span class="math inline">\(h\)</span>。</p><p>当 <span class="math inline">\(0 \le i &lt; h\)</span> 时，第 <spanclass="math inline">\(i\)</span> 层包含 <spanclass="math inline">\(2^i\)</span> 个节点，最底层包含的节点数最少为<span class="math inline">\(1\)</span>，最多为 <spanclass="math inline">\(2^h\)</span>。</p><p>因此对于最大层数为 hhh 的完全二叉树，节点个数一定在 <spanclass="math inline">\([2^h,2^{h+1}-1]\)</span>的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。</p><p>如何判断第 <span class="math inline">\(k\)</span>个节点是否存在呢？如果第 <span class="math inline">\(k\)</span>个节点位于第 <span class="math inline">\(h\)</span> 层，则 <spanclass="math inline">\(k\)</span> 的二进制表示包含 <spanclass="math inline">\(h+1\)</span> 位，其中最高位是 <spanclass="math inline">\(1\)</span>，其余各位从高到低表示从根节点到第 <spanclass="math inline">\(k\)</span> 个节点的路径，<spanclass="math inline">\(0\)</span> 表示移动到左子节点，<spanclass="math inline">\(1\)</span> 表示移动到右子节点。通过位运算得到第<span class="math inline">\(k\)</span>个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 <spanclass="math inline">\(k\)</span> 个节点是否存在。</p><p><img src="/img/算法/二叉树/完全二叉树第k个节点.png" /></p><p>那么如何依次判断k的各个二进制位是否为1呢？这里需要一个<spanclass="math inline">\(bits = 2^{h-1}\)</span>，<spanclass="math inline">\(h\)</span>为要查找节点所在层数(注意根节点是0层),比如现在要查找<spanclass="math inline">\(8\)</span>这个节点，那么<spanclass="math inline">\(bits = 2^{3 - 1} = 0100\)</span>,而<spanclass="math inline">\(8\)</span>的二进制表示是<spanclass="math inline">\(1000\)</span>,用<spanclass="math inline">\(bits\)</span> &amp; <spanclass="math inline">\(1000 = 0\)</span>，所以向左子树走，然后将<spanclass="math inline">\(bits\)</span>左移一位，再与<spanclass="math inline">\(8\)</span>（也就是<spanclass="math inline">\(1000\)</span>）相与得到<spanclass="math inline">\(0010 \&amp; 1000 =0\)</span>,继续向左子树移动，重复上面操作，一直到<spanclass="math inline">\(bits\)</span>为<spanclass="math inline">\(0\)</span>为止，此时节点若不为空，那么就是第<spanclass="math inline">\(8\)</span>个节点。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL-unordered_map中自定义哈希函数</title>
    <link href="/2023/02/24/C++%20STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2023/02/24/C++%20STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2id="unordered_map中自定义哈希函数">unordered_map中自定义哈希函数</h2><p>内容转载自<ahref="https://blog.csdn.net/qq_34525916/article/details/115896842">c++unordered_set，unordered_map中自定义哈希函数</a></p><p>如果想用哈希的时候，但是哈希的目标又不再STL标准的类型内，比如一个自定义的class，就不太方便使用STL默认的哈希函数，比较函数，那么就需要重写了。</p><p><strong>将自定义类型作为unordered_map的键值，需如下两个步骤</strong>：</p><ol type="1"><li>定义自定义key的哈希函数的函数对象，告知此容器如何生成hash的值；</li><li>定义等比函数的函数对象或者在自定义类里重载operator==()，告知容器当出现hash冲突的时候，如何区分hash值相同的不同对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">Line</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2)&#123;<br>       k = d1;<br>       b = d2;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Line&amp; other)<span class="hljs-type">const</span>&#123;<span class="hljs-comment">//重载operator==(),若没有重载==则定义 unordered_map 时需要isEqual</span><br>        <span class="hljs-keyword">return</span> other.k ==k &amp;&amp; other.b == b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">createhash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span>  Line l)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// size_t</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//return size_t(l.k ^ l.b);//自定义哈希</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.k) ^  <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.b);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">isEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span> Line l1, <span class="hljs-type">const</span> Line l2)</span> <span class="hljs-type">const</span><span class="hljs-comment">//最后的const不能少</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//unordered_map&lt;Line ,int , createhash, isEqual&gt; mm;//若使用这种方式,Line类中不需要重载==</span><br>    unordered_map&lt;Line ,<span class="hljs-type">int</span> , createhash&gt; mm; <br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">1</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">auto</span> success = mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">if</span>(success.second == <span class="hljs-literal">false</span>)<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;mm insert failed &quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : mm)<br>    &#123;<br>        std::cout&lt;&lt; ele.first.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.first.b&lt;&lt;std::endl; <br><br>    &#125;<br><br>    <span class="hljs-comment">//unordered_set&lt;Line, createhash&gt; ms;</span><br>    unordered_set&lt;Line, createhash, isEqual&gt; ms;<span class="hljs-comment">//若使用这种方式,Line类中不需要重载==</span><br>    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">auto</span> it = ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">if</span>(it.second == <span class="hljs-literal">false</span>)<br>       std::cout&lt;&lt;<span class="hljs-string">&quot;ms insert failed &quot;</span>&lt;&lt;std::endl; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : ms)<br>    &#123;<br>        std::cout&lt;&lt; ele.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.b&lt;&lt;std::endl; <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表内部传递方式和内存占用">哈希表内部传递方式和内存占用</h3><ol type="1"><li>放入哈希表的key，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。</li><li>放入哈希表的key，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ lambda函数用法</title>
    <link href="/2023/02/24/C++%20lambda%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/C++%20lambda%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Lambda表达式（也叫lambda函数，或简称lambda），是从C++11开始引入并不断完善的，是能够捕获作用域中变量的匿名函数对象。因为C++是不能嵌套定义函数的，所以lambda就成了我们构造闭包的主要手段，不过在对象的生命周期上还是有点不同。</p><h2 id="lambda基本语法">Lambda基本语法</h2><figure><img src="/img/C++/lambda/lambda基本语法.png" alt="lambda基本语法" /><figcaption aria-hidden="true">lambda基本语法</figcaption></figure><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。下面对重要的组成部分进行说明：</p><h3 id="捕获列表">捕获列表</h3><p><strong>值捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=100,因为i是创建时拷贝的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [&amp;i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=0, 因为传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（隐式捕获），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p><p><strong>lambda捕获列表：</strong></p><ul><li>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</li><li>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>[this]。函数体内可以使用Lambda所在类中的成员变量。</li><li>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>[&amp;a]。将a按引用进行传递。</li><li>[=，&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>悬垂引用：</strong></p><p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p><h3 id="形参列表">形参列表</h3><p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C++14前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C++14起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> &amp;b) &#123;<br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//输出：10  20</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(i,j);<br><span class="hljs-comment">//输出：1 20</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>) &#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">f</span>(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明符">说明符</h3><ul><li>mutable：允许函数体修改各个复制捕获的对象，以及调用其非 const成员函数;</li><li>constexpr：显式指定函数调用运算符为 constexpr函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr函数的所有要求，则它也会是 constexpr； (C++17 起)</li><li>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和constexpr。(C++20 起)</li></ul><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span><br><span class="hljs-keyword">auto</span> f = [i, &amp;j]() <span class="hljs-keyword">mutable</span> &#123;<br>i = <span class="hljs-number">100</span>, j = <span class="hljs-number">100</span>;<br>&#125;;<br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//输出:0 100</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回类型--">返回类型 -&gt;</h3><p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的return语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = []() -&gt; <span class="hljs-type">double</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p><h3 id="函数体">函数体 <span class="math inline">\(\{ \}\)</span></h3><p>略，同普通函数的函数体。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::accumulate函数用法</title>
    <link href="/2023/02/24/C++%20accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/C++%20accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>accumulate定义在#include<numeric>中，有两种用法，一个是累加求和，另一个是自定义类型数据的处理</p><h2 id="默认累加求和">默认累加求和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="自定义对数据的处理">自定义对数据的处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> BinaryOperation &gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init,</span></span><br><span class="hljs-params"><span class="hljs-function">                        BinaryOperation op )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><p><strong>first, last</strong>: 要求和的元素范围</p><p><strong>init</strong>：和的初值</p><p><strong>op</strong>:被使用的二元函数对象。接收当前积累值 a （初始化为init ）和当前元素 b 的二元运算符。</p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// accumulate example</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">// std::minus</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>      <span class="hljs-comment">// std::accumulate</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">2</span>*y;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myclass</span> &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>*y;&#125;<br>&#125; myobject;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> init = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> numbers[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using default accumulate: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers,numbers+<span class="hljs-number">3</span>,init);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using functional minus: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom function: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers, numbers + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, [](<span class="hljs-type">int</span> a, Grade b)&#123;<span class="hljs-keyword">return</span> a + b * <span class="hljs-number">2</span>; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom object: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, myobject);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">using</span> <span class="hljs-keyword">default</span> accumulate: <span class="hljs-number">160</span><br><span class="hljs-keyword">using</span> functional minus: <span class="hljs-number">40</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-keyword">function</span>: <span class="hljs-number">120</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-type">object</span>: <span class="hljs-number">280</span><br></code></pre></td></tr></table></figure><p>转载自<ahref="https://blog.csdn.net/gongjianbo1992/article/details/105128849">C++Lambda表达式的基本使用</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中数学公式换行问题</title>
    <link href="/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-书写-latex-公式时的一些问题及解决方法">Hexo 书写 LaTeX公式时的一些问题及解决方法</h2><p>使用hexo撰写博客的时候难免会用到数学公式，，如果公式过长，我们通常希望把方程分成多行显示，这时候就需要用到换行符号<code>\\</code>，但是写出来的Markdown 经过 Hexo 的处理以后显示不正确，这与 Hexo的渲染引擎有关系。</p><p>Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax支持，因此首先要启用 MathJax 才能渲染 LaTeX公式.但是它并不支持MathJax换行，这是因为我们的markdown文件首先会被hexo-theme-marked的marked.js解析，这就会使得使用Latex语法所写的MathJax公式中的_和，最后轮到MathJax来对公式进行解析就出错了。</p><h3 id="安装hexo-renderer-pandoc">安装hexo-renderer-pandoc</h3><p>为了使用pandoc作为Hexo的渲染引擎，我们需要安装插件hexo-renderer-pandoc，步骤如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载默认渲染插件</span><br><span class="hljs-built_in">npm</span> install hexo-renderer-pandoc --svae <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p>但是在安装pandoc之后发现，公式中使用<code>\\</code>仍然不能换行，经过一番折腾之后发现了一个曲线救国的方法：在需要换行的公式加上align对齐：</p><p>例如</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>在显示的时候会发现并没有换行</p><p><img src="/img/latex/错误用法.png" /></p><p>而加上aligin之后就可以正常换行</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br><span class="hljs-built_in">&amp;</span>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> <span class="hljs-built_in">&amp;</span>B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]  <br><span class="hljs-keyword">\end</span>&#123;align&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p><img src="/img/latex/正确用法.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的随机过程</title>
    <link href="/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="正态过程">正态过程</h2><h3id="多维正态分布的概率密度和特征函数">多维正态分布的概率密度和特征函数</h3><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数.png" /></p><p>记 <imgsrc="/img/随机过程/常见随机过程/正态概率密度符号替换.png" /></p><p>则<span class="math inline">\((X,Y)\)</span>的联合概率密度为</p><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-新.png" /><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-注.png" /></p><h3 id="证明随机过程xt是正态过程">证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程</h3><p>要证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程，即证对<spanclass="math inline">\(\forall t_1,t_2,\dots\)</span> , <spanclass="math inline">\(t_n，(X(t_1),X(t_2),\dots,X(t_n))\)</span>是<spanclass="math inline">\(n\)</span>维正态分布。</p><h4 id="方法1用特征函数">方法1：用特征函数</h4><h4 id="方法2正态分布的线性不变性">方法2：正态分布的线性不变性</h4><p><strong>正态分布的线性不变性</strong>:</p><p><img src="/img/随机过程/常见随机过程/正态分布线性不变性.png" /></p><p><strong>正态分布的线性变换不变性</strong>:</p><p><imgsrc="/img/随机过程/常见随机过程/正态分布的线性变换不变性.png" /></p><h2 id="维纳过程">维纳过程</h2><p><img src="/img/随机过程/常见随机过程/维纳过程条件.png" /> <imgsrc="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><h3 id="维纳过程的分布">维纳过程的分布</h3><p><img src="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><p>设<span class="math inline">\(t&gt;s\)</span>，因<spanclass="math inline">\(W(0)=0\)</span>,且<spanclass="math inline">\(W(t)\)</span>是平稳独立增量过程，故</p><p><span class="math display">\[W(t) - W(s) = W(t-s+s)-W(s)\]</span></p><p>与</p><p><span class="math display">\[W(t-s) - W(0) = W(t-s)\]</span>有相同分布<span class="math inline">\(N(0,\sigma^2 (t-s))\)</span>。</p><p><strong>维纳过程是正态过程</strong>。</p><h3 id="维纳过程的数字特征">维纳过程的数字特征</h3><p><strong>维纳过程是平稳独立增量过程</strong>，其数字特征如下。</p><p><img src="/img/随机过程/常见随机过程/维纳过程的数字特征.png" /></p><h2 id="计数过程和泊松过程">计数过程和泊松过程</h2><h3 id="定义">定义</h3><p><strong>计数过程</strong>：</p><p><img src="/img/随机过程/常见随机过程/计数过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/计数过程定义2.png" /></p><p><strong>Poisson过程是一类很重要的计数过程</strong>。</p><p><strong>Poisson过程数学模型</strong>：</p><p><img src="/img/随机过程/常见随机过程/泊松过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程定义2.png" /></p><h3 id="齐次泊松过程">齐次泊松过程</h3><p><img src="/img/随机过程/常见随机过程/齐次泊松过程定义.png" /></p><h3 id="泊松过程的等价定义">泊松过程的等价定义</h3><p><img src="/img/随机过程/常见随机过程/泊松过程等价定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程等价定义2.png" /></p><h3 id="齐次泊松过程的有关结论">齐次泊松过程的有关结论</h3><h4 id="数字特征">数字特征</h4><p><strong>均值函数</strong>： <spanclass="math inline">\(m(t)=E\{N(t)\}=\lambda t\)</span></p><p><strong>方差函数</strong>: <span class="math inline">\(D(t)=\lambdat\)</span></p><p><strong>协方差函数</strong>: <spanclass="math inline">\(C(s,t)=\lambda min(s,t)\)</span></p><p><strong>相关函数</strong>： <spanclass="math inline">\(R(s,t)=\lambda min(s,t)+\lambda^2 st\)</span></p><p>故有<spanclass="math inline">\(\lambda=\frac{E\{N(t)\}}{t}\)</span>,称<spanclass="math inline">\(\lambda\)</span>为<strong>事件的到达率</strong>或<strong>单位时间内事件出现的平均次数</strong>。</p><h3 id="时间间隔与等待时间的分布">时间间隔与等待时间的分布</h3><p>如下图所示，<spanclass="math inline">\(N(t)\)</span>是轨道是跃度为<spanclass="math inline">\(1\)</span>的阶梯函数。</p><p><img src="/img/随机过程/常见随机过程/N（t）的分布函数.png" /></p><p>用<span class="math inline">\(T_n\)</span>表示事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n-1\)</span>次出现与第<spanclass="math inline">\(n\)</span>次出现的时间间隔。<spanclass="math inline">\(W_n\)</span>为事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n\)</span>次出现的<strong>等待时间(到达时间)</strong>，则有：</p><p><span class="math display">\[W_n=\sum\limits_{i=1}^nT_i\]</span></p><p>和</p><p><span class="math display">\[T_n=W_n - W_{n-1}\]</span></p><p><img src="/img/随机过程/常见随机过程/时间间隔序列分布定理.png" /></p><h3 id="到达时间的条件分布">到达时间的条件分布</h3><p><img src="/img/随机过程/常见随机过程/引理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理2.png" /> <imgsrc="/img/随机过程/常见随机过程/注1.png" /> <imgsrc="/img/随机过程/常见随机过程/注2.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性空间</title>
    <link href="/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="线性空间">线性空间</h2><p><strong>线性空间定义</strong>： <imgsrc="/img/矩阵论/线性空间/线性空间定义.jpg" /></p><p><strong>线性子空间定义</strong>：</p><p><img src="/img/矩阵论/线性空间/线性子空间定义.png" /></p><p><strong>平凡子空间</strong>：<spanclass="math inline">\(V\)</span>空间的平凡子空间指<spanclass="math inline">\(0\)</span>空间和<spanclass="math inline">\(V\)</span>空间本身，其他维数的空间都是非平凡子空间。</p><p><strong>线性空间的和</strong>：</p><p><img src="/img/矩阵论/线性空间/线性空间的和.jpg" /></p><h3 id="维数定理">维数定理</h3><p><img src="/img/矩阵论/线性空间/维数定理.png" /></p><h3 id="直和">直和</h3><p><img src="/img/矩阵论/线性空间/直和定义.png" /></p><h4id="判断线性空间v的两个子空间v_1和v_2是否是直和的方法">判断线性空间V的两个子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>是否是直和的方法</h4><p>判断<span class="math inline">\(V_1 \cap V_2 =\{0\}\)</span>是否成立，若成立，就是直和；否则不是直和。</p><p>将子空间的概念推广到多个子空间，于是在多个子空间中就可以定义这样的直和关系：</p><p><img src="/img/矩阵论/线性空间/多个子空间的直和.jpg" /></p><h3 id="酉空间">酉空间</h3><p>欧几里得空间：定义了内积的实线性空间。</p><p>欧几里得空间的定义推广到复线性空间就是酉空间。</p><h3 id="正交补子空间">正交补子空间</h3><p><img src="/img/矩阵论/线性空间/正交补子空间定义.png" /></p><p>这里的<spanclass="math inline">\(V_n(C)\)</span>指的是酉空间。这里的<spanclass="math inline">\(n\)</span>表示维数，<spanclass="math inline">\(C\)</span>表示复数空间。这个定义指的是复数域内的<spanclass="math inline">\(n\)</span>维空间，即是酉空间。</p><p>也就是说，一个空间V的子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>不仅要满足直和的关系，还要相互正交。<strong>这样的空间我们称<spanclass="math inline">\(V_2\)</span>为<spanclass="math inline">\(V_1\)</span>的正交补子空间（或简称正交补）</strong>。显然，二者是互为正交补的。<strong>正交补分解实际上就是在分正交基。直和分解实际上就是在分解基向量</strong>。</p><p><strong>定理</strong>：<spanclass="math inline">\(V_n(C)\)</span>的任意子空间<spanclass="math inline">\(V_1\)</span>都有唯一的正交补。</p><h3 id="kronecker积">Kronecker积</h3><h4 id="kronecker积-1">Kronecker积</h4><p><img src="/img/矩阵论/线性空间/Kronecker积.png" /></p><p>其中<span class="math inline">\(a_{ij}\)</span>为矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列的元素，对于<spanclass="math inline">\(A \in \mathbb{R^{m × n}}\)</span> 和 <spanclass="math inline">\(B \in \mathbb{R^{p × q}}\)</span>,<spanclass="math inline">\(A \otimes B \in \mathbb{R^{(mp) ×(nq)}}\)</span>。</p><p><strong>Kronecker积的性质如下</strong>：</p><p><img src="/img/矩阵论/线性空间/Kronecker积性质1.png" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质2.jpg" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质3.png" /></p><p>这些性质中前4条与矩阵运算完全相同，从第5条开始是Kronecker积独有的性质。</p><p>给出一些定义和定理：</p><p><img src="/img/矩阵论/线性空间/Kronecker积定理.jpg" /></p><p>Kronecker积的特征值：</p><p><img src="/img/矩阵论/线性空间/Kronecker积的特征值.jpg" /></p><h4 id="kronecker和">Kronecker和</h4><p><img src="/img/矩阵论/线性空间/Kronecker和.jpg" /></p><p>由定义2我们可以看到，对于Kronecker积而言，m阶矩阵和n阶矩阵之间是无法直接求和的，所以，我们通过对单位阵的Kronecker积运算，同时把他们化为<spanclass="math inline">\((m ×n)\)</span>阶方阵，这样就可以对矩阵进行求和运算了。</p><h4 id="向量化算符">向量化算符</h4><p><img src="/img/矩阵论/线性空间/向量化算符.png" /></p><p>性质：</p><p><img src="/img/矩阵论/线性空间/向量化算符性质.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题的一些心得</title>
    <link href="/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>记录一下在刷题的时候的一些小trick以及踩的一些坑。</p><!-- ### string.size()`string.size()`返回的是一个无符号数，所以在循环中如果需要对使用`s.size()`的话，需要使用`(int)s.size()`。 --><h2 id="滑动窗口">滑动窗口</h2><p>滑动窗口就是<strong>不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。它通常用于字符串或者数组特定长度下内容是否相同，也可以查找在内容相同情况下的最短长度(一般来说需要查找的数组或者字符串是连续的)。</p><h2 id="二分法扩展">二分法扩展</h2><p>二分法作为一种常见的查找算法，其实不单单可以只寻找某一个数。</p><h3id="查找有序数组中最左侧大于或等于k的数">查找有序数组中最左侧大于或等于k的数</h3><p><img src="/img/算法/二分法/二分法拓展.png" /></p><p>如上图所示，查找数组中最左侧大于或等于3的数也可以使用二分法。首先对整个数组二分，看中间的数是否满足大于或等于3，若满足继续在左侧二分，否则在右半侧二分，一直到结束，得到的所有满足条件的最小下标就是求得的结果。</p><p><strong>这个问题与普通二分法查找的区别在于</strong>：二分法是使用二分找个一个满足条件的数之后就结果查找，但是这里需要一直二分到最后，然后在所有满足条件的数中比较。</p><h3 id="寻找局部最小值">寻找局部最小值</h3><p>在一个无序数组arr中，相邻的数都不相同，那么如何在这个数组arr中找到一个局部最小值？这里的极小值定义是比左右两侧都小的数，在数组最左侧则只需要满足比它右侧的数小，在数组最右侧的数只需要满足比它左侧的数小即可。</p><p>首先判断<code>arr[0]</code>和<code>arr[n - 1]</code>是否是极小值，若右极小值则直接返回。若都不是极小值那么取最中间的数<code>arr[m]</code>,判断<code>arr[m]</code>是否为局部最小值，若为局部最小值则直接返回。</p><p><img src="/img/算法/二分法/局部最小值-2.png" /></p><p>若不为极小值那么它要么比它左侧的数大，要么比它右侧的数大。假设它比左侧的数大，那么就在左半边进行二分，如此一来，就存在了二分的点，直至找到一个局部最小值为止。</p><p><img src="/img/算法/二分法/局部最小值-1.png" /></p><p><strong>这里可以看出来二分法不只是能用在有序数组，在无序的情况下满足特定条件也可以用二分。</strong></p><h2 id="求两个数的均值">求两个数的均值</h2><p>一般的写法是 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>但是这样并不是无懈可击的，可能会出现一个问题，当<code>low</code>和<code>high</code>都很大的时候<code>low + high</code>可能会溢出，这样结果就变成一个负数。更加好的写法是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><code>low</code>和<code>high</code>都没有溢出，那么<code>high - low</code>也不会溢出，这样结果就不会溢出。</p><p>更加简化的写法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="时间复杂度master公式">时间复杂度（Master公式）</h2><p>若有<span class="math inline">\(T(N)=a * T(\frac{N}{b})+O(N^d)\)</span>，则说明这个算法满足<strong>Master公式</strong>。也就是说只要是<strong>满足子问题等规模的递归都可以用Master公式</strong>。a，b，d的值可能会有三种情况。</p><ol type="1"><li><span class="math inline">\(\log_b a &lt;d\)</span>,则算法时间复杂度为<spanclass="math inline">\(O(N^d)\)</span>。</li><li><span class="math inline">\(\log_b a &gt;d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^{\log_ba})\)</span>。</li><li><span class="math inline">\(\log_b a =d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^d * \logn)\)</span>。</li></ol><h2 id="链表">链表</h2><h3 id="重要技巧">重要技巧</h3><h4 id="额外数据结构记录哈希表等">额外数据结构记录（哈希表等）</h4><p>此技巧一般只适用于笔试做题，面试一般不适用。</p><p>设置额外的数据结构，比如数组、哈希表或者栈等来辅助做题。</p><h4 id="快慢指针">快慢指针</h4><p>有一些问题诸如寻找链表的中点，最简单暴力的方法是遍历一遍链表然后得到链表长度，然后根据长度得到其最中间的节点。这样做有一个问题，就是需要遍历一遍半的链表。而使用快慢指针就可以少遍历一遍链表。</p><p>它的思想是设置一个<code>fast</code>节点和一个<code>slow</code>节点，每次<code>fast</code>节点往后走两步，而<code>slow</code>节点往后走一步。这样当<code>fast</code>节点走完整个链表的时候，<code>slow</code>节点就在链表的中间。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点。偶数长度返回上中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">nullptr</span>)<br>            fast = fast -&gt; next;<br>      <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>&#125;<br></code></pre></td></tr></table></figure><p>需要特别注意的是，<strong>不要死记这代码，实际上在做题或者应用中的不同情况是是有很多细微的差别的，比如若链表长度是偶数，有的时候需要中间靠前的节点，有的时候需要中间靠后的节点，还有的时候需要中间靠前节点的前驱节点，不同情况要做对应的调整，同时还要注意边界条件，比如节点为空或者只有一个节点的情况。</strong></p><p>链表长度为偶数情况下，寻找中间靠后的那个节点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点，偶数长度返回下中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>      fast = fast -&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><!-- - 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点后一个 --><h3 id="面试时链表解题方法论">面试时链表解题方法论</h3><ol type="1"><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。比如可以直接把链表copy到数组。</li><li>对于面试，时间复杂度仍然放在第一位，但是要找到空间复杂度最省的方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平稳过程</title>
    <link href="/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="严平稳过程">严平稳过程</h2><p><img src="/img/随机过程/平稳过程/严平稳过程定义.png" /> <imgsrc="/img/随机过程/平稳过程/严平稳过程定义-2.png"alt="严平稳过程定义" /></p><p>严平稳过程有限维分布不随时间的推移而改变，，它的当前变化情况与过去的情况有不可忽视的联系。</p><p>严平稳过程的一维分布与时间无关，而二维分布仅与<spanclass="math inline">\(t_1\)</span>和<spanclass="math inline">\(t_2\)</span>的时间间隔有关，与时间起点无关。</p><h2 id="宽平稳过程">宽平稳过程</h2><p>由于</p><ul><li>工程中确定一个过程的有限维分布函数族,进而判定过程的严平稳性十分困难；</li><li>部分随机过程(如正态过程)的概率特征主要由一阶和二阶矩函数确定；</li><li>工程实际中,通常仅需在相关理论范畴内考虑平稳过程,即只限于研究一、二阶矩（均值、相关函数等）理论.</li></ul><p>所以有了宽平稳过程。</p><p>定义： <img src="/img/随机过程/平稳过程/宽平稳过程定义.png"alt="宽平稳过程定义" /></p><p>其中<span class="math inline">\(R_x(\tau)\)</span>为<spanclass="math inline">\(\{X(t),t \inT\}\)</span>的自相关函数。其协方差函数为 <spanclass="math display">\[C_X(s,t)=R_X(s,t)-|m_X|^2=R_X(\tau)-|m_X|^2\]</span></p><p>自协方差函数与自相关函数都仅依赖于<spanclass="math inline">\(t－s\)</span></p><p><strong>维纳过程不是宽平稳过程，但是维纳过程是增量宽平稳过程，即</strong><span class="math display">\[X(t)=W(t+a)-W(t), t \ge 0, \quad(a&gt;0)\]</span></p><p>是宽平稳过程</p><h2 id="两种平稳性的关系">两种平稳性的关系</h2><ul><li>严平稳过程不一定是宽平稳的;</li></ul><p>因宽平稳过程一定是二阶矩过程, 而严平稳过程未必是二阶矩过程.</p><ul><li>宽平稳不一定 严平稳;</li><li>严平稳过程是宽平稳过程的充要条件是其二阶矩存在.</li><li>对于正态过程, 宽平稳性与严平稳性等价.</li></ul><h2 id="平稳过程的自相关函数">平稳过程的自相关函数</h2><p><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-1.png" /><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-2.png" /></p><p>证明:</p><ol type="1"><li><img src="/img/随机过程/平稳过程/自相关证明1.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明2.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明3.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明4.png" /></li></ol><p>推论： <img src="/img/随机过程/平稳过程/自相关函数推论.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.2.png" /></p><p>证明： <img src="/img/随机过程/平稳过程/5.2.2证明.png" /></p><p>定理: <img src="/img/随机过程/平稳过程/定理5.2.3.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.4.png" /></p><p>推论： <img src="/img/随机过程/平稳过程/定理5.2.4推论1.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广义逆矩阵</title>
    <link href="/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="单边逆">单边逆</h2><p>所谓矩阵的单边逆就是指矩阵的左逆和右逆。</p><figure><img src="/img/矩阵论/单边逆定义.png" alt="矩阵的单边逆" /><figcaption aria-hidden="true">矩阵的单边逆</figcaption></figure><p><strong>定理1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(A\)</span>为列满秩矩阵</li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(A\)</span>为行满秩矩阵</li></ul><p><strong>推论1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(N(A)=\{0\}\)</span></li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(R(A)=\mathbb{C}^m\)</span></li></ul><h3 id="单边逆的求法">单边逆的求法</h3><p><strong>例1</strong>: <img src="/img/矩阵论/例1-1.png" /> <imgsrc="/img/矩阵论/例1-2.png" /></p><p><strong>例2</strong>: <img src="/img/矩阵论/例2-1.png" /> <imgsrc="/img/矩阵论/例2-2.png" /></p><p>需要注意的是例1求左逆矩阵进行的是初等行变换,例2求右逆矩阵是进行的初等列变换，初等行变换我们在线性代数中常用，比较熟悉，但是要求右逆矩阵一定要进行初等列变换。</p><h2 id="广义逆矩阵">广义逆矩阵</h2><p><strong>定义</strong>: <img src="/img/矩阵论/广义逆定义.png" /></p><p><strong>性质</strong>: <img src="/img/矩阵论/广义逆定理1.png" /></p><p>推论: <img src="/img/矩阵论/广义逆推论1.png" /></p><p>需要注意的是，同线性代数中的矩阵的逆不同的是，这里求的广义逆一般不唯一。既然不唯一，有许多解的话，我们就考虑是否有一个通解可以将所有的广义逆全部表示呢？的确有，下面我们就介绍定理2，该定理表示的就是全部的广义逆：</p><p><img src="/img/矩阵论/全部广义逆集合定义.png" /></p><p><strong>定理2</strong>(不常考): <imgsrc="/img/矩阵论/广义逆定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆定理2-2.png" /></p><p><strong>定理3</strong>: <img src="/img/矩阵论/广义逆定理3-1.png" /><img src="/img/矩阵论/广义逆定理3-2.png" /></p><ul><li>(i)是逆矩阵性质在广义逆的推广</li><li>(ii)说的是一个矩阵乘以他的广义矩阵是幂等矩阵，且他们矩阵的秩相等</li><li>(iii)可以看出0矩阵的广义逆矩阵可以是任何矩阵（包括0矩阵）</li><li>(v)说的是<span class="math inline">\(AA^{-1}\)</span>与<spanclass="math inline">\(A\)</span>的值域相同,<spanclass="math inline">\(A^{-1}A\)</span>与<spanclass="math inline">\(A\)</span>的零空间相同,证明如下:</li></ul><p><img src="/img/矩阵论/定理3(v)证明.png" /></p><h2 id="自反广义逆矩阵">自反广义逆矩阵</h2><p>自反广义逆矩阵是广义逆矩阵里的一类特殊矩阵,其定义如下: <imgsrc="/img/矩阵论/自反广义逆矩阵定义.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/自反广义逆矩阵定理1.png" /></p><p>需要注意的是，自反广义逆矩阵并不唯一。事实上，对于 <imgsrc="/img/矩阵论/广义逆矩阵/图1.png" /></p><p>构造这样的矩阵 <img src="/img/矩阵论/广义逆矩阵/图2.png" /></p><p>所有满足这样条件的矩阵G，就是A的自反广义逆。所以自反广义逆并不唯一.</p><p><strong>定理2</strong>(考试不要求): <imgsrc="/img/矩阵论/广义逆矩阵/定理2.png" /></p><p>定理2给出了自反广义逆矩阵的一种具体的构造方法,</p><p><strong>定理3</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/定理3.png" /></p><p>定理3给出了在广义逆矩阵中，区分自反广义逆的一种有效方法。当广义逆矩阵的秩等于矩阵A的秩的时候是自反广义逆。当广义逆的秩大于矩阵A的秩的时候是广义逆矩阵而不是自反广义逆矩阵。</p><h2 id="m-p广义逆矩阵">M-P广义逆矩阵</h2><p>M-P广义逆矩阵（Moore-Penrose）矩阵是在自反广义逆矩阵之上又加了两个条件形成的矩阵，要求更加苛刻。我们一般用<span class="math inline">\(A^+\)</span> 来表示M-P广义逆矩阵。 <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定义.png" /></p><p>这四个条件，共同保证了 <span class="math inline">\(A^+\)</span>的<strong>唯一性</strong>。</p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理1.png" /></p><p>该定理给出了<span class="math inline">\(A^+\)</span>的具体计算方法。定理的证明直接用该式子验证定义中的四个式子即可.</p><p><strong>定理2</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则 <spanclass="math inline">\(A^+\)</span>是唯一的.</p><p>这一点已经在上面提到过了,定义中的四个式子保证了<spanclass="math inline">\(A^+\)</span>的唯一.</p><h3 id="m-p广义逆的性质">M-P广义逆的性质</h3><p><img src="/img/矩阵论/广义逆矩阵/M-P广义逆定理3.png" /></p><p><strong>定理5</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理5.png" /></p><h3 id="m-p广义逆的计算">M-P广义逆的计算</h3><h4 id="最大秩分解">最大秩分解</h4><p><img src="/img/矩阵论/广义逆矩阵/引理1.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆的计算定理1.png" /></p><p><strong>例1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-2.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-3.png" /></p><h4 id="奇异值分解法">奇异值分解法</h4><p><strong>定理2</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-2.png" /></p><h3 id="m-p广义逆的应用">M-P广义逆的应用</h3><h4 id="判断方程有没有解">判断方程有没有解</h4><p>求出<span class="math inline">\(A^+\)</span>,判断<spanclass="math inline">\(AA^+b\)</span>是否等于<spanclass="math inline">\(b\)</span>,若不等于则没有解，否则有解。</p><h4id="求方程的最佳逼近解最小范数解最小二乘解">求方程的最佳逼近解/最小范数解/最小二乘解</h4><p>当方程有解的时候，可以求得最小范数解为<spanclass="math inline">\(A^+b\)</span>；当方程没有解的时候，可以求出最佳逼近解为<spanclass="math inline">\(A^+b\)</span>，最小二乘通解为<spanclass="math inline">\(A^+ b+(I-A^+ A)u, \forall u \in\mathbb{C}^n\)</span>,其中<span class="math inline">\(A\)</span>为<spanclass="math inline">\(n\)</span>阶矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    <url>/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"> --><h2id="三角分解qr分解需要是非奇异矩阵">三角分解(QR分解)(需要是非奇异矩阵)</h2><h3id="正交三角分解通过schmidt正交化">正交三角分解(通过Schmidt正交化)</h3><p>若 <span class="math inline">\(n\)</span> 阶实矩阵 <spanclass="math inline">\(A\in \mathbb {C}^{n\times n}\)</span> 满秩，且<span class="math display">\[A = [\alpha_1,...,\alpha_n]\]</span></p><p>其中 <span class="math inline">\(\alpha_1,...,\alpha_n\)</span> 是<span class="math inline">\(\mathbb {C}^{n\times n}\)</span>中线性无关向量组</p><p><strong>正交化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned} \beta_1&amp;=\alpha_1\\\beta_2&amp;=\alpha_2 -\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1\\ \vdots \\ \beta_n &amp;= \alpha_n -\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}\end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \alpha_1 &amp;=\beta_1\\ \alpha_2 &amp;=\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1+ \beta_2\\ \vdots \\ \alpha_n &amp;=\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}+ \beta_n \end{aligned} \]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\alpha_1,\alpha_2,...,\alpha_n\end{bmatrix} &amp;=\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;\triangleqB\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix} \end{aligned}\]</span></p><p><strong>单位化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned}q_1=&amp;\frac{\beta_1}{||\beta_1||} \\ &amp;\vdots \\ q_n =&amp; \frac{\beta_n}{||\beta_n||} \end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \beta_1 =&amp;q_1||\beta_1|| \\ &amp;\vdots \\ \beta_n =&amp; q_n ||\beta_n||\end{aligned}\]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix} &amp;=\begin{bmatrix}q_1,q_2,...,q_n\end{bmatrix}\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\end{aligned} \]</span></p><p>综上，结合正交化和单位化可得</p><p><span class="math display">\[ \begin{aligned} A &amp;=B\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp;||\beta_n||\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;||\beta_2||&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq QR \end{aligned} \]</span></p><p><strong>QR 分解定理</strong> : <span class="math inline">\(A\in\mathbb {C}^{n\times n}\)</span> ,则存在酉矩阵 <spanclass="math inline">\(Q\)</span> 和正线上三角阵 <spanclass="math inline">\(R\)</span> ，使 <spanclass="math display">\[A=QR\]</span></p><p>且分解唯一</p><p><strong>正交三角分解的求法</strong> 1. 取矩阵 <spanclass="math inline">\(A=(A_1,A_2,...,A_n)\)</span> 的列向量，进行<strong>Schmidt 标准正交化</strong>,得 <spanclass="math inline">\(v_1,v_2,...,v_n\)</span> ，有 <spanclass="math display">\[Q=(v_1,v_2,...,v_n)\]</span> 2. 再由 <spanclass="math inline">\(R=Q^HA\)</span> 得到 <spanclass="math inline">\(R\)</span> , 于是 <spanclass="math inline">\(A=QR\)</span></p><h3 id="householder变换分解">HouseHolder变换分解</h3><p>将矩阵A按列划分为 <spanclass="math inline">\((\alpha_1,\alpha_2,\dots,\alpha_n)\)</span>,以4阶方阵为例，</p><p>第一步 令 <spanclass="math display">\[\omega_1=\frac{\alpha_1-a_1*e_1}{||\alpha_1-a_1*e_1||_2}，a_1=||\alpha_1||_2\]</span></p><p>于是 <spanclass="math display">\[H_1A=(H_1\alpha_1,H_1\alpha_2，...，H_1\alpha_n)=\left\{\begin{matrix} a_1 &amp; * &amp; \cdots &amp; * \\                   0      &amp; \\                   \vdots &amp; &amp;B_1 \\0\end{matrix}\right\}\]</span></p><p>第二步</p><p>从第一步中得到 <spanclass="math inline">\(B_1=(\beta_2,\beta_2,\cdots,\beta_n)\inR^{n-1}\)</span></p><p>取 <spanclass="math display">\[\omega_2=\frac{\beta_2-b_2*e_1}{||\beta_2-b_2*e_1||_2}，b_1=||\beta_2||_2\]</span></p><p>则 <spanclass="math display">\[\widehat{H_2}=I-2*\omega_2*\omega_2^T,H_2=\left\{\begin{matrix}1 &amp; 0^T \\                                                              0 &amp;\widehat{H_2}，                                              \end{matrix}\right\}\]</span></p><p>得到 <span class="math display">\[H_2(H_1*A) = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp;* \\                                       0 &amp; a_2 &amp; * &amp; \cdots&amp;* \\                                       0 &amp; 0 &amp;  &amp;\\                                       \vdots &amp; \vdots&amp;  &amp;C_2&amp; \\                                       0 &amp; 0\end{bmatrix} , C_2\in R^{n-2}\]</span></p><p>依次类推，进行第n步时，得到第n-1个 <spanclass="math inline">\(H_{n-1}\)</span>阵,使得 <spanclass="math display">\[H_{n-1} \cdots H_2H_1*A = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp; * \\                                                   0 &amp; a_2 &amp; *&amp; \cdots &amp; * \\                                                   0 &amp; 0 &amp; a_3&amp; \cdots &amp; *\\                                                  \vdots &amp; \vdots&amp; &amp;\ddots \\                                                    0 &amp; 0 &amp; 0&amp; \cdots &amp;a_n\end{bmatrix}=R\]</span></p><p>其中 <span class="math inline">\(H_{n-1} \cdotsH_2H_1*A=H\)</span>也称为HouseHolder矩阵，也为自逆矩阵 <spanclass="math inline">\(H=H^{-1}\)</span></p><p><span class="math display">\[H_{n-1} \cdots H_2H_1*A=R\]</span> <spanclass="math display">\[\Rightarrow (H_{n-1} \cdots H_2*H_1)^{-1}*H_{n-1}\cdots H_2H_1*A=(H_{n-1} \cdots H_2*H_1)^{-1}*R\]</span> <spanclass="math display">\[\Rightarrow A=H_1^{-1} \cdotsH_{n-1}^{-1}*R\]</span> <span class="math display">\[\RightarrowA=H_1\cdots H_{n-1}*R\]</span></p><p>得到 <span class="math inline">\(A=QR\)</span>,其中 <spanclass="math inline">\(Q\)</span>为正交矩阵， <spanclass="math inline">\(R\)</span>为上三角矩阵 <spanclass="math display">\[\begin{cases}Q = H_1\cdots H_{n-1}\\R = Q^{-1}A=QA\end{cases}\]</span></p><h3 id="三角分解的性质">三角分解的性质</h3><p><strong>定理1</strong>:设 <span class="math inline">\(A\in \mathbb{C}_r^{m\times n}\)</span>，则 <span class="math inline">\(A\)</span>可以唯一地分解为 <span class="math display">\[A=U_1 R\]</span></p><p>其中 <span class="math inline">\(U_1\)</span>是酉矩阵， <spanclass="math inline">\(R\)</span> 是正线上三角复矩阵，或 <spanclass="math inline">\(A\)</span> 可以唯一地分解为 <spanclass="math display">\[A=L U_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角复矩阵， <spanclass="math inline">\(U_2\)</span>是酉矩阵</p><p><strong>推论1</strong>：设 <span class="math inline">\(A \in \mathbb{R}^{n × n}_n\)</span>,则 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=Q_1 R\]</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是则正交矩阵，<spanclass="math inline">\(R\)</span>是正线上三角实矩阵，或 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=L Q_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角实矩阵， <spanclass="math inline">\(Q_2\)</span>是正交矩阵。</p><p><strong>推论2</strong>：设A是实对称正定矩阵，则存在唯一正线上三角实矩阵<span class="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^T R\]</span></p><p><strong>推论3</strong>：设 <spanclass="math inline">\(A\)</span>是正定Hermite矩阵，则存在唯一正线上三角复矩阵<spanclass="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^H R\]</span></p><h2 id="矩阵的满秩分解">矩阵的满秩分解</h2><p>设 <span class="math inline">\(A\in \mathbb {C}_r^{m\timesn}\)</span>，则存在 <span class="math inline">\(B\in \mathbb{C}_r^{m\times r}, C\in \mathbb {C}_r^{r\times n}\)</span>，满足 <spanclass="math display">\[ A = BC \]</span></p><p><span class="math inline">\(\mathbb {C}_r\)</span> 表示矩阵的秩为<span class="math inline">\(r\)</span></p><p>实际上上述定理用文字描述就是，一个亏秩的矩阵可以分解成一个列满秩与行满秩矩阵的乘积</p><p>证明：因为 <span class="math inline">\(rank(A)=r\)</span>，所以一定可以找到与 <spanclass="math inline">\(A\)</span> 相似的一个矩阵</p><p><span class="math display">\[ A \simeq\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\\0_{(m-r)\timesr}&amp;0_{(m-r)\times(n-r)}\end{bmatrix}=\begin{bmatrix}E_r\\0_{(m-r)\timesr}\end{bmatrix}\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\end{bmatrix}\]</span></p><p>因此存在两个可逆矩阵 <span class="math inline">\(P,Q\)</span>，使<span class="math inline">\(PAQ=\begin {bmatrix} E_r&amp;0\\0&amp;0\end{bmatrix}\)</span>，则</p><p><span class="math display">\[ \begin{aligned} A &amp;=P^{-1}\begin{bmatrix}E_r\\0\end{bmatrix}\begin{bmatrix}E_r&amp;0\end{bmatrix}Q^{-1}\\&amp;\triangleq BC \end{aligned} \]</span></p><p>因为 <span class="math inline">\(P^{-1}\)</span> 是可逆矩阵，<spanclass="math inline">\(\begin {bmatrix} E_r\\0\end {bmatrix}\)</span>是一个列满秩矩阵，所以 <span class="math inline">\(B=P^{-1}\begin{bmatrix} E_r\\0\end {bmatrix}\)</span> 仍是一个列满秩矩阵；同理，<spanclass="math inline">\(C=\begin {bmatrix} E_r&amp;0\end {bmatrix}Q^{-1}\)</span> 是一个行满秩矩阵</p><h3 id="矩阵满秩分解的计算">矩阵满秩分解的计算</h3><p>如何在给定矩阵 <span class="math inline">\(A\)</span>的情况下，求出矩阵 <span class="math inline">\(B,C\)</span> 呢？</p><p>设</p><p><span class="math display">\[\begin{align}&amp;A = [\alpha_1,\alpha_2,...,\alpha_n]\\ &amp;B =[\beta_1,\beta_2,...,\beta_r]  \end{align}\]</span></p><p>其中 <span class="math inline">\(\beta_1,...,\beta_r\)</span>线性无关</p><p>所以 <span class="math display">\[ \begin{aligned} &amp;A=BC\\&amp;\Rightarrow[\alpha_1,\alpha_2,...,\alpha_n]=[\beta_1,...,\beta_r]\begin{bmatrix}c_{11}&amp;\cdots&amp;c_{1n}\\\vdots &amp;\ddots&amp;\vdots\\c_{r1}&amp;\cdots&amp;c_{rn}\end{bmatrix} \end{aligned} \]</span></p><p>实际上我们可以取 <spanclass="math inline">\(\beta_1,...,\beta_r\)</span> 为 <spanclass="math inline">\(\alpha_1,...,\alpha_n\)</span>的一个极大线性无关组，因此 <span class="math inline">\(B\)</span>就是矩阵 <span class="math inline">\(A\)</span>列向量组的一个极大线性无关组，<span class="math inline">\(C\)</span>就是用该线性无关组去表示 <span class="math inline">\(A\)</span>时的系数</p><h4 id="例-1">例 1</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换 <span class="math display">\[A=\begin{bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\\0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}1&amp;4&amp;-1\\2&amp;0&amp;0\\-1&amp;2&amp;-4\\2&amp;6&amp;-5\end{bmatrix}，C=\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\end{bmatrix}\]</span></p><h4 id="例-2">例 2</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换</p><p><span class="math display">\[A=\begin{bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}2&amp;1&amp;-2\\2&amp;5&amp;-1\\1&amp;3&amp;-1\end{bmatrix},C=\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><h2 id="矩阵的lu分解">矩阵的LU分解</h2><p>LU 分解（LUDecomposition）是矩阵分解的一种，可以将一个矩阵分解为一个单位下三角矩阵和一个上三角矩阵的乘积，以四阶矩阵为例<span class="math display">\[ L = \begin{bmatrix}1&amp;0&amp;0&amp;0 \\*&amp;1&amp;0&amp;0\\ *&amp;*&amp;1&amp;0\\*&amp;*&amp;*&amp;1\end{bmatrix},U=\begin{bmatrix}*&amp;*&amp;*&amp;*\\0&amp;*&amp;*&amp;*\\0&amp;0&amp;*&amp;*\\0&amp;0&amp;0&amp;*\end{bmatrix}\]</span></p><p>LU 矩阵是否一定存在？答案是否，具体看下面的例子</p><p>设 <span class="math inline">\(\begin {bmatrix} 0&amp;1 \\1&amp;0\end{bmatrix}=\begin {bmatrix} a&amp;0\\b&amp;c\end {bmatrix}\begin{bmatrix} l&amp;m\\0&amp;n\end {bmatrix}\)</span>，则应该满足如下 4个式子</p><p><span class="math display">\[ \begin{cases} al=0\\ am=1\\ bl=1\\bm+cn=0 \end{cases} \]</span></p><p>由 <span class="math inline">\(al=0\)</span> 得 <spanclass="math inline">\(a=0\)</span> 或 <spanclass="math inline">\(l=0\)</span>，但实际上这两种情况带入上面的式子都会推出矛盾，因此不是所有情况LU 分解都存在</p><p><strong>LU 分解定理</strong> ：设 <span class="math inline">\(A\in\mathbb {C}_n^{n\times n}\)</span>，<spanclass="math inline">\(A\)</span> 有唯一的 LU 分解 <spanclass="math inline">\(\Leftrightarrow A\)</span> 的各阶顺序主子式 <spanclass="math inline">\(\Delta k \neq 0,\ k=1,2...,n\)</span></p><p><span class="math inline">\(k\)</span> 阶顺序主子式指的是矩阵左上角<span class="math inline">\(k\times k\)</span> 个元素组成的行列式</p><p>将矩阵 <span class="math inline">\(A\)</span> 分解为 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span> 之后，解方程组 <spanclass="math inline">\(Ax=b\)</span> 就变得简单了，因为 <spanclass="math inline">\(A=LU\)</span>，所以 <spanclass="math inline">\((LU) x=b\Rightarrow L (Ux)=b\Rightarrow \begin{cases} Ly=b\\Ux=y\end {cases}\)</span></p><p>所以 <span class="math inline">\(x=U^{-1} y=U^{-1} L^{-1}b\)</span></p><h3 id="lu-矩阵的求法">LU 矩阵的求法</h3><p>实际上 LU 矩阵有非常多的求法，这里列举一种比较简单的待定系数法</p><p>设 <span class="math inline">\(A = \begin {bmatrix}2&amp;3&amp;4\\1&amp;1&amp;9\\1&amp;2&amp;-6\end{bmatrix}\)</span>，求矩阵 <span class="math inline">\(A\)</span> 的 LU分解矩阵 <span class="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span></p><p><strong>解</strong>：令 <span class="math display">\[L=\begin{bmatrix}1&amp;0&amp;0\\l_1&amp;1&amp;0\\l_2&amp;l_3&amp;1\end{bmatrix},U=\begin{bmatrix}u_1&amp;u_2&amp;u_3\\0&amp;u_4&amp;u_5\\0&amp;0&amp;u_6\end{bmatrix}\]</span></p><p>由于 <span class="math inline">\(A=LU\)</span>，所以有</p><p><span class="math display">\[ \begin{cases} u_1=2\\ u_2=3\\ u_3=4\\l_1u_1=1\\ l_1u_2+u_4=1\\ l_1u_3+u_5=9\\ l_2u_1=1\\ l_2u_2+l_3u_4=2\\l_2u_3+l_3u_5+u_6=-6 \end{cases} \]</span></p><p>上面的方程组非常容易解，最后求出</p><p><span class="math display">\[ L =\begin{bmatrix}1&amp;0&amp;0\\\frac{1}{2}&amp;1&amp;0\\\frac{1}{2}&amp;-1&amp;1\end{bmatrix},U=\begin{bmatrix}2&amp;3&amp;4\\0&amp;-\frac{1}{2}&amp;7\\0&amp;0&amp;-1\end{bmatrix}\]</span></p><h2 id="奇异值分解">奇异值分解</h2><p><strong>奇异值</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{m × n}_r,AA^H\)</span> 的特征值为 <spanclass="math display">\[\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_n =0\]</span></p><p>则称 <span class="math inline">\(\sigma_i=\sqrt{\lambda_i}\)</span>为矩阵A的正奇异值。<strong><span class="math inline">\(A\)</span>和<span class="math inline">\(A^H\)</span>相同的奇异值</strong>。</p><p><strong>奇异值分解</strong>：当给定一个大小为<spanclass="math inline">\(m × n\)</span>的矩阵<spanclass="math inline">\(A\)</span>,虽然矩阵<spanclass="math inline">\(A\)</span>不一定是方阵，但大小为<spanclass="math inline">\(m × m\)</span>的<spanclass="math inline">\(AA^T\)</span>和<span class="math inline">\(n ×n\)</span>的<span class="math inline">\(AA^T\)</span>是对称矩阵,若<spanclass="math inline">\(AA^T=P \Lambda_1 Q^T\)</span>,<spanclass="math inline">\(A^T A=Q\Lambda_2Q^T\)</span>,则矩阵A的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T\]</span></p><p>其中，矩阵<span class="math inline">\(P=(\overrightarrow{p_1},\overrightarrow{p_2}, \dots, \overrightarrow{p_m})\)</span>的大小为<span class="math inline">\(m × m\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{p_1}, \overrightarrow{p_2}, \dots,\overrightarrow{p_m}\)</span>是 <spanclass="math inline">\(AA^T\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的左奇异向量（left singularvector）；矩阵<span class="math inline">\(Q=(\overrightarrow{q_1},\overrightarrow{q_2}, \dots, \overrightarrow{q_m})\)</span>的大小为<span class="math inline">\(n × n\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{q_1}, \overrightarrow{q_2}, \dots,\overrightarrow{q_m}\)</span>是 <spanclass="math inline">\(A^TA\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的右奇异向量（left singularvector）；矩阵<spanclass="math inline">\(\Lambda_1\)</span>的大小为<spanclass="math inline">\(m × m\)</span>，矩阵<spanclass="math inline">\(\Lambda_2\)</span>的大小为<spanclass="math inline">\(n ×n\)</span>，两个矩阵对角线上的非零元素相同（即矩阵<spanclass="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的非零特征值相同）；矩阵<spanclass="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(m ×n\)</span>，位于对角线上的元素被称为<strong>奇异值</strong>（singularvalue）。</p><p>设<span class="math inline">\(A\)</span>的秩为r，当 <spanclass="math inline">\(m \ne n\)</span>时，矩阵<spanclass="math inline">\(\Lambda_1\)</span>和<spanclass="math inline">\(\Lambda_2\)</span>的大小显然是不同的，但是他们对角线上的非零元素是相同的，记矩阵<spanclass="math inline">\(\Lambda_1\)</span>(或<spanclass="math inline">\(\Lambda_2\)</span>)对角线上的非零元素为<spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_r\)</span>，这些数皆为非负数，又记矩阵<spanclass="math inline">\(\Sigma\)</span>对角线上的非零元素分别为<spanclass="math inline">\(\sigma_1,\sigma_2,\dots,\sigma_r\)</span>，则<spanclass="math display">\[\sigma_1=\sqrt{\lambda_1},\sigma_2=\sqrt{\lambda_2},\dots,\sigma_r=\sqrt{\lambda_r}\]</span></p><p>即非零奇异值的平方对应着矩阵<spanclass="math inline">\(\Lambda_1\)</span>（或矩阵<spanclass="math inline">\(\Lambda_2\)</span>）的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。</p><p><strong>例1</strong>：一个<spanclass="math inline">\(3×2\)</span>的矩阵<spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\)</span>，求其奇异值分解。</p><p>由 <span class="math display">\[AA^T=\begin{bmatrix}    5&amp;0&amp;0 \\ 0&amp;0&amp;0 \\ 0&amp;0&amp;0\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=\lambda_3=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{p_1}=(1,0,0)^T,\overrightarrow{p_2}=(0,1,0)^T,\overrightarrow{p_3}=(0,0,1)^T\)</span></p><p>由 <span class="math display">\[A^TA=\begin{bmatrix}    1&amp;2 \\ 2&amp;4\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{q_1}=(\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T,\overrightarrow{q_2}=(-\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T\)</span></p><p>令 <span class="math display">\[\Sigma=\begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p>注意矩阵<span class="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(3 × 2\)</span>，此时，矩阵<spanclass="math inline">\(A\)</span>的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T=(\overrightarrow{p_1},\overrightarrow{p_2}, \overrightarrow{p_3})\Sigma (\overrightarrow{q_1},\overrightarrow{q_2})^T \\ =\begin{bmatrix}    1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix} \begin{bmatrix}    \frac{\sqrt{5}}{5}&amp;\frac{2\sqrt{5}}{5} \\\frac{-2\sqrt{5}}{5}&amp;\frac{\sqrt{5}}{5}\end{bmatrix} = \begin{bmatrix}    1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p><strong>例2</strong>：求对称矩阵<spanclass="math inline">\(A=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}\)</span>的奇异值分解。</p><p>经计算可以发现<spanclass="math inline">\(A^TA=AA^T=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix} \begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}=\begin{bmatrix}  5&amp;4 \\ 4&amp;5\end{bmatrix}\)</span>，左奇异向量和右奇异向量构成的矩阵也是相等的，即<span class="math display">\[P=Q=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p>则其奇异值分解为 <span class="math display">\[A=P\SigmaQ^T=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2}&amp; \frac{\sqrt{2}}{2}\end{bmatrix}\begin{bmatrix}    3&amp;0 \\ 0&amp;1\end{bmatrix}\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p><strong>注</strong>：这是由于当矩阵<spanclass="math inline">\(A\)</span>为对称矩阵时，其可以被正交对角化，这时奇异值分解等于正交对角化分解。</p><h2 id="谱分解">谱分解</h2><p><strong>谱分解</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{n × n}\)</span>是单纯矩阵，则 <spanclass="math inline">\(A\)</span>可以分解为一系列幂等矩阵 <spanclass="math inline">\(A_i(i=1,2, \dots,n)\)</span>的加权和 <spanclass="math display">\[A=\sum_{i=1}^n \lambda_i A_i\]</span></p><p>其中 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span>是A的特征值。</p><p><strong>单纯矩阵</strong>：若矩阵 <spanclass="math inline">\(A\)</span>的<strong>代数重数</strong>等于<strong>几何重数</strong>，则称<spanclass="math inline">\(A\)</span>为单纯矩阵。<strong>代数重数</strong>为矩阵<spanclass="math inline">\(A\)</span>特征值的重数，<strong>几何重数</strong>为齐次方程组<spanclass="math inline">\(Ax=\lambda_ix(i=1,2,\dots,k)\)</span>的解空间<spanclass="math inline">\(V_{\lambda_i}\)</span>的维数，也即特征值对应的最多无关特征向量数。</p><p><strong>幂等矩阵</strong>：若 <spanclass="math inline">\(A\)</span>为方阵，且 <spanclass="math inline">\(A^2=A\)</span>，则称<spanclass="math inline">\(A\)</span>为幂等矩阵。所有幂等矩阵都相似与对角元全为0或1的对角阵。</p><p><strong>更一般的单纯矩阵谱分解定理</strong>：设 <spanclass="math inline">\(A \in \mathbb{C}^{n × n}\)</span>，他有 <spanclass="math inline">\(k\)</span>个相异特征值 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,k)\)</span>，则 <spanclass="math inline">\(A\)</span>是单纯矩阵的充要条件是存在<spanclass="math inline">\(k\)</span>个矩阵<spanclass="math inline">\(A_i(i=1,2,\dots,k)\)</span>满足</p><ol type="1"><li><span class="math inline">\(A_i A_j = \begin{cases}  A_i, i=j \\ 0,i\ne j \end{cases}\)</span></li><li><span class="math inline">\(\sum_{i=1}^k A_i = E_n\)</span></li><li><span class="math inline">\(A=\sum_{i=1}^k \lambda_iA_i\)</span></li></ol><p>该定理比定理3要求放宽了，不再要求必须要有n个特征值了，这里的k可以小于等于n。</p><p><strong>例1</strong>：求正规矩阵 <span class="math inline">\(A =\begin{bmatrix}  0&amp;1&amp;1&amp;1 \\ 1&amp;0&amp;-1&amp;1 \\1&amp;-1&amp;0&amp;1 \\ -1&amp;1&amp;1&amp;0\end{bmatrix}\)</span>的谱分解表达式。</p><p><strong>解</strong>：首先计算 <spanclass="math inline">\(A\)</span>的特征值和特征向量 <spanclass="math display">\[|\lambda_ I - A |=(\lambda - 1)^3 (\lambda +3)\]</span></p><p>从而 <span class="math inline">\(A\)</span>的特征值为 <spanclass="math display">\[\lambda_1=\lambda_2=\lambda_3=1,\lambda_4=-3\]</span></p><p>当<spanclass="math inline">\(\lambda=1\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_1=(1,1,0,0)^T \\ \alpha_2=(1,0,1,0)^T \\\alpha_3=(-1,0,0,1)^T\]</span></p><p>当<spanclass="math inline">\(\lambda=-3\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_4=(1,-1,-1,1)^T\]</span></p><p>将 <spanclass="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交化并单位化得<spanclass="math display">\[\eta_1=(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0,0)^T\\\eta_2=(\frac{1}{\sqrt{6}},\frac{1}{\sqrt{6}},\frac{2}{\sqrt{6}},0)^T \\\eta_3=(-\frac{1}{2\sqrt{3}},\frac{1}{2\sqrt{3}},\frac{1}{\sqrt{3}},\frac{3}{2\sqrt{3}})^T\]</span></p><p>将<span class="math inline">\(\alpha_4\)</span>单位话得 <spanclass="math display">\[\eta_4=(\frac{1}{2},-\frac{1}{2},-\frac{1}{2},\frac{1}{2})\]</span></p><p>故有 <span class="math display">\[G_1=\eta_1 \eta_1^H+\eta_2 \eta_2^H+\eta_3 \eta_3^H \\= \begin{bmatrix}    \frac{3}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;\frac{3}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{3}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{3}{4}    \end{bmatrix}\]</span></p><p><span class="math display">\[G_2=\eta_4 \eta_4^H \\=\begin{bmatrix}    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4}\end{bmatrix}\]</span></p><p>这样其谱分解表达式为 <span class="math display">\[A=G_1 -3G_2\]</span></p><p>注意<span class="math inline">\(G_1\)</span>和<spanclass="math inline">\(G_2\)</span>的系数<spanclass="math inline">\(\lambda_i\)</span>为其对应的特征值。<!-- https://www.cnblogs.com/blairgrowing/p/15800825.html --></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>范数</title>
    <link href="/2022/12/05/%E8%8C%83%E6%95%B0/"/>
    <url>/2022/12/05/%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>不管向量范数、矩阵范数还是算子范数，都需要满足三个特性:</p><ul><li>正定性</li><li>齐次性</li><li>三角不等式</li></ul><h2 id="向量范数">向量范数</h2><p><strong>1 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_1=\sum\limits_{i=1}^N|x_i|\)</span>，即向量元素绝对值之和</p><p><strong>2 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_2=(\sum\limits_{i=1}^N (x_i)^2)^{\frac{1}{2}}\)</span>，也叫欧几里得范数，常用于计算向量长度，即向量元素的平方和再开方</p><p><strong><span class="math inline">\(\infty\)</span>-范数</strong>:<span class="math inline">\(\Vert \boldsymbol{x}\Vert_{\infty}=\max\limits_{i}|x_i|\)</span>，即所有向量元素中绝对值的最大值</p><!-- **-$\infty$- 范数**:$\Vert \boldsymbol {x}\Vert_{-\infty}=\min\limits_{i} |x_i|$，即所有向量元素绝对值中的最小值 --><p><strong>P - 范数</strong>:<span class="math inline">\(\Vert\boldsymbol {x}\Vert_p=(\sum\limits_{i=1}^N (x_i)^p)^{\frac{1}{p}}\)</span>，即向量元素的 p 次方和再开 p 次方</p><h2 id="矩阵范数">矩阵范数</h2><p>设<span class="math inline">\(A \in \mathbb{C}^{m ×n}\)</span>，则</p><p><span class="math inline">\({||A||}_{m_1} = \sum\limits^{n}_{j=1}\sum\limits^{m}_{i=1} |a_{ij}|\)</span></p><p><span class="math inline">\(||A||_{m_2} = {||A||}_{F}=\sqrt{\sum\limits^{n}_{j=1} \sum\limits^{m}_{i=1} |a_{ij}^2|} =\sqrt{tr(A^HA)} = \sqrt{tr(AA^H)}\)</span></p><p><spanclass="math inline">\(||A||_{m_\infty}=\max\limits_{i,j}\{|a_{ij}|\},1\le i \le m, 1 \le j \le n\)</span></p><h3 id="矩阵范数的性质">矩阵范数的性质</h3><p><img src="/img/矩阵论/矩阵范数性质-定理1.png" /> <imgsrc="/img/矩阵论/矩阵范数性质-定理1-2.png" /></p><ul><li><span class="math inline">\({||A||}_{m_1}\)</span>范数与向量范数<span class="math inline">\(||x||_1\)</span>相容</li><li><span class="math inline">\({||A||}_{m_2}\)</span>范数与向量范数<span class="math inline">\(||x||_2\)</span>相容</li><li><spanclass="math inline">\({||A||}_{m_{\infty}}\)</span>范数与向量范数 <spanclass="math inline">\(||x||_\infty\)</span> 不相容</li></ul><h3 id="证明一个范数是矩阵范数流程">证明一个范数是矩阵范数流程</h3><ul><li>证明非负性、齐次性、三角不等式</li><li>看他定义是哪种类型的范数，若是相容的需要证明相容性</li></ul><h2 id="算子范数">算子范数</h2><p>算子范数定义1： <img src="/img/矩阵论/算子范数定义1.png" /></p><p>注意：并不是所以的矩阵范数都与向量范数相容。只有满足该条件的矩阵范数才与向量范数是相容的。</p><p>算子范数定义2： <img src="/img/矩阵论/算子范数定义2.png" /></p><p><strong>则称此矩阵范数为从属于向量范数 <spanclass="math inline">\(||x||\)</span>的算子范数</strong>。这里的x可是n维空间的任意取向。</p><p><strong>算子范数表示</strong>：</p><p><span class="math inline">\({||A||}_1=\max\limits_{1 \le j \len}\{\sum\limits^{s}_{j=1}|a_{ij}|\}\)</span>,列模和范数，即所有矩阵列向量绝对值之和的最大值</p><p><span class="math inline">\(||A||_2=\sqrt{\rho(A^HA)}\)</span>，谱范数</p><p><span class="math inline">\(||A||_\infty=\max\limits_{1 \le i \les}\{\sum^n_{j=1}|a_{ij}|\}\)</span>,行模和范数,即所有矩阵行向量绝对值之和的最大值</p><h3 id="算子范数性质">算子范数性质</h3><ul><li><span class="math inline">\({||A||}_{1}\)</span> 范数与向量范数<span class="math inline">\(||x||_1\)</span> 相容</li><li><span class="math inline">\({||A||}_{2}\)</span> 范数与向量范数<span class="math inline">\(||x||_2\)</span> 相容</li><li><span class="math inline">\(||·||_a\)</span>是算子范数 <spanclass="math inline">\(\Rightarrow ||E||_a = 1\)</span></li><li>设<span class="math inline">\(A \in \mathbb{C}^{n × n}，||A||_a\)</span>是从属向量范数<spanclass="math inline">\(||x||\)</span>的算子范数，若<spanclass="math inline">\(||A||_a &lt; 1\)</span>,则 <spanclass="math inline">\(E \pm A\)</span> 可逆，且<spanclass="math inline">\(||(E \pm A)^{-1}||_a \le (1 -||A||_a)^{-1}\)</span></li></ul><p><img src="/img/矩阵论/算子范数性质-定理3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jordan标准型</title>
    <link href="/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <url>/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="jordan标准型">Jordan标准型</h2><figure><img src="/img/矩阵论/Jordan标准型定义.png" alt="Jordan标准型定义" /><figcaption aria-hidden="true">Jordan标准型定义</figcaption></figure><p>其中 <spanclass="math inline">\(J_1(\lambda_1),J_2(\lambda_2)\)</span>分别构成Jardon块。</p><p>即对任意矩阵 <spanclass="math inline">\(A\)</span>，比存在n阶可逆矩阵<spanclass="math inline">\(P\)</span>，使 <spanclass="math display">\[P^{-1}AP=\begin{bmatrix}    J_1 &amp; &amp; &amp; \\ &amp; J_2 &amp; &amp; \\ &amp; &amp; \ddots&amp; \\ &amp; &amp; &amp; J_n\end{bmatrix} = J\]</span></p><p>每一个 <span class="math inline">\(J\)</span> 都是Jardon块 <spanclass="math display">\[J_i=\begin{bmatrix}    \lambda_i &amp; 1 &amp; &amp; \\ &amp; \lambda_i &amp; \ddots &amp;&amp; \\ &amp; &amp; \ddots &amp;1 \\ &amp; &amp; &amp; \lambda_i\end{bmatrix}\]</span></p><h3 id="jordan标准型的结构与结论">Jordan标准型的结构与结论</h3><ul><li>Jordan标准型的个数<spanclass="math inline">\(k\)</span>是线性无关特征向量的个数</li><li>矩阵可对角化当且仅当<span class="math inline">\(k=n\)</span></li><li>相应于一个已知特征值的Jordan块的个数是该特征值的几何重数，它是相应的特征子空间的维数，相应于一个已知特征值的所有Jordan的阶数之和，是该特征值的代数重数</li><li>特征值的几何重数 &lt; 代数重数</li><li>矩阵不同特征值对应的特征向量线性无关</li></ul><figure><img src="/img/矩阵论/Jordan标准型定理2.png" alt="定理2" /><figcaption aria-hidden="true">定理2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征值估计</title>
    <link href="/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>shur不等式</strong> <imgsrc="/img/矩阵论/特征值估计-shur不等式.png" /></p><p>证明如下： <img src="/img/矩阵论/shur不等式证明.png" /></p><p><strong>行盖尔圆盘和列盖尔圆盘</strong>： <imgsrc="/img/矩阵论/盖尔圆盘.png" /></p><p><strong>圆盘定理</strong>： <img src="/img/矩阵论/圆盘定理1.png" /><img src="/img/矩阵论/圆盘定理2.png" /></p><p>推论1：设<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>相似于对角阵.</p><p>推论2： 设<span class="math inline">\(n\)</span>阶实阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>特征值全为实数.</p><p><strong>对角占优矩阵</strong>：</p><p><img src="/img/矩阵论/对角占优矩阵.png" /></p><p><strong>Rayleigh商</strong>：设<span class="math inline">\(A \in\mathbb{C}^{n \times n}\)</span>为Hermite矩阵，<spanclass="math inline">\(x \in \mathbb{C}\)</span>，称 <spanclass="math display">\[R(x)=\frac{x^HAx}{x^Hx}, x \ne 0\]</span></p><p>为<span class="math inline">\(A\)</span>的Rayleigh商。</p><p><strong>定理（Rayleigh-Ritz）</strong>: <imgsrc="/img/矩阵论/Rayleigh-Ritz定理.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵函数</title>
    <link href="/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数">矩阵函数</h2><p><strong>定义</strong>： 设幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty} c_kz^k\)</span>收敛半径为<span class="math inline">\(r\)</span>，且当<spanclass="math inline">\(|z|&lt;r\)</span>的时候，幂级数收敛于<spanclass="math inline">\(f(z)\)</span>，即</p><p><span class="math display">\[f(z)=\sum\limits_{k=0}^{\infty} c_kz^k,|z|&lt;r\]</span></p><p>如果<span class="math inline">\(A \in\mathbb{C}^{n×n}\)</span>满足<spanclass="math inline">\(r(A)&lt;r\)</span>,则收敛的矩阵幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty}a_kA^k\)</span>的和为矩阵函数，记为<spanclass="math inline">\(f(A)\)</span>，即</p><p><span class="math display">\[f(A)=\sum\limits_{k=0}^{\infty} c_kA^k\]</span></p><p>把<span class="math inline">\(f(A)\)</span>的方阵换为<spanclass="math inline">\(At\)</span>,<spanclass="math inline">\(t\)</span>为参数，得到</p><p><span class="math display">\[f(At)=\sum\limits_{k=0}^{\infty}c_k(At)^k\]</span></p><p>常见的矩阵级数有：</p><p><img src="/img/矩阵论/矩阵函数/常见矩阵函数1.png" /> <imgsrc="/img/矩阵论/矩阵函数/常见矩阵函数2.png" alt="常见矩阵函数" /></p><h3 id="矩阵函数的计算方法">矩阵函数的计算方法</h3><h4 id="利用相似对角化">利用相似对角化</h4><p>设<span class="math inline">\(P^{-1}AP= diag(\lambda_1,\lambda_2,\dots, \lambda_3) = D\)</span></p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算2.png" /></p><p><strong>例1</strong>：</p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-3.png" /></p><h4 id="jordan标准型法">Jordan标准型法</h4><p><img src="/img/矩阵论/矩阵函数/Jordan法-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-4.png" /></p><p><strong>例2</strong>：</p><p><img src="/img/矩阵论/矩阵函数/Jordan法-例2-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例2-2.png" /></p><h4 id="数项级数求和法">数项级数求和法</h4><p><img src="/img/矩阵论/矩阵函数/数项级数求和法.png" /></p><p>由哈密尔顿-凯莱定理于是我们有：</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-2.png" /></p><p>由该定理，我们可以实现降次的目的。</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/数项级数求和法-4.png" /></p><h3 id="矩阵函数的性质">矩阵函数的性质</h3><p><img src="/img/矩阵论/矩阵函数/矩阵函数性质.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近似算法</title>
    <link href="/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="近似算法">近似算法</h2><p>假设现在需要解决一个NP-Hard问题，但是又不太可能在多项式时间内求解，但是我们可以退而求其次，那么就必须要牺牲下面的其中一项：</p><ul><li>求得最优解</li><li>在多项式时间内完成</li><li>覆盖问题的所有例子</li></ul><p>而牺牲第二条是不能接受的，当我们选择满足后两者（也就是牺牲第一项），即对解的优越性放宽要求时，设计出的算法被称为<strong>近似算法</strong>。</p><h2 id="load-balancing问题">Load Balancing问题</h2><p>给定<span class="math inline">\(m\)</span>台相同的机器，<spanclass="math inline">\(n\)</span>个任务，任务<spanclass="math inline">\(j\)</span>需要的处理时间为<spanclass="math inline">\(t_j\)</span>,且每个任务<spanclass="math inline">\(j\)</span>必须在一台机器上连续完成。</p><p>令<span class="math inline">\(J(i)\)</span>为分配给机器<spanclass="math inline">\(i\)</span>的任务子集，机器<spanclass="math inline">\(i\)</span>的负载为<spanclass="math inline">\(L_i=\sum\limits_{j \inJ(i)}t_j\)</span>,该问题的时间跨度(makespan)为所有机器上的结束时间最大值<spanclass="math inline">\(L=\max\limits_i L_i\)</span>。</p><p><strong>LoadBalancing</strong>：求上述问题中的任务分配使得时间跨度最小。</p><h3 id="贪心算法">贪心算法</h3><p>每次将任务<spanclass="math inline">\(j\)</span>分配在当前负载最小的机器上： <imgsrc="/img/近似算法/LoadBalancing贪心算法.png" /></p><p><strong>引理1</strong>：最优解makespan<span class="math inline">\(L^*\ge \max\limits_j t_j\)</span>。</p><p>用时最长的这个任务总需要分配到一个机器上完成.</p><p><strong>引理2</strong>:最优解makespan <span class="math inline">\(L^*\ge \frac{1}{m} \sum\limits_j t_j\)</span></p><p>所有任务的总运行时间为<span class="math inline">\(\sum\limits_jt_j\)</span>,那么<spanclass="math inline">\(L^*\)</span>的时间跨度必然选自<spanclass="math inline">\(m\)</span>个机器中最大的一个,而<spanclass="math inline">\(m\)</span>个机器中的最大时间跨度一定不小于<spanclass="math inline">\(\frac{1}{m}\)</span>的总运行时间.</p><p><strong>定理:贪心算法是LoadBalancing问题的二倍近似算法。</strong></p><p>证明:</p><p>假设负载<span class="math inline">\(L_i\)</span>为问题的平静,令<spanclass="math inline">\(j\)</span>为最后一个分配到该机器的任务,由贪心算法,在任务<spanclass="math inline">\(j\)</span>分配之前,机器<spanclass="math inline">\(i\)</span>的负载是最小的.<spanclass="math inline">\(j\)</span>分配之前机器<spanclass="math inline">\(i\)</span>的负载为<span class="math inline">\(L_i- t_j\)</span>,也就是说在准备分配<spanclass="math inline">\(j\)</span>的时候有<span class="math inline">\(L_i- t_j\)</span>小于或等于所有机器上的负载<span class="math inline">\(L_k,1 \le k \le m\)</span></p><p><img src="/img/近似算法/LoadBalancing贪心算法证明-1.png" /></p><p>分配任务<span class="math inline">\(j\)</span>之前,由引理1: <spanclass="math display">\[  \begin{aligned}    L_i - t_j &amp;\le \frac{1}{m}\sum\limits_k L_k \\        &amp;=  \frac{1}{m} \sum\limits_k t_k \\        &amp;\le L^*    \end{aligned}\]</span></p><p>分配任务<span class="math inline">\(j\)</span>后,由上式以及引理2:<span class="math display">\[L_i = (L_i -t_i) + t_j \le L^* +\max\limits_j t_j \le L^* + L^* = 2L^*\]</span></p><p>那么贪心算法是Load Balancing的紧2倍近似算法吗?判断<spanclass="math inline">\(\rho\)</span>-近似算法是否紧的要看该算法相比于最优解有比<spanclass="math inline">\(\rho\)</span>更低的近似率吗?若有则说明其并不是紧的。</p><p>答:大致是的,考虑下面的一个Load Balancing的实例,有<spanclass="math inline">\(m\)</span>个机器,<spanclass="math inline">\(m^2\)</span>个任务,其中有<spanclass="math inline">\(m(m-1)\)</span>个任务运行时间为1,一个任务的运行时间为<spanclass="math inline">\(m\)</span>.贪心算法的结果如下图所示:</p><p><img src="/img/近似算法/LoadBalancing实例-贪心算法.png" /></p><p>而最优解的结果为:</p><p><img src="/img/近似算法/LoadBalancing实例-最优解.png" /></p><p>这个实例里贪心算法的时间跨度为19,而最优解的时间跨度为10.</p><h3 id="lptlongest-processing-time算法">LPT(longest ProcessingTime)算法</h3><p>LPT算法是在上面的贪心算法基础之上,先对<spanclass="math inline">\(n\)</span>个任务按时间降序排序,然后再按照上面的贪心算法执行.</p><p><img src="/img/近似算法/LoadBalancingLPT算法.png" /></p><p>通过观察可以得出,当任务数小于或等于机器数的时候,LRT算法就是最优解.这时候只需要把任务<spanclass="math inline">\(i\)</span>分配给机器<spanclass="math inline">\(i\)</span>.</p><p><strong>引理3</strong>:如果任务数多于机器数<spanclass="math inline">\(m\)</span>,有<span class="math inline">\(L^* \ge2t_{m+1}\)</span>.</p><p>设前<spanclass="math inline">\(m+1\)</span>个任务的运行时间分别为<spanclass="math inline">\(t_1,\dots,t_{m+1}\)</span>,由于运行时间<spanclass="math inline">\(t_i\)</span>是按照降序排列,所以前<spanclass="math inline">\(m+1\)</span>个任务的运行时间都不小于<spanclass="math inline">\(t_{m+1}\)</span>,且由于鸽笼原则,至少有一个机器会被分配两个任务.</p><p><strong>定理:LPT算法是Load Balancing的一个<spanclass="math inline">\(\frac{3}{2}\)</span>近似算法.</strong></p><p>证明:与证明贪心算法相同的方法 <span class="math display">\[L_i=(L_i -t_j) + t_j \le L^* + \frac{1}{2}L^* = \frac{3}{2}L\]</span></p><p>那么LPT算法是Load Balancing的紧<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似算法吗?不是;LPT算法是LoadBalancing的紧<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似算法吗?很可能是.</p><h2 id="centrer-selection-problem中心选址问题">Centrer SelectionProblem(中心选址问题)</h2><p>定义:给定一个大小为<spanclass="math inline">\(n\)</span>个地址集合<spanclass="math inline">\(s_1,s_2,\dots,s_n\)</span>以及一个整数<spanclass="math inline">\(k&gt;0\)</span>,选择<spanclass="math inline">\(k\)</span>个中心使所有地址到离它最近的中心距离的最大值最短.</p><p><img src="/img/近似算法/CentrerSelectionProblem.png" /></p><p>几个概念:</p><ul><li><span class="math inline">\(dist(x, y)\)</span>:<spanclass="math inline">\(x,y\)</span>的距离.</li><li><span class="math inline">\(dist(s_i, C)=\min\limits_{c \inC}\)</span>:<spanclass="math inline">\(s_i\)</span>到离它最近的中心的距离,这里采用欧式距离.</li><li><span class="math inline">\(r(C)=\max\limits_{i}dist(s_i,C)\)</span>:最小的覆盖半径.</li></ul><p>中心选址问题的目标便是找到一个中心集合<spanclass="math inline">\(C\)</span>使覆盖半径<spanclass="math inline">\(r(C)\)</span>最小,其中中心的数量等于<spanclass="math inline">\(k\)</span>.</p><p>距离的一些性质: <span class="math display">\[dist(x,x)=0\tag{同一性}\]</span> <span class="math display">\[dist(x,y)=dist(y,x)\tag{对称性}\]</span> <span class="math display">\[dist(x,y) \ledist(x,z) + dist(z,y) \tag{三角不等式}\]</span></p><h3 id="贪心算法-1">贪心算法</h3><p>开始时我们任意选取一个地址作为中心，接着选择离第一个中心最远的那个地址作为第二个中心，如此的重复进行,直到选了<spanclass="math inline">\(k\)</span>个中心为止。</p><p><img src="/img/近似算法/CentrerSelectionProblem贪心算法.png" /></p><p><strong>定理：贪心算法是中心选址问题的2倍近似解</strong></p><p>证明(反证法)：</p><p>假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span></p><ul><li>对近似解集合<span class="math inline">\(C\)</span>的中心<spanclass="math inline">\(c_i\)</span>，总有一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>在<spanclass="math inline">\(c_i\)</span>的圆中(任意一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>的圆里最少有一个地址<spanclass="math inline">\(s\)</span>,而贪心算法选址都是在地址集合中选的，并且<spanclass="math inline">\(c_i\)</span>的半径 <spanclass="math inline">\(&gt;\)</span> <spanclass="math inline">\(c_i^*\)</span>的半径，所以<spanclass="math inline">\(c_i^*\)</span>必然在某一个中心<spanclass="math inline">\(c_i\)</span>的圆里)</li><li>令<span class="math inline">\(c_i\)</span>是与<spanclass="math inline">\(c_i^*\)</span>对应的中心</li><li>对于任意一个离最优解<spanclass="math inline">\(c_i^*\)</span>最近的地址<spanclass="math inline">\(s\)</span>,有</li></ul><p><span class="math display">\[dist(s,C) \le dist(s, c_i) \le dist(s,c_i^*) + dist(c_i^*, c_i) \le r(C^*) + r(C^*) = 2r(C^*)\]</span></p><p>上式与假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span>相违背，故有<spanclass="math inline">\(r(C^*) \ge\frac{1}{2}r(C)\)</span>,即贪心算法是中心选址问题的2倍近似解。</p><p>中心选址问题有没有<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似解或者<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似解？</p><p>答：没有，除非P＝NP，否则中心选址问题没有倍率比2小的近似算法。</p><h2 id="weighted-vertex-cover">Weighted Vertex Cover</h2><p>带权值的顶点覆盖：对于给出的一个顶点带权值的图<spanclass="math inline">\(G\)</span>，找到一个顶点覆盖，使它们的权值之和最小。（这里我们主要解决的是：求图<spanclass="math inline">\(G=(V,E)\)</span>的顶点覆盖<spanclass="math inline">\(S\)</span>，要使顶点集合<spanclass="math inline">\(S\)</span>中所有顶点的权值之和最小。</p><p><img src="/img/近似算法/WeightedVertexCover.png" /></p><h3 id="pricing-method">Pricing Method</h3><p><strong>定价法</strong>：因为顶点覆盖要求每条边至少有一个顶点在集合<spanclass="math inline">\(S\)</span>里,每条边必须被一些顶点所覆盖，根据顶点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>，给边<span class="math inline">\(e =(i, j)\)</span> 标上价格<span class="math inline">\(P_e\)</span>。</p><p>公平性：与顶点<spanclass="math inline">\(i\)</span>所连接的所有边的价格（权值）之和必须小于顶点<spanclass="math inline">\(i\)</span>的权值。</p><p>引理：：图<spanclass="math inline">\(G\)</span>的所有边的价格（权值）之和 <spanclass="math inline">\(\le\)</span> 顶点覆盖<spanclass="math inline">\(S\)</span>中所有顶点的权值之和（两个简单的缩放）。</p><p><img src="/img/近似算法/WeightedVertexCover-不等式放缩.png" /></p><p>上面第一个<spanclass="math inline">\(\le\)</span>不能写成等号，等号只在每条边都恰好只有一个顶点在<spanclass="math inline">\(S\)</span>中时才成立，若有边的两个顶点都在<spanclass="math inline">\(S\)</span>中，那么这条边就会被计算两次。</p><p>求解过程：边的价格设置与找寻顶点覆盖同时进行</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-求解过程.png" /></p><p>例子：</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-例子.png" /></p><p><strong>Pricing Method是Weighted VertexCover</strong>的一个2倍近似算法。</p><p>证明：</p><p>首先证明<span class="math inline">\(S\)</span>是一个点覆盖：</p><p>算法结束条件：在while循环的每次迭代结束之后，至少有一个顶点会是紧致的（除非图没有边），所以在算法结束的时候每条边的两个顶点中至少有一个是紧的，即每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，而VertexCover要求每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，所以<spanclass="math inline">\(S\)</span>必然是一个点覆盖，否则循环就不会停止。</p><p>然后再证明<spanclass="math inline">\(S\)</span>是最优解的一个2倍近似解：</p><p><img src="/img/近似算法/证明PricingMethod2倍近似解.png" /></p><p>第一处放缩很容易得出，<spanclass="math inline">\(S\)</span>肯定为顶点集<spanclass="math inline">\(V\)</span>的一个子集；<spanclass="math inline">\(\sum\limits_{i \in V} \sum\limits_{e=(i,j)} p_e =2 \sum\limits_{e \in E} p_e\)</span>是因为计算与<spanclass="math inline">\(V\)</span>中所有顶点相连的边时，每条边会被计算两次；最右边一个放缩为引理的结论。</p><h2id="线性规划解决最小带权点覆盖问题">线性规划解决最小带权点覆盖问题</h2><h3 id="整数规划">整数规划</h3><p>对于图<spanclass="math inline">\(G=(V,E)\)</span>,对图中的每个点<spanclass="math inline">\(v \in V\)</span>，定义函数<spanclass="math inline">\(x(v) \in {0, 1}\)</span>,且 <spanclass="math inline">\(x(v)=0\)</span>，表示顶点 <spanclass="math inline">\(v\)</span>不在点覆盖集合里。</p><p>对图中任意一条边 <span class="math inline">\((u,v) \inE\)</span>,由点覆盖定义，顶点<spanclass="math inline">\(u\)</span>、顶点<spanclass="math inline">\(v\)</span> 至少有一个必须在点覆盖中 ，因此：<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>.</p><p>因而得到最小权值点覆盖的规划模型：其中<spanclass="math inline">\(w(v)\)</span> 表示顶点<spanclass="math inline">\(v\)</span>的权值。</p><p><img src="/img/近似算法/整数规划.png" /></p><h3 id="线性规划">线性规划</h3><p>线性规划在整数规划的基础之上不再限定<spanclass="math inline">\(x(v)\)</span>只为0或1，而是有一个范围 <spanclass="math inline">\(x(v) \in [0, 1]\)</span> 这样在整数规划中的<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>仍然成立.这是可以的。因为：前者是后者的一个特例。前者称为0-1整数规划，后者为普通的线性规划。因此，线性规划中的最优解是0-1整数规划最优解的一个下界（因为线性规划最优解包含了0-1整数规划最优解）。</p><p><img src="/img/近似算法/点覆盖-LP规划.png" /></p><p><strong>用线性规划的解来构造最小权值点覆盖问题的近似解算法</strong>:</p><p>对于每一个顶点<spanclass="math inline">\(v\)</span>，都会求得一个<spanclass="math inline">\(x(v)\)</span>的值。若，<spanclass="math inline">\(x(v) \ge 1/2\)</span>,则将该顶点加入到点覆盖集合中，否则舍去顶点<spanclass="math inline">\(v\)</span>，直至图G中所有的顶点都处理完毕。此时得到的顶点集合<spanclass="math inline">\(C\)</span>即为最小权值点覆盖问题的近似解的点覆盖集合。</p><p><strong>线性规划求得的顶点集合C是最小权值点覆盖问题的二倍近似解</strong>:</p><p>设 <span class="math inline">\(C^*\)</span>是最小权值点覆盖问题的一个最优解，<span class="math inline">\(Z\)</span>是线性规划的一个最优解， <spanclass="math inline">\(C\)</span>是最小权值点覆盖问题的近似解.</p><ol type="1"><li>由于最小权值点覆盖问题的一个最优解是线性规划的一个可行解，故：<spanclass="math inline">\(Z \le W(C^*)\)</span>(<spanclass="math inline">\(W\)</span>为求权值的函数)</li><li>为什么求得的集合<spanclass="math inline">\(C\)</span>就是一个点覆盖呢？因为对任意边<spanclass="math inline">\((u,v) \in E\)</span>,有<spanclass="math inline">\(x(u)+x(v)\ge 1\)</span>，即在<spanclass="math inline">\(x(u)\)</span>和<spanclass="math inline">\(x(v)\)</span>中至少有一个的值大于1/2。因此，顶点<spanclass="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>至少有一个会被加入到集合<spanclass="math inline">\(C\)</span>中，从而使得图<spanclass="math inline">\(G\)</span>中的每一条边都会被覆盖。</li><li>由下式</li></ol><p><img src="/img/近似算法/证明线性规划是2倍近似解.png" /></p><p>以及<span class="math inline">\(Z \le W(C^*)\)</span>,知:<spanclass="math inline">\(W(C) \le 2Z &lt;=2W(C^*)\)</span>,即近似解<spanclass="math inline">\(C\)</span>的权值<span class="math inline">\(W(C)\le\)</span> 二倍最优解<spanclass="math inline">\(C^*\)</span>的权值.</p><p>那么是否有比2倍近似解更小的近似解?最小的近似解倍率是多少?</p><p>答:有.</p><p><strong>定理</strong>: 若 P <span class="math inline">\(\ne\)</span>NP,那么没有比<span class="math inline">\(\rho = 1.3607(10\sqrt{5} -21)\)</span>更小的<span class="math inline">\(\rho\)</span>-近似解.</p><h2id="多项式时间逼近算法polynomial-time-approximation-scheme">多项式时间逼近算法(PolynomialTime Approximation Scheme)</h2><p>上面的<spanclass="math inline">\(\rho\)</span>-近似算法是通过牺牲最优解来换取时间和例子,多项式时间逼近算法可以产生任意高质量的解决方案，但以精度换取时间。</p><p>以背包问题为例:物品<spanclass="math inline">\(i\)</span>的价值为<spanclass="math inline">\(v_i\)</span> ,重量为<spanclass="math inline">\(w_i\)</span>;背包最多可以拿的物品重量为<spanclass="math inline">\(W\)</span>.现在求最大可以拿取的物品价值。</p><p><img src="/img/近似算法/背包问题-例子.png" /></p><h3 id="方法1动态规划-1">方法1：动态规划-1</h3><p>定义<spanclass="math inline">\(OPT(i,w)=\)</span>所有物品中可以拿到的<strong>最大价值</strong>。</p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>新的容量为<span class="math inline">\(w-w_i\)</span></li><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w-w_i\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划1.png" /></p><p>运行时间：<span class="math inline">\(O(n W)\)</span></p><ul><li><span class="math inline">\(W=\)</span>重量限制</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="方法2动态规划2">方法2：动态规划2</h3><p>定义<span class="math inline">\(OPT(i,v)=\)</span>物品<spanclass="math inline">\(1,2,\dots,i\)</span>中拿取且得到的物品价值为<spanclass="math inline">\(v\)</span>所消耗的<strong>最小重量</strong></p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>消耗重量<span class="math inline">\(w_i\)</span>,且新的价值为<spanclass="math inline">\(v-v_i\)</span></li><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划2.png" /></p><p>运行时间：<span class="math inline">\(O(n V^*)=O(n^2v_{max})\)</span></p><ul><li><span class="math inline">\(V^*\)</span>为在<spanclass="math inline">\(OPT(n, v) \leW\)</span>的情况下可以选取的最大价值</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="多项式时间逼近算法">多项式时间逼近算法</h3><p>以上的动态规划都可以得到最优解，但是考虑一个问题：若所有物品的价值远大于重量的时候，上面的动态规划还可行吗？</p><p>这时候问题的输入不是多项式的（物品的价值，因为在计算机内数据都要转化为2进制再处理），这时候为了使求解时间更快，引入了新的算法<strong>多项式时间逼近算法（PolynomialTime Approximation Scheme）</strong>。它的大致思想是：</p><ul><li>将所有的价值向上舍入到一个较小的范围里</li><li>在向上舍入后的实力上运行动态规划算法</li><li>得到向上舍入实例的最优解</li></ul><p>注：这里一定要是向上舍入而不能是四舍五入，虽然全部向上舍入可能会在原来的问题中丢失一些较为优质的解，但是若四舍五入的时候，若有向下舍去的价值，可能在新的实例中找到的解在原问题中是不可行解。</p><p><img src="/img/近似算法/背包问题-四舍五入.png" /></p><p>首先对所有价值向上舍入：</p><p><img src="/img/近似算法/向上舍入.png" /></p><ul><li><spanclass="math inline">\(v_{max}\)</span>为原始例子里的最大价值</li><li><span class="math inline">\(\varepsilon\)</span>为精确参数</li><li><span class="math inline">\(\theta\)</span>为放缩因子</li></ul><p>对于放缩之后的例子，复杂度<span class="math inline">\(O(n^3 /\varepsilon)\)</span>,使用上面的动态规划-2方法的运行时间为<spanclass="math inline">\(0(n^2 \hat{v}_{max})\)</span>.</p><p>其中</p><p><img src="/img/近似算法/公式1.png" /></p><p><strong>定理</strong>：若<spanclass="math inline">\(S\)</span>为多项式时间逼近算法找到的一个解，同时<spanclass="math inline">\(S^*\)</span>为另一个可行解，那么有 <spanclass="math inline">\((1+\varepsilon) \sum\limits_{i \in S}v_i \ge\sum\limits_{i \in S^*}v_i\)</span></p><p>证明：</p><p><img src="/img/近似算法/多项式时间逼近算法-证明.png" /></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NP问题以及常见多项式规约</title>
    <link href="/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="pnpnpcnph问题">P、NP、NPC、NPH问题</h2><p><strong>P问题</strong>：存在多项式时间算法的决策问题。</p><p><strong>NP问题</strong>：能在多项式时间内验证某个猜想答案的正确性，但问题求解可能在无法在多项式时间内完成。比如Composite问题、3-Satisfiability、HamiltonianCycle，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。</p><p><strong>结论1</strong>：P <spanclass="math inline">\(\subseteq\)</span> NP</p><p><strong>结论2</strong>：NP <spanclass="math inline">\(\subseteq\)</span> EXP</p><p><strong>EXP问题</strong>：存在指数时间算法的决策问题。</p><p><strong>NPC问题</strong>: 需要满足两个条件</p><ul><li>它是一个NP问题</li><li>所有的NP问题都可以规约到NP-complete</li></ul><p><strong>定理</strong>：若Y是一个NPC问题，那么Y可以在多项式时间内求解<strong>当且仅当</strong>P<spanclass="math inline">\(=\)</span>NP</p><p>证明：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若P <span class="math inline">\(=\)</span>NP，那么Y可以在多项式时间求解，因为Y是NP（NPC的第一个条件：它要先是一个NP）</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若Y可以在多项式时间求解： - 令X为任意一个NP问题，因为X <spanclass="math inline">\(\le_p\)</span>Y，而Y可以在多项式时间求解，故X也可以在多项式时间求解。NP <spanclass="math inline">\(\subseteq\)</span> P - 又已知P <spanclass="math inline">\(\subseteq\)</span> NP,所以 P <spanclass="math inline">\(=\)</span> NP</p><p><strong>如果</strong>我们给NPC问题找到了一个多项式时间复杂度的算法，那么也就意味着我们给所有的NP问题找到了多项式时间复杂度的算法，从而NP=P，因为P=NP，所以“P对NP问题”就可以被解决。但给NPC问题找一个多项式时间复杂度的算法太难了，所以现在人们普遍相信P≠NP。</p><p><strong>NPH问题</strong>：满足上面NPC问题的第二个条件，但不一定要满足第一个条件，所以NPH的范围比HPC更大。</p><h3 id="证明一个问题是npc问题的步骤">证明一个问题是NPC问题的步骤</h3><ul><li>证明这个问题Y属于NP</li><li>选择一个NPC问题X</li><li>证明X可以多项式规约到Y</li></ul><h3 id="证明一个问题是nph问题的步骤">证明一个问题是NPH问题的步骤</h3><p>要证明一个问题是NP-hard，通常是找到一个已被证明了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC<span class="math inline">\(\le\)</span> NP-hard）,简单来说就是：</p><ul><li>对问题A给定限制条件得到一个特例B问题</li><li>证明问题B是NPC问题</li></ul><h2 id="npc之间规约的例子">NPC之间规约的例子</h2><h3 id="sat-le_p-independent-set">3-SAT <spanclass="math inline">\(\le_p\)</span> Independent Set</h3><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造:</p><ul><li>3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点</li><li>连接句子里的点连接形成三角形</li><li>连接不同Clause里每个Literal和它对应的非</li></ul><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h3 id="hamiltonian-cycle-problem">Hamiltonian Cycle problem</h3><p><strong>Hamiltonian Cycle</strong>:给定一个无向图 <spanclass="math inline">\(G=(V,E)\)</span>，是否存在一个简单的环 <spanclass="math inline">\(\Gamma\)</span> 包含 <spanclass="math inline">\(V\)</span> 中所有的点。</p><figure><img src="/img/多项式规约/HamiltonianCycle定义.png"alt="有奇数个节点的Hamiltonian Cycle" /><figcaption aria-hidden="true">有奇数个节点的HamiltonianCycle</figcaption></figure><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p><strong>DIR-HAM-CYCL <span class="math inline">\(\le_p\)</span>Ham-Cycle</strong>: 证明：给定一个有向图<spanclass="math inline">\(G=(V,E)\)</span>,构造一个有<spanclass="math inline">\(3n\)</span>个节点的无向图<spanclass="math inline">\(G&#39;\)</span>，则<spanclass="math inline">\(G\)</span>有Hamiltonian Cycle当且仅当<spanclass="math inline">\(G&#39;\)</span>有Hamiltonian Cycle。</p><p><img src="/img/多项式规约/DIR-HAM-CYC2Ham-Cycle.png" /></p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若<span class="math inline">\(G\)</span>中有一个有向的HamiltonianCycle，则<spanclass="math inline">\(G&#39;\)</span>中肯定也有一个HamiltonianCycle，且顺序与有向图的节点顺序相同。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若<spanclass="math inline">\(G&#39;\)</span>中有一个无向的HamiltonianCycle，则从蓝色节点出发，节点的颜色出现顺序必然是两种中的一种 -B,G,R,B,G,R,<span class="math inline">\(\dots\)</span> -B,R,G,B,R,G,<span class="math inline">\(\dots\)</span></p><p>若<span class="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第一种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相同；若<spanclass="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第二种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相反。</p><h3 id="sat-le_p-hamiltonian-cycle-problem">3SAT <spanclass="math inline">\(\le_p\)</span> Hamiltonian Cycle problem</h3><!-- **Vertex Cover**：一组顶点的集合，使得图的每条边至少与集合中的一个顶点相连接。在这里Vertex Cover问题是给定图$G$和点集的个数$k$，要找到图$G$的一个大小为$k$的点覆盖。（也就是常说的最小点覆盖） --><p><strong>构造思路:有<spanclass="math inline">\(n\)</span>个变量的3-SAT有<spanclass="math inline">\(2^n\)</span>种可能的分配，要将其规约到HamiltonianCycle，其对应的Hamiltonian Cycle应该也有<spanclass="math inline">\(2^n\)</span>种可能的分配方式。</strong></p><p>构造方法：对一个有<span class="math inline">\(n\)</span>个变量和<spanclass="math inline">\(k\)</span>个句子的3-SAT,构造<spanclass="math inline">\(3k+3\)</span>个节点的HamiltonianCycle，其中每个变量<span class="math inline">\(x_i\)</span>对应<spanclass="math inline">\(3k+3\)</span>个节点，令外再增加一个源点<spanclass="math inline">\(s\)</span>、一个汇点<spanclass="math inline">\(t\)</span>。</p><p><img src="/img/多项式规约/3-SAT2Ham-Cycle构造.png" /></p><p>如果 <spanclass="math inline">\(x_i=1\)</span>，则形成从左向右的一个路径；如果<spanclass="math inline">\(x_i=0\)</span>，则形成从右向左的一个路径。</p><p>对于每一个clause <span class="math inline">\(c_j=z_1 z_2z_3\)</span>，若<span class="math inline">\(z=x_i\)</span>,则添加有向边<spanclass="math inline">\((v_{i,3j},c_j)和(c_j,v_{i,3j+1})\)</span>;若<spanclass="math inline">\(z=\bar{x}_i\)</span>,则添加有向边<spanclass="math inline">\((c_j,v_{i,3j})和(v_{i,3j+1},c_j)\)</span>，这里<spanclass="math inline">\(1\le j\le m, 1\le i\len\)</span>。如上图所示（即若<spanclass="math inline">\(z=x_i\)</span>,该节点与<spanclass="math inline">\(c\)</span>节点的连接顺序是从左边进入<spanclass="math inline">\(c\)</span>节点，然后从右边出<spanclass="math inline">\(c\)</span>节点；反之顺序相反）。</p><p>如果选择子句<span class="math inline">\(C_1\)</span>中<spanclass="math inline">\(x_1=1\)</span>,则<spanclass="math inline">\(x_1\)</span>对应的路径为从左向右;同理<spanclass="math inline">\(x_2=0\)</span>,则<spanclass="math inline">\(x_2\)</span>对应的路径为从右向左；<spanclass="math inline">\(x_3=1\)</span>,则<spanclass="math inline">\(x_3\)</span>对应的路径为从左向右。其余句子同理，这样就得到了最终的图<spanclass="math inline">\(G\)</span>。</p><p><strong>证明</strong>:</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>假设3-SAT有一个可满足的分配<spanclass="math inline">\(x^*\)</span>：</p><ul><li>对于<span class="math inline">\(x_i\)</span>,若其为1，则第<spanclass="math inline">\(i\)</span>行从左往右遍历；反之，若其为0，则第<spanclass="math inline">\(i\)</span>行从右往左遍历</li><li>且对于每个句子节点<spanclass="math inline">\(c_i\)</span>，至少会有一行便利的时候会经过<spanclass="math inline">\(c_i\)</span>，否则便不满足每个句子都为真的条件，也就是该分配并不是可满足的。</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>假设构造的图<spanclass="math inline">\(G\)</span>有一个Ham-Cycle，那么</p><ul><li>若Ham-Cycle进入句子节点<spanclass="math inline">\(c_i\)</span>，那么它一定会返回相同的行，否则便不存在简单环。</li><li>这样Ham-Cycle里的句子节点<spanclass="math inline">\(c_i\)</span>与同一行的两个相邻节点相连，记这两个相邻节点之间的边为<spanclass="math inline">\(e_i\)</span></li><li>去掉句子节点<span class="math inline">\(c_i\)</span>，同时用<spanclass="math inline">\(e_i\)</span>替换与<spanclass="math inline">\(c_i\)</span>相连的两条边。</li><li>按上面的方法去掉所有的句子节点得到图也必然存在Ham-Cycle，且节点的顺序是相同的。</li><li>若Ham-Cycle的第<spanclass="math inline">\(i\)</span>行是从左往右遍历的，便令<spanclass="math inline">\(x_i=1\)</span>;反之则令<spanclass="math inline">\(x_i=0\)</span>，这样便得到一个分配方案，且其是可满足的。</li></ul><p>这样便得到一个分配方式，且每个句子都是可满足的。</p><h3 id="ham-cycle-le_p-tsptraveling-saleperson-problem">HAM-CYCLE <spanclass="math inline">\(\le_p\)</span> TSP(Traveling SalepersonProblem)</h3><p><strong>TSP(Traveling Saleperson Problem)</strong>：给定一个<spanclass="math inline">\(n\)</span>个城市的集合以及城市之间的距离<spanclass="math inline">\(d(u,v)\)</span>,是否存在一个旅行的路线使行走的距离<spanclass="math inline">\(\le n\)</span>?</p><p>旅行者问题与HAM-CYCLE的区别在于：旅行者问题并不限定简单路径，也就是说一个节点可以通过多次，只需要考虑最后的路径长度。</p><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p>$HAM-CYCLE <span class="math inline">\(\le_p\)</span> TSP(TravelingSaleperson Problem)$</p><p><strong>构造</strong>：给定一个HAM-CYCLE的实例<spanclass="math inline">\(G=(V,E)\)</span>,<spanclass="math inline">\(V\)</span>中的每个节点构造一个城市节点，城市之间的距离根据<spanclass="math inline">\(E\)</span>进行赋值: <spanclass="math display">\[d(u,v)= \begin{cases}    1, (u,v) \in E  \\    2, (u,v) \notin E\end{cases}\]</span></p><p>则TSP中有一个旅行路径<span class="math inline">\(\len\)</span>当且仅当<spanclass="math inline">\(G\)</span>中存在HAM-CYCLE</p><h3 id="sat-le_p-3-colorable">3-SAT <spanclass="math inline">\(\le_p\)</span> 3-Colorable</h3><p><strong>3-Colorable</strong>:给定一个无向图<spanclass="math inline">\(G\)</span>，并给图中的每个节点染上红、蓝、绿的其中一种颜色，那么是否存在一种染色方式使相邻的节点都有不同的颜色？</p><p>3-SAT <span class="math inline">\(\le_p\)</span> 3-Colorable</p><p><strong>构造</strong>：</p><ul><li>对每个Literal，构造一个节点</li><li>同时添加三个节点<spanclass="math inline">\(T、F、B\)</span>，连接这三个节点形成一个三角形</li><li>对每个literal节点，创建一个它的"非"并与它相连</li><li>所有的Literal节点都与<span class="math inline">\(B\)</span>相连</li></ul><p>如下图所示： <imgsrc="/img/多项式规约/3-SAT23-COLOLABLE-1.png" /></p><p>这样构造保证了下面的每个Literal节点都是绿色或红色，且它的“非”与它的颜色刚好相反。</p><p>继续接上面：</p><ul><li>对每个Clause，假设<span class="math inline">\(C_i=x_1 \vee\overline{x_2} \vee x_3\)</span>,则对<span class="math inline">\(x_1 ,\overline{x_2} , x_3\)</span>添加6个节点以及13条边</li></ul><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-2.png" /></p><p>即<span class="math inline">\(x_1 , \overline{x_2} ,x_3\)</span>下方的两行一共6个节点，并将左下角的节点、第一行的节点与之前构造的<spanclass="math inline">\(T\)</span>节点相连，右下角的节点与之前的<spanclass="math inline">\(F\)</span>节点相连。</p><p>这样构造是为了保证当三个Literal节点全为红色的时候，是不满足三着色的，如下图所示：当三个Literal节点全为红色的时候，他们下面那行节点必须为蓝色，这样最后一行从左到右着色，最后一个节点冲突。</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-3.png" /></p><p><strong>3-SAT <span class="math inline">\(\le_p\)</span>3-Colorable</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若图3-Colorable：</p><ul><li>将所有为绿色的Literal节点设为真</li><li>由上面可知，当图3-Colorable的时候三个Literal节点至少有一个是绿色的，那么该句子的输出为真</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>若3-SAT是可满足的：则 - 三个Literal节点至少有一个为真 -将为真的Literal节点染为绿色，然后将该节点下面的节点染为红色（否则会冲突），再继续将下面的节点染为蓝色-对中间一行没有染红的节点染为蓝色，然后它们下面一行没有染色的节点可唯一确定颜色</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-4.png" /></p><p>上面没有染色的Literal节点绿色、红色皆可。</p><h3 id="color搜索问题-le_p-3-color判断问题自规约">3-COLOR搜索问题 <spanclass="math inline">\(\le_p\)</span> 3-COLOR判断问题（自规约）</h3><p><strong>方法1</strong>：</p><p>将3-COLOR图中不相邻的点合并，合并后的点表示之前所有合并过来点的集合，如下图所示：</p><p><img src="/img/多项式规约/3-color自规约.png" /></p><p>然后一直重复上述步骤，若图可以进行3着色，那么到最后图必然会合并为一个三角形。染色是对最后的三角形三个点所代表的点的集合染成不同的颜色，便为最后的3着色。</p><p><strong>方法2</strong>：</p><p>设判定算法为<span class="math inline">\(D\)</span></p><ol type="1"><li>调用算法<spanclass="math inline">\(D\)</span>判断原图是否有解，若无解，则返回NO。</li><li>任意选择一对边<span class="math inline">\((u,v)\)</span>，满足<spanclass="math inline">\((u,v) \notin E\)</span><ol type="1"><li>考虑图<span class="math inline">\(G&#39; = G +(u,v)\)</span>，调用<spanclass="math inline">\(D\)</span>判断是否有解。</li><li>若<span class="math inline">\(G&#39;\)</span>无解，标记点对<spanclass="math inline">\((u,v)\)</span>；若有解，添加边<spanclass="math inline">\((u,v)\)</span>到<spanclass="math inline">\(G\)</span>中。</li></ol></li><li>返回步骤2，继续选择一对未标记点对。</li><li>若图<spanclass="math inline">\(G\)</span>构成一个三部完全图，每一部选择一个颜色，输出颜色方案。### 点覆盖搜索问题 <span class="math inline">\(\le_p\)</span>点覆盖判断问题</li></ol><ul><li>从1开始，依次查找该图有没有<spanclass="math inline">\(k^*\)</span>个顶点的顶点覆盖(这样得到的第一次满足的<spanclass="math inline">\(k^*\)</span> 的值就是该图最小顶点覆盖的数目)</li><li>从图中选出一个点<span class="math inline">\(v\)</span>，若去除该点后图的顶点覆盖数目变为<span class="math inline">\(k^* −1\)</span>，则<spanclass="math inline">\(v\)</span>是原图顶点覆盖中的一员，反之则不是</li><li>在<span class="math inline">\(G −v\)</span>中递归执行上述两步。</li></ul><h3 id="ham-cycle搜索问题-le_p-ham-cycle判断问题">Ham-Cycle搜索问题<span class="math inline">\(\le_p\)</span> Ham-Cycle判断问题</h3><p>证明：若可以在多项式时间内给出判定一个图是否存在哈密尔顿圈，则可以在多项式时间内找到一个图的哈密尔顿圈（如果存在的话）</p><p>首先判断<spanclass="math inline">\(G\)</span>中是否存在Ham-Cycle,若不存在则算法结束，如果存在则继续寻找Ham-Cycle:<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">对G中的每条边e<br>&#123;<br>    若G-e不存在Ham-<span class="hljs-keyword">Cycle</span>，将e加入S中；<br>    否则令G=G-e<br>&#125;<br>最后所得的集合便是一个Ham-<span class="hljs-keyword">Cycle</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式规约</title>
    <link href="/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="多项式规约">多项式规约</h2><p>定义：若问题X 的任意实例可以由下面两条之和解决</p><ul><li>问题X可以通过多项式时间的基本运算步骤转换为问题Y；</li><li>问题X多项式次调用求解问题Y的算法，且问题Y可以在多项式时间内被求解。</li></ul><p>那么称问题X可以多项式规约到问题Y，记为 $ X _{p} Y$。需要注意的是，问题X转换为问题Y之后，问题Y的运行时间是建立在问题Y的输入上。</p><p>多项式规约的几个性质：</p><ul><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若Y能在多项式时间内求解，那么X也能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若X不能在多项式时间内求解，那么Y也不能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p} Y\)</span> 且 <spanclass="math inline">\(Y \le_{p} X\)</span>，那么X和Y是等价的。</li></ul><h3 id="基本的规约方法">基本的规约方法</h3><ul><li>简单的恒等归约：比如最大独立集和最小点覆盖。</li><li>从特殊例子到一般例子：比如 <span class="math inline">\(点覆盖\le_{p} 集合覆盖\)</span>。<br /></li><li>通过一些小技巧规约。比如 <span class="math inline">\(3-SAT \le_{p}独立集\)</span></li></ul><h3 id="简单的恒等规约">简单的恒等规约</h3><h4 id="独立集问题independent-set">独立集问题（Independent Set）</h4><p><strong>定义</strong>：给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k(V为顶点集，E为边集)，是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \gek\)</span>并且图中每条边至多有一个顶点在S中？</p><figure><img src="/img/多项式规约/独立集.png" alt="独立集" /><figcaption aria-hidden="true">独立集</figcaption></figure><h4 id="点覆盖问题vertex-cover">点覆盖问题（Vertex Cover）</h4><p><strong>定义</strong>:给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k,是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \lek\)</span>并且图中的每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中？</p><figure><img src="/img/多项式规约/点覆盖.png" alt="点覆盖" /><figcaption aria-hidden="true">点覆盖</figcaption></figure><h4 id="vertex-cover和independent-set的关系">Vertex Cover和IndependentSet的关系</h4><p><strong>定理： <span class="math inline">\(点覆盖 \equiv_p独立集\)</span></strong></p><p>证明如下：</p><p><span class="math inline">\(\Rightarrow\)</span></p><ul><li>令<span class="math inline">\(S\)</span>为任意独立集</li><li>对任意的边 <span class="math inline">\((u,v)\)</span></li><li><span class="math inline">\(S\)</span>是独立集 <spanclass="math inline">\(\Rightarrow\)</span> <span class="math inline">\(u\notin S\)</span> 或 <span class="math inline">\(v \notin S \Rightarrowu \in V - S\)</span> 或 <span class="math inline">\(v \in V -S\)</span></li><li>所以 <span class="math inline">\(V-S\)</span> 是一个点覆盖</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><ul><li>令 <span class="math inline">\(V-S\)</span>是一个点覆盖</li><li>对两个顶点 <span class="math inline">\(u \in S\)</span> 及 <spanclass="math inline">\(v \in S\)</span></li><li>若 <span class="math inline">\(V-S\)</span> 是一个点覆盖,那么 <spanclass="math inline">\((u, v) \notin E\)</span></li><li>因此，没有相邻的顶点在 <span class="math inline">\(S\)</span> 中<span class="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(S\)</span>是独立集</li></ul><h3 id="从特殊例子到一般例子">从特殊例子到一般例子</h3><h4 id="集合覆盖set-cover">集合覆盖（Set Cover）</h4><p><strong>定义</strong>：给定一个集合<spanclass="math inline">\(U\)</span>，以及<spanclass="math inline">\(U\)</span>的子集<spanclass="math inline">\(S_1,S_2,\dots,S_m\)</span>以及一个整数<spanclass="math inline">\(k\)</span>，是否存在小于或等于<spanclass="math inline">\(k\)</span>个子集<spanclass="math inline">\(S_i\)</span>的并等于<spanclass="math inline">\(U\)</span>?</p><p><strong>例子</strong>:</p><figure><img src="/img/多项式规约/集合覆盖例子.png" alt="几何覆盖例子" /><figcaption aria-hidden="true">几何覆盖例子</figcaption></figure><h4 id="vertex-cover归约到set-cover">Vertex Cover归约到Set Cover</h4><p><strong>证明：给定一个Vertex-Cover的实例<spanclass="math inline">\(G=(V,E),k\)</span>,可以构造一个与VertexCover大小相等的Set Cover的实例。（从特殊例子到一般例子）</strong></p><ul><li>创建一个Set Cover的实例<span class="math inline">\(k = k,U=E,S_v=\{e\in E: 与V相连的边\}\)</span></li><li>可以看到Set Cover的<span class="math inline">\(size \lek\)</span>当且仅当Vertex Cover的<span class="math inline">\(size \lek\)</span></li></ul><p><strong>例子</strong>：有如下点覆盖</p><p><img src="/img/多项式规约/VertexCover归约到SetCover例子.png" /></p><p>构造Set Cover的<span class="math inline">\(U\)</span>为VertexCover的边集，即<span class="math inline">\(U=(1,2,3,4,5,6)\)</span>，SetCover的每个子集<span class="math inline">\(S_i\)</span>为VertexCover中对应顶点所连的边,故有 <span class="math display">\[    S_a=\{3,7\}， \\    S_b=\{2,4\}， \\    S_c=\{3,4,5,6\}， \\    S_d=\{5\}，  \\    S_e=\{1\}， \\    S_f=\{1,2,6,7\}    \]</span></p><p>可以看到<span class="math inline">\(S_c\)</span>和<spanclass="math inline">\(S_f\)</span>构成一个SetCover的实例，而这两个子集对应的顶点恰好组成一个Vertex Cover的实例。</p><h3 id="通过小技巧规约">通过"小技巧"规约</h3><h4 id="sat问题">3-SAT问题</h4><p><strong>Literal（字）</strong>：一个布尔变量或者它的非<spanclass="math inline">\(x_i \quad or \quad \overline{x_i}\)</span></p><p><strong>Clause（句子）</strong>：Literal的析取 <spanclass="math inline">\(C_j = x_1 \vee \overline{x_2} \veex_3\)</span></p><p><strong>Formula（式子）</strong>：Clause的合取 <spanclass="math inline">\(\Phi=C_1 \wedge C_2 \wedge C_3 \wedgeC_4\)</span></p><p><strong>SAT</strong>:给定CNF式子<spanclass="math inline">\(\Phi\)</span>，是否存在一个满足结果是True的分配<spanclass="math inline">\(x_1,\dots,x_n\)</span>？若有则称式子<spanclass="math inline">\(\Phi\)</span>是<strong>可满足</strong>的。</p><p><strong>3-SAT</strong>:每个Clause只有三个Literals。</p><p><strong>例子</strong>：</p><p><img src="/img/多项式规约/3-SAT例子.png" /></p><h4id="satisfiability3-sat归约到independent-set">3-Satisfiability（3-SAT）归约到IndependentSet</h4><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造: -3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点 -连接句子里的点连接形成三角形 -连接不同Clause里每个Literal和它对应的非</p><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h2 id="自规约重要">自规约（重要）</h2><p><strong>决策问题（Decision Problem）</strong>：诸如"是否存在一个<spanclass="math inline">\(size \ge k\)</span>的点覆盖"</p><p><strong>求解问题（SearchProblem）</strong>：诸如"寻找一个最小的点覆盖"</p><p><strong>自规约（Self-Reducibility）</strong>：Search Problem <spanclass="math inline">\(\le_p\)</span> Decision Problem</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大流最小割</title>
    <link href="/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <url>/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小割">最小割</h2><p>在图论中，去掉其中所有边能使一张网络流图不再连通（即分成两个子图）的边集称为图的割。一个$st-cut $即去掉的边把源点s和汇点t划分在两个不同的部分。</p><figure><img src="/img/最大流最小割/最小割定义.png" alt="最小割定义" /><figcaption aria-hidden="true">最小割定义</figcaption></figure><p>一般来说，一张图中有多个不同的<spanclass="math inline">\(st-cut\)</span>，如下图便为其中一个 <spanclass="math inline">\(st-cut\)</span> 。</p><figure><img src="/img/最大流最小割/一个割例子.png" alt="一个割例子" /><figcaption aria-hidden="true">一个割例子</figcaption></figure><p>但是在实际应用中，我们去掉每条边往往都是有代价的，以边的容量作为权值，一个割中去掉的边的权值之和为这个割的值，那么最小割就是这张图上最小的割。</p><h2 id="最大流">最大流</h2><p>为了求解最小割，需要引入最大流的概念。用边的权值表示边的最大流量，一个<span class="math inline">\(st-flow\)</span>是从源点s到汇点t的流量。通俗的讲，最大流就是从源点s到汇点t的最大流量。</p><figure><img src="/img/最大流最小割/最大流.png" alt="最大流" /><figcaption aria-hidden="true">最大流</figcaption></figure><h2 id="求解最大流">求解最大流</h2><h3 id="贪心算法">贪心算法</h3><ul><li>开始时对每条边e令<span class="math inline">\(f(e)=0\)</span></li><li>找到一条从源点s到汇点t的路径 <span class="math inline">\(s\rightarrow t\)</span> 使路径上的每条边e满足 <spanclass="math inline">\(f(e)&lt;c(e)\)</span> ,其中 <spanclass="math inline">\(c(e)\)</span> 为边e的权值</li><li><span class="math inline">\(flow = flow + 路径上的流量\)</span></li><li>重复上述步骤直至找不到新的路径</li></ul><h3 id="ford-fulkerson算法">Ford-Fulkerson算法</h3><h4 id="残留图residual-graph">残留图(Residual Graph)</h4><p>在另一个图中，额外构造一个反向边，权值是实际流过该边的流量 <spanclass="math inline">\(f(e)\)</span> 。</p><figure><img src="/img/最大流最小割/残余图.png" alt="残余图" /><figcaption aria-hidden="true">残余图</figcaption></figure><p>剩余图有以下性质： - <strong>增广路径(AugmentingPath)</strong>:一个增广路径P是从残余图中的一条简单路径 <spanclass="math inline">\(s \rightarrow t\)</span> -增广路径的容量是该条路径所有边中的最小权值</p><h4 id="算法说明">算法说明</h4><ul><li>每次找到一条从s到t的增广路径，并调整flow和残留图，不断调整直到没有增广路径</li><li>当残留图中不存在从s到t的增广路径时，该图已经达到最大流</li></ul><h4 id="例子">例子</h4><p>初始时没有反向边,此时残留图等于原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子1.png" /></p><p>从中选取一条增广路径,并更新残留图和原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子2.png" /></p><p>重复上面的步骤,注意<strong>增广路径一定要从残留图中找</strong>,且可以使用残留图中的反向边.</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子3.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子4.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子5.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子6.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>此时,没有新的增广路径,则最大流的值等于流进s的流量,即 <spanclass="math inline">\(flow = s_{in}\)</span></p><h2 id="最大流与最小割的关系">最大流与最小割的关系</h2><p><strong>最大流最小割定理：最大流=最小割。</strong>最大流-最小割定理用来证明Ford-Fulkson方法的确达到了最大流.</p><figure><img src="/img/最大流最小割/最大流最小割定理.png"alt="最大流最小割定理" /><figcaption aria-hidden="true">最大流最小割定理</figcaption></figure><p>证明:</p><ul><li><span class="math inline">\((i) \Rightarrow (ii)\)</span>:弱对偶性法则的推论</li><li><span class="math inline">\((ii) \Rightarrow (iii)\)</span>:反证法<br />若f是一个最大流,且仍存在增广路径,那么可以让f加上增广路径的流量,与f是一个最大流相悖.故<spanclass="math inline">\((ii) \Rightarrow (iii)\)</span>成立</li><li><span class="math inline">\((iii) \Rightarrow (i)\)</span></li></ul><p>设f是一个流,且没有增广路径,令A等于s的可达顶点集,则</p><p><img src="/img/最大流最小割/iii到i.png" /></p><h2 id="求出最大流之后如何求最小割">求出最大流之后如何求最小割</h2><p>求完最大流之后，在残留图中用BFS遍历，结束后可得到一个从<spanclass="math inline">\(s\)</span>出发可达的集合，将原图分为两个子集合，<spanclass="math inline">\(s\)</span>可达的集合<spanclass="math inline">\(X\)</span>以及<spanclass="math inline">\(s\)</span>不可达的集合<spanclass="math inline">\(Y\)</span>,其中<spanclass="math inline">\(Y\)</span>中必然包含汇点<spanclass="math inline">\(t\)</span>。</p><p>连接两个集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的边有两种情况</p><ul><li>已被占满的前向边</li><li>没有流量的反向边(即从<span class="math inline">\(Y\)</span>到<spanclass="math inline">\(X\)</span>的边)</li></ul><p>其中被占满的前向边集合就是所求的最小割</p><p>还是用上面的例子 <imgsrc="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>在<span class="math inline">\(G_f\)</span>中,用BFS遍历可得<spanclass="math inline">\(s\)</span>可达的顶点集合为<spanclass="math inline">\(\{s, 3\}\)</span>，在<spanclass="math inline">\(G\)</span>中查看<span class="math inline">\(\{s,3\}\)</span>与图中剩余顶点集合的关系。</p><ul><li>已被占满的前向边:<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span></li><li>没有流量的反向边:<span class="math inline">\(2 \rightarrow3\)</span></li></ul><p>所以图中的一个最小割为<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git撤销commit命令">Git撤销commit命令</h2><p>当要撤销的提交不是最开始的提交时 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD~<br></code></pre></td></tr></table></figure>当要撤销的提交时最开始的提交时 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">update</span> <span class="hljs-operator">-</span><span class="hljs-keyword">ref</span> <span class="hljs-operator">-</span>d HEAD<br></code></pre></td></tr></table></figure> ## Git连接远程仓库<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>url<br></code></pre></td></tr></table></figure> 注：url为github仓库链接 ## Git删除已经add的文件1.要删除的文件少时 一种是 <code>git rm --cached</code>"文件路径"，不删除物理文件，仅将该文件从缓存中删除； 一种是<code>git rm --f</code>"文件路径"，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。</p><p>2.要删除的文件多时 <code>git rm -r --cached</code> . 清空缓存区然后将本地文件删除，再次<code>add</code></p><h2 id="git创建远程新分支">Git创建远程新分支</h2><p>git无法直接通过命令方式创建远程新分支，需要间接来创建,这里我创建的远程新分支名叫vedio</p><p>首先</p><p><code>git checkout --orphan 分支名</code> <imgsrc="https://img-blog.csdnimg.cn/20210403164118752.png" /> <strong>gitrm -rf .</strong> （这一步很关键）然后创建一个文件readme.md（其实任何文件都可以），add并commit，然后</p><p><code>git push origin 分支名</code></p><p>就可以啦~如下图红框圈注的命令 <imgsrc="https://img-blog.csdnimg.cn/20210403164816128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTQyMQ==,size_16,color_FFFFFF,t_70" />## git强制提交本地分支覆盖远程分支 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> localBranchName:remoteBranchName --force<br></code></pre></td></tr></table></figure> ## Git从远程仓库拉取<code>git pull origin main</code> ## Git创建与切换分支 创建分支<code>git branch branch_name</code> 切换分支<code>git checkout branch_name</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Latex常用表示</title>
    <link href="/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th>小写字母</th><th>语法</th><th>大写字母</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(A\)</span></td><td><code>A</code></td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td><td><span class="math inline">\(B\)</span></td><td><code>B</code></td></tr><tr class="odd"><td><span class="math inline">\(\gamma\)</span></td><td><code>\gamma</code></td><td><span class="math inline">\(\Gamma\)</span></td><td><code>\Gamma</code></td></tr><tr class="even"><td><span class="math inline">\(\delta\)</span></td><td><code>\delta</code></td><td><span class="math inline">\(\Delta\)</span></td><td><code>\Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td><td><span class="math inline">\(E\)</span></td><td><code>E</code></td></tr><tr class="even"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(Z\)</span></td><td><code>Z</code></td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td><td><span class="math inline">\(H\)</span></td><td><code>H</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span></td><td><code>\theta</code></td><td><span class="math inline">\(\Theta\)</span></td><td><code>\Theta</code></td></tr><tr class="even"><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(I\)</span></td><td><code>I</code></td></tr><tr class="even"><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td><td><span class="math inline">\(K\)</span></td><td><code>K</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span></td><td><code>\lambda</code></td><td><span class="math inline">\(\Lambda\)</span></td><td><code>\Lambda</code></td></tr><tr class="even"><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td><td><span class="math inline">\(M\)</span></td><td><code>M</code></td></tr><tr class="odd"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(N\)</span></td><td><code>N</code></td></tr><tr class="even"><td><span class="math inline">\(\xi\)</span></td><td><code>\xi</code></td><td><span class="math inline">\(\Xi\)</span></td><td><code>\Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(O\)</span></td><td><code>O</code></td></tr><tr class="even"><td><span class="math inline">\(\pi\)</span></td><td><code>\pi</code></td><td><span class="math inline">\(\Pi\)</span></td><td><code>\Pi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td><td><span class="math inline">\(R\)</span></td><td><code>R</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\sigma\)</span></td><td><code>\sigma</code></td><td><span class="math inline">\(\Sigma\)</span></td><td><code>\Sigma</code></td></tr><tr class="odd"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td><td><span class="math inline">\(T\)</span></td><td><code>T</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td><code>\upsilon</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span></td><td><code>\phi</code></td><td><span class="math inline">\(\Phi\)</span></td><td><code>\Phi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td><td><span class="math inline">\(X\)</span></td><td><code>X</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span></td><td><code>\psi</code></td><td><span class="math inline">\(\Psi\)</span></td><td><code>\Psi</code></td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span></td><td><code>\omega</code></td><td><span class="math inline">\(\Omega\)</span></td><td><code>\Omega</code></td></tr></tbody></table><p>var开头的只有小写希腊字母，没有大写。</p><h2 id="运算符符号">运算符符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td></tr><tr class="even"><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="odd"><td><span class="math inline">\(\int\)</span></td><td><code>\int</code></td></tr><tr class="even"><td><span class="math inline">\(\oplus\)</span></td><td><code>\oplus</code></td></tr><tr class="odd"><td><span class="math inline">\(\otimes\)</span></td><td><code>\otimes</code></td></tr><tr class="even"><td><span class="math inline">\(\times\)</span></td><td><code>\times</code></td></tr><tr class="odd"><td><span class="math inline">\(\cdot\)</span></td><td><code>\codt</code></td></tr><tr class="even"><td><span class="math inline">\(\cap\)</span></td><td><code>\cap</code></td></tr><tr class="odd"><td><span class="math inline">\(\cup\)</span></td><td><code>\cup</code></td></tr></tbody></table><h2 id="关系符号">关系符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\le\)</span></td><td><code>\le</code></td></tr><tr class="even"><td><span class="math inline">\(\ge\)</span></td><td><code>\ge</code></td></tr><tr class="odd"><td><span class="math inline">\(\ll\)</span></td><td><code>\ll</code></td></tr><tr class="even"><td><span class="math inline">\(\gg\)</span></td><td><code>\gg</code></td></tr><tr class="odd"><td><span class="math inline">\(\equiv\)</span></td><td><code>\equiv</code></td></tr><tr class="even"><td><span class="math inline">\(\subseteq\)</span></td><td><code>\subseteq</code></td></tr><tr class="odd"><td><span class="math inline">\(\supseteq\)</span></td><td><code>\supseteq</code></td></tr><tr class="even"><td><span class="math inline">\(\subset\)</span></td><td><code>\subset</code></td></tr><tr class="odd"><td><span class="math inline">\(\supset\)</span></td><td><code>\supset</code></td></tr></tbody></table><h2 id="箭头符号">箭头符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Leftarrow\)</span></td><td><code>\Leftarrow</code></td></tr><tr class="even"><td><span class="math inline">\(\Rightarrow\)</span></td><td><code>\Rightarrow</code></td></tr></tbody></table><h2 id="其他符号">其他符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\infty\)</span></td><td><code>\infty</code></td><td>无穷</td></tr><tr class="even"><td><span class="math inline">\(\exists\)</span></td><td><code>\exists</code></td><td>存在</td></tr><tr class="odd"><td><span class="math inline">\(\forall\)</span></td><td><code>\forall</code></td><td>任取</td></tr><tr class="even"><td><span class="math inline">\(\ldots\)</span></td><td><code>\ldots</code></td><td>下三连点</td></tr><tr class="odd"><td><span class="math inline">\(\cdots\)</span></td><td><code>\cdots</code></td><td>中三连点</td></tr><tr class="even"><td><span class="math inline">\(\vdots\)</span></td><td><code>\vdots</code></td><td>竖三连点</td></tr><tr class="odd"><td><span class="math inline">\(\ddots\)</span></td><td><code>\ddots</code></td><td>斜三连点</td></tr><tr class="even"><td><span class="math inline">\(\overline{x}\)</span></td><td><code>\overline&#123;x&#125;</code></td><td>平均</td></tr><tr class="odd"><td><span class="math inline">\(\quad\)</span></td><td><code>\quad</code></td><td>空格</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>本文大部分转载自知乎<ahref="https://www.zhihu.com/people/ruan-xing-zhi"><span class="citation"data-cites="阮行止">@阮行止</span></a>，后添加了自己的一些思考。</p><h2 id="从一个生活问题谈起">1. 从一个生活问题谈起</h2><p>先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，<strong>需要用到尽量少的钞票</strong>。</p><p>依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。</p><p>这种策略称为“<strong>贪心</strong>”：假设我们面对的局面是“需要凑出w”，贪心策略会<strong>尽快</strong>让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。</p><p>但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：<br />　　15=1×11+4×1 （贪心策略使用了5张钞票）<br />　　15=3×5 （正确的策略，只用3张钞票）<br />　　为什么会这样呢？贪心策略错在了哪里？</p><p><strong>鼠目寸光</strong>。</p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。</p><p>在这里我们发现，贪心是一种<strong>只考虑眼前情况</strong>的策略。</p><p>那么，现在我们怎样才能避免鼠目寸光呢？</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。</p><p>重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。</p><p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？</p><p>明显<strong>cost=f(4)+1=4+1=5</strong>，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。</p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1=2+1=3</strong>。</p><p>那么，现在w=15的时候，我们该取那种钞票呢？<strong>当然是各种方案中，cost值最低的那一个！</strong></p><ul><li>取11：cost=f(4)+1=4+1=5</li><li>取5:cost=f(10)+1=2+1=3</li><li>取1:cost=f(14)+1=4+1=5</li></ul><p>显而易见，cost值最低的是取5的方案。<strong>我们通过上面三个式子，做出了正确的决策！</strong></p><p>这给了我们一个<strong>至关重要</strong>的启示——f(n)只与f(n-1),f(n-5),f(n-11) 相关；更确切地说：</p><blockquote><p>f(n)=min{f(n-1),f(n-5),f(n-11)}+1</p></blockquote><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><figure><img src="/img/动态规划/解决方案.jpg" alt="pic1" /><figcaption aria-hidden="true">pic1</figcaption></figure><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：</p><ul><li>f(n)只与f(n-1),f(n-5),f(n-11)的值有关。</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。<strong>其他信息并不需要</strong>。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。<strong>我们将求解f(c)称作求解f(n)的“子问题”</strong>。</p><p><strong>这就是DP（动态规划，dynamic programming）</strong>.</p><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</strong></p><h2 id="几个简单的概念">2. 几个简单的概念</h2><ul><li><strong>无后效性</strong><br />一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</li></ul><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p><p>“<strong>未来与过去无关</strong>”，这就是<strong>无后效性</strong>。</p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><ul><li>最优子结构</li></ul><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).</p><p>f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的最优解，我们即可算出w=15的最优解。</p><p>大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“最优子结构性质”。</p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="dp的典型应用dag最短路">3. DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><figure><img src="/img/动态规划/最短路径.png" alt="最短路径" /><figcaption aria-hidden="true">最短路径</figcaption></figure><p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).</p><p>想要到T，要么经过C，要么经过D。从而<spanclass="math inline">\(f(T)=min\{f(C)+20,f(D)+10\}\)</span>.</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是<spanclass="math inline">\(S \rightarrow P\rightarrow Q \rightarrowT\)</span>,那肯定S走到Q的最优路径是<span class="math inline">\(S\rightarrow P\rightarrowQ\)</span>。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><blockquote><p>f(P)=min{f(R)+W<sub><span class="math inline">\(R \rightarrowP\)</span></sub>}</p></blockquote><p>其中R为有路通到P的所有的点， [公式] 为R到P的过路费。</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="对dp原理的一点讨论">4. 对DP原理的一点讨论</h2><ul><li>DP的核心思想</li></ul><p>DP为什么会快？</p><p>无论是DP还是暴力，我们的算法都是在<strong>可能解空间</strong>内，寻找<strong>最优解</strong>。</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。</p><p>DP是枚举<strong>有希望成为答案的解</strong>。这个空间比暴力的小得多。</p><p>也就是说：<strong>DP自带剪枝</strong>。</p><p>DP舍弃了一大堆不可能成为最优解的答案。譬如：<br />　　15 = 5+5+5 被考虑了。<br />　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。</p><p>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><ul><li>DP的操作过程</li></ul><p>一言以蔽之：<strong>大事化小，小事化了</strong>。</p><p>将一个大问题转化成几个小问题；<br />　　求解小问题；<br />　　推出大问题的解。</p><ul><li>如何设计DP算法</li></ul><p>下面介绍比较通用的设计DP算法的步骤。</p><p>首先，把我们面对的局面表示为x。这一步称为设计状态。</p><p>对于状态x，记我们要求出的答案(e.g.最小费用)为f(x).我们的目标是求出f(T).<strong>找出f(x)与哪些局面有关（记为p）</strong>，写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><ul><li>DP三连</li></ul><p>设计DP算法，往往可以遵循DP三连：</p><p>我是谁？ ——设计状态，表示局面</p><p>我从哪里来？</p><p>我要到哪里去？ ——设计转移</p><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，<strong>更新能从x走到的一些解</strong>。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><blockquote><p>思考题：如何把钞票问题的代码改写成“我到哪里去”的形式？<br />提示：求出f(x)之后，更新f(x+1),f(x+5),f(x+11).</p></blockquote><h2 id="例题最长上升子序列">5. 例题：最长上升子序列</h2><p>扯了这么多形而上的内容，还是做一道例题吧。</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。<br />　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p><p>如何设计状态（我是谁）？</p><p>我们记<spanclass="math inline">\(f(x)\)</span>为以a<sub>x</sub>结尾的LIS长度，那么答案就是<span class="math inline">\(max\{f(x)\}\)</span></p><p>状态x从哪里推过来（我从哪里来）？</p><p>考虑比x小的每一个p：如果 a<sub>x</sub> &gt; a<sub>p</sub>，那么<spanclass="math inline">\(f(x)\)</span>可以取<spanclass="math inline">\(f(p)+1\)</span>.</p><p>解释：我们把 a<sub>x</sub> 接在 a<sub>p</sub>的后面，肯定能构造一个以 a<sub>x</sub> 结尾的上升子序列，长度比以a<sub>p</sub> 结尾的LIS大1.那么，我们可以写出状态转移方程了：</p><figure><img src="/img/动态规划/状态转移方程.svg" alt="状态转移方程" /><figcaption aria-hidden="true">状态转移方程</figcaption></figure><p>至此解决问题。两层for循环，复杂度O(n<sup>2</sup>) 。</p><figure><img src="/img/动态规划/最长上升子序列代码.jpg"alt="最长上升子序列代码" /><figcaption aria-hidden="true">最长上升子序列代码</figcaption></figure><p>从这三个例题中可以看出，DP是一种思想，一种“大事化小，小事化了”的思想。带着这种思想，DP将会成为我们解决问题的利器。</p><h2 id="习题">6. 习题</h2><p>如果读者有兴趣，可以试着完成下面几个习题：</p><ol type="1"><li>请采取一些优化手段，以 O(n log<sub>2</sub> n)的复杂度解决LIS问题。</li></ol><p>提示：可以参考这篇博客 <ahref="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">JuniorDynamic Programming--动态规划初步·各种子序列问题</a></p><ol start="2" type="1"><li>“按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成<ahref="https://www.luogu.com.cn/problem/P1541">P1541 乌龟棋 - 洛谷</a>。</li><li>01背包问题是一种常见的DP模型。请完成<ahref="https://www.luogu.com.cn/problem/P1048">P1048 采药 -洛谷</a>。</li></ol><h2 id="读后思考动态规划和分治法的区别与共同点">7.读后思考：动态规划和分治法的区别与共同点？</h2><h3 id="分治法">1. 分治法</h3><p>分治法(Divide-and-Conquer) :将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治模式在每一层递归上都有三个步骤：</p><ul><li>分解(Divide)：将原问题分解成一系列子问题；</li><li>解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。</li><li>合并(Combine)：将子问题的结果合并成原问题的解。</li></ul><p>合并排序(MergeSort)是一个典型分治法的例子。其对应的直观的操作如下:</p><p>分解： 将n个元素分成各含n/2个元素的子序列；</p><p>解决：用合并排序法对两个子序列递归地排序；</p><p>合并：合并两个已排序的子序列以得到排序结果。</p><h3 id="动态规划法">2. 动态规划法</h3><p>动态规划算法的设计可以分为如下4个步骤：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><p><strong>分治法是指将问题划分成一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。</strong></p><p>适合采用动态规划方法的最优化问题中的两个要素：<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p><p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p><p>In a word, <strong>分治法 —— 各子问题独立；动态规划 ——各子问题重叠</strong>。</p><p>算法导论：<strong>动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><h2 id="红黑树的性质">红黑树的性质</h2><ol type="1"><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</li></ol><p>由性质5我们可以推出：<br />性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</p><h2 id="红黑树和avl的区别">红黑树和AVL的区别</h2><ol type="1"><li><p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p></li><li><p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p></li><li><p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胜者树与败者树</title>
    <link href="/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    <url>/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>胜者树与败者树是完全二叉树。就像是参加比赛一样，每个选手有不同的实力，两个选手PK,实力决定胜负，晋级下一轮，经过几轮之后，就能得到冠军。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。在k路归并排序中经常用到。</p><h2 id="胜者树">胜者树</h2><p>胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p><figure><img src="/img/胜者树败者树/fig1.jpg" alt="fig1" /><figcaption aria-hidden="true">fig1</figcaption></figure><p>上图是一个胜者树的示例。规定数值小者胜。 1. b3 PKb4，b3胜b4负，内部结点ls[4]的值为3； 2. b3 PKb0，b3胜b0负，内部结点ls[2]的值为3； 3. b1 PKb2，b1胜b2负，内部结点ls[3]的值为1； 4. b3 PKb1，b3胜b1负，内部结点ls[1]的值为3。</p><p>取出胜者b3之后，叶子结点b3的值变为11时，重构的胜者树如下:</p><figure><img src="/img/胜者树败者树/fig2.jpg" alt="fig2" /><figcaption aria-hidden="true">fig2</figcaption></figure><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。</li></ol><p>用胜者树对n个节点实现排序操作，构建胜者树和构建堆比较相似，区别在于胜者树只有叶子节点存放了数据，中间节点记录的是叶子节点间的关系。</p><p>胜者树在每次重构时只需与其兄弟结点比较，一直到根节点选出胜者为止。</p><h2 id="败者树">败者树</h2><p>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p><figure><img src="/img/胜者树败者树/fig3.jpg" alt="fig3" /><figcaption aria-hidden="true">fig3</figcaption></figure><p>上图是一棵败者树。规定数大者败。</p><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；</li></ol><p>败者树重构过程如下： -将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。-比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。</p><figure><img src="/img/胜者树败者树/fig4.jpg" alt="fig4" /><figcaption aria-hidden="true">fig4</figcaption></figure><h2 id="胜者树败者树堆比较">胜者树、败者树、堆比较</h2><h3 id="相同点">相同点</h3><p>这三者空间和时间复杂度都是一样的。调整一次的时间复杂度都是O(logN)的。</p><h3 id="不同点">不同点</h3><p>一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，<strong>调整堆的时候，每次都要选出父结点的两个孩子节点的最小值，然后再用孩子结点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了胜者树。这样<strong>每次比较只用跟自己的兄弟结点进行比较就好</strong>，所以用胜者树可以比堆少一半的比较次数。</p><p>而<strong>胜者树想要比较兄弟结点首先要获得其父结点，也就是说需要访存两次</strong>，这时人们又想能否再次减少比较次数，于是就有了败者树。败者树每个新元素上升时，<strong>只需要获得父节点并比较即可</strong>。</p><p>总的来说，败者树与胜者树相比减少了访存时间。<strong>现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了</strong>。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html#:~:text=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91%E9%83%BD%E6%98%AF%E5%AE%8C%E5%85%A8,%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BE%E5%88%B0%E6%9C%80%E5%80%BC%E3%80%82">胜者树和败者树</a></li><li><ahref="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
