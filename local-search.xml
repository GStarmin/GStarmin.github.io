<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉树">什么是二叉树</h2><p>二叉树是一种常见的数据结构，它是每个节点至多有两棵子树的树。</p><p>二叉树有两种特殊的形式，满二叉树和完全二叉树。</p><p><strong>满⼆叉树</strong>：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆叉树为满⼆叉树。一棵深度为k的满二叉树节点个数为<spanclass="math inline">\(2^k -1\)</span>。</p><p><strong>完全⼆叉树</strong>：至多只有最下面的两层结点的度数可以小于2,并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。</p><p><img src="/img/算法/二叉树/完全二叉树和满二叉树.png" /></p><p>我们可以看出满二叉树是完全二叉树， 但完全二叉树不一定是满二叉树。</p><h2 id="二叉搜索树二叉排序树">二叉搜索树（二叉排序树）</h2><p>二叉排序树虽然名叫排序树，但是它其实是用来搜索的，是一种有序的二叉树。它遵循着左小右大的规则：</p><ul><li>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；</li><li>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；</li><li>它的左、右⼦树也分别为⼆叉搜索树。</li></ul><p><img src="/img/算法/二叉树/二叉排序树.jpg" /></p><h2 id="平衡二叉树">平衡二叉树</h2><p>二叉搜索树有一个缺点，在插入数据是有序的序列（包括升序和降序），会导致二叉树退化成链表，从而导致在查找，删除，添加时的性能均从O（logN）降低为O（N），这是不能接受的。</p><p>究其原因，是因为二叉搜索树退化成链表的时候，树的高度与节点的个数相等，也就是成正比，所以为了优化这种情况，就出现了具有平衡能力的二叉搜索树，其中AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O（logN）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G.M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm forthe organization of information》中公开了这一数据结构。</p><p><strong>平衡二叉树的性质</strong></p><p>平衡二叉树本质上是特殊的二叉搜索树（二叉排序树），它具有二叉搜索树所有的特点，此外它有自己的特别的性质，如下：</p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>平衡二叉树的左右两个子树都是一棵平衡二叉树。</li></ul><p>平衡因子指的是，平衡二叉树在保持平衡的时候，是通过平衡因子来判断的</p><p><span class="math display">\[节点的平衡因子 = 该节点的左子树的高度 -该节点右子树的高度\]</span></p><p>只有当值等于-1（右子树的高度大），0（左右子树的高度相等），1（左子树的高度大）的时候，能够代表该子树是平衡的除此之外，就认为该节点已经失衡了，需要旋转来维持平衡。</p><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的遍历是对于理解二叉树以及应对二叉树问题必不可少的因素，甚至有很多算法问题都是基于二叉树的不同遍历算法来做的。</p><p>二叉树的遍历有多种实现方式，不同的方式这里都要熟练掌握，只有熟练掌握不同的遍历方式才能以不变应万变来应对不同的问题。</p><h3 id="递归法">递归法</h3><p>很简单，不需要多说，二叉树的前序、中序、后序遍历其实都是一个模板，区别在于它们将当前节点值添加到结果数组<code>res</code>的时间不一样，而这种区别是由不同遍历方式下父节点与子节点的遍历次序导致的。</p><h4 id="前序遍历">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">oreOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    res.<span class="hljs-built_in">emplace_back</span>(res -&gt; val, res);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; left);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">inOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; left, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历">后序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">postOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; left, res);<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; right, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="迭代法">迭代法</h3><h4 id="前序遍历-1">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历-1">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历-1">后序遍历</h4><p>迭代法的后序遍历相比较前序遍历和中序遍历是要麻烦一些的。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// stk.emplace(cur);</span><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; cur -&gt; right != pre)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);   <span class="hljs-comment">// 若右孩子存在且没有遍历过那么将cur重新压栈，访问右子树</span><br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            pre = cur;<br>            cur = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="morris法">Morris法</h3><p>Morris法只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979年的论文「Traversing Binary Trees Simply andCheaply」中首次提出，因此被称为 Morris 遍历。</p><h4 id="前序遍历-2">前序遍历</h4><p>Morris遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下（假设当前遍历到的节点为<code>cur</code>）:</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>,然后将<code>cur</code>加入答案。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树。<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>这样我们利用 Morris遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)      <span class="hljs-comment">// 左子节点为空直接将val加入res中</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;  <br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h4 id="中序遍历-2">中序遍历</h4><p>Morris法的中序遍历与前序遍历的思想是相同的，不同的是在当前节点的左孩子存在时的处理方式不同，思路如下（假设当前遍历到的节点为<code>cur</code>）：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空，然后将当<code>cur</code>加入答案。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root,* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左子节点为空直接遍历右子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            pre = cur -&gt; left;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>其中 <span class="math inline">\(n\)</span>为二叉搜索树的节点个数。Morris遍历中每个节点会被访问两次，因此总时间复杂度为 <spanclass="math inline">\(O(2n)=O(n)\)</span>。</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>。</li></ul><h4 id="后序遍历-2">后序遍历</h4><p>后续遍历思路依然同上，不同的仍然是把<code>cur</code>加入答案的时机，思路如下：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>        root = root -&gt; right;<br>        count++;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">end</span>() - count, res.<span class="hljs-built_in">end</span>());<br> &#125;<br><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br><br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左孩子不空寻找cur左子树的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">// 为空说明左子树尚未遍历，将pre的右孩子更新为cur</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明左子树已经遍历，将pre右孩子重新置空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-built_in">addPath</span>(res, cur -&gt; left);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左孩子为空直接访问右子树</span><br>            cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-built_in">addPath</span>(res, root); <span class="hljs-comment">// root节点没有parent，所以root需要单独addPath</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，所以由于root节点没有parent，最后要再单独对root节点调用<code>addPath</code>。</strong></p><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><p>上面这种解法是leetcode的官方解法，这里我还有另外一种思路，如上面所说，<strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，那么是否可以采用Morris的方法将输出顺序改为<code>cur</code>、<code>cur</code>的右孩子、<code>cur</code>的左孩子，在输出完之后再统一对<code>res</code>进行翻转？</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) <br>    &#123;<br>        <br>        pre = cur -&gt; right;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// cur右孩子为空，直接将cur加入答案并访问左子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则寻找 `父右左` 遍历模式下的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; left != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; left != cur)<br>                pre = pre -&gt; left;<br>            <span class="hljs-keyword">if</span>(pre -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 为空说明右子树尚未遍历</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; left = cur;<br>                cur = cur -&gt; right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;       <br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明右子树已经遍历</span><br>            &#123;<br>                pre -&gt; left = <span class="hljs-literal">nullptr</span>;<br>                cur = cur -&gt; left;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 翻转数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有右子树的节点只被访问一次，有右子树的节点被访问两次，最后翻转数组。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h2 id="二叉树问题的小trick">二叉树问题的小trick</h2><p>二叉树中有一类问题其实套路是固定的，虽然不同问题要求的东西不一样，但是仔细分析会发现，其实它们用到的套路是一样的。<strong>当一个问题的结果需要树的左右子树也满足条件，且每层子树需要返回的参数一样时，便可以用到递归套路。</strong></p><h3 id="验证二叉搜索树">验证二叉搜索树</h3><p><strong>问题</strong>：给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>分析</strong>：如何判断一个二叉树是否是二叉搜索树？它需要满足两个条件：</p><ol type="1"><li>它的左子树和右子树都是二叉搜索树；</li><li>它的节点值大于左子树的最大值且小于右子树的最小值。</li></ol><p>那么从以上两点出发，就可以构造一个递归套路，每层需要向上层返回自己这颗树是否是二叉搜索树，如果不是那么整个树一定不是二叉搜索树；同时还要向上层返回自己这颗子树的最大值和最小值。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root, LONG_MIN, LONG_MAX);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBST</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= upper || root -&gt; val &lt;= lower)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root -&gt; left, lower, root -&gt; val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root -&gt; right, root -&gt; val, upper);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是反向思维，若<code>cur</code>的值需要大于左子树最大值并且小于右子树最小值，那么就等价于让它的左子树判断其最大值是否小于<code>cur</code>值以及<code>cur</code>右子树判断其最小值是否大于<code>cur</code>值.</p><h3 id="验证平衡二叉树">验证平衡二叉树</h3><p><strong>问题</strong>:给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p><strong>分析</strong>:一个二叉树是平衡二叉树,那么它必然满足它的左右子树都是平衡二叉树,且左右子树的高度差的绝对值不大于1.那么就又可以以相似的方式构造递归,每次需要向上层返回的参数有:</p><ul><li>当前子树是否是平衡二叉树</li><li>当前子树的深度</li></ul><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> is_balance;<br>    <span class="hljs-built_in">isBalancedTree</span>(root, is_balance, height);<br>    <span class="hljs-keyword">return</span> is_balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isBalancedTree</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">bool</span> &amp;is_balance, <span class="hljs-type">int</span> &amp;height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        is_balance = <span class="hljs-literal">true</span>;<br>        height = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">bool</span> left_balance, right_balance;<br>    <span class="hljs-type">int</span> left_height, right_height;<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; left, left_balance, left_height);<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; right, right_balance, right_height);<br>    <span class="hljs-keyword">if</span>(!left_balance || !right_balance || <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)<br>        is_balance = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        is_balance = <span class="hljs-literal">true</span>;<br>    height = <span class="hljs-built_in">max</span>(left_height, right_height) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL-unordered_map</title>
    <link href="/2023/02/24/C++%20STL-unordered_map/"/>
    <url>/2023/02/24/C++%20STL-unordered_map/</url>
    
    <content type="html"><![CDATA[<p>unordered_map定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = std::hash&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Pred = std::equal_to&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, Ty&gt; &gt; &gt;<br>    <span class="hljs-keyword">class</span> unordered_map;<br>    &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">unordered_map</span><br></code></pre></td></tr></table></figure><ul><li><strong>第1个参数</strong>:存储key值。</li><li><strong>第2个参数</strong>:存储mapped value。</li><li><strong>第3个参数</strong>:为哈希函数的函数对象。它将key作为参数，并利用函数对象中的哈希函数返回类型为size_t的唯一哈希值。默认值为std::hash&lt;key &gt;。</li><li><strong>第4个参数</strong>:为等比函数的函数对象。它内部通过等比操作符’=='来判断两个key是否相等，返回值为bool类型。默认值是std::equal_to&lt;key &gt;。</li></ul><h2 id="基本操作">基本操作</h2><h3 id="插入">插入</h3><p>一种插入的特殊情况是，unordered_map插入的<strong>值</strong>是int类型(key的类型无所谓)，这时候可以用第二种方式插入:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="删除元素">删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-comment">// 删除</span><br>    mymap.<span class="hljs-built_in">erase</span>(mymap.<span class="hljs-built_in">begin</span>());    <br>    mymap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>    mymap.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找元素">查找元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">if</span>(hash_map.<span class="hljs-built_in">find</span>(key) != hash_map.<span class="hljs-built_in">end</span>())       <span class="hljs-comment">// 查找</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;True&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;False&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="unordered_map中自定义哈希函数">unordered_map中自定义哈希函数</h2><p>内容转载自<ahref="https://blog.csdn.net/qq_34525916/article/details/115896842">c++unordered_set，unordered_map中自定义哈希函数</a></p><p>如果想用哈希的时候，但是哈希的目标又不再STL标准的类型内，比如一个自定义的class，就不太方便使用STL默认的哈希函数，比较函数，那么就需要重写了。</p><p><strong>将自定义类型作为unordered_map的键值，需如下两个步骤</strong>：</p><ol type="1"><li>定义自定义key的哈希函数的函数对象，告知此容器如何生成hash的值；</li><li>定义等比函数的函数对象或者在自定义类里重载operator==()，告知容器当出现hash冲突的时候，如何区分hash值相同的不同对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">Line</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2)&#123;<br>       k = d1;<br>       b = d2;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Line&amp; other)<span class="hljs-type">const</span>&#123;<span class="hljs-comment">//重载operator==(),若没有重载==则定义 unordered_map 时需要isEqual</span><br>        <span class="hljs-keyword">return</span> other.k ==k &amp;&amp; other.b == b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">createhash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span>  Line l)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// size_t</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//return size_t(l.k ^ l.b);//自定义哈希</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.k) ^  <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.b);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">isEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span> Line l1, <span class="hljs-type">const</span> Line l2)</span> <span class="hljs-type">const</span><span class="hljs-comment">//最后的const不能少</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//unordered_map&lt;Line ,int , createhash, isEqual&gt; mm;//若使用这种方式,Line类中不需要重载==</span><br>    unordered_map&lt;Line ,<span class="hljs-type">int</span> , createhash&gt; mm; <br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">1</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">auto</span> success = mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">if</span>(success.second == <span class="hljs-literal">false</span>)<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;mm insert failed &quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : mm)<br>    &#123;<br>        std::cout&lt;&lt; ele.first.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.first.b&lt;&lt;std::endl; <br><br>    &#125;<br><br>    <span class="hljs-comment">//unordered_set&lt;Line, createhash&gt; ms;</span><br>    unordered_set&lt;Line, createhash, isEqual&gt; ms;<span class="hljs-comment">//若使用这种方式,Line类中不需要重载==</span><br>    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">auto</span> it = ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">if</span>(it.second == <span class="hljs-literal">false</span>)<br>       std::cout&lt;&lt;<span class="hljs-string">&quot;ms insert failed &quot;</span>&lt;&lt;std::endl; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : ms)<br>    &#123;<br>        std::cout&lt;&lt; ele.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.b&lt;&lt;std::endl; <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表内部传递方式和内存占用">哈希表内部传递方式和内存占用</h3><ol type="1"><li>放入哈希表的key，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。</li><li>放入哈希表的key，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ lambda函数用法</title>
    <link href="/2023/02/24/C++%20lambda%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/C++%20lambda%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Lambda表达式（也叫lambda函数，或简称lambda），是从C++11开始引入并不断完善的，是能够捕获作用域中变量的匿名函数对象。因为C++是不能嵌套定义函数的，所以lambda就成了我们构造闭包的主要手段，不过在对象的生命周期上还是有点不同。</p><h2 id="lambda基本语法">Lambda基本语法</h2><figure><img src="/img/C++/lambda/lambda基本语法.png" alt="lambda基本语法" /><figcaption aria-hidden="true">lambda基本语法</figcaption></figure><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。下面对重要的组成部分进行说明：</p><h3 id="捕获列表">捕获列表</h3><p><strong>值捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=100,因为i是创建时拷贝的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [&amp;i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=0, 因为传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（隐式捕获），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p><p><strong>lambda捕获列表：</strong></p><ul><li>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</li><li>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>[this]。函数体内可以使用Lambda所在类中的成员变量。</li><li>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>[&amp;a]。将a按引用进行传递。</li><li>[=，&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>悬垂引用：</strong></p><p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p><h3 id="形参列表">形参列表</h3><p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C++14前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C++14起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> &amp;b) &#123;<br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//输出：10  20</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(i,j);<br><span class="hljs-comment">//输出：1 20</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>) &#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">f</span>(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明符">说明符</h3><ul><li>mutable：允许函数体修改各个复制捕获的对象，以及调用其非 const成员函数;</li><li>constexpr：显式指定函数调用运算符为 constexpr函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr函数的所有要求，则它也会是 constexpr； (C++17 起)</li><li>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和constexpr。(C++20 起)</li></ul><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span><br><span class="hljs-keyword">auto</span> f = [i, &amp;j]() <span class="hljs-keyword">mutable</span> &#123;<br>i = <span class="hljs-number">100</span>, j = <span class="hljs-number">100</span>;<br>&#125;;<br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//输出:0 100</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回类型--">返回类型 -&gt;</h3><p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的return语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = []() -&gt; <span class="hljs-type">double</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p><h3 id="函数体">函数体 <span class="math inline">\(\{ \}\)</span></h3><p>略，同普通函数的函数体。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::accumulate函数用法</title>
    <link href="/2023/02/24/C++%20accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/C++%20accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>accumulate定义在#include<numeric>中，有两种用法，一个是累加求和，另一个是自定义类型数据的处理</p><h2 id="默认累加求和">默认累加求和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="自定义对数据的处理">自定义对数据的处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> BinaryOperation &gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init,</span></span><br><span class="hljs-params"><span class="hljs-function">                        BinaryOperation op )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><p><strong>first, last</strong>: 要求和的元素范围</p><p><strong>init</strong>：和的初值</p><p><strong>op</strong>:被使用的二元函数对象。接收当前积累值 a （初始化为init ）和当前元素 b 的二元运算符。</p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// accumulate example</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">// std::minus</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>      <span class="hljs-comment">// std::accumulate</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">2</span>*y;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myclass</span> &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>*y;&#125;<br>&#125; myobject;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> init = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> numbers[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using default accumulate: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers,numbers+<span class="hljs-number">3</span>,init);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using functional minus: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom function: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers, numbers + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, [](<span class="hljs-type">int</span> a, Grade b)&#123;<span class="hljs-keyword">return</span> a + b * <span class="hljs-number">2</span>; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom object: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, myobject);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">using</span> <span class="hljs-keyword">default</span> accumulate: <span class="hljs-number">160</span><br><span class="hljs-keyword">using</span> functional minus: <span class="hljs-number">40</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-keyword">function</span>: <span class="hljs-number">120</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-type">object</span>: <span class="hljs-number">280</span><br></code></pre></td></tr></table></figure><p>转载自<ahref="https://blog.csdn.net/gongjianbo1992/article/details/105128849">C++Lambda表达式的基本使用</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中数学公式换行问题</title>
    <link href="/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-书写-latex-公式时的一些问题及解决方法">Hexo 书写 LaTeX公式时的一些问题及解决方法</h2><p>使用hexo撰写博客的时候难免会用到数学公式，，如果公式过长，我们通常希望把方程分成多行显示，这时候就需要用到换行符号<code>\\</code>，但是写出来的Markdown 经过 Hexo 的处理以后显示不正确，这与 Hexo的渲染引擎有关系。</p><p>Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax支持，因此首先要启用 MathJax 才能渲染 LaTeX公式.但是它并不支持MathJax换行，这是因为我们的markdown文件首先会被hexo-theme-marked的marked.js解析，这就会使得使用Latex语法所写的MathJax公式中的_和，最后轮到MathJax来对公式进行解析就出错了。</p><h3 id="安装hexo-renderer-pandoc">安装hexo-renderer-pandoc</h3><p>为了使用pandoc作为Hexo的渲染引擎，我们需要安装插件hexo-renderer-pandoc，步骤如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载默认渲染插件</span><br><span class="hljs-built_in">npm</span> install hexo-renderer-pandoc --svae <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p>但是在安装pandoc之后发现，公式中使用<code>\\</code>仍然不能换行，经过一番折腾之后发现了一个曲线救国的方法：在需要换行的公式加上align对齐：</p><p>例如</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>在显示的时候会发现并没有换行</p><p><img src="/img/latex/错误用法.png" /></p><p>而加上aligin之后就可以正常换行</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br><span class="hljs-built_in">&amp;</span>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> <span class="hljs-built_in">&amp;</span>B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]  <br><span class="hljs-keyword">\end</span>&#123;align&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p><img src="/img/latex/正确用法.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的随机过程</title>
    <link href="/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="正态过程">正态过程</h2><h3id="多维正态分布的概率密度和特征函数">多维正态分布的概率密度和特征函数</h3><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数.png" /></p><p>记 <imgsrc="/img/随机过程/常见随机过程/正态概率密度符号替换.png" /></p><p>则<span class="math inline">\((X,Y)\)</span>的联合概率密度为</p><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-新.png" /><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-注.png" /></p><h3 id="证明随机过程xt是正态过程">证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程</h3><p>要证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程，即证对<spanclass="math inline">\(\forall t_1,t_2,\dots\)</span> , <spanclass="math inline">\(t_n，(X(t_1),X(t_2),\dots,X(t_n))\)</span>是<spanclass="math inline">\(n\)</span>维正态分布。</p><h4 id="方法1用特征函数">方法1：用特征函数</h4><h4 id="方法2正态分布的线性不变性">方法2：正态分布的线性不变性</h4><p><strong>正态分布的线性不变性</strong>:</p><p><img src="/img/随机过程/常见随机过程/正态分布线性不变性.png" /></p><p><strong>正态分布的线性变换不变性</strong>:</p><p><imgsrc="/img/随机过程/常见随机过程/正态分布的线性变换不变性.png" /></p><h2 id="维纳过程">维纳过程</h2><p><img src="/img/随机过程/常见随机过程/维纳过程条件.png" /> <imgsrc="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><h3 id="维纳过程的分布">维纳过程的分布</h3><p><img src="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><p>设<span class="math inline">\(t&gt;s\)</span>，因<spanclass="math inline">\(W(0)=0\)</span>,且<spanclass="math inline">\(W(t)\)</span>是平稳独立增量过程，故</p><p><span class="math display">\[W(t) - W(s) = W(t-s+s)-W(s)\]</span></p><p>与</p><p><span class="math display">\[W(t-s) - W(0) = W(t-s)\]</span>有相同分布<span class="math inline">\(N(0,\sigma^2 (t-s))\)</span>。</p><p><strong>维纳过程是正态过程</strong>。</p><h3 id="维纳过程的数字特征">维纳过程的数字特征</h3><p><strong>维纳过程是平稳独立增量过程</strong>，其数字特征如下。</p><p><img src="/img/随机过程/常见随机过程/维纳过程的数字特征.png" /></p><h2 id="计数过程和泊松过程">计数过程和泊松过程</h2><h3 id="定义">定义</h3><p><strong>计数过程</strong>：</p><p><img src="/img/随机过程/常见随机过程/计数过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/计数过程定义2.png" /></p><p><strong>Poisson过程是一类很重要的计数过程</strong>。</p><p><strong>Poisson过程数学模型</strong>：</p><p><img src="/img/随机过程/常见随机过程/泊松过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程定义2.png" /></p><h3 id="齐次泊松过程">齐次泊松过程</h3><p><img src="/img/随机过程/常见随机过程/齐次泊松过程定义.png" /></p><h3 id="泊松过程的等价定义">泊松过程的等价定义</h3><p><img src="/img/随机过程/常见随机过程/泊松过程等价定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程等价定义2.png" /></p><h3 id="齐次泊松过程的有关结论">齐次泊松过程的有关结论</h3><h4 id="数字特征">数字特征</h4><p><strong>均值函数</strong>： <spanclass="math inline">\(m(t)=E\{N(t)\}=\lambda t\)</span></p><p><strong>方差函数</strong>: <span class="math inline">\(D(t)=\lambdat\)</span></p><p><strong>协方差函数</strong>: <spanclass="math inline">\(C(s,t)=\lambda min(s,t)\)</span></p><p><strong>相关函数</strong>： <spanclass="math inline">\(R(s,t)=\lambda min(s,t)+\lambda^2 st\)</span></p><p>故有<spanclass="math inline">\(\lambda=\frac{E\{N(t)\}}{t}\)</span>,称<spanclass="math inline">\(\lambda\)</span>为<strong>事件的到达率</strong>或<strong>单位时间内事件出现的平均次数</strong>。</p><h3 id="时间间隔与等待时间的分布">时间间隔与等待时间的分布</h3><p>如下图所示，<spanclass="math inline">\(N(t)\)</span>是轨道是跃度为<spanclass="math inline">\(1\)</span>的阶梯函数。</p><p><img src="/img/随机过程/常见随机过程/N（t）的分布函数.png" /></p><p>用<span class="math inline">\(T_n\)</span>表示事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n-1\)</span>次出现与第<spanclass="math inline">\(n\)</span>次出现的时间间隔。<spanclass="math inline">\(W_n\)</span>为事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n\)</span>次出现的<strong>等待时间(到达时间)</strong>，则有：</p><p><span class="math display">\[W_n=\sum\limits_{i=1}^nT_i\]</span></p><p>和</p><p><span class="math display">\[T_n=W_n - W_{n-1}\]</span></p><p><img src="/img/随机过程/常见随机过程/时间间隔序列分布定理.png" /></p><h3 id="到达时间的条件分布">到达时间的条件分布</h3><p><img src="/img/随机过程/常见随机过程/引理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理2.png" /> <imgsrc="/img/随机过程/常见随机过程/注1.png" /> <imgsrc="/img/随机过程/常见随机过程/注2.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性空间</title>
    <link href="/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="线性空间">线性空间</h2><p><strong>线性空间定义</strong>： <imgsrc="/img/矩阵论/线性空间/线性空间定义.jpg" /></p><p><strong>线性子空间定义</strong>：</p><p><img src="/img/矩阵论/线性空间/线性子空间定义.png" /></p><p><strong>平凡子空间</strong>：<spanclass="math inline">\(V\)</span>空间的平凡子空间指<spanclass="math inline">\(0\)</span>空间和<spanclass="math inline">\(V\)</span>空间本身，其他维数的空间都是非平凡子空间。</p><p><strong>线性空间的和</strong>：</p><p><img src="/img/矩阵论/线性空间/线性空间的和.jpg" /></p><h3 id="维数定理">维数定理</h3><p><img src="/img/矩阵论/线性空间/维数定理.png" /></p><h3 id="直和">直和</h3><p><img src="/img/矩阵论/线性空间/直和定义.png" /></p><h4id="判断线性空间v的两个子空间v_1和v_2是否是直和的方法">判断线性空间V的两个子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>是否是直和的方法</h4><p>判断<span class="math inline">\(V_1 \cap V_2 =\{0\}\)</span>是否成立，若成立，就是直和；否则不是直和。</p><p>将子空间的概念推广到多个子空间，于是在多个子空间中就可以定义这样的直和关系：</p><p><img src="/img/矩阵论/线性空间/多个子空间的直和.jpg" /></p><h3 id="酉空间">酉空间</h3><p>欧几里得空间：定义了内积的实线性空间。</p><p>欧几里得空间的定义推广到复线性空间就是酉空间。</p><h3 id="正交补子空间">正交补子空间</h3><p><img src="/img/矩阵论/线性空间/正交补子空间定义.png" /></p><p>这里的<spanclass="math inline">\(V_n(C)\)</span>指的是酉空间。这里的<spanclass="math inline">\(n\)</span>表示维数，<spanclass="math inline">\(C\)</span>表示复数空间。这个定义指的是复数域内的<spanclass="math inline">\(n\)</span>维空间，即是酉空间。</p><p>也就是说，一个空间V的子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>不仅要满足直和的关系，还要相互正交。<strong>这样的空间我们称<spanclass="math inline">\(V_2\)</span>为<spanclass="math inline">\(V_1\)</span>的正交补子空间（或简称正交补）</strong>。显然，二者是互为正交补的。<strong>正交补分解实际上就是在分正交基。直和分解实际上就是在分解基向量</strong>。</p><p><strong>定理</strong>：<spanclass="math inline">\(V_n(C)\)</span>的任意子空间<spanclass="math inline">\(V_1\)</span>都有唯一的正交补。</p><h3 id="kronecker积">Kronecker积</h3><h4 id="kronecker积-1">Kronecker积</h4><p><img src="/img/矩阵论/线性空间/Kronecker积.png" /></p><p>其中<span class="math inline">\(a_{ij}\)</span>为矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列的元素，对于<spanclass="math inline">\(A \in \mathbb{R^{m × n}}\)</span> 和 <spanclass="math inline">\(B \in \mathbb{R^{p × q}}\)</span>,<spanclass="math inline">\(A \otimes B \in \mathbb{R^{(mp) ×(nq)}}\)</span>。</p><p><strong>Kronecker积的性质如下</strong>：</p><p><img src="/img/矩阵论/线性空间/Kronecker积性质1.png" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质2.jpg" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质3.png" /></p><p>这些性质中前4条与矩阵运算完全相同，从第5条开始是Kronecker积独有的性质。</p><p>给出一些定义和定理：</p><p><img src="/img/矩阵论/线性空间/Kronecker积定理.jpg" /></p><p>Kronecker积的特征值：</p><p><img src="/img/矩阵论/线性空间/Kronecker积的特征值.jpg" /></p><h4 id="kronecker和">Kronecker和</h4><p><img src="/img/矩阵论/线性空间/Kronecker和.jpg" /></p><p>由定义2我们可以看到，对于Kronecker积而言，m阶矩阵和n阶矩阵之间是无法直接求和的，所以，我们通过对单位阵的Kronecker积运算，同时把他们化为<spanclass="math inline">\((m ×n)\)</span>阶方阵，这样就可以对矩阵进行求和运算了。</p><h4 id="向量化算符">向量化算符</h4><p><img src="/img/矩阵论/线性空间/向量化算符.png" /></p><p>性质：</p><p><img src="/img/矩阵论/线性空间/向量化算符性质.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题的一些心得</title>
    <link href="/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>记录一下在刷题的时候的一些小trick以及踩的一些坑。</p><!-- ### string.size()`string.size()`返回的是一个无符号数，所以在循环中如果需要对使用`s.size()`的话，需要使用`(int)s.size()`。 --><h2 id="滑动窗口">滑动窗口</h2><p>滑动窗口就是<strong>不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。它通常用于字符串或者数组特定长度下内容是否相同，也可以查找在内容相同情况下的最短长度(一般来说需要查找的数组或者字符串是连续的)。</p><h2 id="异或运算">异或运算</h2><h3 id="异或运算实现变量交换">异或运算实现变量交换</h3><p>可以理解为<strong>无进位相加</strong>，异或运算的性质如下：</p><ul><li>0 ^ N = N</li><li>N ^ N = N</li><li>a ^ b = b ^ a (交换律)</li><li>a ^ b ^ c = a ^ (b ^ c) （结合律）</li></ul><p>异或运算的妙用：交换两个数的值不使用额外变量： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">17</span>, b = <span class="hljs-number">23</span>;<br><span class="hljs-comment">// 交换a，b的值</span><br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure></p><p>但是<strong>需要注意的是，可以这样使用的前提是a和b指向的内存是不同的，但是两个数的值可以相同。</strong>比如在一个数组中对nums[i]和nums[j]进行交换，要使用这种方法，必须要保证i和j相同，否则nums[i]位置上的数会被抹成0。所以一般情况下不推荐这种用法。</p><h3 id="异或运算查找出现奇数次的数">异或运算查找出现奇数次的数</h3><h4 id="只有一种数出现奇数次">只有一种数出现奇数次</h4><p>一个数组中只有一种数出现奇数次，其余的数都出现偶数次，那么如果寻找这个出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>就是出现奇数次的数。因为异或运算满足交换律，出现偶数次的数相互异或的结果为<spanclass="math inline">\(0\)</span>，出现奇数次的数相互异或的结果为这个数的值，所以总的结果就是这个出现奇数次的数。</p><h4 id="有两种数出现奇数次">有两种数出现奇数次</h4><p>一个数组中有两种数出现奇数次，其余的数都出现偶数次，那么如果寻找出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>为a ^b。因为a和b是不同的数，所以必然有a ^ b <spanclass="math inline">\(\ne\)</span> 0,也就是a ^b的二进制至少有一位是1，那么假设a ^ b的二进制第8位为1，让<spanclass="math inline">\(eor\)</span>与数组中第8位为1的数异或，得到的<spanclass="math inline">\(eor^{&#39;}\)</span>就是a或b，再用<spanclass="math inline">\(eor^{&#39;}\)</span>与<spanclass="math inline">\(eor\)</span>异或得到的就是另外一个数。</p><p><img src="/img/算法/异或/查找数组中出现奇数次个数的数图解.png" /></p><p>因为a和b在第8为上的值一定是不一样的，所以肯定在不同的区域里，这样去用<spanclass="math inline">\(eor\)</span>异或第8位为1的数得到的就是a，b其中之一，出现偶数次的数不影响异或的结果。</p><p>那么就有一个问题，<strong>选哪一位的1？如何提取出这一位上的1？</strong>这里选择提取出a^ b最右边一位的1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>) <span class="hljs-comment">// 提取出eor最右侧的1</span><br></code></pre></td></tr></table></figure><p>将<spanclass="math inline">\(eor\)</span>用二进制表示就可以更直观的看出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">             eor = <span class="hljs-number">11001110</span>    <br>        ~eor + <span class="hljs-number">1</span> = <span class="hljs-number">00110010</span><br>eor &amp; (~eor + <span class="hljs-number">1</span>) = <span class="hljs-number">00000010</span> <span class="hljs-comment">// 提取出来最右侧的1</span><br></code></pre></td></tr></table></figure><h2 id="二分法扩展">二分法扩展</h2><p>二分法作为一种常见的查找算法，其实不单单可以只寻找某一个数。</p><h3id="查找有序数组中最左侧大于或等于k的数">查找有序数组中最左侧大于或等于k的数</h3><p><img src="/img/算法/二分法/二分法拓展.png" /></p><p>如上图所示，查找数组中最左侧大于或等于3的数也可以使用二分法。首先对整个数组二分，看中间的数是否满足大于或等于3，若满足继续在左侧二分，否则在右半侧二分，一直到结束，得到的所有满足条件的最小下标就是求得的结果。</p><p><strong>这个问题与普通二分法查找的区别在于</strong>：二分法是使用二分找个一个满足条件的数之后就结果查找，但是这里需要一直二分到最后，然后在所有满足条件的数中比较。</p><h3 id="寻找局部最小值">寻找局部最小值</h3><p>在一个无序数组arr中，相邻的数都不相同，那么如何在这个数组arr中找到一个局部最小值？这里的极小值定义是比左右两侧都小的数，在数组最左侧则只需要满足比它右侧的数小，在数组最右侧的数只需要满足比它左侧的数小即可。</p><p>首先判断<code>arr[0]</code>和<code>arr[n - 1]</code>是否是极小值，若右极小值则直接返回。若都不是极小值那么取最中间的数<code>arr[m]</code>,判断<code>arr[m]</code>是否为局部最小值，若为局部最小值则直接返回。</p><p><img src="/img/算法/二分法/局部最小值-2.png" /></p><p>若不为极小值那么它要么比它左侧的数大，要么比它右侧的数大。假设它比左侧的数大，那么就在左半边进行二分，如此一来，就存在了二分的点，直至找到一个局部最小值为止。</p><p><img src="/img/算法/二分法/局部最小值-1.png" /></p><p><strong>这里可以看出来二分法不只是能用在有序数组，在无序的情况下满足特定条件也可以用二分。</strong></p><h2 id="求两个数的均值">求两个数的均值</h2><p>一般的写法是 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>但是这样并不是无懈可击的，可能会出现一个问题，当<code>low</code>和<code>high</code>都很大的时候<code>low + high</code>可能会溢出，这样结果就变成一个负数。更加好的写法是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><code>low</code>和<code>high</code>都没有溢出，那么<code>high - low</code>也不会溢出，这样结果就不会溢出。</p><p>更加简化的写法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="时间复杂度master公式">时间复杂度（Master公式）</h2><p>若有<span class="math inline">\(T(N)=a * T(\frac{N}{b})+O(N^d)\)</span>，则说明这个算法满足<strong>Master公式</strong>。也就是说只要是<strong>满足子问题等规模的递归都可以用Master公式</strong>。a，b，d的值可能会有三种情况。</p><ol type="1"><li><span class="math inline">\(\log_b a &lt;d\)</span>,则算法时间复杂度为<spanclass="math inline">\(O(N^d)\)</span>。</li><li><span class="math inline">\(\log_b a &gt;d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^{\log_ba})\)</span>。</li><li><span class="math inline">\(\log_b a =d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^d * \logn)\)</span>。</li></ol><h2 id="链表">链表</h2><h3 id="重要技巧">重要技巧</h3><h4 id="额外数据结构记录哈希表等">额外数据结构记录（哈希表等）</h4><p>此技巧一般只适用于笔试做题，面试一般不适用。</p><p>设置额外的数据结构，比如数组、哈希表或者栈等来辅助做题。</p><h4 id="快慢指针">快慢指针</h4><p>有一些问题诸如寻找链表的中点，最简单暴力的方法是遍历一遍链表然后得到链表长度，然后根据长度得到其最中间的节点。这样做有一个问题，就是需要遍历一遍半的链表。而使用快慢指针就可以少遍历一遍链表。</p><p>它的思想是设置一个<code>fast</code>节点和一个<code>slow</code>节点，每次<code>fast</code>节点往后走两步，而<code>slow</code>节点往后走一步。这样当<code>fast</code>节点走完整个链表的时候，<code>slow</code>节点就在链表的中间。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 链表长度为偶数情况下，默认寻找中间靠前的那个节点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">nullptr</span>)<br>            fast = fast -&gt; next;<br>      <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>&#125;<br></code></pre></td></tr></table></figure><p>需要特别注意的是，<strong>不要死记这代码，实际上在做题或者应用中的不同情况是是有很多细微的差别的，比如若链表长度是偶数，有的时候需要中间靠前的节点，有的时候需要中间靠后的节点，还有的时候需要中间靠前节点的前驱节点，不同情况要做对应的调整，同时还要注意边界条件，比如节点为空或者只有一个节点的情况。</strong></p><p>链表长度为偶数情况下，寻找中间靠后的那个节点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 链表长度为偶数情况下，寻找中间靠后的那个节点</span><br> <span class="hljs-comment">// 同时保证链表长度为奇数情况下可以找到正中间的节点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>      fast = fast -&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试时链表解题方法论">面试时链表解题方法论</h3><ol type="1"><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。比如可以直接把链表copy到数组。</li><li>对于面试，时间复杂度仍然放在第一位，但是要找到空间复杂度最省的方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平稳过程</title>
    <link href="/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="严平稳过程">严平稳过程</h2><p><img src="/img/随机过程/平稳过程/严平稳过程定义.png" /> <imgsrc="/img/随机过程/平稳过程/严平稳过程定义-2.png"alt="严平稳过程定义" /></p><p>严平稳过程有限维分布不随时间的推移而改变，，它的当前变化情况与过去的情况有不可忽视的联系。</p><p>严平稳过程的一维分布与时间无关，而二维分布仅与<spanclass="math inline">\(t_1\)</span>和<spanclass="math inline">\(t_2\)</span>的时间间隔有关，与时间起点无关。</p><h2 id="宽平稳过程">宽平稳过程</h2><p>由于</p><ul><li>工程中确定一个过程的有限维分布函数族,进而判定过程的严平稳性十分困难；</li><li>部分随机过程(如正态过程)的概率特征主要由一阶和二阶矩函数确定；</li><li>工程实际中,通常仅需在相关理论范畴内考虑平稳过程,即只限于研究一、二阶矩（均值、相关函数等）理论.</li></ul><p>所以有了宽平稳过程。</p><p>定义： <img src="/img/随机过程/平稳过程/宽平稳过程定义.png"alt="宽平稳过程定义" /></p><p>其中<span class="math inline">\(R_x(\tau)\)</span>为<spanclass="math inline">\(\{X(t),t \inT\}\)</span>的自相关函数。其协方差函数为 <spanclass="math display">\[C_X(s,t)=R_X(s,t)-|m_X|^2=R_X(\tau)-|m_X|^2\]</span></p><p>自协方差函数与自相关函数都仅依赖于<spanclass="math inline">\(t－s\)</span></p><p><strong>维纳过程不是宽平稳过程，但是维纳过程是增量宽平稳过程，即</strong><span class="math display">\[X(t)=W(t+a)-W(t), t \ge 0, \quad(a&gt;0)\]</span></p><p>是宽平稳过程</p><h2 id="两种平稳性的关系">两种平稳性的关系</h2><ul><li>严平稳过程不一定是宽平稳的;</li></ul><p>因宽平稳过程一定是二阶矩过程, 而严平稳过程未必是二阶矩过程.</p><ul><li>宽平稳不一定 严平稳;</li><li>严平稳过程是宽平稳过程的充要条件是其二阶矩存在.</li><li>对于正态过程, 宽平稳性与严平稳性等价.</li></ul><h2 id="平稳过程的自相关函数">平稳过程的自相关函数</h2><p><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-1.png" /><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-2.png" /></p><p>证明:</p><ol type="1"><li><img src="/img/随机过程/平稳过程/自相关证明1.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明2.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明3.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明4.png" /></li></ol><p>推论： <img src="/img/随机过程/平稳过程/自相关函数推论.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.2.png" /></p><p>证明： <img src="/img/随机过程/平稳过程/5.2.2证明.png" /></p><p>定理: <img src="/img/随机过程/平稳过程/定理5.2.3.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.4.png" /></p><p>推论： <img src="/img/随机过程/平稳过程/定理5.2.4推论1.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广义逆矩阵</title>
    <link href="/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="单边逆">单边逆</h2><p>所谓矩阵的单边逆就是指矩阵的左逆和右逆。</p><figure><img src="/img/矩阵论/单边逆定义.png" alt="矩阵的单边逆" /><figcaption aria-hidden="true">矩阵的单边逆</figcaption></figure><p><strong>定理1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(A\)</span>为列满秩矩阵</li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(A\)</span>为行满秩矩阵</li></ul><p><strong>推论1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(N(A)=\{0\}\)</span></li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(R(A)=\mathbb{C}^m\)</span></li></ul><h3 id="单边逆的求法">单边逆的求法</h3><p><strong>例1</strong>: <img src="/img/矩阵论/例1-1.png" /> <imgsrc="/img/矩阵论/例1-2.png" /></p><p><strong>例2</strong>: <img src="/img/矩阵论/例2-1.png" /> <imgsrc="/img/矩阵论/例2-2.png" /></p><p>需要注意的是例1求左逆矩阵进行的是初等行变换,例2求右逆矩阵是进行的初等列变换，初等行变换我们在线性代数中常用，比较熟悉，但是要求右逆矩阵一定要进行初等列变换。</p><h2 id="广义逆矩阵">广义逆矩阵</h2><p><strong>定义</strong>: <img src="/img/矩阵论/广义逆定义.png" /></p><p><strong>性质</strong>: <img src="/img/矩阵论/广义逆定理1.png" /></p><p>推论: <img src="/img/矩阵论/广义逆推论1.png" /></p><p>需要注意的是，同线性代数中的矩阵的逆不同的是，这里求的广义逆一般不唯一。既然不唯一，有许多解的话，我们就考虑是否有一个通解可以将所有的广义逆全部表示呢？的确有，下面我们就介绍定理2，该定理表示的就是全部的广义逆：</p><p><img src="/img/矩阵论/全部广义逆集合定义.png" /></p><p><strong>定理2</strong>(不常考): <imgsrc="/img/矩阵论/广义逆定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆定理2-2.png" /></p><p><strong>定理3</strong>: <img src="/img/矩阵论/广义逆定理3-1.png" /><img src="/img/矩阵论/广义逆定理3-2.png" /></p><ul><li>(i)是逆矩阵性质在广义逆的推广</li><li>(ii)说的是一个矩阵乘以他的广义矩阵是幂等矩阵，且他们矩阵的秩相等</li><li>(iii)可以看出0矩阵的广义逆矩阵可以是任何矩阵（包括0矩阵）</li><li>(v)说的是<span class="math inline">\(AA^{-1}\)</span>与<spanclass="math inline">\(A\)</span>的值域相同,<spanclass="math inline">\(A^{-1}A\)</span>与<spanclass="math inline">\(A\)</span>的零空间相同,证明如下:</li></ul><p><img src="/img/矩阵论/定理3(v)证明.png" /></p><h2 id="自反广义逆矩阵">自反广义逆矩阵</h2><p>自反广义逆矩阵是广义逆矩阵里的一类特殊矩阵,其定义如下: <imgsrc="/img/矩阵论/自反广义逆矩阵定义.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/自反广义逆矩阵定理1.png" /></p><p>需要注意的是，自反广义逆矩阵并不唯一。事实上，对于 <imgsrc="/img/矩阵论/广义逆矩阵/图1.png" /></p><p>构造这样的矩阵 <img src="/img/矩阵论/广义逆矩阵/图2.png" /></p><p>所有满足这样条件的矩阵G，就是A的自反广义逆。所以自反广义逆并不唯一.</p><p><strong>定理2</strong>(考试不要求): <imgsrc="/img/矩阵论/广义逆矩阵/定理2.png" /></p><p>定理2给出了自反广义逆矩阵的一种具体的构造方法,</p><p><strong>定理3</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/定理3.png" /></p><p>定理3给出了在广义逆矩阵中，区分自反广义逆的一种有效方法。当广义逆矩阵的秩等于矩阵A的秩的时候是自反广义逆。当广义逆的秩大于矩阵A的秩的时候是广义逆矩阵而不是自反广义逆矩阵。</p><h2 id="m-p广义逆矩阵">M-P广义逆矩阵</h2><p>M-P广义逆矩阵（Moore-Penrose）矩阵是在自反广义逆矩阵之上又加了两个条件形成的矩阵，要求更加苛刻。我们一般用<span class="math inline">\(A^+\)</span> 来表示M-P广义逆矩阵。 <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定义.png" /></p><p>这四个条件，共同保证了 <span class="math inline">\(A^+\)</span>的<strong>唯一性</strong>。</p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理1.png" /></p><p>该定理给出了<span class="math inline">\(A^+\)</span>的具体计算方法。定理的证明直接用该式子验证定义中的四个式子即可.</p><p><strong>定理2</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则 <spanclass="math inline">\(A^+\)</span>是唯一的.</p><p>这一点已经在上面提到过了,定义中的四个式子保证了<spanclass="math inline">\(A^+\)</span>的唯一.</p><h3 id="m-p广义逆的性质">M-P广义逆的性质</h3><p><img src="/img/矩阵论/广义逆矩阵/M-P广义逆定理3.png" /></p><p><strong>定理5</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理5.png" /></p><h3 id="m-p广义逆的计算">M-P广义逆的计算</h3><h4 id="最大秩分解">最大秩分解</h4><p><img src="/img/矩阵论/广义逆矩阵/引理1.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆的计算定理1.png" /></p><p><strong>例1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-2.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-3.png" /></p><h4 id="奇异值分解法">奇异值分解法</h4><p><strong>定理2</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-2.png" /></p><h3 id="m-p广义逆的应用">M-P广义逆的应用</h3><h4 id="判断方程有没有解">判断方程有没有解</h4><p>求出<span class="math inline">\(A^+\)</span>,判断<spanclass="math inline">\(AA^+b\)</span>是否等于<spanclass="math inline">\(b\)</span>,若不等于则没有解，否则有解。</p><h4id="求方程的最佳逼近解最小范数解最小二乘解">求方程的最佳逼近解/最小范数解/最小二乘解</h4><p>当方程有解的时候，可以求得最小范数解为<spanclass="math inline">\(A^+b\)</span>；当方程没有解的时候，可以求出最佳逼近解为<spanclass="math inline">\(A^+b\)</span>，最小二乘通解为<spanclass="math inline">\(A^+ b+(I-A^+ A)u, \forall u \in\mathbb{C}^n\)</span>,其中<span class="math inline">\(A\)</span>为<spanclass="math inline">\(n\)</span>阶矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    <url>/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"> --><h2id="三角分解qr分解需要是非奇异矩阵">三角分解(QR分解)(需要是非奇异矩阵)</h2><h3id="正交三角分解通过schmidt正交化">正交三角分解(通过Schmidt正交化)</h3><p>若 <span class="math inline">\(n\)</span> 阶实矩阵 <spanclass="math inline">\(A\in \mathbb {C}^{n\times n}\)</span> 满秩，且<span class="math display">\[A = [\alpha_1,...,\alpha_n]\]</span></p><p>其中 <span class="math inline">\(\alpha_1,...,\alpha_n\)</span> 是<span class="math inline">\(\mathbb {C}^{n\times n}\)</span>中线性无关向量组</p><p><strong>正交化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned} \beta_1&amp;=\alpha_1\\\beta_2&amp;=\alpha_2 -\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1\\ \vdots \\ \beta_n &amp;= \alpha_n -\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}\end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \alpha_1 &amp;=\beta_1\\ \alpha_2 &amp;=\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1+ \beta_2\\ \vdots \\ \alpha_n &amp;=\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}+ \beta_n \end{aligned} \]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\alpha_1,\alpha_2,...,\alpha_n\end{bmatrix} &amp;=\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;\triangleqB\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix} \end{aligned}\]</span></p><p><strong>单位化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned}q_1=&amp;\frac{\beta_1}{||\beta_1||} \\ &amp;\vdots \\ q_n =&amp; \frac{\beta_n}{||\beta_n||} \end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \beta_1 =&amp;q_1||\beta_1|| \\ &amp;\vdots \\ \beta_n =&amp; q_n ||\beta_n||\end{aligned}\]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix} &amp;=\begin{bmatrix}q_1,q_2,...,q_n\end{bmatrix}\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\end{aligned} \]</span></p><p>综上，结合正交化和单位化可得</p><p><span class="math display">\[ \begin{aligned} A &amp;=B\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp;||\beta_n||\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;||\beta_2||&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq QR \end{aligned} \]</span></p><p><strong>QR 分解定理</strong> : <span class="math inline">\(A\in\mathbb {C}^{n\times n}\)</span> ,则存在酉矩阵 <spanclass="math inline">\(Q\)</span> 和正线上三角阵 <spanclass="math inline">\(R\)</span> ，使 <spanclass="math display">\[A=QR\]</span></p><p>且分解唯一</p><p><strong>正交三角分解的求法</strong> 1. 取矩阵 <spanclass="math inline">\(A=(A_1,A_2,...,A_n)\)</span> 的列向量，进行<strong>Schmidt 标准正交化</strong>,得 <spanclass="math inline">\(v_1,v_2,...,v_n\)</span> ，有 <spanclass="math display">\[Q=(v_1,v_2,...,v_n)\]</span> 2. 再由 <spanclass="math inline">\(R=Q^HA\)</span> 得到 <spanclass="math inline">\(R\)</span> , 于是 <spanclass="math inline">\(A=QR\)</span></p><h3 id="householder变换分解">HouseHolder变换分解</h3><p>将矩阵A按列划分为 <spanclass="math inline">\((\alpha_1,\alpha_2,\dots,\alpha_n)\)</span>,以4阶方阵为例，</p><p>第一步 令 <spanclass="math display">\[\omega_1=\frac{\alpha_1-a_1*e_1}{||\alpha_1-a_1*e_1||_2}，a_1=||\alpha_1||_2\]</span></p><p>于是 <spanclass="math display">\[H_1A=(H_1\alpha_1,H_1\alpha_2，...，H_1\alpha_n)=\left\{\begin{matrix} a_1 &amp; * &amp; \cdots &amp; * \\                   0      &amp; \\                   \vdots &amp; &amp;B_1 \\0\end{matrix}\right\}\]</span></p><p>第二步</p><p>从第一步中得到 <spanclass="math inline">\(B_1=(\beta_2,\beta_2,\cdots,\beta_n)\inR^{n-1}\)</span></p><p>取 <spanclass="math display">\[\omega_2=\frac{\beta_2-b_2*e_1}{||\beta_2-b_2*e_1||_2}，b_1=||\beta_2||_2\]</span></p><p>则 <spanclass="math display">\[\widehat{H_2}=I-2*\omega_2*\omega_2^T,H_2=\left\{\begin{matrix}1 &amp; 0^T \\                                                              0 &amp;\widehat{H_2}，                                              \end{matrix}\right\}\]</span></p><p>得到 <span class="math display">\[H_2(H_1*A) = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp;* \\                                       0 &amp; a_2 &amp; * &amp; \cdots&amp;* \\                                       0 &amp; 0 &amp;  &amp;\\                                       \vdots &amp; \vdots&amp;  &amp;C_2&amp; \\                                       0 &amp; 0\end{bmatrix} , C_2\in R^{n-2}\]</span></p><p>依次类推，进行第n步时，得到第n-1个 <spanclass="math inline">\(H_{n-1}\)</span>阵,使得 <spanclass="math display">\[H_{n-1} \cdots H_2H_1*A = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp; * \\                                                   0 &amp; a_2 &amp; *&amp; \cdots &amp; * \\                                                   0 &amp; 0 &amp; a_3&amp; \cdots &amp; *\\                                                  \vdots &amp; \vdots&amp; &amp;\ddots \\                                                    0 &amp; 0 &amp; 0&amp; \cdots &amp;a_n\end{bmatrix}=R\]</span></p><p>其中 <span class="math inline">\(H_{n-1} \cdotsH_2H_1*A=H\)</span>也称为HouseHolder矩阵，也为自逆矩阵 <spanclass="math inline">\(H=H^{-1}\)</span></p><p><span class="math display">\[H_{n-1} \cdots H_2H_1*A=R\]</span> <spanclass="math display">\[\Rightarrow (H_{n-1} \cdots H_2*H_1)^{-1}*H_{n-1}\cdots H_2H_1*A=(H_{n-1} \cdots H_2*H_1)^{-1}*R\]</span> <spanclass="math display">\[\Rightarrow A=H_1^{-1} \cdotsH_{n-1}^{-1}*R\]</span> <span class="math display">\[\RightarrowA=H_1\cdots H_{n-1}*R\]</span></p><p>得到 <span class="math inline">\(A=QR\)</span>,其中 <spanclass="math inline">\(Q\)</span>为正交矩阵， <spanclass="math inline">\(R\)</span>为上三角矩阵 <spanclass="math display">\[\begin{cases}Q = H_1\cdots H_{n-1}\\R = Q^{-1}A=QA\end{cases}\]</span></p><h3 id="三角分解的性质">三角分解的性质</h3><p><strong>定理1</strong>:设 <span class="math inline">\(A\in \mathbb{C}_r^{m\times n}\)</span>，则 <span class="math inline">\(A\)</span>可以唯一地分解为 <span class="math display">\[A=U_1 R\]</span></p><p>其中 <span class="math inline">\(U_1\)</span>是酉矩阵， <spanclass="math inline">\(R\)</span> 是正线上三角复矩阵，或 <spanclass="math inline">\(A\)</span> 可以唯一地分解为 <spanclass="math display">\[A=L U_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角复矩阵， <spanclass="math inline">\(U_2\)</span>是酉矩阵</p><p><strong>推论1</strong>：设 <span class="math inline">\(A \in \mathbb{R}^{n × n}_n\)</span>,则 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=Q_1 R\]</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是则正交矩阵，<spanclass="math inline">\(R\)</span>是正线上三角实矩阵，或 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=L Q_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角实矩阵， <spanclass="math inline">\(Q_2\)</span>是正交矩阵。</p><p><strong>推论2</strong>：设A是实对称正定矩阵，则存在唯一正线上三角实矩阵<span class="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^T R\]</span></p><p><strong>推论3</strong>：设 <spanclass="math inline">\(A\)</span>是正定Hermite矩阵，则存在唯一正线上三角复矩阵<spanclass="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^H R\]</span></p><h2 id="矩阵的满秩分解">矩阵的满秩分解</h2><p>设 <span class="math inline">\(A\in \mathbb {C}_r^{m\timesn}\)</span>，则存在 <span class="math inline">\(B\in \mathbb{C}_r^{m\times r}, C\in \mathbb {C}_r^{r\times n}\)</span>，满足 <spanclass="math display">\[ A = BC \]</span></p><p><span class="math inline">\(\mathbb {C}_r\)</span> 表示矩阵的秩为<span class="math inline">\(r\)</span></p><p>实际上上述定理用文字描述就是，一个亏秩的矩阵可以分解成一个列满秩与行满秩矩阵的乘积</p><p>证明：因为 <span class="math inline">\(rank(A)=r\)</span>，所以一定可以找到与 <spanclass="math inline">\(A\)</span> 相似的一个矩阵</p><p><span class="math display">\[ A \simeq\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\\0_{(m-r)\timesr}&amp;0_{(m-r)\times(n-r)}\end{bmatrix}=\begin{bmatrix}E_r\\0_{(m-r)\timesr}\end{bmatrix}\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\end{bmatrix}\]</span></p><p>因此存在两个可逆矩阵 <span class="math inline">\(P,Q\)</span>，使<span class="math inline">\(PAQ=\begin {bmatrix} E_r&amp;0\\0&amp;0\end{bmatrix}\)</span>，则</p><p><span class="math display">\[ \begin{aligned} A &amp;=P^{-1}\begin{bmatrix}E_r\\0\end{bmatrix}\begin{bmatrix}E_r&amp;0\end{bmatrix}Q^{-1}\\&amp;\triangleq BC \end{aligned} \]</span></p><p>因为 <span class="math inline">\(P^{-1}\)</span> 是可逆矩阵，<spanclass="math inline">\(\begin {bmatrix} E_r\\0\end {bmatrix}\)</span>是一个列满秩矩阵，所以 <span class="math inline">\(B=P^{-1}\begin{bmatrix} E_r\\0\end {bmatrix}\)</span> 仍是一个列满秩矩阵；同理，<spanclass="math inline">\(C=\begin {bmatrix} E_r&amp;0\end {bmatrix}Q^{-1}\)</span> 是一个行满秩矩阵</p><h3 id="矩阵满秩分解的计算">矩阵满秩分解的计算</h3><p>如何在给定矩阵 <span class="math inline">\(A\)</span>的情况下，求出矩阵 <span class="math inline">\(B,C\)</span> 呢？</p><p>设</p><p><span class="math display">\[\begin{align}&amp;A = [\alpha_1,\alpha_2,...,\alpha_n]\\ &amp;B =[\beta_1,\beta_2,...,\beta_r]  \end{align}\]</span></p><p>其中 <span class="math inline">\(\beta_1,...,\beta_r\)</span>线性无关</p><p>所以 <span class="math display">\[ \begin{aligned} &amp;A=BC\\&amp;\Rightarrow[\alpha_1,\alpha_2,...,\alpha_n]=[\beta_1,...,\beta_r]\begin{bmatrix}c_{11}&amp;\cdots&amp;c_{1n}\\\vdots &amp;\ddots&amp;\vdots\\c_{r1}&amp;\cdots&amp;c_{rn}\end{bmatrix} \end{aligned} \]</span></p><p>实际上我们可以取 <spanclass="math inline">\(\beta_1,...,\beta_r\)</span> 为 <spanclass="math inline">\(\alpha_1,...,\alpha_n\)</span>的一个极大线性无关组，因此 <span class="math inline">\(B\)</span>就是矩阵 <span class="math inline">\(A\)</span>列向量组的一个极大线性无关组，<span class="math inline">\(C\)</span>就是用该线性无关组去表示 <span class="math inline">\(A\)</span>时的系数</p><h4 id="例-1">例 1</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换 <span class="math display">\[A=\begin{bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\\0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}1&amp;4&amp;-1\\2&amp;0&amp;0\\-1&amp;2&amp;-4\\2&amp;6&amp;-5\end{bmatrix}，C=\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\end{bmatrix}\]</span></p><h4 id="例-2">例 2</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换</p><p><span class="math display">\[A=\begin{bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}2&amp;1&amp;-2\\2&amp;5&amp;-1\\1&amp;3&amp;-1\end{bmatrix},C=\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><h2 id="矩阵的lu分解">矩阵的LU分解</h2><p>LU 分解（LUDecomposition）是矩阵分解的一种，可以将一个矩阵分解为一个单位下三角矩阵和一个上三角矩阵的乘积，以四阶矩阵为例<span class="math display">\[ L = \begin{bmatrix}1&amp;0&amp;0&amp;0 \\*&amp;1&amp;0&amp;0\\ *&amp;*&amp;1&amp;0\\*&amp;*&amp;*&amp;1\end{bmatrix},U=\begin{bmatrix}*&amp;*&amp;*&amp;*\\0&amp;*&amp;*&amp;*\\0&amp;0&amp;*&amp;*\\0&amp;0&amp;0&amp;*\end{bmatrix}\]</span></p><p>LU 矩阵是否一定存在？答案是否，具体看下面的例子</p><p>设 <span class="math inline">\(\begin {bmatrix} 0&amp;1 \\1&amp;0\end{bmatrix}=\begin {bmatrix} a&amp;0\\b&amp;c\end {bmatrix}\begin{bmatrix} l&amp;m\\0&amp;n\end {bmatrix}\)</span>，则应该满足如下 4个式子</p><p><span class="math display">\[ \begin{cases} al=0\\ am=1\\ bl=1\\bm+cn=0 \end{cases} \]</span></p><p>由 <span class="math inline">\(al=0\)</span> 得 <spanclass="math inline">\(a=0\)</span> 或 <spanclass="math inline">\(l=0\)</span>，但实际上这两种情况带入上面的式子都会推出矛盾，因此不是所有情况LU 分解都存在</p><p><strong>LU 分解定理</strong> ：设 <span class="math inline">\(A\in\mathbb {C}_n^{n\times n}\)</span>，<spanclass="math inline">\(A\)</span> 有唯一的 LU 分解 <spanclass="math inline">\(\Leftrightarrow A\)</span> 的各阶顺序主子式 <spanclass="math inline">\(\Delta k \neq 0,\ k=1,2...,n\)</span></p><p><span class="math inline">\(k\)</span> 阶顺序主子式指的是矩阵左上角<span class="math inline">\(k\times k\)</span> 个元素组成的行列式</p><p>将矩阵 <span class="math inline">\(A\)</span> 分解为 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span> 之后，解方程组 <spanclass="math inline">\(Ax=b\)</span> 就变得简单了，因为 <spanclass="math inline">\(A=LU\)</span>，所以 <spanclass="math inline">\((LU) x=b\Rightarrow L (Ux)=b\Rightarrow \begin{cases} Ly=b\\Ux=y\end {cases}\)</span></p><p>所以 <span class="math inline">\(x=U^{-1} y=U^{-1} L^{-1}b\)</span></p><h3 id="lu-矩阵的求法">LU 矩阵的求法</h3><p>实际上 LU 矩阵有非常多的求法，这里列举一种比较简单的待定系数法</p><p>设 <span class="math inline">\(A = \begin {bmatrix}2&amp;3&amp;4\\1&amp;1&amp;9\\1&amp;2&amp;-6\end{bmatrix}\)</span>，求矩阵 <span class="math inline">\(A\)</span> 的 LU分解矩阵 <span class="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span></p><p><strong>解</strong>：令 <span class="math display">\[L=\begin{bmatrix}1&amp;0&amp;0\\l_1&amp;1&amp;0\\l_2&amp;l_3&amp;1\end{bmatrix},U=\begin{bmatrix}u_1&amp;u_2&amp;u_3\\0&amp;u_4&amp;u_5\\0&amp;0&amp;u_6\end{bmatrix}\]</span></p><p>由于 <span class="math inline">\(A=LU\)</span>，所以有</p><p><span class="math display">\[ \begin{cases} u_1=2\\ u_2=3\\ u_3=4\\l_1u_1=1\\ l_1u_2+u_4=1\\ l_1u_3+u_5=9\\ l_2u_1=1\\ l_2u_2+l_3u_4=2\\l_2u_3+l_3u_5+u_6=-6 \end{cases} \]</span></p><p>上面的方程组非常容易解，最后求出</p><p><span class="math display">\[ L =\begin{bmatrix}1&amp;0&amp;0\\\frac{1}{2}&amp;1&amp;0\\\frac{1}{2}&amp;-1&amp;1\end{bmatrix},U=\begin{bmatrix}2&amp;3&amp;4\\0&amp;-\frac{1}{2}&amp;7\\0&amp;0&amp;-1\end{bmatrix}\]</span></p><h2 id="奇异值分解">奇异值分解</h2><p><strong>奇异值</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{m × n}_r,AA^H\)</span> 的特征值为 <spanclass="math display">\[\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_n =0\]</span></p><p>则称 <span class="math inline">\(\sigma_i=\sqrt{\lambda_i}\)</span>为矩阵A的正奇异值。<strong><span class="math inline">\(A\)</span>和<span class="math inline">\(A^H\)</span>相同的奇异值</strong>。</p><p><strong>奇异值分解</strong>：当给定一个大小为<spanclass="math inline">\(m × n\)</span>的矩阵<spanclass="math inline">\(A\)</span>,虽然矩阵<spanclass="math inline">\(A\)</span>不一定是方阵，但大小为<spanclass="math inline">\(m × m\)</span>的<spanclass="math inline">\(AA^T\)</span>和<span class="math inline">\(n ×n\)</span>的<span class="math inline">\(AA^T\)</span>是对称矩阵,若<spanclass="math inline">\(AA^T=P \Lambda_1 Q^T\)</span>,<spanclass="math inline">\(A^T A=Q\Lambda_2Q^T\)</span>,则矩阵A的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T\]</span></p><p>其中，矩阵<span class="math inline">\(P=(\overrightarrow{p_1},\overrightarrow{p_2}, \dots, \overrightarrow{p_m})\)</span>的大小为<span class="math inline">\(m × m\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{p_1}, \overrightarrow{p_2}, \dots,\overrightarrow{p_m}\)</span>是 <spanclass="math inline">\(AA^T\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的左奇异向量（left singularvector）；矩阵<span class="math inline">\(Q=(\overrightarrow{q_1},\overrightarrow{q_2}, \dots, \overrightarrow{q_m})\)</span>的大小为<span class="math inline">\(n × n\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{q_1}, \overrightarrow{q_2}, \dots,\overrightarrow{q_m}\)</span>是 <spanclass="math inline">\(A^TA\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的右奇异向量（left singularvector）；矩阵<spanclass="math inline">\(\Lambda_1\)</span>的大小为<spanclass="math inline">\(m × m\)</span>，矩阵<spanclass="math inline">\(\Lambda_2\)</span>的大小为<spanclass="math inline">\(n ×n\)</span>，两个矩阵对角线上的非零元素相同（即矩阵<spanclass="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的非零特征值相同）；矩阵<spanclass="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(m ×n\)</span>，位于对角线上的元素被称为<strong>奇异值</strong>（singularvalue）。</p><p>设<span class="math inline">\(A\)</span>的秩为r，当 <spanclass="math inline">\(m \ne n\)</span>时，矩阵<spanclass="math inline">\(\Lambda_1\)</span>和<spanclass="math inline">\(\Lambda_2\)</span>的大小显然是不同的，但是他们对角线上的非零元素是相同的，记矩阵<spanclass="math inline">\(\Lambda_1\)</span>(或<spanclass="math inline">\(\Lambda_2\)</span>)对角线上的非零元素为<spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_r\)</span>，这些数皆为非负数，又记矩阵<spanclass="math inline">\(\Sigma\)</span>对角线上的非零元素分别为<spanclass="math inline">\(\sigma_1,\sigma_2,\dots,\sigma_r\)</span>，则<spanclass="math display">\[\sigma_1=\sqrt{\lambda_1},\sigma_2=\sqrt{\lambda_2},\dots,\sigma_r=\sqrt{\lambda_r}\]</span></p><p>即非零奇异值的平方对应着矩阵<spanclass="math inline">\(\Lambda_1\)</span>（或矩阵<spanclass="math inline">\(\Lambda_2\)</span>）的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。</p><p><strong>例1</strong>：一个<spanclass="math inline">\(3×2\)</span>的矩阵<spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\)</span>，求其奇异值分解。</p><p>由 <span class="math display">\[AA^T=\begin{bmatrix}    5&amp;0&amp;0 \\ 0&amp;0&amp;0 \\ 0&amp;0&amp;0\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=\lambda_3=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{p_1}=(1,0,0)^T,\overrightarrow{p_2}=(0,1,0)^T,\overrightarrow{p_3}=(0,0,1)^T\)</span></p><p>由 <span class="math display">\[A^TA=\begin{bmatrix}    1&amp;2 \\ 2&amp;4\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{q_1}=(\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T,\overrightarrow{q_2}=(-\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T\)</span></p><p>令 <span class="math display">\[\Sigma=\begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p>注意矩阵<span class="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(3 × 2\)</span>，此时，矩阵<spanclass="math inline">\(A\)</span>的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T=(\overrightarrow{p_1},\overrightarrow{p_2}, \overrightarrow{p_3})\Sigma (\overrightarrow{q_1},\overrightarrow{q_2})^T \\ =\begin{bmatrix}    1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix} \begin{bmatrix}    \frac{\sqrt{5}}{5}&amp;\frac{2\sqrt{5}}{5} \\\frac{-2\sqrt{5}}{5}&amp;\frac{\sqrt{5}}{5}\end{bmatrix} = \begin{bmatrix}    1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p><strong>例2</strong>：求对称矩阵<spanclass="math inline">\(A=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}\)</span>的奇异值分解。</p><p>经计算可以发现<spanclass="math inline">\(A^TA=AA^T=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix} \begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}=\begin{bmatrix}  5&amp;4 \\ 4&amp;5\end{bmatrix}\)</span>，左奇异向量和右奇异向量构成的矩阵也是相等的，即<span class="math display">\[P=Q=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p>则其奇异值分解为 <span class="math display">\[A=P\SigmaQ^T=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2}&amp; \frac{\sqrt{2}}{2}\end{bmatrix}\begin{bmatrix}    3&amp;0 \\ 0&amp;1\end{bmatrix}\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p><strong>注</strong>：这是由于当矩阵<spanclass="math inline">\(A\)</span>为对称矩阵时，其可以被正交对角化，这时奇异值分解等于正交对角化分解。</p><h2 id="谱分解">谱分解</h2><p><strong>谱分解</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{n × n}\)</span>是单纯矩阵，则 <spanclass="math inline">\(A\)</span>可以分解为一系列幂等矩阵 <spanclass="math inline">\(A_i(i=1,2, \dots,n)\)</span>的加权和 <spanclass="math display">\[A=\sum_{i=1}^n \lambda_i A_i\]</span></p><p>其中 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span>是A的特征值。</p><p><strong>单纯矩阵</strong>：若矩阵 <spanclass="math inline">\(A\)</span>的<strong>代数重数</strong>等于<strong>几何重数</strong>，则称<spanclass="math inline">\(A\)</span>为单纯矩阵。<strong>代数重数</strong>为矩阵<spanclass="math inline">\(A\)</span>特征值的重数，<strong>几何重数</strong>为齐次方程组<spanclass="math inline">\(Ax=\lambda_ix(i=1,2,\dots,k)\)</span>的解空间<spanclass="math inline">\(V_{\lambda_i}\)</span>的维数，也即特征值对应的最多无关特征向量数。</p><p><strong>幂等矩阵</strong>：若 <spanclass="math inline">\(A\)</span>为方阵，且 <spanclass="math inline">\(A^2=A\)</span>，则称<spanclass="math inline">\(A\)</span>为幂等矩阵。所有幂等矩阵都相似与对角元全为0或1的对角阵。</p><p><strong>更一般的单纯矩阵谱分解定理</strong>：设 <spanclass="math inline">\(A \in \mathbb{C}^{n × n}\)</span>，他有 <spanclass="math inline">\(k\)</span>个相异特征值 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,k)\)</span>，则 <spanclass="math inline">\(A\)</span>是单纯矩阵的充要条件是存在<spanclass="math inline">\(k\)</span>个矩阵<spanclass="math inline">\(A_i(i=1,2,\dots,k)\)</span>满足</p><ol type="1"><li><span class="math inline">\(A_i A_j = \begin{cases}  A_i, i=j \\ 0,i\ne j \end{cases}\)</span></li><li><span class="math inline">\(\sum_{i=1}^k A_i = E_n\)</span></li><li><span class="math inline">\(A=\sum_{i=1}^k \lambda_iA_i\)</span></li></ol><p>该定理比定理3要求放宽了，不再要求必须要有n个特征值了，这里的k可以小于等于n。</p><p><strong>例1</strong>：求正规矩阵 <span class="math inline">\(A =\begin{bmatrix}  0&amp;1&amp;1&amp;1 \\ 1&amp;0&amp;-1&amp;1 \\1&amp;-1&amp;0&amp;1 \\ -1&amp;1&amp;1&amp;0\end{bmatrix}\)</span>的谱分解表达式。</p><p><strong>解</strong>：首先计算 <spanclass="math inline">\(A\)</span>的特征值和特征向量 <spanclass="math display">\[|\lambda_ I - A |=(\lambda - 1)^3 (\lambda +3)\]</span></p><p>从而 <span class="math inline">\(A\)</span>的特征值为 <spanclass="math display">\[\lambda_1=\lambda_2=\lambda_3=1,\lambda_4=-3\]</span></p><p>当<spanclass="math inline">\(\lambda=1\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_1=(1,1,0,0)^T \\ \alpha_2=(1,0,1,0)^T \\\alpha_3=(-1,0,0,1)^T\]</span></p><p>当<spanclass="math inline">\(\lambda=-3\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_4=(1,-1,-1,1)^T\]</span></p><p>将 <spanclass="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交化并单位化得<spanclass="math display">\[\eta_1=(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0,0)^T\\\eta_2=(\frac{1}{\sqrt{6}},\frac{1}{\sqrt{6}},\frac{2}{\sqrt{6}},0)^T \\\eta_3=(-\frac{1}{2\sqrt{3}},\frac{1}{2\sqrt{3}},\frac{1}{\sqrt{3}},\frac{3}{2\sqrt{3}})^T\]</span></p><p>将<span class="math inline">\(\alpha_4\)</span>单位话得 <spanclass="math display">\[\eta_4=(\frac{1}{2},-\frac{1}{2},-\frac{1}{2},\frac{1}{2})\]</span></p><p>故有 <span class="math display">\[G_1=\eta_1 \eta_1^H+\eta_2 \eta_2^H+\eta_3 \eta_3^H \\= \begin{bmatrix}    \frac{3}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;\frac{3}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{3}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{3}{4}    \end{bmatrix}\]</span></p><p><span class="math display">\[G_2=\eta_4 \eta_4^H \\=\begin{bmatrix}    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4}\end{bmatrix}\]</span></p><p>这样其谱分解表达式为 <span class="math display">\[A=G_1 -3G_2\]</span></p><p>注意<span class="math inline">\(G_1\)</span>和<spanclass="math inline">\(G_2\)</span>的系数<spanclass="math inline">\(\lambda_i\)</span>为其对应的特征值。<!-- https://www.cnblogs.com/blairgrowing/p/15800825.html --></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>范数</title>
    <link href="/2022/12/05/%E8%8C%83%E6%95%B0/"/>
    <url>/2022/12/05/%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>不管向量范数、矩阵范数还是算子范数，都需要满足三个特性:</p><ul><li>正定性</li><li>齐次性</li><li>三角不等式</li></ul><h2 id="向量范数">向量范数</h2><p><strong>1 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_1=\sum\limits_{i=1}^N|x_i|\)</span>，即向量元素绝对值之和</p><p><strong>2 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_2=(\sum\limits_{i=1}^N (x_i)^2)^{\frac{1}{2}}\)</span>，也叫欧几里得范数，常用于计算向量长度，即向量元素的平方和再开方</p><p><strong><span class="math inline">\(\infty\)</span>-范数</strong>:<span class="math inline">\(\Vert \boldsymbol{x}\Vert_{\infty}=\max\limits_{i}|x_i|\)</span>，即所有向量元素中绝对值的最大值</p><!-- **-$\infty$- 范数**:$\Vert \boldsymbol {x}\Vert_{-\infty}=\min\limits_{i} |x_i|$，即所有向量元素绝对值中的最小值 --><p><strong>P - 范数</strong>:<span class="math inline">\(\Vert\boldsymbol {x}\Vert_p=(\sum\limits_{i=1}^N (x_i)^p)^{\frac{1}{p}}\)</span>，即向量元素的 p 次方和再开 p 次方</p><h2 id="矩阵范数">矩阵范数</h2><p>设<span class="math inline">\(A \in \mathbb{C}^{m ×n}\)</span>，则</p><p><span class="math inline">\({||A||}_{m_1} = \sum\limits^{n}_{j=1}\sum\limits^{m}_{i=1} |a_{ij}|\)</span></p><p><span class="math inline">\(||A||_{m_2} = {||A||}_{F}=\sqrt{\sum\limits^{n}_{j=1} \sum\limits^{m}_{i=1} |a_{ij}^2|} =\sqrt{tr(A^HA)} = \sqrt{tr(AA^H)}\)</span></p><p><spanclass="math inline">\(||A||_{m_\infty}=\max\limits_{i,j}\{|a_{ij}|\},1\le i \le m, 1 \le j \le n\)</span></p><h3 id="矩阵范数的性质">矩阵范数的性质</h3><p><img src="/img/矩阵论/矩阵范数性质-定理1.png" /> <imgsrc="/img/矩阵论/矩阵范数性质-定理1-2.png" /></p><ul><li><span class="math inline">\({||A||}_{m_1}\)</span>范数与向量范数<span class="math inline">\(||x||_1\)</span>相容</li><li><span class="math inline">\({||A||}_{m_2}\)</span>范数与向量范数<span class="math inline">\(||x||_2\)</span>相容</li><li><spanclass="math inline">\({||A||}_{m_{\infty}}\)</span>范数与向量范数 <spanclass="math inline">\(||x||_\infty\)</span> 不相容</li></ul><h3 id="证明一个范数是矩阵范数流程">证明一个范数是矩阵范数流程</h3><ul><li>证明非负性、齐次性、三角不等式</li><li>看他定义是哪种类型的范数，若是相容的需要证明相容性</li></ul><h2 id="算子范数">算子范数</h2><p>算子范数定义1： <img src="/img/矩阵论/算子范数定义1.png" /></p><p>注意：并不是所以的矩阵范数都与向量范数相容。只有满足该条件的矩阵范数才与向量范数是相容的。</p><p>算子范数定义2： <img src="/img/矩阵论/算子范数定义2.png" /></p><p><strong>则称此矩阵范数为从属于向量范数 <spanclass="math inline">\(||x||\)</span>的算子范数</strong>。这里的x可是n维空间的任意取向。</p><p><strong>算子范数表示</strong>：</p><p><span class="math inline">\({||A||}_1=\max\limits_{1 \le j \len}\{\sum\limits^{s}_{j=1}|a_{ij}|\}\)</span>,列模和范数，即所有矩阵列向量绝对值之和的最大值</p><p><span class="math inline">\(||A||_2=\sqrt{\rho(A^HA)}\)</span>，谱范数</p><p><span class="math inline">\(||A||_\infty=\max\limits_{1 \le i \les}\{\sum^n_{j=1}|a_{ij}|\}\)</span>,行模和范数,即所有矩阵行向量绝对值之和的最大值</p><h3 id="算子范数性质">算子范数性质</h3><ul><li><span class="math inline">\({||A||}_{1}\)</span> 范数与向量范数<span class="math inline">\(||x||_1\)</span> 相容</li><li><span class="math inline">\({||A||}_{2}\)</span> 范数与向量范数<span class="math inline">\(||x||_2\)</span> 相容</li><li><span class="math inline">\(||·||_a\)</span>是算子范数 <spanclass="math inline">\(\Rightarrow ||E||_a = 1\)</span></li><li>设<span class="math inline">\(A \in \mathbb{C}^{n × n}，||A||_a\)</span>是从属向量范数<spanclass="math inline">\(||x||\)</span>的算子范数，若<spanclass="math inline">\(||A||_a &lt; 1\)</span>,则 <spanclass="math inline">\(E \pm A\)</span> 可逆，且<spanclass="math inline">\(||(E \pm A)^{-1}||_a \le (1 -||A||_a)^{-1}\)</span></li></ul><p><img src="/img/矩阵论/算子范数性质-定理3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jordan标准型</title>
    <link href="/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <url>/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="jordan标准型">Jordan标准型</h2><figure><img src="/img/矩阵论/Jordan标准型定义.png" alt="Jordan标准型定义" /><figcaption aria-hidden="true">Jordan标准型定义</figcaption></figure><p>其中 <spanclass="math inline">\(J_1(\lambda_1),J_2(\lambda_2)\)</span>分别构成Jardon块。</p><p>即对任意矩阵 <spanclass="math inline">\(A\)</span>，比存在n阶可逆矩阵<spanclass="math inline">\(P\)</span>，使 <spanclass="math display">\[P^{-1}AP=\begin{bmatrix}    J_1 &amp; &amp; &amp; \\ &amp; J_2 &amp; &amp; \\ &amp; &amp; \ddots&amp; \\ &amp; &amp; &amp; J_n\end{bmatrix} = J\]</span></p><p>每一个 <span class="math inline">\(J\)</span> 都是Jardon块 <spanclass="math display">\[J_i=\begin{bmatrix}    \lambda_i &amp; 1 &amp; &amp; \\ &amp; \lambda_i &amp; \ddots &amp;&amp; \\ &amp; &amp; \ddots &amp;1 \\ &amp; &amp; &amp; \lambda_i\end{bmatrix}\]</span></p><h3 id="jordan标准型的结构与结论">Jordan标准型的结构与结论</h3><ul><li>Jordan标准型的个数<spanclass="math inline">\(k\)</span>是线性无关特征向量的个数</li><li>矩阵可对角化当且仅当<span class="math inline">\(k=n\)</span></li><li>相应于一个已知特征值的Jordan块的个数是该特征值的几何重数，它是相应的特征子空间的维数，相应于一个已知特征值的所有Jordan的阶数之和，是该特征值的代数重数</li><li>特征值的几何重数 &lt; 代数重数</li><li>矩阵不同特征值对应的特征向量线性无关</li></ul><figure><img src="/img/矩阵论/Jordan标准型定理2.png" alt="定理2" /><figcaption aria-hidden="true">定理2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征值估计</title>
    <link href="/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>shur不等式</strong> <imgsrc="/img/矩阵论/特征值估计-shur不等式.png" /></p><p>证明如下： <img src="/img/矩阵论/shur不等式证明.png" /></p><p><strong>行盖尔圆盘和列盖尔圆盘</strong>： <imgsrc="/img/矩阵论/盖尔圆盘.png" /></p><p><strong>圆盘定理</strong>： <img src="/img/矩阵论/圆盘定理1.png" /><img src="/img/矩阵论/圆盘定理2.png" /></p><p>推论1：设<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>相似于对角阵.</p><p>推论2： 设<span class="math inline">\(n\)</span>阶实阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>特征值全为实数.</p><p><strong>对角占优矩阵</strong>：</p><p><img src="/img/矩阵论/对角占优矩阵.png" /></p><p><strong>Rayleigh商</strong>：设<span class="math inline">\(A \in\mathbb{C}^{n \times n}\)</span>为Hermite矩阵，<spanclass="math inline">\(x \in \mathbb{C}\)</span>，称 <spanclass="math display">\[R(x)=\frac{x^HAx}{x^Hx}, x \ne 0\]</span></p><p>为<span class="math inline">\(A\)</span>的Rayleigh商。</p><p><strong>定理（Rayleigh-Ritz）</strong>: <imgsrc="/img/矩阵论/Rayleigh-Ritz定理.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵函数</title>
    <link href="/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数">矩阵函数</h2><p><strong>定义</strong>： 设幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty} c_kz^k\)</span>收敛半径为<span class="math inline">\(r\)</span>，且当<spanclass="math inline">\(|z|&lt;r\)</span>的时候，幂级数收敛于<spanclass="math inline">\(f(z)\)</span>，即</p><p><span class="math display">\[f(z)=\sum\limits_{k=0}^{\infty} c_kz^k,|z|&lt;r\]</span></p><p>如果<span class="math inline">\(A \in\mathbb{C}^{n×n}\)</span>满足<spanclass="math inline">\(r(A)&lt;r\)</span>,则收敛的矩阵幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty}a_kA^k\)</span>的和为矩阵函数，记为<spanclass="math inline">\(f(A)\)</span>，即</p><p><span class="math display">\[f(A)=\sum\limits_{k=0}^{\infty} c_kA^k\]</span></p><p>把<span class="math inline">\(f(A)\)</span>的方阵换为<spanclass="math inline">\(At\)</span>,<spanclass="math inline">\(t\)</span>为参数，得到</p><p><span class="math display">\[f(At)=\sum\limits_{k=0}^{\infty}c_k(At)^k\]</span></p><p>常见的矩阵级数有：</p><p><img src="/img/矩阵论/矩阵函数/常见矩阵函数1.png" /> <imgsrc="/img/矩阵论/矩阵函数/常见矩阵函数2.png" alt="常见矩阵函数" /></p><h3 id="矩阵函数的计算方法">矩阵函数的计算方法</h3><h4 id="利用相似对角化">利用相似对角化</h4><p>设<span class="math inline">\(P^{-1}AP= diag(\lambda_1,\lambda_2,\dots, \lambda_3) = D\)</span></p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算2.png" /></p><p><strong>例1</strong>：</p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-3.png" /></p><h4 id="jordan标准型法">Jordan标准型法</h4><p><img src="/img/矩阵论/矩阵函数/Jordan法-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-4.png" /></p><p><strong>例2</strong>：</p><p><img src="/img/矩阵论/矩阵函数/Jordan法-例2-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例2-2.png" /></p><h4 id="数项级数求和法">数项级数求和法</h4><p><img src="/img/矩阵论/矩阵函数/数项级数求和法.png" /></p><p>由哈密尔顿-凯莱定理于是我们有：</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-2.png" /></p><p>由该定理，我们可以实现降次的目的。</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/数项级数求和法-4.png" /></p><h3 id="矩阵函数的性质">矩阵函数的性质</h3><p><img src="/img/矩阵论/矩阵函数/矩阵函数性质.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近似算法</title>
    <link href="/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="近似算法">近似算法</h2><p>假设现在需要解决一个NP-Hard问题，但是又不太可能在多项式时间内求解，但是我们可以退而求其次，那么就必须要牺牲下面的其中一项：</p><ul><li>求得最优解</li><li>在多项式时间内完成</li><li>覆盖问题的所有例子</li></ul><p>而牺牲第二条是不能接受的，当我们选择满足后两者（也就是牺牲第一项），即对解的优越性放宽要求时，设计出的算法被称为<strong>近似算法</strong>。</p><h2 id="load-balancing问题">Load Balancing问题</h2><p>给定<span class="math inline">\(m\)</span>台相同的机器，<spanclass="math inline">\(n\)</span>个任务，任务<spanclass="math inline">\(j\)</span>需要的处理时间为<spanclass="math inline">\(t_j\)</span>,且每个任务<spanclass="math inline">\(j\)</span>必须在一台机器上连续完成。</p><p>令<span class="math inline">\(J(i)\)</span>为分配给机器<spanclass="math inline">\(i\)</span>的任务子集，机器<spanclass="math inline">\(i\)</span>的负载为<spanclass="math inline">\(L_i=\sum\limits_{j \inJ(i)}t_j\)</span>,该问题的时间跨度(makespan)为所有机器上的结束时间最大值<spanclass="math inline">\(L=\max\limits_i L_i\)</span>。</p><p><strong>LoadBalancing</strong>：求上述问题中的任务分配使得时间跨度最小。</p><h3 id="贪心算法">贪心算法</h3><p>每次将任务<spanclass="math inline">\(j\)</span>分配在当前负载最小的机器上： <imgsrc="/img/近似算法/LoadBalancing贪心算法.png" /></p><p><strong>引理1</strong>：最优解makespan<span class="math inline">\(L^*\ge \max\limits_j t_j\)</span>。</p><p>用时最长的这个任务总需要分配到一个机器上完成.</p><p><strong>引理2</strong>:最优解makespan <span class="math inline">\(L^*\ge \frac{1}{m} \sum\limits_j t_j\)</span></p><p>所有任务的总运行时间为<span class="math inline">\(\sum\limits_jt_j\)</span>,那么<spanclass="math inline">\(L^*\)</span>的时间跨度必然选自<spanclass="math inline">\(m\)</span>个机器中最大的一个,而<spanclass="math inline">\(m\)</span>个机器中的最大时间跨度一定不小于<spanclass="math inline">\(\frac{1}{m}\)</span>的总运行时间.</p><p><strong>定理:贪心算法是LoadBalancing问题的二倍近似算法。</strong></p><p>证明:</p><p>假设负载<span class="math inline">\(L_i\)</span>为问题的平静,令<spanclass="math inline">\(j\)</span>为最后一个分配到该机器的任务,由贪心算法,在任务<spanclass="math inline">\(j\)</span>分配之前,机器<spanclass="math inline">\(i\)</span>的负载是最小的.<spanclass="math inline">\(j\)</span>分配之前机器<spanclass="math inline">\(i\)</span>的负载为<span class="math inline">\(L_i- t_j\)</span>,也就是说在准备分配<spanclass="math inline">\(j\)</span>的时候有<span class="math inline">\(L_i- t_j\)</span>小于或等于所有机器上的负载<span class="math inline">\(L_k,1 \le k \le m\)</span></p><p><img src="/img/近似算法/LoadBalancing贪心算法证明-1.png" /></p><p>分配任务<span class="math inline">\(j\)</span>之前,由引理1: <spanclass="math display">\[  \begin{aligned}    L_i - t_j &amp;\le \frac{1}{m}\sum\limits_k L_k \\        &amp;=  \frac{1}{m} \sum\limits_k t_k \\        &amp;\le L^*    \end{aligned}\]</span></p><p>分配任务<span class="math inline">\(j\)</span>后,由上式以及引理2:<span class="math display">\[L_i = (L_i -t_i) + t_j \le L^* +\max\limits_j t_j \le L^* + L^* = 2L^*\]</span></p><p>那么贪心算法是Load Balancing的紧2倍近似算法吗?判断<spanclass="math inline">\(\rho\)</span>-近似算法是否紧的要看该算法相比于最优解有比<spanclass="math inline">\(\rho\)</span>更低的近似率吗?若有则说明其并不是紧的。</p><p>答:大致是的,考虑下面的一个Load Balancing的实例,有<spanclass="math inline">\(m\)</span>个机器,<spanclass="math inline">\(m^2\)</span>个任务,其中有<spanclass="math inline">\(m(m-1)\)</span>个任务运行时间为1,一个任务的运行时间为<spanclass="math inline">\(m\)</span>.贪心算法的结果如下图所示:</p><p><img src="/img/近似算法/LoadBalancing实例-贪心算法.png" /></p><p>而最优解的结果为:</p><p><img src="/img/近似算法/LoadBalancing实例-最优解.png" /></p><p>这个实例里贪心算法的时间跨度为19,而最优解的时间跨度为10.</p><h3 id="lptlongest-processing-time算法">LPT(longest ProcessingTime)算法</h3><p>LPT算法是在上面的贪心算法基础之上,先对<spanclass="math inline">\(n\)</span>个任务按时间降序排序,然后再按照上面的贪心算法执行.</p><p><img src="/img/近似算法/LoadBalancingLPT算法.png" /></p><p>通过观察可以得出,当任务数小于或等于机器数的时候,LRT算法就是最优解.这时候只需要把任务<spanclass="math inline">\(i\)</span>分配给机器<spanclass="math inline">\(i\)</span>.</p><p><strong>引理3</strong>:如果任务数多于机器数<spanclass="math inline">\(m\)</span>,有<span class="math inline">\(L^* \ge2t_{m+1}\)</span>.</p><p>设前<spanclass="math inline">\(m+1\)</span>个任务的运行时间分别为<spanclass="math inline">\(t_1,\dots,t_{m+1}\)</span>,由于运行时间<spanclass="math inline">\(t_i\)</span>是按照降序排列,所以前<spanclass="math inline">\(m+1\)</span>个任务的运行时间都不小于<spanclass="math inline">\(t_{m+1}\)</span>,且由于鸽笼原则,至少有一个机器会被分配两个任务.</p><p><strong>定理:LPT算法是Load Balancing的一个<spanclass="math inline">\(\frac{3}{2}\)</span>近似算法.</strong></p><p>证明:与证明贪心算法相同的方法 <span class="math display">\[L_i=(L_i -t_j) + t_j \le L^* + \frac{1}{2}L^* = \frac{3}{2}L\]</span></p><p>那么LPT算法是Load Balancing的紧<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似算法吗?不是;LPT算法是LoadBalancing的紧<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似算法吗?很可能是.</p><h2 id="centrer-selection-problem中心选址问题">Centrer SelectionProblem(中心选址问题)</h2><p>定义:给定一个大小为<spanclass="math inline">\(n\)</span>个地址集合<spanclass="math inline">\(s_1,s_2,\dots,s_n\)</span>以及一个整数<spanclass="math inline">\(k&gt;0\)</span>,选择<spanclass="math inline">\(k\)</span>个中心使所有地址到离它最近的中心距离的最大值最短.</p><p><img src="/img/近似算法/CentrerSelectionProblem.png" /></p><p>几个概念:</p><ul><li><span class="math inline">\(dist(x, y)\)</span>:<spanclass="math inline">\(x,y\)</span>的距离.</li><li><span class="math inline">\(dist(s_i, C)=\min\limits_{c \inC}\)</span>:<spanclass="math inline">\(s_i\)</span>到离它最近的中心的距离,这里采用欧式距离.</li><li><span class="math inline">\(r(C)=\max\limits_{i}dist(s_i,C)\)</span>:最小的覆盖半径.</li></ul><p>中心选址问题的目标便是找到一个中心集合<spanclass="math inline">\(C\)</span>使覆盖半径<spanclass="math inline">\(r(C)\)</span>最小,其中中心的数量等于<spanclass="math inline">\(k\)</span>.</p><p>距离的一些性质: <span class="math display">\[dist(x,x)=0\tag{同一性}\]</span> <span class="math display">\[dist(x,y)=dist(y,x)\tag{对称性}\]</span> <span class="math display">\[dist(x,y) \ledist(x,z) + dist(z,y) \tag{三角不等式}\]</span></p><h3 id="贪心算法-1">贪心算法</h3><p>开始时我们任意选取一个地址作为中心，接着选择离第一个中心最远的那个地址作为第二个中心，如此的重复进行,直到选了<spanclass="math inline">\(k\)</span>个中心为止。</p><p><img src="/img/近似算法/CentrerSelectionProblem贪心算法.png" /></p><p><strong>定理：贪心算法是中心选址问题的2倍近似解</strong></p><p>证明(反证法)：</p><p>假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span></p><ul><li>对近似解集合<span class="math inline">\(C\)</span>的中心<spanclass="math inline">\(c_i\)</span>，总有一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>在<spanclass="math inline">\(c_i\)</span>的圆中(任意一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>的圆里最少有一个地址<spanclass="math inline">\(s\)</span>,而贪心算法选址都是在地址集合中选的，并且<spanclass="math inline">\(c_i\)</span>的半径 <spanclass="math inline">\(&gt;\)</span> <spanclass="math inline">\(c_i^*\)</span>的半径，所以<spanclass="math inline">\(c_i^*\)</span>必然在某一个中心<spanclass="math inline">\(c_i\)</span>的圆里)</li><li>令<span class="math inline">\(c_i\)</span>是与<spanclass="math inline">\(c_i^*\)</span>对应的中心</li><li>对于任意一个离最优解<spanclass="math inline">\(c_i^*\)</span>最近的地址<spanclass="math inline">\(s\)</span>,有</li></ul><p><span class="math display">\[dist(s,C) \le dist(s, c_i) \le dist(s,c_i^*) + dist(c_i^*, c_i) \le r(C^*) + r(C^*) = 2r(C^*)\]</span></p><p>上式与假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span>相违背，故有<spanclass="math inline">\(r(C^*) \ge\frac{1}{2}r(C)\)</span>,即贪心算法是中心选址问题的2倍近似解。</p><p>中心选址问题有没有<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似解或者<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似解？</p><p>答：没有，除非P＝NP，否则中心选址问题没有倍率比2小的近似算法。</p><h2 id="weighted-vertex-cover">Weighted Vertex Cover</h2><p>带权值的顶点覆盖：对于给出的一个顶点带权值的图<spanclass="math inline">\(G\)</span>，找到一个顶点覆盖，使它们的权值之和最小。（这里我们主要解决的是：求图<spanclass="math inline">\(G=(V,E)\)</span>的顶点覆盖<spanclass="math inline">\(S\)</span>，要使顶点集合<spanclass="math inline">\(S\)</span>中所有顶点的权值之和最小。</p><p><img src="/img/近似算法/WeightedVertexCover.png" /></p><h3 id="pricing-method">Pricing Method</h3><p><strong>定价法</strong>：因为顶点覆盖要求每条边至少有一个顶点在集合<spanclass="math inline">\(S\)</span>里,每条边必须被一些顶点所覆盖，根据顶点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>，给边<span class="math inline">\(e =(i, j)\)</span> 标上价格<span class="math inline">\(P_e\)</span>。</p><p>公平性：与顶点<spanclass="math inline">\(i\)</span>所连接的所有边的价格（权值）之和必须小于顶点<spanclass="math inline">\(i\)</span>的权值。</p><p>引理：：图<spanclass="math inline">\(G\)</span>的所有边的价格（权值）之和 <spanclass="math inline">\(\le\)</span> 顶点覆盖<spanclass="math inline">\(S\)</span>中所有顶点的权值之和（两个简单的缩放）。</p><p><img src="/img/近似算法/WeightedVertexCover-不等式放缩.png" /></p><p>上面第一个<spanclass="math inline">\(\le\)</span>不能写成等号，等号只在每条边都恰好只有一个顶点在<spanclass="math inline">\(S\)</span>中时才成立，若有边的两个顶点都在<spanclass="math inline">\(S\)</span>中，那么这条边就会被计算两次。</p><p>求解过程：边的价格设置与找寻顶点覆盖同时进行</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-求解过程.png" /></p><p>例子：</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-例子.png" /></p><p><strong>Pricing Method是Weighted VertexCover</strong>的一个2倍近似算法。</p><p>证明：</p><p>首先证明<span class="math inline">\(S\)</span>是一个点覆盖：</p><p>算法结束条件：在while循环的每次迭代结束之后，至少有一个顶点会是紧致的（除非图没有边），所以在算法结束的时候每条边的两个顶点中至少有一个是紧的，即每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，而VertexCover要求每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，所以<spanclass="math inline">\(S\)</span>必然是一个点覆盖，否则循环就不会停止。</p><p>然后再证明<spanclass="math inline">\(S\)</span>是最优解的一个2倍近似解：</p><p><img src="/img/近似算法/证明PricingMethod2倍近似解.png" /></p><p>第一处放缩很容易得出，<spanclass="math inline">\(S\)</span>肯定为顶点集<spanclass="math inline">\(V\)</span>的一个子集；<spanclass="math inline">\(\sum\limits_{i \in V} \sum\limits_{e=(i,j)} p_e =2 \sum\limits_{e \in E} p_e\)</span>是因为计算与<spanclass="math inline">\(V\)</span>中所有顶点相连的边时，每条边会被计算两次；最右边一个放缩为引理的结论。</p><h2id="线性规划解决最小带权点覆盖问题">线性规划解决最小带权点覆盖问题</h2><h3 id="整数规划">整数规划</h3><p>对于图<spanclass="math inline">\(G=(V,E)\)</span>,对图中的每个点<spanclass="math inline">\(v \in V\)</span>，定义函数<spanclass="math inline">\(x(v) \in {0, 1}\)</span>,且 <spanclass="math inline">\(x(v)=0\)</span>，表示顶点 <spanclass="math inline">\(v\)</span>不在点覆盖集合里。</p><p>对图中任意一条边 <span class="math inline">\((u,v) \inE\)</span>,由点覆盖定义，顶点<spanclass="math inline">\(u\)</span>、顶点<spanclass="math inline">\(v\)</span> 至少有一个必须在点覆盖中 ，因此：<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>.</p><p>因而得到最小权值点覆盖的规划模型：其中<spanclass="math inline">\(w(v)\)</span> 表示顶点<spanclass="math inline">\(v\)</span>的权值。</p><p><img src="/img/近似算法/整数规划.png" /></p><h3 id="线性规划">线性规划</h3><p>线性规划在整数规划的基础之上不再限定<spanclass="math inline">\(x(v)\)</span>只为0或1，而是有一个范围 <spanclass="math inline">\(x(v) \in [0, 1]\)</span> 这样在整数规划中的<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>仍然成立.这是可以的。因为：前者是后者的一个特例。前者称为0-1整数规划，后者为普通的线性规划。因此，线性规划中的最优解是0-1整数规划最优解的一个下界（因为线性规划最优解包含了0-1整数规划最优解）。</p><p><img src="/img/近似算法/点覆盖-LP规划.png" /></p><p><strong>用线性规划的解来构造最小权值点覆盖问题的近似解算法</strong>:</p><p>对于每一个顶点<spanclass="math inline">\(v\)</span>，都会求得一个<spanclass="math inline">\(x(v)\)</span>的值。若，<spanclass="math inline">\(x(v) \ge 1/2\)</span>,则将该顶点加入到点覆盖集合中，否则舍去顶点<spanclass="math inline">\(v\)</span>，直至图G中所有的顶点都处理完毕。此时得到的顶点集合<spanclass="math inline">\(C\)</span>即为最小权值点覆盖问题的近似解的点覆盖集合。</p><p><strong>线性规划求得的顶点集合C是最小权值点覆盖问题的二倍近似解</strong>:</p><p>设 <span class="math inline">\(C^*\)</span>是最小权值点覆盖问题的一个最优解，<span class="math inline">\(Z\)</span>是线性规划的一个最优解， <spanclass="math inline">\(C\)</span>是最小权值点覆盖问题的近似解.</p><ol type="1"><li>由于最小权值点覆盖问题的一个最优解是线性规划的一个可行解，故：<spanclass="math inline">\(Z \le W(C^*)\)</span>(<spanclass="math inline">\(W\)</span>为求权值的函数)</li><li>为什么求得的集合<spanclass="math inline">\(C\)</span>就是一个点覆盖呢？因为对任意边<spanclass="math inline">\((u,v) \in E\)</span>,有<spanclass="math inline">\(x(u)+x(v)\ge 1\)</span>，即在<spanclass="math inline">\(x(u)\)</span>和<spanclass="math inline">\(x(v)\)</span>中至少有一个的值大于1/2。因此，顶点<spanclass="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>至少有一个会被加入到集合<spanclass="math inline">\(C\)</span>中，从而使得图<spanclass="math inline">\(G\)</span>中的每一条边都会被覆盖。</li><li>由下式</li></ol><p><img src="/img/近似算法/证明线性规划是2倍近似解.png" /></p><p>以及<span class="math inline">\(Z \le W(C^*)\)</span>,知:<spanclass="math inline">\(W(C) \le 2Z &lt;=2W(C^*)\)</span>,即近似解<spanclass="math inline">\(C\)</span>的权值<span class="math inline">\(W(C)\le\)</span> 二倍最优解<spanclass="math inline">\(C^*\)</span>的权值.</p><p>那么是否有比2倍近似解更小的近似解?最小的近似解倍率是多少?</p><p>答:有.</p><p><strong>定理</strong>: 若 P <span class="math inline">\(\ne\)</span>NP,那么没有比<span class="math inline">\(\rho = 1.3607(10\sqrt{5} -21)\)</span>更小的<span class="math inline">\(\rho\)</span>-近似解.</p><h2id="多项式时间逼近算法polynomial-time-approximation-scheme">多项式时间逼近算法(PolynomialTime Approximation Scheme)</h2><p>上面的<spanclass="math inline">\(\rho\)</span>-近似算法是通过牺牲最优解来换取时间和例子,多项式时间逼近算法可以产生任意高质量的解决方案，但以精度换取时间。</p><p>以背包问题为例:物品<spanclass="math inline">\(i\)</span>的价值为<spanclass="math inline">\(v_i\)</span> ,重量为<spanclass="math inline">\(w_i\)</span>;背包最多可以拿的物品重量为<spanclass="math inline">\(W\)</span>.现在求最大可以拿取的物品价值。</p><p><img src="/img/近似算法/背包问题-例子.png" /></p><h3 id="方法1动态规划-1">方法1：动态规划-1</h3><p>定义<spanclass="math inline">\(OPT(i,w)=\)</span>所有物品中可以拿到的<strong>最大价值</strong>。</p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>新的容量为<span class="math inline">\(w-w_i\)</span></li><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w-w_i\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划1.png" /></p><p>运行时间：<span class="math inline">\(O(n W)\)</span></p><ul><li><span class="math inline">\(W=\)</span>重量限制</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="方法2动态规划2">方法2：动态规划2</h3><p>定义<span class="math inline">\(OPT(i,v)=\)</span>物品<spanclass="math inline">\(1,2,\dots,i\)</span>中拿取且得到的物品价值为<spanclass="math inline">\(v\)</span>所消耗的<strong>最小重量</strong></p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>消耗重量<span class="math inline">\(w_i\)</span>,且新的价值为<spanclass="math inline">\(v-v_i\)</span></li><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划2.png" /></p><p>运行时间：<span class="math inline">\(O(n V^*)=O(n^2v_{max})\)</span></p><ul><li><span class="math inline">\(V^*\)</span>为在<spanclass="math inline">\(OPT(n, v) \leW\)</span>的情况下可以选取的最大价值</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="多项式时间逼近算法">多项式时间逼近算法</h3><p>以上的动态规划都可以得到最优解，但是考虑一个问题：若所有物品的价值远大于重量的时候，上面的动态规划还可行吗？</p><p>这时候问题的输入不是多项式的（物品的价值，因为在计算机内数据都要转化为2进制再处理），这时候为了使求解时间更快，引入了新的算法<strong>多项式时间逼近算法（PolynomialTime Approximation Scheme）</strong>。它的大致思想是：</p><ul><li>将所有的价值向上舍入到一个较小的范围里</li><li>在向上舍入后的实力上运行动态规划算法</li><li>得到向上舍入实例的最优解</li></ul><p>注：这里一定要是向上舍入而不能是四舍五入，虽然全部向上舍入可能会在原来的问题中丢失一些较为优质的解，但是若四舍五入的时候，若有向下舍去的价值，可能在新的实例中找到的解在原问题中是不可行解。</p><p><img src="/img/近似算法/背包问题-四舍五入.png" /></p><p>首先对所有价值向上舍入：</p><p><img src="/img/近似算法/向上舍入.png" /></p><ul><li><spanclass="math inline">\(v_{max}\)</span>为原始例子里的最大价值</li><li><span class="math inline">\(\varepsilon\)</span>为精确参数</li><li><span class="math inline">\(\theta\)</span>为放缩因子</li></ul><p>对于放缩之后的例子，复杂度<span class="math inline">\(O(n^3 /\varepsilon)\)</span>,使用上面的动态规划-2方法的运行时间为<spanclass="math inline">\(0(n^2 \hat{v}_{max})\)</span>.</p><p>其中</p><p><img src="/img/近似算法/公式1.png" /></p><p><strong>定理</strong>：若<spanclass="math inline">\(S\)</span>为多项式时间逼近算法找到的一个解，同时<spanclass="math inline">\(S^*\)</span>为另一个可行解，那么有 <spanclass="math inline">\((1+\varepsilon) \sum\limits_{i \in S}v_i \ge\sum\limits_{i \in S^*}v_i\)</span></p><p>证明：</p><p><img src="/img/近似算法/多项式时间逼近算法-证明.png" /></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NP问题以及常见多项式规约</title>
    <link href="/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="pnpnpcnph问题">P、NP、NPC、NPH问题</h2><p><strong>P问题</strong>：存在多项式时间算法的决策问题。</p><p><strong>NP问题</strong>：能在多项式时间内验证某个猜想答案的正确性，但问题求解可能在无法在多项式时间内完成。比如Composite问题、3-Satisfiability、HamiltonianCycle，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。</p><p><strong>结论1</strong>：P <spanclass="math inline">\(\subseteq\)</span> NP</p><p><strong>结论2</strong>：NP <spanclass="math inline">\(\subseteq\)</span> EXP</p><p><strong>EXP问题</strong>：存在指数时间算法的决策问题。</p><p><strong>NPC问题</strong>: 需要满足两个条件</p><ul><li>它是一个NP问题</li><li>所有的NP问题都可以规约到NP-complete</li></ul><p><strong>定理</strong>：若Y是一个NPC问题，那么Y可以在多项式时间内求解<strong>当且仅当</strong>P<spanclass="math inline">\(=\)</span>NP</p><p>证明：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若P <span class="math inline">\(=\)</span>NP，那么Y可以在多项式时间求解，因为Y是NP（NPC的第一个条件：它要先是一个NP）</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若Y可以在多项式时间求解： - 令X为任意一个NP问题，因为X <spanclass="math inline">\(\le_p\)</span>Y，而Y可以在多项式时间求解，故X也可以在多项式时间求解。NP <spanclass="math inline">\(\subseteq\)</span> P - 又已知P <spanclass="math inline">\(\subseteq\)</span> NP,所以 P <spanclass="math inline">\(=\)</span> NP</p><p><strong>如果</strong>我们给NPC问题找到了一个多项式时间复杂度的算法，那么也就意味着我们给所有的NP问题找到了多项式时间复杂度的算法，从而NP=P，因为P=NP，所以“P对NP问题”就可以被解决。但给NPC问题找一个多项式时间复杂度的算法太难了，所以现在人们普遍相信P≠NP。</p><p><strong>NPH问题</strong>：满足上面NPC问题的第二个条件，但不一定要满足第一个条件，所以NPH的范围比HPC更大。</p><h3 id="证明一个问题是npc问题的步骤">证明一个问题是NPC问题的步骤</h3><ul><li>证明这个问题Y属于NP</li><li>选择一个NPC问题X</li><li>证明X可以多项式规约到Y</li></ul><h3 id="证明一个问题是nph问题的步骤">证明一个问题是NPH问题的步骤</h3><p>要证明一个问题是NP-hard，通常是找到一个已被证明了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC<span class="math inline">\(\le\)</span> NP-hard）,简单来说就是：</p><ul><li>对问题A给定限制条件得到一个特例B问题</li><li>证明问题B是NPC问题</li></ul><h2 id="npc之间规约的例子">NPC之间规约的例子</h2><h3 id="sat-le_p-independent-set">3-SAT <spanclass="math inline">\(\le_p\)</span> Independent Set</h3><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造:</p><ul><li>3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点</li><li>连接句子里的点连接形成三角形</li><li>连接不同Clause里每个Literal和它对应的非</li></ul><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h3 id="hamiltonian-cycle-problem">Hamiltonian Cycle problem</h3><p><strong>Hamiltonian Cycle</strong>:给定一个无向图 <spanclass="math inline">\(G=(V,E)\)</span>，是否存在一个简单的环 <spanclass="math inline">\(\Gamma\)</span> 包含 <spanclass="math inline">\(V\)</span> 中所有的点。</p><figure><img src="/img/多项式规约/HamiltonianCycle定义.png"alt="有奇数个节点的Hamiltonian Cycle" /><figcaption aria-hidden="true">有奇数个节点的HamiltonianCycle</figcaption></figure><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p><strong>DIR-HAM-CYCL <span class="math inline">\(\le_p\)</span>Ham-Cycle</strong>: 证明：给定一个有向图<spanclass="math inline">\(G=(V,E)\)</span>,构造一个有<spanclass="math inline">\(3n\)</span>个节点的无向图<spanclass="math inline">\(G&#39;\)</span>，则<spanclass="math inline">\(G\)</span>有Hamiltonian Cycle当且仅当<spanclass="math inline">\(G&#39;\)</span>有Hamiltonian Cycle。</p><p><img src="/img/多项式规约/DIR-HAM-CYC2Ham-Cycle.png" /></p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若<span class="math inline">\(G\)</span>中有一个有向的HamiltonianCycle，则<spanclass="math inline">\(G&#39;\)</span>中肯定也有一个HamiltonianCycle，且顺序与有向图的节点顺序相同。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若<spanclass="math inline">\(G&#39;\)</span>中有一个无向的HamiltonianCycle，则从蓝色节点出发，节点的颜色出现顺序必然是两种中的一种 -B,G,R,B,G,R,<span class="math inline">\(\dots\)</span> -B,R,G,B,R,G,<span class="math inline">\(\dots\)</span></p><p>若<span class="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第一种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相同；若<spanclass="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第二种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相反。</p><h3 id="sat-le_p-hamiltonian-cycle-problem">3SAT <spanclass="math inline">\(\le_p\)</span> Hamiltonian Cycle problem</h3><!-- **Vertex Cover**：一组顶点的集合，使得图的每条边至少与集合中的一个顶点相连接。在这里Vertex Cover问题是给定图$G$和点集的个数$k$，要找到图$G$的一个大小为$k$的点覆盖。（也就是常说的最小点覆盖） --><p><strong>构造思路:有<spanclass="math inline">\(n\)</span>个变量的3-SAT有<spanclass="math inline">\(2^n\)</span>种可能的分配，要将其规约到HamiltonianCycle，其对应的Hamiltonian Cycle应该也有<spanclass="math inline">\(2^n\)</span>种可能的分配方式。</strong></p><p>构造方法：对一个有<span class="math inline">\(n\)</span>个变量和<spanclass="math inline">\(k\)</span>个句子的3-SAT,构造<spanclass="math inline">\(3k+3\)</span>个节点的HamiltonianCycle，其中每个变量<span class="math inline">\(x_i\)</span>对应<spanclass="math inline">\(3k+3\)</span>个节点，令外再增加一个源点<spanclass="math inline">\(s\)</span>、一个汇点<spanclass="math inline">\(t\)</span>。</p><p><img src="/img/多项式规约/3-SAT2Ham-Cycle构造.png" /></p><p>如果 <spanclass="math inline">\(x_i=1\)</span>，则形成从左向右的一个路径；如果<spanclass="math inline">\(x_i=0\)</span>，则形成从右向左的一个路径。</p><p>对于每一个clause <span class="math inline">\(c_j=z_1 z_2z_3\)</span>，若<span class="math inline">\(z=x_i\)</span>,则添加有向边<spanclass="math inline">\((v_{i,3j},c_j)和(c_j,v_{i,3j+1})\)</span>;若<spanclass="math inline">\(z=\bar{x}_i\)</span>,则添加有向边<spanclass="math inline">\((c_j,v_{i,3j})和(v_{i,3j+1},c_j)\)</span>，这里<spanclass="math inline">\(1\le j\le m, 1\le i\len\)</span>。如上图所示（即若<spanclass="math inline">\(z=x_i\)</span>,该节点与<spanclass="math inline">\(c\)</span>节点的连接顺序是从左边进入<spanclass="math inline">\(c\)</span>节点，然后从右边出<spanclass="math inline">\(c\)</span>节点；反之顺序相反）。</p><p>如果选择子句<span class="math inline">\(C_1\)</span>中<spanclass="math inline">\(x_1=1\)</span>,则<spanclass="math inline">\(x_1\)</span>对应的路径为从左向右;同理<spanclass="math inline">\(x_2=0\)</span>,则<spanclass="math inline">\(x_2\)</span>对应的路径为从右向左；<spanclass="math inline">\(x_3=1\)</span>,则<spanclass="math inline">\(x_3\)</span>对应的路径为从左向右。其余句子同理，这样就得到了最终的图<spanclass="math inline">\(G\)</span>。</p><p><strong>证明</strong>:</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>假设3-SAT有一个可满足的分配<spanclass="math inline">\(x^*\)</span>：</p><ul><li>对于<span class="math inline">\(x_i\)</span>,若其为1，则第<spanclass="math inline">\(i\)</span>行从左往右遍历；反之，若其为0，则第<spanclass="math inline">\(i\)</span>行从右往左遍历</li><li>且对于每个句子节点<spanclass="math inline">\(c_i\)</span>，至少会有一行便利的时候会经过<spanclass="math inline">\(c_i\)</span>，否则便不满足每个句子都为真的条件，也就是该分配并不是可满足的。</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>假设构造的图<spanclass="math inline">\(G\)</span>有一个Ham-Cycle，那么</p><ul><li>若Ham-Cycle进入句子节点<spanclass="math inline">\(c_i\)</span>，那么它一定会返回相同的行，否则便不存在简单环。</li><li>这样Ham-Cycle里的句子节点<spanclass="math inline">\(c_i\)</span>与同一行的两个相邻节点相连，记这两个相邻节点之间的边为<spanclass="math inline">\(e_i\)</span></li><li>去掉句子节点<span class="math inline">\(c_i\)</span>，同时用<spanclass="math inline">\(e_i\)</span>替换与<spanclass="math inline">\(c_i\)</span>相连的两条边。</li><li>按上面的方法去掉所有的句子节点得到图也必然存在Ham-Cycle，且节点的顺序是相同的。</li><li>若Ham-Cycle的第<spanclass="math inline">\(i\)</span>行是从左往右遍历的，便令<spanclass="math inline">\(x_i=1\)</span>;反之则令<spanclass="math inline">\(x_i=0\)</span>，这样便得到一个分配方案，且其是可满足的。</li></ul><p>这样便得到一个分配方式，且每个句子都是可满足的。</p><h3 id="ham-cycle-le_p-tsptraveling-saleperson-problem">HAM-CYCLE <spanclass="math inline">\(\le_p\)</span> TSP(Traveling SalepersonProblem)</h3><p><strong>TSP(Traveling Saleperson Problem)</strong>：给定一个<spanclass="math inline">\(n\)</span>个城市的集合以及城市之间的距离<spanclass="math inline">\(d(u,v)\)</span>,是否存在一个旅行的路线使行走的距离<spanclass="math inline">\(\le n\)</span>?</p><p>旅行者问题与HAM-CYCLE的区别在于：旅行者问题并不限定简单路径，也就是说一个节点可以通过多次，只需要考虑最后的路径长度。</p><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p>$HAM-CYCLE <span class="math inline">\(\le_p\)</span> TSP(TravelingSaleperson Problem)$</p><p><strong>构造</strong>：给定一个HAM-CYCLE的实例<spanclass="math inline">\(G=(V,E)\)</span>,<spanclass="math inline">\(V\)</span>中的每个节点构造一个城市节点，城市之间的距离根据<spanclass="math inline">\(E\)</span>进行赋值: <spanclass="math display">\[d(u,v)= \begin{cases}    1, (u,v) \in E  \\    2, (u,v) \notin E\end{cases}\]</span></p><p>则TSP中有一个旅行路径<span class="math inline">\(\len\)</span>当且仅当<spanclass="math inline">\(G\)</span>中存在HAM-CYCLE</p><h3 id="sat-le_p-3-colorable">3-SAT <spanclass="math inline">\(\le_p\)</span> 3-Colorable</h3><p><strong>3-Colorable</strong>:给定一个无向图<spanclass="math inline">\(G\)</span>，并给图中的每个节点染上红、蓝、绿的其中一种颜色，那么是否存在一种染色方式使相邻的节点都有不同的颜色？</p><p>3-SAT <span class="math inline">\(\le_p\)</span> 3-Colorable</p><p><strong>构造</strong>：</p><ul><li>对每个Literal，构造一个节点</li><li>同时添加三个节点<spanclass="math inline">\(T、F、B\)</span>，连接这三个节点形成一个三角形</li><li>对每个literal节点，创建一个它的"非"并与它相连</li><li>所有的Literal节点都与<span class="math inline">\(B\)</span>相连</li></ul><p>如下图所示： <imgsrc="/img/多项式规约/3-SAT23-COLOLABLE-1.png" /></p><p>这样构造保证了下面的每个Literal节点都是绿色或红色，且它的“非”与它的颜色刚好相反。</p><p>继续接上面：</p><ul><li>对每个Clause，假设<span class="math inline">\(C_i=x_1 \vee\overline{x_2} \vee x_3\)</span>,则对<span class="math inline">\(x_1 ,\overline{x_2} , x_3\)</span>添加6个节点以及13条边</li></ul><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-2.png" /></p><p>即<span class="math inline">\(x_1 , \overline{x_2} ,x_3\)</span>下方的两行一共6个节点，并将左下角的节点、第一行的节点与之前构造的<spanclass="math inline">\(T\)</span>节点相连，右下角的节点与之前的<spanclass="math inline">\(F\)</span>节点相连。</p><p>这样构造是为了保证当三个Literal节点全为红色的时候，是不满足三着色的，如下图所示：当三个Literal节点全为红色的时候，他们下面那行节点必须为蓝色，这样最后一行从左到右着色，最后一个节点冲突。</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-3.png" /></p><p><strong>3-SAT <span class="math inline">\(\le_p\)</span>3-Colorable</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若图3-Colorable：</p><ul><li>将所有为绿色的Literal节点设为真</li><li>由上面可知，当图3-Colorable的时候三个Literal节点至少有一个是绿色的，那么该句子的输出为真</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>若3-SAT是可满足的：则 - 三个Literal节点至少有一个为真 -将为真的Literal节点染为绿色，然后将该节点下面的节点染为红色（否则会冲突），再继续将下面的节点染为蓝色-对中间一行没有染红的节点染为蓝色，然后它们下面一行没有染色的节点可唯一确定颜色</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-4.png" /></p><p>上面没有染色的Literal节点绿色、红色皆可。</p><h3 id="color搜索问题-le_p-3-color判断问题自规约">3-COLOR搜索问题 <spanclass="math inline">\(\le_p\)</span> 3-COLOR判断问题（自规约）</h3><p><strong>方法1</strong>：</p><p>将3-COLOR图中不相邻的点合并，合并后的点表示之前所有合并过来点的集合，如下图所示：</p><p><img src="/img/多项式规约/3-color自规约.png" /></p><p>然后一直重复上述步骤，若图可以进行3着色，那么到最后图必然会合并为一个三角形。染色是对最后的三角形三个点所代表的点的集合染成不同的颜色，便为最后的3着色。</p><p><strong>方法2</strong>：</p><p>设判定算法为<span class="math inline">\(D\)</span></p><ol type="1"><li>调用算法<spanclass="math inline">\(D\)</span>判断原图是否有解，若无解，则返回NO。</li><li>任意选择一对边<span class="math inline">\((u,v)\)</span>，满足<spanclass="math inline">\((u,v) \notin E\)</span><ol type="1"><li>考虑图<span class="math inline">\(G&#39; = G +(u,v)\)</span>，调用<spanclass="math inline">\(D\)</span>判断是否有解。</li><li>若<span class="math inline">\(G&#39;\)</span>无解，标记点对<spanclass="math inline">\((u,v)\)</span>；若有解，添加边<spanclass="math inline">\((u,v)\)</span>到<spanclass="math inline">\(G\)</span>中。</li></ol></li><li>返回步骤2，继续选择一对未标记点对。</li><li>若图<spanclass="math inline">\(G\)</span>构成一个三部完全图，每一部选择一个颜色，输出颜色方案。### 点覆盖搜索问题 <span class="math inline">\(\le_p\)</span>点覆盖判断问题</li></ol><ul><li>从1开始，依次查找该图有没有<spanclass="math inline">\(k^*\)</span>个顶点的顶点覆盖(这样得到的第一次满足的<spanclass="math inline">\(k^*\)</span> 的值就是该图最小顶点覆盖的数目)</li><li>从图中选出一个点<span class="math inline">\(v\)</span>，若去除该点后图的顶点覆盖数目变为<span class="math inline">\(k^* −1\)</span>，则<spanclass="math inline">\(v\)</span>是原图顶点覆盖中的一员，反之则不是</li><li>在<span class="math inline">\(G −v\)</span>中递归执行上述两步。</li></ul><h3 id="ham-cycle搜索问题-le_p-ham-cycle判断问题">Ham-Cycle搜索问题<span class="math inline">\(\le_p\)</span> Ham-Cycle判断问题</h3><p>证明：若可以在多项式时间内给出判定一个图是否存在哈密尔顿圈，则可以在多项式时间内找到一个图的哈密尔顿圈（如果存在的话）</p><p>首先判断<spanclass="math inline">\(G\)</span>中是否存在Ham-Cycle,若不存在则算法结束，如果存在则继续寻找Ham-Cycle:<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">对G中的每条边e<br>&#123;<br>    若G-e不存在Ham-<span class="hljs-keyword">Cycle</span>，将e加入S中；<br>    否则令G=G-e<br>&#125;<br>最后所得的集合便是一个Ham-<span class="hljs-keyword">Cycle</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式规约</title>
    <link href="/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="多项式规约">多项式规约</h2><p>定义：若问题X 的任意实例可以由下面两条之和解决</p><ul><li>问题X可以通过多项式时间的基本运算步骤转换为问题Y；</li><li>问题X多项式次调用求解问题Y的算法，且问题Y可以在多项式时间内被求解。</li></ul><p>那么称问题X可以多项式规约到问题Y，记为 $ X _{p} Y$。需要注意的是，问题X转换为问题Y之后，问题Y的运行时间是建立在问题Y的输入上。</p><p>多项式规约的几个性质：</p><ul><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若Y能在多项式时间内求解，那么X也能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若X不能在多项式时间内求解，那么Y也不能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p} Y\)</span> 且 <spanclass="math inline">\(Y \le_{p} X\)</span>，那么X和Y是等价的。</li></ul><h3 id="基本的规约方法">基本的规约方法</h3><ul><li>简单的恒等归约：比如最大独立集和最小点覆盖。</li><li>从特殊例子到一般例子：比如 <span class="math inline">\(点覆盖\le_{p} 集合覆盖\)</span>。<br /></li><li>通过一些小技巧规约。比如 <span class="math inline">\(3-SAT \le_{p}独立集\)</span></li></ul><h3 id="简单的恒等规约">简单的恒等规约</h3><h4 id="独立集问题independent-set">独立集问题（Independent Set）</h4><p><strong>定义</strong>：给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k(V为顶点集，E为边集)，是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \gek\)</span>并且图中每条边至多有一个顶点在S中？</p><figure><img src="/img/多项式规约/独立集.png" alt="独立集" /><figcaption aria-hidden="true">独立集</figcaption></figure><h4 id="点覆盖问题vertex-cover">点覆盖问题（Vertex Cover）</h4><p><strong>定义</strong>:给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k,是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \lek\)</span>并且图中的每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中？</p><figure><img src="/img/多项式规约/点覆盖.png" alt="点覆盖" /><figcaption aria-hidden="true">点覆盖</figcaption></figure><h4 id="vertex-cover和independent-set的关系">Vertex Cover和IndependentSet的关系</h4><p><strong>定理： <span class="math inline">\(点覆盖 \equiv_p独立集\)</span></strong></p><p>证明如下：</p><p><span class="math inline">\(\Rightarrow\)</span></p><ul><li>令<span class="math inline">\(S\)</span>为任意独立集</li><li>对任意的边 <span class="math inline">\((u,v)\)</span></li><li><span class="math inline">\(S\)</span>是独立集 <spanclass="math inline">\(\Rightarrow\)</span> <span class="math inline">\(u\notin S\)</span> 或 <span class="math inline">\(v \notin S \Rightarrowu \in V - S\)</span> 或 <span class="math inline">\(v \in V -S\)</span></li><li>所以 <span class="math inline">\(V-S\)</span> 是一个点覆盖</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><ul><li>令 <span class="math inline">\(V-S\)</span>是一个点覆盖</li><li>对两个顶点 <span class="math inline">\(u \in S\)</span> 及 <spanclass="math inline">\(v \in S\)</span></li><li>若 <span class="math inline">\(V-S\)</span> 是一个点覆盖,那么 <spanclass="math inline">\((u, v) \notin E\)</span></li><li>因此，没有相邻的顶点在 <span class="math inline">\(S\)</span> 中<span class="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(S\)</span>是独立集</li></ul><h3 id="从特殊例子到一般例子">从特殊例子到一般例子</h3><h4 id="集合覆盖set-cover">集合覆盖（Set Cover）</h4><p><strong>定义</strong>：给定一个集合<spanclass="math inline">\(U\)</span>，以及<spanclass="math inline">\(U\)</span>的子集<spanclass="math inline">\(S_1,S_2,\dots,S_m\)</span>以及一个整数<spanclass="math inline">\(k\)</span>，是否存在小于或等于<spanclass="math inline">\(k\)</span>个子集<spanclass="math inline">\(S_i\)</span>的并等于<spanclass="math inline">\(U\)</span>?</p><p><strong>例子</strong>:</p><figure><img src="/img/多项式规约/集合覆盖例子.png" alt="几何覆盖例子" /><figcaption aria-hidden="true">几何覆盖例子</figcaption></figure><h4 id="vertex-cover归约到set-cover">Vertex Cover归约到Set Cover</h4><p><strong>证明：给定一个Vertex-Cover的实例<spanclass="math inline">\(G=(V,E),k\)</span>,可以构造一个与VertexCover大小相等的Set Cover的实例。（从特殊例子到一般例子）</strong></p><ul><li>创建一个Set Cover的实例<span class="math inline">\(k = k,U=E,S_v=\{e\in E: 与V相连的边\}\)</span></li><li>可以看到Set Cover的<span class="math inline">\(size \lek\)</span>当且仅当Vertex Cover的<span class="math inline">\(size \lek\)</span></li></ul><p><strong>例子</strong>：有如下点覆盖</p><p><img src="/img/多项式规约/VertexCover归约到SetCover例子.png" /></p><p>构造Set Cover的<span class="math inline">\(U\)</span>为VertexCover的边集，即<span class="math inline">\(U=(1,2,3,4,5,6)\)</span>，SetCover的每个子集<span class="math inline">\(S_i\)</span>为VertexCover中对应顶点所连的边,故有 <span class="math display">\[    S_a=\{3,7\}， \\    S_b=\{2,4\}， \\    S_c=\{3,4,5,6\}， \\    S_d=\{5\}，  \\    S_e=\{1\}， \\    S_f=\{1,2,6,7\}    \]</span></p><p>可以看到<span class="math inline">\(S_c\)</span>和<spanclass="math inline">\(S_f\)</span>构成一个SetCover的实例，而这两个子集对应的顶点恰好组成一个Vertex Cover的实例。</p><h3 id="通过小技巧规约">通过"小技巧"规约</h3><h4 id="sat问题">3-SAT问题</h4><p><strong>Literal（字）</strong>：一个布尔变量或者它的非<spanclass="math inline">\(x_i \quad or \quad \overline{x_i}\)</span></p><p><strong>Clause（句子）</strong>：Literal的析取 <spanclass="math inline">\(C_j = x_1 \vee \overline{x_2} \veex_3\)</span></p><p><strong>Formula（式子）</strong>：Clause的合取 <spanclass="math inline">\(\Phi=C_1 \wedge C_2 \wedge C_3 \wedgeC_4\)</span></p><p><strong>SAT</strong>:给定CNF式子<spanclass="math inline">\(\Phi\)</span>，是否存在一个满足结果是True的分配<spanclass="math inline">\(x_1,\dots,x_n\)</span>？若有则称式子<spanclass="math inline">\(\Phi\)</span>是<strong>可满足</strong>的。</p><p><strong>3-SAT</strong>:每个Clause只有三个Literals。</p><p><strong>例子</strong>：</p><p><img src="/img/多项式规约/3-SAT例子.png" /></p><h4id="satisfiability3-sat归约到independent-set">3-Satisfiability（3-SAT）归约到IndependentSet</h4><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造: -3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点 -连接句子里的点连接形成三角形 -连接不同Clause里每个Literal和它对应的非</p><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h2 id="自规约重要">自规约（重要）</h2><p><strong>决策问题（Decision Problem）</strong>：诸如"是否存在一个<spanclass="math inline">\(size \ge k\)</span>的点覆盖"</p><p><strong>求解问题（SearchProblem）</strong>：诸如"寻找一个最小的点覆盖"</p><p><strong>自规约（Self-Reducibility）</strong>：Search Problem <spanclass="math inline">\(\le_p\)</span> Decision Problem</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大流最小割</title>
    <link href="/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <url>/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小割">最小割</h2><p>在图论中，去掉其中所有边能使一张网络流图不再连通（即分成两个子图）的边集称为图的割。一个$st-cut $即去掉的边把源点s和汇点t划分在两个不同的部分。</p><figure><img src="/img/最大流最小割/最小割定义.png" alt="最小割定义" /><figcaption aria-hidden="true">最小割定义</figcaption></figure><p>一般来说，一张图中有多个不同的<spanclass="math inline">\(st-cut\)</span>，如下图便为其中一个 <spanclass="math inline">\(st-cut\)</span> 。</p><figure><img src="/img/最大流最小割/一个割例子.png" alt="一个割例子" /><figcaption aria-hidden="true">一个割例子</figcaption></figure><p>但是在实际应用中，我们去掉每条边往往都是有代价的，以边的容量作为权值，一个割中去掉的边的权值之和为这个割的值，那么最小割就是这张图上最小的割。</p><h2 id="最大流">最大流</h2><p>为了求解最小割，需要引入最大流的概念。用边的权值表示边的最大流量，一个<span class="math inline">\(st-flow\)</span>是从源点s到汇点t的流量。通俗的讲，最大流就是从源点s到汇点t的最大流量。</p><figure><img src="/img/最大流最小割/最大流.png" alt="最大流" /><figcaption aria-hidden="true">最大流</figcaption></figure><h2 id="求解最大流">求解最大流</h2><h3 id="贪心算法">贪心算法</h3><ul><li>开始时对每条边e令<span class="math inline">\(f(e)=0\)</span></li><li>找到一条从源点s到汇点t的路径 <span class="math inline">\(s\rightarrow t\)</span> 使路径上的每条边e满足 <spanclass="math inline">\(f(e)&lt;c(e)\)</span> ,其中 <spanclass="math inline">\(c(e)\)</span> 为边e的权值</li><li><span class="math inline">\(flow = flow + 路径上的流量\)</span></li><li>重复上述步骤直至找不到新的路径</li></ul><h3 id="ford-fulkerson算法">Ford-Fulkerson算法</h3><h4 id="残留图residual-graph">残留图(Residual Graph)</h4><p>在另一个图中，额外构造一个反向边，权值是实际流过该边的流量 <spanclass="math inline">\(f(e)\)</span> 。</p><figure><img src="/img/最大流最小割/残余图.png" alt="残余图" /><figcaption aria-hidden="true">残余图</figcaption></figure><p>剩余图有以下性质： - <strong>增广路径(AugmentingPath)</strong>:一个增广路径P是从残余图中的一条简单路径 <spanclass="math inline">\(s \rightarrow t\)</span> -增广路径的容量是该条路径所有边中的最小权值</p><h4 id="算法说明">算法说明</h4><ul><li>每次找到一条从s到t的增广路径，并调整flow和残留图，不断调整直到没有增广路径</li><li>当残留图中不存在从s到t的增广路径时，该图已经达到最大流</li></ul><h4 id="例子">例子</h4><p>初始时没有反向边,此时残留图等于原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子1.png" /></p><p>从中选取一条增广路径,并更新残留图和原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子2.png" /></p><p>重复上面的步骤,注意<strong>增广路径一定要从残留图中找</strong>,且可以使用残留图中的反向边.</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子3.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子4.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子5.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子6.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>此时,没有新的增广路径,则最大流的值等于流进s的流量,即 <spanclass="math inline">\(flow = s_{in}\)</span></p><h2 id="最大流与最小割的关系">最大流与最小割的关系</h2><p><strong>最大流最小割定理：最大流=最小割。</strong>最大流-最小割定理用来证明Ford-Fulkson方法的确达到了最大流.</p><figure><img src="/img/最大流最小割/最大流最小割定理.png"alt="最大流最小割定理" /><figcaption aria-hidden="true">最大流最小割定理</figcaption></figure><p>证明:</p><ul><li><span class="math inline">\((i) \Rightarrow (ii)\)</span>:弱对偶性法则的推论</li><li><span class="math inline">\((ii) \Rightarrow (iii)\)</span>:反证法<br />若f是一个最大流,且仍存在增广路径,那么可以让f加上增广路径的流量,与f是一个最大流相悖.故<spanclass="math inline">\((ii) \Rightarrow (iii)\)</span>成立</li><li><span class="math inline">\((iii) \Rightarrow (i)\)</span></li></ul><p>设f是一个流,且没有增广路径,令A等于s的可达顶点集,则</p><p><img src="/img/最大流最小割/iii到i.png" /></p><h2 id="求出最大流之后如何求最小割">求出最大流之后如何求最小割</h2><p>求完最大流之后，在残留图中用BFS遍历，结束后可得到一个从<spanclass="math inline">\(s\)</span>出发可达的集合，将原图分为两个子集合，<spanclass="math inline">\(s\)</span>可达的集合<spanclass="math inline">\(X\)</span>以及<spanclass="math inline">\(s\)</span>不可达的集合<spanclass="math inline">\(Y\)</span>,其中<spanclass="math inline">\(Y\)</span>中必然包含汇点<spanclass="math inline">\(t\)</span>。</p><p>连接两个集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的边有两种情况</p><ul><li>已被占满的前向边</li><li>没有流量的反向边(即从<span class="math inline">\(Y\)</span>到<spanclass="math inline">\(X\)</span>的边)</li></ul><p>其中被占满的前向边集合就是所求的最小割</p><p>还是用上面的例子 <imgsrc="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>在<span class="math inline">\(G_f\)</span>中,用BFS遍历可得<spanclass="math inline">\(s\)</span>可达的顶点集合为<spanclass="math inline">\(\{s, 3\}\)</span>，在<spanclass="math inline">\(G\)</span>中查看<span class="math inline">\(\{s,3\}\)</span>与图中剩余顶点集合的关系。</p><ul><li>已被占满的前向边:<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span></li><li>没有流量的反向边:<span class="math inline">\(2 \rightarrow3\)</span></li></ul><p>所以图中的一个最小割为<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git撤销commit命令">Git撤销commit命令</h2><p>当要撤销的提交不是最开始的提交时 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD~<br></code></pre></td></tr></table></figure>当要撤销的提交时最开始的提交时 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">update</span> <span class="hljs-operator">-</span><span class="hljs-keyword">ref</span> <span class="hljs-operator">-</span>d HEAD<br></code></pre></td></tr></table></figure> ## Git连接远程仓库<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>url<br></code></pre></td></tr></table></figure> 注：url为github仓库链接 ## Git删除已经add的文件1.要删除的文件少时 一种是 <code>git rm --cached</code>"文件路径"，不删除物理文件，仅将该文件从缓存中删除； 一种是<code>git rm --f</code>"文件路径"，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。</p><p>2.要删除的文件多时 <code>git rm -r --cached</code> . 清空缓存区然后将本地文件删除，再次<code>add</code></p><h2 id="git创建远程新分支">Git创建远程新分支</h2><p>git无法直接通过命令方式创建远程新分支，需要间接来创建,这里我创建的远程新分支名叫vedio</p><p>首先</p><p><code>git checkout --orphan 分支名</code> <imgsrc="https://img-blog.csdnimg.cn/20210403164118752.png" /> <strong>gitrm -rf .</strong> （这一步很关键）然后创建一个文件readme.md（其实任何文件都可以），add并commit，然后</p><p><code>git push origin 分支名</code></p><p>就可以啦~如下图红框圈注的命令 <imgsrc="https://img-blog.csdnimg.cn/20210403164816128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTQyMQ==,size_16,color_FFFFFF,t_70" />## git强制提交本地分支覆盖远程分支 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> localBranchName:remoteBranchName --force<br></code></pre></td></tr></table></figure> ## Git从远程仓库拉取<code>git pull origin main</code> ## Git创建与切换分支 创建分支<code>git branch branch_name</code> 切换分支<code>git checkout branch_name</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Latex常用表示</title>
    <link href="/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th>小写字母</th><th>语法</th><th>大写字母</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(A\)</span></td><td><code>A</code></td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td><td><span class="math inline">\(B\)</span></td><td><code>B</code></td></tr><tr class="odd"><td><span class="math inline">\(\gamma\)</span></td><td><code>\gamma</code></td><td><span class="math inline">\(\Gamma\)</span></td><td><code>\Gamma</code></td></tr><tr class="even"><td><span class="math inline">\(\delta\)</span></td><td><code>\delta</code></td><td><span class="math inline">\(\Delta\)</span></td><td><code>\Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td><td><span class="math inline">\(E\)</span></td><td><code>E</code></td></tr><tr class="even"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(Z\)</span></td><td><code>Z</code></td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td><td><span class="math inline">\(H\)</span></td><td><code>H</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span></td><td><code>\theta</code></td><td><span class="math inline">\(\Theta\)</span></td><td><code>\Theta</code></td></tr><tr class="even"><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(I\)</span></td><td><code>I</code></td></tr><tr class="even"><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td><td><span class="math inline">\(K\)</span></td><td><code>K</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span></td><td><code>\lambda</code></td><td><span class="math inline">\(\Lambda\)</span></td><td><code>\Lambda</code></td></tr><tr class="even"><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td><td><span class="math inline">\(M\)</span></td><td><code>M</code></td></tr><tr class="odd"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(N\)</span></td><td><code>N</code></td></tr><tr class="even"><td><span class="math inline">\(\xi\)</span></td><td><code>\xi</code></td><td><span class="math inline">\(\Xi\)</span></td><td><code>\Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(O\)</span></td><td><code>O</code></td></tr><tr class="even"><td><span class="math inline">\(\pi\)</span></td><td><code>\pi</code></td><td><span class="math inline">\(\Pi\)</span></td><td><code>\Pi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td><td><span class="math inline">\(R\)</span></td><td><code>R</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\sigma\)</span></td><td><code>\sigma</code></td><td><span class="math inline">\(\Sigma\)</span></td><td><code>\Sigma</code></td></tr><tr class="odd"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td><td><span class="math inline">\(T\)</span></td><td><code>T</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td><code>\upsilon</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span></td><td><code>\phi</code></td><td><span class="math inline">\(\Phi\)</span></td><td><code>\Phi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td><td><span class="math inline">\(X\)</span></td><td><code>X</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span></td><td><code>\psi</code></td><td><span class="math inline">\(\Psi\)</span></td><td><code>\Psi</code></td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span></td><td><code>\omega</code></td><td><span class="math inline">\(\Omega\)</span></td><td><code>\Omega</code></td></tr></tbody></table><p>var开头的只有小写希腊字母，没有大写。</p><h2 id="运算符符号">运算符符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td></tr><tr class="even"><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="odd"><td><span class="math inline">\(\int\)</span></td><td><code>\int</code></td></tr><tr class="even"><td><span class="math inline">\(\oplus\)</span></td><td><code>\oplus</code></td></tr><tr class="odd"><td><span class="math inline">\(\otimes\)</span></td><td><code>\otimes</code></td></tr><tr class="even"><td><span class="math inline">\(\times\)</span></td><td><code>\times</code></td></tr><tr class="odd"><td><span class="math inline">\(\cdot\)</span></td><td><code>\codt</code></td></tr><tr class="even"><td><span class="math inline">\(\cap\)</span></td><td><code>\cap</code></td></tr><tr class="odd"><td><span class="math inline">\(\cup\)</span></td><td><code>\cup</code></td></tr></tbody></table><h2 id="关系符号">关系符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\le\)</span></td><td><code>\le</code></td></tr><tr class="even"><td><span class="math inline">\(\ge\)</span></td><td><code>\ge</code></td></tr><tr class="odd"><td><span class="math inline">\(\ll\)</span></td><td><code>\ll</code></td></tr><tr class="even"><td><span class="math inline">\(\gg\)</span></td><td><code>\gg</code></td></tr><tr class="odd"><td><span class="math inline">\(\equiv\)</span></td><td><code>\equiv</code></td></tr><tr class="even"><td><span class="math inline">\(\subseteq\)</span></td><td><code>\subseteq</code></td></tr><tr class="odd"><td><span class="math inline">\(\supseteq\)</span></td><td><code>\supseteq</code></td></tr><tr class="even"><td><span class="math inline">\(\subset\)</span></td><td><code>\subset</code></td></tr><tr class="odd"><td><span class="math inline">\(\supset\)</span></td><td><code>\supset</code></td></tr></tbody></table><h2 id="箭头符号">箭头符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Leftarrow\)</span></td><td><code>\Leftarrow</code></td></tr><tr class="even"><td><span class="math inline">\(\Rightarrow\)</span></td><td><code>\Rightarrow</code></td></tr></tbody></table><h2 id="其他符号">其他符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\infty\)</span></td><td><code>\infty</code></td><td>无穷</td></tr><tr class="even"><td><span class="math inline">\(\exists\)</span></td><td><code>\exists</code></td><td>存在</td></tr><tr class="odd"><td><span class="math inline">\(\forall\)</span></td><td><code>\forall</code></td><td>任取</td></tr><tr class="even"><td><span class="math inline">\(\ldots\)</span></td><td><code>\ldots</code></td><td>下三连点</td></tr><tr class="odd"><td><span class="math inline">\(\cdots\)</span></td><td><code>\cdots</code></td><td>中三连点</td></tr><tr class="even"><td><span class="math inline">\(\vdots\)</span></td><td><code>\vdots</code></td><td>竖三连点</td></tr><tr class="odd"><td><span class="math inline">\(\ddots\)</span></td><td><code>\ddots</code></td><td>斜三连点</td></tr><tr class="even"><td><span class="math inline">\(\overline{x}\)</span></td><td><code>\overline&#123;x&#125;</code></td><td>平均</td></tr><tr class="odd"><td><span class="math inline">\(\quad\)</span></td><td><code>\quad</code></td><td>空格</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>本文大部分转载自知乎<ahref="https://www.zhihu.com/people/ruan-xing-zhi"><span class="citation"data-cites="阮行止">@阮行止</span></a>，后添加了自己的一些思考。</p><h2 id="从一个生活问题谈起">1. 从一个生活问题谈起</h2><p>先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，<strong>需要用到尽量少的钞票</strong>。</p><p>依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。</p><p>这种策略称为“<strong>贪心</strong>”：假设我们面对的局面是“需要凑出w”，贪心策略会<strong>尽快</strong>让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。</p><p>但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：<br />　　15=1×11+4×1 （贪心策略使用了5张钞票）<br />　　15=3×5 （正确的策略，只用3张钞票）<br />　　为什么会这样呢？贪心策略错在了哪里？</p><p><strong>鼠目寸光</strong>。</p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。</p><p>在这里我们发现，贪心是一种<strong>只考虑眼前情况</strong>的策略。</p><p>那么，现在我们怎样才能避免鼠目寸光呢？</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。</p><p>重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。</p><p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？</p><p>明显<strong>cost=f(4)+1=4+1=5</strong>，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。</p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1=2+1=3</strong>。</p><p>那么，现在w=15的时候，我们该取那种钞票呢？<strong>当然是各种方案中，cost值最低的那一个！</strong></p><ul><li>取11：cost=f(4)+1=4+1=5</li><li>取5:cost=f(10)+1=2+1=3</li><li>取1:cost=f(14)+1=4+1=5</li></ul><p>显而易见，cost值最低的是取5的方案。<strong>我们通过上面三个式子，做出了正确的决策！</strong></p><p>这给了我们一个<strong>至关重要</strong>的启示——f(n)只与f(n-1),f(n-5),f(n-11) 相关；更确切地说：</p><blockquote><p>f(n)=min{f(n-1),f(n-5),f(n-11)}+1</p></blockquote><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><figure><img src="/img/动态规划/解决方案.jpg" alt="pic1" /><figcaption aria-hidden="true">pic1</figcaption></figure><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：</p><ul><li>f(n)只与f(n-1),f(n-5),f(n-11)的值有关。</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。<strong>其他信息并不需要</strong>。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。<strong>我们将求解f(c)称作求解f(n)的“子问题”</strong>。</p><p><strong>这就是DP（动态规划，dynamic programming）</strong>.</p><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</strong></p><h2 id="几个简单的概念">2. 几个简单的概念</h2><ul><li><strong>无后效性</strong><br />一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</li></ul><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p><p>“<strong>未来与过去无关</strong>”，这就是<strong>无后效性</strong>。</p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><ul><li>最优子结构</li></ul><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).</p><p>f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的最优解，我们即可算出w=15的最优解。</p><p>大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“最优子结构性质”。</p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="dp的典型应用dag最短路">3. DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><figure><img src="/img/动态规划/最短路径.png" alt="最短路径" /><figcaption aria-hidden="true">最短路径</figcaption></figure><p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).</p><p>想要到T，要么经过C，要么经过D。从而<spanclass="math inline">\(f(T)=min\{f(C)+20,f(D)+10\}\)</span>.</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是<spanclass="math inline">\(S \rightarrow P\rightarrow Q \rightarrowT\)</span>,那肯定S走到Q的最优路径是<span class="math inline">\(S\rightarrow P\rightarrowQ\)</span>。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><blockquote><p>f(P)=min{f(R)+W<sub><span class="math inline">\(R \rightarrowP\)</span></sub>}</p></blockquote><p>其中R为有路通到P的所有的点， [公式] 为R到P的过路费。</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="对dp原理的一点讨论">4. 对DP原理的一点讨论</h2><ul><li>DP的核心思想</li></ul><p>DP为什么会快？</p><p>无论是DP还是暴力，我们的算法都是在<strong>可能解空间</strong>内，寻找<strong>最优解</strong>。</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。</p><p>DP是枚举<strong>有希望成为答案的解</strong>。这个空间比暴力的小得多。</p><p>也就是说：<strong>DP自带剪枝</strong>。</p><p>DP舍弃了一大堆不可能成为最优解的答案。譬如：<br />　　15 = 5+5+5 被考虑了。<br />　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。</p><p>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><ul><li>DP的操作过程</li></ul><p>一言以蔽之：<strong>大事化小，小事化了</strong>。</p><p>将一个大问题转化成几个小问题；<br />　　求解小问题；<br />　　推出大问题的解。</p><ul><li>如何设计DP算法</li></ul><p>下面介绍比较通用的设计DP算法的步骤。</p><p>首先，把我们面对的局面表示为x。这一步称为设计状态。</p><p>对于状态x，记我们要求出的答案(e.g.最小费用)为f(x).我们的目标是求出f(T).<strong>找出f(x)与哪些局面有关（记为p）</strong>，写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><ul><li>DP三连</li></ul><p>设计DP算法，往往可以遵循DP三连：</p><p>我是谁？ ——设计状态，表示局面</p><p>我从哪里来？</p><p>我要到哪里去？ ——设计转移</p><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，<strong>更新能从x走到的一些解</strong>。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><blockquote><p>思考题：如何把钞票问题的代码改写成“我到哪里去”的形式？<br />提示：求出f(x)之后，更新f(x+1),f(x+5),f(x+11).</p></blockquote><h2 id="例题最长上升子序列">5. 例题：最长上升子序列</h2><p>扯了这么多形而上的内容，还是做一道例题吧。</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。<br />　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p><p>如何设计状态（我是谁）？</p><p>我们记<spanclass="math inline">\(f(x)\)</span>为以a<sub>x</sub>结尾的LIS长度，那么答案就是<span class="math inline">\(max\{f(x)\}\)</span></p><p>状态x从哪里推过来（我从哪里来）？</p><p>考虑比x小的每一个p：如果 a<sub>x</sub> &gt; a<sub>p</sub>，那么<spanclass="math inline">\(f(x)\)</span>可以取<spanclass="math inline">\(f(p)+1\)</span>.</p><p>解释：我们把 a<sub>x</sub> 接在 a<sub>p</sub>的后面，肯定能构造一个以 a<sub>x</sub> 结尾的上升子序列，长度比以a<sub>p</sub> 结尾的LIS大1.那么，我们可以写出状态转移方程了：</p><figure><img src="/img/动态规划/状态转移方程.svg" alt="状态转移方程" /><figcaption aria-hidden="true">状态转移方程</figcaption></figure><p>至此解决问题。两层for循环，复杂度O(n<sup>2</sup>) 。</p><figure><img src="/img/动态规划/最长上升子序列代码.jpg"alt="最长上升子序列代码" /><figcaption aria-hidden="true">最长上升子序列代码</figcaption></figure><p>从这三个例题中可以看出，DP是一种思想，一种“大事化小，小事化了”的思想。带着这种思想，DP将会成为我们解决问题的利器。</p><h2 id="习题">6. 习题</h2><p>如果读者有兴趣，可以试着完成下面几个习题：</p><ol type="1"><li>请采取一些优化手段，以 O(n log<sub>2</sub> n)的复杂度解决LIS问题。</li></ol><p>提示：可以参考这篇博客 <ahref="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">JuniorDynamic Programming--动态规划初步·各种子序列问题</a></p><ol start="2" type="1"><li>“按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成<ahref="https://www.luogu.com.cn/problem/P1541">P1541 乌龟棋 - 洛谷</a>。</li><li>01背包问题是一种常见的DP模型。请完成<ahref="https://www.luogu.com.cn/problem/P1048">P1048 采药 -洛谷</a>。</li></ol><h2 id="读后思考动态规划和分治法的区别与共同点">7.读后思考：动态规划和分治法的区别与共同点？</h2><h3 id="分治法">1. 分治法</h3><p>分治法(Divide-and-Conquer) :将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治模式在每一层递归上都有三个步骤：</p><ul><li>分解(Divide)：将原问题分解成一系列子问题；</li><li>解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。</li><li>合并(Combine)：将子问题的结果合并成原问题的解。</li></ul><p>合并排序(MergeSort)是一个典型分治法的例子。其对应的直观的操作如下:</p><p>分解： 将n个元素分成各含n/2个元素的子序列；</p><p>解决：用合并排序法对两个子序列递归地排序；</p><p>合并：合并两个已排序的子序列以得到排序结果。</p><h3 id="动态规划法">2. 动态规划法</h3><p>动态规划算法的设计可以分为如下4个步骤：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><p><strong>分治法是指将问题划分成一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。</strong></p><p>适合采用动态规划方法的最优化问题中的两个要素：<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p><p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p><p>In a word, <strong>分治法 —— 各子问题独立；动态规划 ——各子问题重叠</strong>。</p><p>算法导论：<strong>动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><h2 id="红黑树的性质">红黑树的性质</h2><ol type="1"><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</li></ol><p>由性质5我们可以推出：<br />性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</p><h2 id="红黑树和avl的区别">红黑树和AVL的区别</h2><ol type="1"><li><p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p></li><li><p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p></li><li><p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胜者树与败者树</title>
    <link href="/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    <url>/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>胜者树与败者树是完全二叉树。就像是参加比赛一样，每个选手有不同的实力，两个选手PK,实力决定胜负，晋级下一轮，经过几轮之后，就能得到冠军。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。在k路归并排序中经常用到。</p><h2 id="胜者树">胜者树</h2><p>胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p><figure><img src="/img/胜者树败者树/fig1.jpg" alt="fig1" /><figcaption aria-hidden="true">fig1</figcaption></figure><p>上图是一个胜者树的示例。规定数值小者胜。 1. b3 PKb4，b3胜b4负，内部结点ls[4]的值为3； 2. b3 PKb0，b3胜b0负，内部结点ls[2]的值为3； 3. b1 PKb2，b1胜b2负，内部结点ls[3]的值为1； 4. b3 PKb1，b3胜b1负，内部结点ls[1]的值为3。</p><p>取出胜者b3之后，叶子结点b3的值变为11时，重构的胜者树如下:</p><figure><img src="/img/胜者树败者树/fig2.jpg" alt="fig2" /><figcaption aria-hidden="true">fig2</figcaption></figure><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。</li></ol><p>用胜者树对n个节点实现排序操作，构建胜者树和构建堆比较相似，区别在于胜者树只有叶子节点存放了数据，中间节点记录的是叶子节点间的关系。</p><p>胜者树在每次重构时只需与其兄弟结点比较，一直到根节点选出胜者为止。</p><h2 id="败者树">败者树</h2><p>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p><figure><img src="/img/胜者树败者树/fig3.jpg" alt="fig3" /><figcaption aria-hidden="true">fig3</figcaption></figure><p>上图是一棵败者树。规定数大者败。</p><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；</li></ol><p>败者树重构过程如下： -将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。-比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。</p><figure><img src="/img/胜者树败者树/fig4.jpg" alt="fig4" /><figcaption aria-hidden="true">fig4</figcaption></figure><h2 id="胜者树败者树堆比较">胜者树、败者树、堆比较</h2><h3 id="相同点">相同点</h3><p>这三者空间和时间复杂度都是一样的。调整一次的时间复杂度都是O(logN)的。</p><h3 id="不同点">不同点</h3><p>一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，<strong>调整堆的时候，每次都要选出父结点的两个孩子节点的最小值，然后再用孩子结点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了胜者树。这样<strong>每次比较只用跟自己的兄弟结点进行比较就好</strong>，所以用胜者树可以比堆少一半的比较次数。</p><p>而<strong>胜者树想要比较兄弟结点首先要获得其父结点，也就是说需要访存两次</strong>，这时人们又想能否再次减少比较次数，于是就有了败者树。败者树每个新元素上升时，<strong>只需要获得父节点并比较即可</strong>。</p><p>总的来说，败者树与胜者树相比减少了访存时间。<strong>现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了</strong>。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html#:~:text=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91%E9%83%BD%E6%98%AF%E5%AE%8C%E5%85%A8,%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BE%E5%88%B0%E6%9C%80%E5%80%BC%E3%80%82">胜者树和败者树</a></li><li><ahref="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
