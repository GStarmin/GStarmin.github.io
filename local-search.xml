<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CFS调度算法</title>
    <link href="/2024/05/11/CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/11/CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="cfs调度算法">CFS调度算法</h1><h3id="cfs能在真实硬件上模拟出一种公平的精确的任务多处理cpu"><strong>CFS能在真实硬件上模拟出一种“公平的、精确的任务多处理CPU”。</strong></h3><ol type="1"><li><p><strong>公平，</strong>即对于n个正在运行的任务，当这些任务同时不断地运行时，CPU会尽可能分配给他们1/n的处理时间。<em>CFS是一种基于加权公平排队思想的调度算法。</em></p></li><li><p><strong>精确，</strong>指的是它采用<strong>红黑树</strong>作为调度的任务队列的数据结构。</p></li></ol><p><strong>简单介绍下红黑树特性：</strong></p><ol type="1"><li>每个结点要么是红的要么是黑的。</li><li>根结点是黑的。</li><li>每个叶结点都是黑的。</li><li>如果一个结点是红的，那么它的两个儿子都是黑的。</li><li>对于任意结点而言，其到叶结点的每条路径都包含相同数目的黑结点。</li></ol><ul><li><strong>接下来进入正餐，介绍下CFS：</strong></li></ul><ol type="1"><li><p>CFS使用红黑树结构，来存储要调度的任务队列。</p></li><li><p>每个节点代表了一个要调度的任务，节点的key即为虚拟时间（vruntime），虚拟时间由这个人物的运行时间计算而来。</p></li><li><p>key越小，也就是vruntime越小的话，红黑树对应的节点就越靠左。</p></li><li><p><strong>CFSscheduler每次都挑选最左边的节点作为下一个要运行的任务，</strong>这个节点是“缓存的”——由一个特殊的指针指向；不需要进行O（logn）遍历来查找。也因此，CFS搜索的时间是O(1)。</p></li></ol><h3id="现在问题还剩下一个vruntime具体应该怎样计算呢"><strong>现在问题还剩下一个，vruntime具体应该怎样计算呢？</strong></h3><ol type="1"><li>vruntime = <strong>实际运行时间 * （NICE_0_LOAD /权重)</strong></li></ol><p>其中，NICE_0_LOAD是nice为0时的权重，它的值是1024。这个公式的意思是，如果进程的权重等于NICE_0_LOAD，那么它的虚拟运行时间和实际运行时间相同。如果进程的权重大于NICE_0_LOAD，<strong>那么它的虚拟运行时间就小于实际运行时间，表示它被优先调度</strong>。如果进程的权重小于NICE_0_LOAD，<strong>那么它的虚拟运行时间就大于实际运行时间，表示它被延后调度。</strong></p><p>实际运行时间很好计算，就是该程序已经运行了多久，那么进程权重应该怎样计算呢？</p><p>答案是根据任务的nice值进行索引。nice值可以理解为是我们事先为任务分配的优先级。这里的任务权重nice范围从-20到19。对应德权重值如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*权重只和进程的nice值有关*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sched_prio_to_weight[<span class="hljs-number">40</span>] = &#123; <br> <span class="hljs-comment">/* -20 */</span>     <span class="hljs-number">88761</span>,     <span class="hljs-number">71755</span>,     <span class="hljs-number">56483</span>,     <span class="hljs-number">46273</span>,     <span class="hljs-number">36291</span>,<br> <span class="hljs-comment">/* -15 */</span>     <span class="hljs-number">29154</span>,     <span class="hljs-number">23254</span>,     <span class="hljs-number">18705</span>,     <span class="hljs-number">14949</span>,     <span class="hljs-number">11916</span>,<br> <span class="hljs-comment">/* -10 */</span>      <span class="hljs-number">9548</span>,      <span class="hljs-number">7620</span>,      <span class="hljs-number">6100</span>,      <span class="hljs-number">4904</span>,      <span class="hljs-number">3906</span>,<br> <span class="hljs-comment">/*  -5 */</span>      <span class="hljs-number">3121</span>,      <span class="hljs-number">2501</span>,      <span class="hljs-number">1991</span>,      <span class="hljs-number">1586</span>,      <span class="hljs-number">1277</span>,<br> <span class="hljs-comment">/*   0 */</span>      <span class="hljs-number">1024</span>,       <span class="hljs-number">820</span>,       <span class="hljs-number">655</span>,       <span class="hljs-number">526</span>,       <span class="hljs-number">423</span>,<br> <span class="hljs-comment">/*   5 */</span>       <span class="hljs-number">335</span>,       <span class="hljs-number">272</span>,       <span class="hljs-number">215</span>,       <span class="hljs-number">172</span>,       <span class="hljs-number">137</span>,<br> <span class="hljs-comment">/*  10 */</span>       <span class="hljs-number">110</span>,        <span class="hljs-number">87</span>,        <span class="hljs-number">70</span>,        <span class="hljs-number">56</span>,        <span class="hljs-number">45</span>,<br> <span class="hljs-comment">/*  15 */</span>        <span class="hljs-number">36</span>,        <span class="hljs-number">29</span>,        <span class="hljs-number">23</span>,        <span class="hljs-number">18</span>,        <span class="hljs-number">15</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>nice值和load weight of this process的对应关系，一一对应</p><p>可能还是有点迷糊，这里举个例子就清楚了，现在我们有一个刚来的task，它的nice值是0，那么它的priority是多少呢？</p><p>答案是1024.</p><p>所以此时，该任务的vruntime += 0*1024/1024 =0，那么该任务的key也就是0，它会被放在红黑树上相应的位置。</p><p><strong>vruntime并不是无限小的，有一个最小值来限定。假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。</strong></p><p>CFS是这样做的：每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内。</p><p><strong>对于新任务来说，vruntime = 0</strong></p><p>这也是显而易见的，新来的任务运行时间是0嘛</p><p>这个特性也是CFS算法唤醒抢占特性的由来：</p><p><strong>CFS的唤醒抢占特性：</strong></p><p>休眠进程在唤醒时会获得vruntime的补偿，它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。</p><p>想象一下当你执行每一个敲击键盘、移动鼠标等交互操作的时候，对于系统来说，这就是来了个新任务-&gt;运行时间为0-&gt;vruntime为0-&gt;被放到调度任务队列红黑树的最左节点-&gt;最左节点通过一个特殊的指针指向，且该指针已被缓存。</p><p><strong>这就是CFS能很快对交互式进程做出反应的全过程。</strong></p><h2 id="cfs流程">CFS流程</h2><ul><li>随着任务的执行，它的运行时间增加，因此vruntime也会变大，它会在红黑树中向右移动（想象一下这个画面）；</li><li>计算密集型作业将运行很长时间，因此它将移到最右侧；</li><li>I/O密集型作业会运行很短的时间，因此它只会稍微向右移动；</li><li>对于更重要的任务，也就是nice值较小的（一般是小于0），他们的移动速度相对慢很多。（相对于nice= 0的任务，nice每小一级，CPU usage就会多10%，"10%effect"）虚拟时钟的滴答声更慢.</li></ul><p><strong>CFS的缺点：</strong></p><p>也和唤醒抢占特性有关。CFS不能区分交互式进程和主动休眠的进程，主动休眠的进程并不要求快速响应，但也会在唤醒时获得补偿，例如通过调用sleep()、nanosleep()的方式，定时醒来完成特定任务，这有可能会导致其它更重要的应用进程被抢占，有损整体性能。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-O(1)调度算法</title>
    <link href="/2024/05/11/OS-O-1-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/11/OS-O-1-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统-o1调度算法">操作系统-O（1）调度算法</h1><p>Linux是一个支持多任务的操作系统，而多个任务之间的切换是通过<code>调度器</code> 来完成，<code>调度器</code>使用不同的调度算法会有不同的效果。</p><p>Linux2.4版本使用的调度算法的时间复杂度为O(n)，其主要原理是通过轮询所有可运行任务列表，然后挑选一个最合适的任务运行，所以其时间复杂度与可运行任务队列的长度成正比。</p><p>而Linux2.6开始替换成名为<code>O(1)调度算法</code>，顾名思义，其时间复杂度为O(1)。虽然在后面的版本开始使用<code>CFS调度算法（完全公平调度算法）</code>，但了解<code>O(1)调度算法</code>对学习Linux调度器还是有很大帮助的，所以本文主要介绍<code>O(1)调度算法</code> 的原理与实现。</p><p>由于在 Linux内核中，任务和进程是相同的概念，所以在本文混用了任务和进程这两个名词。</p><p>针对每个 CPU，都有两组链表组成两个 hash 表，分别是 active RunQueue 和expire RunQueue。而每个哈希表中，都通过拉链法维护了 140个链表，每个槽代表一个优先级，每个链表中的所有任务优先级都相同，因此，调度器可以以O(1)时间时间复杂度获取到优先级最高的进程，而为了进一步提升这一过程的执行效率，调度器还通过一个bitmap 来存储 active 队列各个优先级是否存在任务。</p><p>为什么哈希表要拥有 140 个槽呢？因为他们对应了 0~139 这 140个进程优先级。在 O(1) 调度器中，进程优先级数字越低，实际优先级越高，而0~99 为实时进程优先级，100~139 为非实时进程优先级。</p><h2 id="o1调度器执行过程">O(1)调度器执行过程</h2><p>当 active队列中某一个进程完成执行，它就会被移动到队列尾部；当队列全部任务都执行过指定时间片以后，bitmap该优先级对应的位就会被置为 0，当整个 bitmap 全部被置 0 后，调度器指向active 队列和 expired队列的指针就会交换，并且重新对已执行过的进程进行<strong>优先级重估</strong>，并且添加到全新的active 队列中，开启新的一轮执行。</p><h2 id="o1调度器的缺点">O(1)调度器的缺点</h2><ol type="1"><li><strong>IO 密集型任务的识别准确率欠佳</strong>，尤其是与 O(n)简单粗暴的实现方式相比，并且随着时间的推移，这类问题暴露的也越来越多，直到到了积重难返的地步；</li><li>avtive 队列和 expire队列交换的过程虽然简单快捷，但重新评估优先级仍然存在一定的耗时。</li></ol><h2 id="o1调度算法原理">O(1)调度算法原理</h2><h4 id="prio_array-结构"><code>prio_array</code> 结构</h4><p><code>O(1)调度算法</code>通过优先级来对任务进行分组，可分为140个优先级（0 ~139，数值越小优先级越高），每个优先级的任务由一个队列来维护。<code>prio_array</code>结构就是用来维护这些任务队列，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_USER_RT_PRIO    100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_RT_PRIO         MAX_USER_RT_PRIO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_PRIO            (MAX_RT_PRIO + 40)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">prio_array</span> &#123;<br>    <span class="hljs-type">int</span> nr_active;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bitmap[BITMAP_SIZE];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> queue[MAX_PRIO];<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面介绍 <code>prio_array</code> 结构各个字段的作用：</p><ol type="1"><li><code>nr_active</code>: 所有优先级队列中的总任务数。</li><li><code>bitmap</code>:位图，每个位对应一个优先级的任务队列，用于记录哪个任务队列不为空，能通过<code>bitmap</code> 够快速找到不为空的任务队列。</li><li><code>queue</code>:优先级队列数组，每个元素维护一个优先级队列，比如索引为0的元素维护着优先级为0的任务队列。</li></ol><p>下图更直观地展示了 <code>prio_array</code> 结构各个字段的关系：</p><figure><imgsrc="/img/OS-O-1-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/process-schedule-o1.jpg"alt="prio_array" /><figcaption aria-hidden="true">prio_array</figcaption></figure><p>如上图所述，<code>bitmap</code>的第2位和第6位为1（红色代表为1，白色代表为0），表示优先级为2和6的任务队列不为空，也就是说<code>queue</code> 数组的第2个元素和第6个元素的队列不为空。</p><h3 id="runqueue-结构"><code>runqueue</code> 结构</h3><p>另外，为了减少多核CPU之间的竞争，所以每个CPU都需要维护一份本地的优先队列。因为如果使用全局的优先队列，那么多核CPU就需要对全局优先队列进行上锁，从而导致性能下降。</p><p>每个CPU都需要维护一个 <code>runqueue</code>结构，<code>runqueue</code>结构主要维护任务调度相关的信息，比如优先队列、调度次数、CPU负载信息等。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">runqueue</span> &#123;<br>    <span class="hljs-type">spinlock_t</span> lock;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_running,<br>                  nr_switches,<br>                  expired_timestamp,<br>                  nr_uninterruptible;<br>    <span class="hljs-type">task_t</span> *curr, *idle;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *prev_mm;<br>    <span class="hljs-type">prio_array_t</span> *active, *expired, arrays[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> prev_cpu_load[NR_CPUS];<br>    <span class="hljs-type">task_t</span> *migration_thread;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> migration_queue;<br>    <span class="hljs-type">atomic_t</span> nr_iowait;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>runqueue</code> 结构有两个重要的字段：<code>active</code> 和<code>expired</code>，这两个字段在 <code>O(1)调度算法</code>中起着至关重要的作用。我们先来了解一下 <code>O(1)调度算法</code>的大概原理。</p><p>我们注意到 <code>active</code> 和 <code>expired</code> 字段的类型为<code>prio_array</code>，指向任务优先队列。<code>active</code>代表可以调度的任务队列，而 <code>expired</code>字段代表时间片已经用完的任务队列。<code>active</code> 和<code>expired</code> 会进行以下两个过程：</p><ol type="1"><li>当 <code>active</code> 中的任务时间片用完，那么就会被移动到<code>expired</code> 中。</li><li>当 <code>active</code> 中已经没有任务可以运行，就把<code>expired</code> 与 <code>active</code> 交换，从而<code>expired</code> 中的任务可以重新被调度。</li></ol><p>如下图所示：</p><figure><imgsrc="/img/OS-O-1-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/process-schedule-o1-move.jpg"alt="process-schedule-o1-move" /><figcaption aria-hidden="true">process-schedule-o1-move</figcaption></figure><p><code>O(1)调度算法</code> 把140个优先级的前100个（0 ~ 99）作为<code>实时进程优先级</code>，而后40个（100 ~ 139）作为<code>普通进程优先级</code>。实时进程被放置到实时进程优先级的队列中，而普通进程放置到普通进程优先级的队列中。</p><h3 id="实时进程调度">实时进程调度</h3><p>实时进程分为 <code>FIFO（先进先出）</code> 和<code>RR（时间轮询）</code> 两种，其调度算法比较简单，如下：</p><ol type="1"><li><code>先进先出的实时进程调度</code>：如果调度器在执行某个先进先出的实时进程，那么调度器会一直运行这个进程，直至其主动放弃运行权（退出进程或者sleep等）。</li><li><code>时间轮询的实时进程调度</code>：如果调度器在执行某个时间轮询的实时进程，那么调度器会判断当前进程的时间片是否用完，如果用完的话，那么重新分配时间片给它，并且重新放置回<code>active</code>队列中，然后调度到其他同优先级或者优先级更高的实时进程进行运行。</li></ol><h3 id="普通进程调度">普通进程调度</h3><p>每个进程都要一个动态优先级和静态优先级，静态优先级不会变化（进程创建时被设置），而动态优先级会随着进程的睡眠时间而发生变化。动态优先级可以通过以下公式进行计算：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">动态优先级 = <span class="hljs-built_in">max</span>(<span class="hljs-number">100</span>, <span class="hljs-built_in">min</span>(静态优先级 – bonus + <span class="hljs-number">5</span>), <span class="hljs-number">139</span>))<br></code></pre></td></tr></table></figure><p>上面公式的 <code>bonus（奖励或惩罚）</code>是通过进程的睡眠时间计算出来，进程的睡眠时间越大，<code>bonus</code>的值就越大，那么动态优先级就越高（前面说过优先级的值越小，优先级越高）。</p><blockquote><p>另外要说明一下，实时进程的动态优先级与静态优先级相同。</p></blockquote><p>当一个普通进程被添加到运行队列时，会先计算其动态优先级，然后按照动态优先级的值来添加到对应优先级的队列中。而调度器调度进程时，会先选择优先级最高的任务队列中的进程进行调度运行。</p><h3 id="运行时间片计算">运行时间片计算</h3><p>当进程的时间用完后，就需要重新进行计算。进程的运行时间片与静态优先级有关，可以通过以下公式进行计算：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">静态优先级 &lt; <span class="hljs-number">120</span>，运行时间片 = <span class="hljs-built_in">max</span>((<span class="hljs-number">140</span>-静态优先级)*<span class="hljs-number">20</span>, MIN_TIMESLICE)<br>静态优先级 &gt;= <span class="hljs-number">120</span>，运行时间片 = <span class="hljs-built_in">max</span>((<span class="hljs-number">140</span>-静态优先级)*<span class="hljs-number">5</span>, MIN_TIMESLICE)<br></code></pre></td></tr></table></figure><h2 id="o1调度算法实现">O(1)调度算法实现</h2><p>接下来我们分析一下 <code>O(1)调度算法</code> 在内核中的实现。</p><h3 id="时钟中断">时钟中断</h3><p>时钟中断是由硬件触发的，可以通过编程来设置其频率，Linux内核一般设置为每秒产生100~ 1000次。时钟中断会触发调用 <code>scheduler_tick()</code>内核函数，其主要工作是：减少进程的可运行时间片，如果时间片用完，那么把进程从<code>active</code> 队列移动到 <code>expired</code>队列中。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scheduler_tick</span><span class="hljs-params">(<span class="hljs-type">int</span> user_ticks, <span class="hljs-type">int</span> sys_ticks)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">runqueue_t</span> *rq = <span class="hljs-built_in">this_rq</span>();<br>    <span class="hljs-type">task_t</span> *p = current;<br><br>    ...<br><br>    <span class="hljs-comment">// 处理普通进程</span><br>    <span class="hljs-keyword">if</span> (!--p-&gt;time_slice) &#123;                <span class="hljs-comment">// 减少时间片, 如果时间片用完</span><br>        <span class="hljs-built_in">dequeue_task</span>(p, rq-&gt;active);       <span class="hljs-comment">// 把进程从运行队列中删除</span><br>        <span class="hljs-built_in">set_tsk_need_resched</span>(p);           <span class="hljs-comment">// 设置要重新调度标志</span><br>        p-&gt;prio = <span class="hljs-built_in">effective_prio</span>(p);       <span class="hljs-comment">// 重新计算动态优先级</span><br>        p-&gt;time_slice = <span class="hljs-built_in">task_timeslice</span>(p); <span class="hljs-comment">// 重新计算时间片</span><br>        p-&gt;first_time_slice = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (!rq-&gt;expired_timestamp)<br>            rq-&gt;expired_timestamp = jiffies;<br><br>        <span class="hljs-comment">// 如果不是交互进程或者没有处于饥饿状态</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TASK_INTERACTIVE</span>(p) || <span class="hljs-built_in">EXPIRED_STARVING</span>(rq)) &#123;<br>            <span class="hljs-built_in">enqueue_task</span>(p, rq-&gt;expired); <span class="hljs-comment">// 移动到expired队列</span><br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">enqueue_task</span>(p, rq-&gt;active);  <span class="hljs-comment">// 重新放置到active队列</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码主要完成以下几个工作：</p><ol type="1"><li>减少进程的时间片，并且判断时间片是否已经使用完。</li><li>如果时间片使用完，那么把进程从 <code>active</code> 队列中删除。</li><li>调用 <code>set_tsk_need_resched()</code> 函数设<code>TIF_NEED_RESCHED</code> 标志，表示当前进程需要重新调度。</li><li>调用 <code>effective_prio()</code>函数重新计算进程的动态优先级。</li><li>调用 <code>task_timeslice()</code>函数重新计算进程的可运行时间片。</li><li>如果当前进程是交互进程并且没有处于饥饿状态，那么重新加入到<code>active</code> 队列。</li><li>否则把进程移动到 <code>expired</code> 队列。</li></ol><h3 id="任务调度">任务调度</h3><p>如果进程设置了 <code>TIF_NEED_RESCHED</code>标志，那么当从时钟中断返回到用户空间时，会调用 <code>schedule()</code>函数进行任务调度。<code>schedule()</code> 函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    prev = current;  <span class="hljs-comment">// 当前需要被调度的进程</span><br>    rq = <span class="hljs-built_in">this_rq</span>();  <span class="hljs-comment">// 获取当前CPU的runqueue</span><br><br>    array = rq-&gt;active; <span class="hljs-comment">// active队列</span><br><br>    <span class="hljs-comment">// 如果active队列中没有进程, 那么替换成expired队列</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!array-&gt;nr_active)) &#123;<br>        rq-&gt;active = rq-&gt;expired;<br>        rq-&gt;expired = array;<br>        array = rq-&gt;active;<br>        rq-&gt;expired_timestamp = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    idx = <span class="hljs-built_in">sched_find_first_bit</span>(array-&gt;bitmap); <span class="hljs-comment">// 找到最高优先级的任务队列</span><br>    queue = array-&gt;queue + idx;<br>    next = <span class="hljs-built_in">list_entry</span>(queue-&gt;next, <span class="hljs-type">task_t</span>, run_list); <span class="hljs-comment">// 获取到下一个将要运行的进程</span><br>    ...<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(prev != next)) &#123;<br>        ...<br>        prev = <span class="hljs-built_in">context_switch</span>(rq, prev, next); <span class="hljs-comment">// 切换到next进程进行运行</span><br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码主要完成以下几个步骤：</p><ol type="1"><li>如果当前 <code>runqueue</code> 的 <code>active</code>队列为空，那么把 <code>active</code> 队列与 <code>expired</code>队列进行交换。</li><li>调用 <code>sched_find_first_bit()</code> 函数在 <code>bitmap</code>中找到优先级最高并且不为空的任务队列索引。</li><li>调用 <code>context_switch()</code> 函数切换到next进程进行运行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KV-Server记录</title>
    <link href="/2024/04/28/KV-Server%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/04/28/KV-Server%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="kv-server记录">KV-Server记录</h1><h2 id="rpc模块">RPC模块</h2><p>项目使用到的RPC代码高度依赖于protobuf。RPC是一种使得分布式系统中的不同模块之间能够透明地进行远程调用的技术，使得开发者可以更方便地构建分布式系统，而不用过多关注底层通信细节，调用另一台机器的方法会表现的像调用本地的方法一样。</p><p>那么无论对外表现如何，只要设计多个主机之间的通信，必不可少的就是网络通讯这一步</p><p>我们可以看看一次RPC请求到底干了什么？</p><figure><img src="/img/KV-Server%E8%AE%B0%E5%BD%95/rpc-routine.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由于底层网络通信框架使用的是运输层协议，只能发送字节流，因此会涉及到对象的序列化/反序列化问题，即上图中所示的黄色部分，而常见的网络数据传输格式包括如下三种：</p><ul><li>XML：一种通用和轻量级的数据交换格式语言，是指可扩展标记语言以文本结构进行存储。</li><li>JSON：一种通用和轻量级的数据交换格式，也是以文本的结构进行存储，是一种简单的消息格式。JSON作为数据包格式传输时具有更高的效率，这是因为 JSON 不像 XML那样需要有严格的闭合标签，这就让有效数据量与总数据包比有着显著的提升，从而减少同等数据流量的情况下网络的传输压力。</li><li>Protobuf：是 Google开发的一种独立和轻量级的数据交换格式，以二进制结构进行存储，用于不同服务之间序列化数据。它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者序列化，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</li></ul><p>而该项目便是使用 Protobuf来进行消息的序列化和反序列化，同时使用其来实现RPC框架，其底层的通信流程如下图所示：</p><figure><imgsrc="/img/KV-Server%E8%AE%B0%E5%BD%95/FuwAuCYet70BQWSI1h9Z8NB5rpCH.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>打包流程</strong>：</p><ol type="1"><li>序列化函数参数得到 argsStr，其长度为 argsSize；</li><li>打包 service_name、method_name 和 argsSize 得到 rpcHeader；</li><li>序列化 rpcHeader 得到 rpcHeaderStr，其长度为 headerSize；</li><li>将 headerSize 存储到数据包的前 4 个字节，后面的依次是 rpcHeaderStr和 argsStr；</li><li>通过网络发送数据包；</li></ol><p><strong>解包流程</strong>：</p><ol type="1"><li>通过网络接收数据包；</li><li>首先取出数据包的前 4 个字节，读取出 headerSize 的大小；</li><li>从第 5 个字节开始，读取 headerSize 字节大小的数据，即为 rpcHeaderStr的内容；</li><li>反序列化 rpcHeaderStr，得到 service_name、method_name 和argsSize；</li><li>从 4+headerSize 字节开始，读取 argsSize 字节大小的数据，即为 argsStr的内容；</li><li>反序列化 argsStr 得到函数参数 args；</li></ol><h2 id="消息内容">消息内容</h2><p><strong>raft节点之间rpc通信函数:</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 只有raft节点之间才会涉及rpc通信</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">raftRpc</span>  <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> AppendEntries(AppendEntriesArgs) <span class="hljs-keyword">returns</span>(AppendEntriesReply)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> InstallSnapshot (InstallSnapshotRequest) <span class="hljs-keyword">returns</span> (InstallSnapshotResponse)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> RequestVote (RequestVoteArgs) <span class="hljs-keyword">returns</span> (RequestVoteReply)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日志实体</strong>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 日志实体</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LogEntry</span>&#123;<br>    <span class="hljs-type">bytes</span> Command  =<span class="hljs-number">1</span>;<span class="hljs-comment">// 命令,猜测是增删改查的命令？</span><br><span class="hljs-type">int32</span> LogTerm   =<span class="hljs-number">2</span>;<span class="hljs-comment">// 日志</span><br><span class="hljs-type">int32</span> LogIndex  = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RpcArgs内容</strong>:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// AppendEntriesArgs 由leader复制log条目，也可以当做是心跳连接，注释中的rf为leader节点</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">AppendEntriesArgs</span>  &#123;<br><span class="hljs-comment">//下面几个参数和论文中相同</span><br><span class="hljs-type">int32</span> Term        =<span class="hljs-number">1</span>;<span class="hljs-comment">// 自己当前的任期号</span><br><span class="hljs-type">int32</span> LeaderId       =<span class="hljs-number">2</span>;<span class="hljs-comment">// 领导人的id</span><br><span class="hljs-type">int32</span> PrevLogIndex =<span class="hljs-number">3</span>;<span class="hljs-comment">// 前一个日志的日志号</span><br><span class="hljs-type">int32</span> PrevLogTerm  =<span class="hljs-number">4</span>;<span class="hljs-comment">// 前一个日志的任期号</span><br><span class="hljs-keyword">repeated</span> LogEntry Entries  = <span class="hljs-number">5</span>;<span class="hljs-comment">// 当前日志体</span><br><span class="hljs-type">int32</span> LeaderCommit  = <span class="hljs-number">6</span>;<span class="hljs-comment">// 当前日志体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RpcReply内容</strong>:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// AppendEntriesReply 论文中没有提及返回要设置哪些状态</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">AppendEntriesReply</span> &#123;<br><span class="hljs-type">int32</span> Term =<span class="hljs-number">1</span>;             <span class="hljs-comment">// leader的term可能是与Follower不同的，</span><br><span class="hljs-type">bool</span> Success      =<span class="hljs-number">2</span>;<br><span class="hljs-type">int32</span> UpdateNextIndex = <span class="hljs-number">3</span>; <span class="hljs-comment">// 快速调整leader对应的nextIndex</span><br><span class="hljs-type">int32</span> AppState        =<span class="hljs-number">4</span>;  <span class="hljs-comment">// 用来标识节点（网络）状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>请求投票参数</strong>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">RequestVoteArgs</span>  &#123;<br><span class="hljs-type">int32</span> Term         =<span class="hljs-number">1</span>;<br><span class="hljs-type">int32</span> CandidateId  =<span class="hljs-number">2</span>;<br><span class="hljs-type">int32</span> LastLogIndex =<span class="hljs-number">3</span>;<br><span class="hljs-type">int32</span> LastLogTerm  =<span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>请求投票回复</strong>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// RequestVoteReply</span><br><span class="hljs-comment">// example RequestVote RPC reply structure.</span><br><span class="hljs-comment">// field names must start with capital letters!</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">RequestVoteReply</span>  &#123;<br><span class="hljs-comment">// Your data here (2A).</span><br><span class="hljs-type">int32</span> Term        =<span class="hljs-number">1</span>;<br><span class="hljs-type">bool</span> VoteGranted  =<span class="hljs-number">2</span>;<br><span class="hljs-type">int32</span> VoteState   =<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发起快照请求</strong>:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">InstallSnapshotRequest</span>  &#123;<br><span class="hljs-type">int32</span> LeaderId                 =<span class="hljs-number">1</span>;<span class="hljs-comment">// 领导人的 ID，以便于跟随者重定向请求</span><br><span class="hljs-type">int32</span> Term                     =<span class="hljs-number">2</span>;<span class="hljs-comment">// 领导人的任期号</span><br><span class="hljs-type">int32</span> LastSnapShotIncludeIndex =<span class="hljs-number">3</span>;<span class="hljs-comment">//快照中包含的最后日志条目的索引值</span><br><span class="hljs-type">int32</span> LastSnapShotIncludeTerm  =<span class="hljs-number">4</span>;<span class="hljs-comment">//快照中包含的最后日志条目的任期号</span><br><span class="hljs-type">bytes</span> Data                     =<span class="hljs-number">5</span>;<span class="hljs-comment">//快照信息，当然是用bytes来传递</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发起快照回复</strong>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// InstallSnapshotResponse 只用返回Term，因为对于快照只要Term是符合的就是无条件接受的</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">InstallSnapshotResponse</span>  &#123;<br><span class="hljs-type">int32</span> Term  = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="raft类主要内容">Raft类主要内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Raft</span> :<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::mutex m_mtx;<br>    std::vector&lt;std::shared_ptr&lt; RaftRpc &gt;&gt; m_peers; <span class="hljs-comment">//需要与其他raft节点通信，这里保存与其他结点通信的rpc入口</span><br>    std::shared_ptr&lt;Persister&gt; m_persister;   <span class="hljs-comment">//持久化层，负责raft数据的持久化</span><br>    <span class="hljs-type">int</span> m_me;             <span class="hljs-comment">//raft是以集群启动，这个用来标识自己的的编号</span><br>    <span class="hljs-type">int</span> m_currentTerm;    <span class="hljs-comment">//记录当前的term</span><br>    <span class="hljs-type">int</span> m_votedFor;       <span class="hljs-comment">//记录当前term给谁投票过</span><br>    std::vector&lt;mprrpc:: LogEntry&gt; m_logs; <span class="hljs-comment">//// 日志条目数组，包含了状态机要执行的指令集，以及收到领导时的任期号</span><br>    <span class="hljs-comment">// 这两个状态所有结点都在维护，易失</span><br>    <span class="hljs-type">int</span> m_commitIndex;<br>    <span class="hljs-type">int</span> m_lastApplied; <span class="hljs-comment">// 已经汇报给状态机（上层应用）的log 的index</span><br><br>    <span class="hljs-comment">// 这两个状态是由leader来维护，易失 ，这两个部分在内容补充的部分也会再讲解</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_nextIndex; <span class="hljs-comment">// 这两个状态的下标1开始，因为通常commitIndex和lastApplied从0开始，应该是一个无效的index，因此下标从1开始</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_matchIndex;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span><br>    &#123;<br>        Follower,<br>        Candidate,<br>        Leader<br>    &#125;;<br>    <span class="hljs-comment">// 保存当前身份</span><br>    Status m_status;<br><br>    std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyChan;     <span class="hljs-comment">// client从这里取日志，client与raft通信的接口</span><br>    <span class="hljs-comment">// ApplyMsgQueue chan ApplyMsg // raft内部使用的chan，applyChan是用于和服务层交互，最后好像没用上</span><br><br>    <span class="hljs-comment">// 选举超时</span><br>    std::chrono::_V2::system_clock::time_point m_lastResetElectionTime;<br>    <span class="hljs-comment">// 心跳超时，用于leader</span><br>    std::chrono::_V2::system_clock::time_point m_lastResetHearBeatTime;<br><br>    <span class="hljs-comment">// 用于传入快照点</span><br>    <span class="hljs-comment">// 储存了快照中的最后一个日志的Index和Term</span><br>    <span class="hljs-type">int</span> m_lastSnapshotIncludeIndex;<br>    <span class="hljs-type">int</span> m_lastSnapshotIncludeTerm;<br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AppendEntries1</span><span class="hljs-params">(<span class="hljs-type">const</span> mprrpc::AppendEntriesArgs *args, mprrpc::AppendEntriesReply *reply)</span></span>; <span class="hljs-comment">//日志同步 + 心跳 rpc ，重点关注</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">applierTicker</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//定期向状态机写入日志，非重点函数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CondInstallSnapshot</span><span class="hljs-params">(<span class="hljs-type">int</span> lastIncludedTerm, <span class="hljs-type">int</span> lastIncludedIndex, std::string snapshot)</span></span>;    <span class="hljs-comment">//快照相关，非重点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doElection</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//发起选举</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHeartBeat</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//leader定时发起心跳</span><br>    <span class="hljs-comment">// 每隔一段时间检查睡眠时间内有没有重置定时器，没有则说明超时了</span><br><span class="hljs-comment">// 如果有则设置合适睡眠时间：睡眠到重置时间+超时时间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">electionTimeOutTicker</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//监控是否该发起选举了</span><br>    <span class="hljs-function">std::vector&lt;ApplyMsg&gt; <span class="hljs-title">getApplyLogs</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNewCommandIndex</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrevLogInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> server, <span class="hljs-type">int</span> *preIndex, <span class="hljs-type">int</span> *preTerm)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetState</span><span class="hljs-params">(<span class="hljs-type">int</span> *term, <span class="hljs-type">bool</span> *isLeader)</span></span>;  <span class="hljs-comment">//看当前节点是否是leader</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InstallSnapshot</span><span class="hljs-params">( <span class="hljs-type">const</span> mprrpc::InstallSnapshotRequest *args, mprrpc::InstallSnapshotResponse *reply)</span></span>;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaderHearBeatTicker</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//检查是否需要发起心跳（leader）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaderSendSnapShot</span><span class="hljs-params">(<span class="hljs-type">int</span> server)</span></span>;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaderUpdateCommitIndex</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//leader更新commitIndex</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">matchLog</span><span class="hljs-params">(<span class="hljs-type">int</span> logIndex, <span class="hljs-type">int</span> logTerm)</span></span>;  <span class="hljs-comment">//对应Index的日志是否匹配，只需要Index和Term就可以知道是否匹配</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">persist</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//持久化</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequestVote</span><span class="hljs-params">(<span class="hljs-type">const</span> mprrpc::RequestVoteArgs *args, mprrpc::RequestVoteReply *reply)</span></span>;    <span class="hljs-comment">//变成candidate之后需要让其他结点给自己投票</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpToDate</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> term)</span></span>;   <span class="hljs-comment">//判断当前节点是否含有最新的日志</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLastLogIndex</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getLastLogIndexAndTerm</span><span class="hljs-params">(<span class="hljs-type">int</span> *lastLogIndex, <span class="hljs-type">int</span> *lastLogTerm)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLogTermFromLogIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> logIndex)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRaftStateSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSlicesIndexFromLogIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> logIndex)</span></span>;   <span class="hljs-comment">//设计快照之后logIndex不能与在日志中的数组下标相等了，根据logIndex找到其在日志数组中的位置</span><br><br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sendRequestVote</span><span class="hljs-params">(<span class="hljs-type">int</span> server , std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; args ,  std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; reply,   std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; votedNum)</span> </span>; <span class="hljs-comment">// 请求其他结点的投票</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sendAppendEntries</span><span class="hljs-params">(<span class="hljs-type">int</span> server ,std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; args , std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; reply , std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; appendNums )</span> </span>;  <span class="hljs-comment">//Leader发送心跳后，对心跳的回复进行对应的处理</span><br><br><br>    <span class="hljs-comment">//rf.applyChan &lt;- msg //不拿锁执行  可以单独创建一个线程执行，但是为了同意使用std:thread ，避免使用pthread_create，因此专门写一个函数来执行</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushMsgToKvServer</span><span class="hljs-params">(ApplyMsg msg)</span></span>;  <span class="hljs-comment">//给上层的kvserver层发送消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readPersist</span><span class="hljs-params">(std::string data)</span></span>;    <br>    <span class="hljs-function">std::string <span class="hljs-title">persistData</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">(Op command,<span class="hljs-type">int</span>* newLogIndex,<span class="hljs-type">int</span>* newLogTerm,<span class="hljs-type">bool</span>* isLeader )</span> </span>;   <span class="hljs-comment">// 发布发来一个新日志</span><br><span class="hljs-comment">// 即kv-server主动发起，请求raft（持久层）保存snapshot里面的数据，index是用来表示snapshot快照执行到了哪条命令</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Snapshot</span><span class="hljs-params">(<span class="hljs-type">int</span> index , std::string snapshot )</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::vector&lt;std::shared_ptr&lt; RaftRpc &gt;&gt; peers,<span class="hljs-type">int</span> me,std::shared_ptr&lt;Persister&gt; persister,std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyCh)</span></span>;<span class="hljs-comment">//初始化</span><br></code></pre></td></tr></table></figure><p>重点需要关注的：</p><ol type="1"><li>Raft的主要流程：领导选举（<code>sendRequestVote RequestVote</code>） 日志同步、心跳（<code>sendAppendEntries</code><code>AppendEntries</code> ）</li><li>定时器的维护：主要包括raft向状态机定时写入（<code>applierTicker</code>）、心跳维护定时器（<code>leaderHearBeatTicker</code>）、选举超时定时器（<code>electionTimeOutTicker</code> ）。</li><li>持久化相关：包括哪些内容需要持久化，什么时候需要持久化（persist）</li><li><code>m_nextIndex</code>保存leader下一次应该从哪一个日志开始发送给follower；</li><li><code>m_matchIndex</code>表示follower在哪一个日志是已经匹配了的（由于日志安全性，某一个日志匹配，那么这个日志及其之前的日志都是匹配的）</li></ol><h3 id="init-启动初始化">init() 启动初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Raft::init</span><span class="hljs-params">(std::vector&lt;std::shared_ptr&lt;RaftRpc&gt;&gt; peers, <span class="hljs-type">int</span> me, std::shared_ptr&lt;Persister&gt; persister, std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyCh)</span> </span>&#123;<br>    m_peers = peers;     <span class="hljs-comment">//与其他结点沟通的rpc类</span><br>    m_persister = persister;   <span class="hljs-comment">//持久化类</span><br>    m_me = me;    <span class="hljs-comment">//标记自己，毕竟不能给自己发送rpc吧</span><br><br>    m_mtx.<span class="hljs-built_in">lock</span>();<br><br>    <span class="hljs-comment">//applier</span><br>    <span class="hljs-keyword">this</span>-&gt;applyChan = applyCh;   <span class="hljs-comment">//与kv-server沟通</span><br><span class="hljs-comment">//    rf.ApplyMsgQueue = make(chan ApplyMsg)</span><br>    m_currentTerm = <span class="hljs-number">0</span>;   <span class="hljs-comment">//初始化term为0</span><br>    m_status = Follower;   <span class="hljs-comment">//初始化身份为follower</span><br>    m_commitIndex = <span class="hljs-number">0</span>;  <br>    m_lastApplied = <span class="hljs-number">0</span>;<br>    m_logs.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;m_peers.<span class="hljs-built_in">size</span>();i++)&#123;<br>        m_matchIndex.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        m_nextIndex.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    m_votedFor = <span class="hljs-number">-1</span>;    <span class="hljs-comment">//当前term没有给其他人投过票就用-1表示</span><br><br>    m_lastSnapshotIncludeIndex = <span class="hljs-number">0</span>;<br>    m_lastSnapshotIncludeTerm = <span class="hljs-number">0</span>;<br>    m_lastResetElectionTime = <span class="hljs-built_in">now</span>();<br>    m_lastResetHearBeatTime = <span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-comment">// initialize from state persisted before a crash</span><br>    <span class="hljs-built_in">readPersist</span>(m_persister-&gt;<span class="hljs-built_in">ReadRaftState</span>());<br>    <span class="hljs-keyword">if</span>(m_lastSnapshotIncludeIndex &gt; <span class="hljs-number">0</span>)&#123;<br>        m_lastApplied = m_lastSnapshotIncludeIndex;<br>        <span class="hljs-comment">//rf.commitIndex = rf.lastSnapshotIncludeIndex 崩溃恢复不能读取commitIndex</span><br>    &#125;<br><br>    m_mtx.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-comment">// start ticker  开始三个定时器</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;Raft::leaderHearBeatTicker, <span class="hljs-keyword">this</span>)</span></span>;<br>    t.<span class="hljs-built_in">detach</span>();<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(&amp;Raft::electionTimeOutTicker, <span class="hljs-keyword">this</span>)</span></span>;<br>    t2.<span class="hljs-built_in">detach</span>();<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(&amp;Raft::applierTicker, <span class="hljs-keyword">this</span>)</span></span>;<br>    t3.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从上面可以看到一共产生了三个定时器，分别维护：选举、日志同步和心跳、raft节点与kv-server的联系。相互之间是比较隔离的。</p><h2 id="leader选举">Leader选举</h2><p>主要涉及函数及其流程：</p><figure><imgsrc="/img/KV-Server%E8%AE%B0%E5%BD%95/FjzFfi6jY-SnRVKFrYXoDaKPSNry.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>electionTimeOutTicker</strong>：负责查看是否该发起选举，如果该发起选举就执行doElection发起选举。</p><p><strong>doElection</strong>：实际发起选举，构造需要发送的rpc，并多线程调用sendRequestVote处理rpc及其相应。</p><p><strong>sendRequestVote</strong>：负责发送选举中的RPC，在发送完rpc后还需要负责接收并处理对端发送回来的响应。</p><p><strong>RequestVote</strong>：接收别人发来的选举请求，主要检验是否要给对方投票。</p><h3id="electiontimeoutticker"><strong>electionTimeOutTicker</strong></h3><p>选举超时由于<code>electionTimeOutTicker</code> 维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Raft::electionTimeOutTicker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Check if a Leader election should be started.</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">auto</span> nowTime = <span class="hljs-built_in">now</span>(); <span class="hljs-comment">//睡眠前记录时间</span><br>        <span class="hljs-keyword">auto</span> suitableSleepTime = <span class="hljs-built_in">getRandomizedElectionTimeout</span>() + m_lastResetElectionTime - nowTime;<br>        m_mtx.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">if</span> (suitableSleepTime.<span class="hljs-built_in">count</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(suitableSleepTime);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((m_lastResetElectionTime - nowTime).<span class="hljs-built_in">count</span>() &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//说明睡眠的这段时间有重置定时器，那么就没有超时，再次睡眠</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">doElection</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在死循环中，首先计算距离下一次超时应该睡眠的时间suitableSleepTime，然后睡眠这段时间，醒来后查看睡眠的这段时间选举超时定时器是否被触发，如果没有触发就发起选举。</p><blockquote><p>“举超时定时器是否被触发”：选举定时器的触发条件：收到leader发来的appendEntryRPC、给其他的节点选举投票</p></blockquote><p>在死循环中，首先计算距离上次重置选举计时器的时间加上随机化的选举超时时间，然后线程根据这个时间决定是否睡眠。若超时时间未到，线程进入睡眠状态，若在此期间选举计时器被重置，则继续循环。若超时时间已到，调用<code>doElection()</code>函数启动领导者选举过程。</p><h3 id="doelection函数"><strong>doElection</strong>()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Raft::doElection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m_mtx)</span></span>; <span class="hljs-comment">//c11新特性，使用raii避免死锁</span><br><br><br>    <span class="hljs-keyword">if</span> (m_status != Leader) &#123;<br>        <span class="hljs-built_in">DPrintf</span>(<span class="hljs-string">&quot;[       ticker-func-rf(%d)              ]  选举定时器到期且不是leader，开始选举 \n&quot;</span>, m_me);<br>        <span class="hljs-comment">//当选举的时候定时器超时就必须重新选举，不然没有选票就会一直卡住</span><br>        m_status = Candidate;<br>        <span class="hljs-comment">///开始新一轮的选举</span><br>        m_currentTerm += <span class="hljs-number">1</span>;  <span class="hljs-comment">//无论是刚开始竞选，还是超时重新竞选，term都要增加</span><br>        m_votedFor = m_me; <span class="hljs-comment">//即是自己给自己投票，也避免candidate给同辈的candidate投</span><br>        <span class="hljs-built_in">persist</span>();   <br>        std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; votedNum = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>); <span class="hljs-comment">// 使用 make_shared 函数初始化 !! 亮点</span><br>        <span class="hljs-comment">//重新设置定时器</span><br>        m_lastResetElectionTime = <span class="hljs-built_in">now</span>();<br>        <span class="hljs-comment">//发布RequestVote RPC</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_peers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == m_me) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> lastLogIndex = <span class="hljs-number">-1</span>, lastLogTerm = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">getLastLogIndexAndTerm</span>(&amp;lastLogIndex, &amp;lastLogTerm);<span class="hljs-comment">//获取最后一个log的term和下标，以添加到RPC的发送</span><br><br>            <span class="hljs-comment">//初始化发送参数</span><br>            std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; requestVoteArgs = std::<span class="hljs-built_in">make_shared</span>&lt;mprrpc::RequestVoteArgs&gt;();<br>            requestVoteArgs-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>            requestVoteArgs-&gt;<span class="hljs-built_in">set_candidateid</span>(m_me);<br>            requestVoteArgs-&gt;<span class="hljs-built_in">set_lastlogindex</span>(lastLogIndex);<br>            requestVoteArgs-&gt;<span class="hljs-built_in">set_lastlogterm</span>(lastLogTerm);<br>            std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; requestVoteReply = std::<span class="hljs-built_in">make_shared</span>&lt;mprrpc::RequestVoteReply&gt;();<br><br>            <span class="hljs-comment">//使用匿名函数执行避免其拿到锁</span><br><br>            <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;Raft::sendRequestVote, <span class="hljs-keyword">this</span>, i, requestVoteArgs, requestVoteReply, votedNum)</span></span>; <span class="hljs-comment">// 创建新线程并执行函数，并传递参数</span><br>            t.<span class="hljs-built_in">detach</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="raftappendentries1函数">Raft::AppendEntries1()函数</h3><p>如果对方的任期号比自己当前任期号小，说明对方已经是过期领导人了，那么更新reply状态并直接return。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">term</span>() &lt; m_currentTerm) &#123; <span class="hljs-comment">// 对方的任期号比自己当前任期号小</span><br>   reply-&gt;<span class="hljs-built_in">set_success</span>(<span class="hljs-literal">false</span>);<br>   reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>   reply-&gt;<span class="hljs-built_in">set_updatenextindex</span>(<span class="hljs-number">-100</span>);  <span class="hljs-comment">// 论文中：让领导人可以及时更新自己</span><br>   <span class="hljs-built_in">DPrintf</span>(<span class="hljs-string">&quot;[func-AppendEntries-rf&#123;%d&#125;] 拒绝了 因为Leader&#123;%d&#125;的term&#123;%v&#125;&lt; rf&#123;%d&#125;.term&#123;%d&#125;\n&quot;</span>, m_me, args-&gt;<span class="hljs-built_in">leaderid</span>(),<br>           args-&gt;<span class="hljs-built_in">term</span>(), m_me, m_currentTerm);<br>   <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 注意从过期的领导人收到消息不要重设定时器</span><br> &#125;<br></code></pre></td></tr></table></figure><p>如果对方任期号比自己当前任期号大，那么就说明leader更新了，不管自己之前是不是leader，现在都要成为follwer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">term</span>() &gt; m_currentTerm) &#123; <span class="hljs-comment">// 对方任期号比自己当前任期号大</span><br>    <span class="hljs-comment">// 三变 ,防止遗漏，无论什么时候都是三变</span><br>    <span class="hljs-comment">// args.LeaderId, args.Term, rf.me, rf.currentTerm)</span><br>    m_status = Follower;<br>    m_currentTerm = args-&gt;<span class="hljs-built_in">term</span>();<br>    m_votedFor = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 这里设置成-1有意义，如果突然宕机然后上线理论上是可以投票的</span><br>    <span class="hljs-comment">// 这里可不返回，应该改成让改节点尝试接收日志</span><br>    <span class="hljs-comment">// 如果是领导人和candidate突然转到Follower好像也不用其他操作</span><br>    <span class="hljs-comment">// 如果本来就是Follower，那么其term变化，相当于“不言自明”的换了追随的对象，因为原来的leader的term更小，是不会再接收其消息了</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>如果上面两种情况都不满足，那么说明自己收到的就是当前leader发的包。因为只有leader会向follwer更新日志或者发心跳包。这里的args其实就是leader发送过来的参数。</p><p>如果leader的prevlogindex(前一个日志的日志号)大于当前节点lastLogIndex（最新的日志号），那么说明leader发送的日志过于新了，当前节点要从lastLogIndex+ 1一个一个更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//那么就比较日志，日志有3种情况</span><br>  <span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">prevlogindex</span>() &gt; <span class="hljs-built_in">getLastLogIndex</span>()) &#123;<br>    reply-&gt;<span class="hljs-built_in">set_success</span>(<span class="hljs-literal">false</span>);<br>    reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>    reply-&gt;<span class="hljs-built_in">set_updatenextindex</span>(<span class="hljs-built_in">getLastLogIndex</span>() + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>如果leader的prevlogindex比当前节点快照的最后一条日志号小的话，那么就说明leader共发送的日志比当前节点已经快照的最后一个日志号都要小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">prevlogindex</span>() &lt; m_lastSnapshotIncludeIndex) &#123;<br>    <span class="hljs-comment">// 如果prevlogIndex还没有更上快照</span><br>    reply-&gt;<span class="hljs-built_in">set_success</span>(<span class="hljs-literal">false</span>);<br>    reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>    reply-&gt;<span class="hljs-built_in">set_updatenextindex</span>(<br>        m_lastSnapshotIncludeIndex +<br>        <span class="hljs-number">1</span>);  <span class="hljs-comment">// todo 如果想直接弄到最新好像不对，因为是从后慢慢往前匹配的，这里不匹配说明后面的都不匹配</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 错误写法like：  rf.shrinkLogsToIndex(args.PrevLogIndex)</span><br>    <span class="hljs-comment">// rf.logs = append(rf.logs, args.Entries...)</span><br>    <span class="hljs-comment">// 因为可能会收到过期的log！！！ 因此这里是大于等于</span><br>    <span class="hljs-built_in">myAssert</span>(<br>        <span class="hljs-built_in">getLastLogIndex</span>() &gt;= args-&gt;<span class="hljs-built_in">prevlogindex</span>() + args-&gt;<span class="hljs-built_in">entries_size</span>(),<br>        format(<span class="hljs-string">&quot;[func-AppendEntries1-rf&#123;%d&#125;]rf.getLastLogIndex()&#123;%d&#125; != args.PrevLogIndex&#123;%d&#125;+len(args.Entries)&#123;%d&#125;&quot;</span>,<br>               m_me, <span class="hljs-built_in">getLastLogIndex</span>(), args-&gt;<span class="hljs-built_in">prevlogindex</span>(), args-&gt;<span class="hljs-built_in">entries_size</span>()));<br></code></pre></td></tr></table></figure><h3 id="raftsendappendentries函数">Raft::sendAppendEntries()函数</h3><p><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Raft::sendAppendEntries</span><span class="hljs-params">(<span class="hljs-type">int</span> server, std::shared_ptr&lt;raftRpcProctoc::AppendEntriesArgs&gt; args,</span></span><br><span class="hljs-params"><span class="hljs-function">                             std::shared_ptr&lt;raftRpcProctoc::AppendEntriesReply&gt; reply,</span></span><br><span class="hljs-params"><span class="hljs-function">                             std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; appendNums)</span></span><br></code></pre></td></tr></table></figure><p>args是要发送的AErpc，reply是返回，m_peers是一个代理类的数组，直接调用m_peers[server]的AppendEntries函数，并得到返回值，如果ok为false直接报错并返回，否则对reply进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="hljs-built_in">AppendEntries</span>(args.<span class="hljs-built_in">get</span>(), reply.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure><p>加锁，同时收到多个reply的并发处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg1</span><span class="hljs-params">(m_mtx)</span></span>;<br></code></pre></td></tr></table></figure><p>如果reply-&gt;term() &gt;m_currentTerm,说明自己的任期号已经不是最新的了，将自己转为follower：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (reply-&gt;<span class="hljs-built_in">term</span>() &gt; m_currentTerm) &#123;<br>    m_status = Follower;<br>    m_currentTerm = reply-&gt;<span class="hljs-built_in">term</span>();<br>    m_votedFor = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> ok;<br>  &#125;<br></code></pre></td></tr></table></figure><p>如果reply-&gt;term() &lt;m_currentTerm，说明收到的是过期回复，直接返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply-&gt;<span class="hljs-built_in">term</span>() &lt; m_currentTerm) &#123;<br>    <span class="hljs-built_in">DPrintf</span>(<span class="hljs-string">&quot;[func -sendAppendEntries  rf&#123;%d&#125;]  节点：&#123;%d&#125;的term&#123;%d&#125;&lt;rf&#123;%d&#125;的term&#123;%d&#125;\n&quot;</span>, m_me, server, reply-&gt;<span class="hljs-built_in">term</span>(),<br>            m_me, m_currentTerm);<br>    <span class="hljs-keyword">return</span> ok;<br>  &#125;<br></code></pre></td></tr></table></figure><p>如果reply-&gt;success()不为真：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!reply-&gt;<span class="hljs-built_in">success</span>()) &#123;<br>   <span class="hljs-comment">// 日志不匹配，正常来说就是index要往前-1，既然能到这里，第一个日志（idnex =</span><br>   <span class="hljs-comment">//  1）发送后肯定是匹配的，因此不用考虑变成负数 因为真正的环境不会知道是服务器宕机还是发生网络分区了</span><br>   <span class="hljs-keyword">if</span> (reply-&gt;<span class="hljs-built_in">updatenextindex</span>() != <span class="hljs-number">-100</span>) &#123;<span class="hljs-comment">// -100说明对方的任期号比自己大，在前面已经处理过了（转为follower）</span><br>     <span class="hljs-comment">// todo:待总结，就算term匹配，失败的时候nextIndex也不是照单全收的，因为如果发生rpc延迟，leader的term可能从不符合term要求</span><br>     <span class="hljs-comment">// 变得符合term要求</span><br>     <span class="hljs-comment">// 但是不能直接赋值reply.UpdateNextIndex</span><br>     <span class="hljs-built_in">DPrintf</span>(<span class="hljs-string">&quot;[func -sendAppendEntries  rf&#123;%d&#125;]  返回的日志term相等，但是不匹配，回缩nextIndex[%d]：&#123;%d&#125;\n&quot;</span>, m_me,<br>             server, reply-&gt;<span class="hljs-built_in">updatenextindex</span>());<br>       <br>     <span class="hljs-comment">// 更新server下次要更新的index</span><br>     m_nextIndex[server] = reply-&gt;<span class="hljs-built_in">updatenextindex</span>();  <span class="hljs-comment">// 失败是不更新matchIndex的</span><br>   &#125;<br>   <span class="hljs-comment">//怎么越写越感觉rf.nextIndex数组是冗余的呢，看下论文fig2，其实不是冗余的</span><br> &#125;<br></code></pre></td></tr></table></figure><p>否则说明更新成功,同时更新server的m_matchIndex和m_nextIndex，并将appendNums所对应的值加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">else</span> &#123;<br>   *appendNums = *appendNums + <span class="hljs-number">1</span>;<br>   <span class="hljs-built_in">DPrintf</span>(<span class="hljs-string">&quot;---------------------------tmp------------------------- 節點&#123;%d&#125;返回true,當前*appendNums&#123;%d&#125;&quot;</span>, server,<br>           *appendNums);<br>   <span class="hljs-comment">// rf.matchIndex[server] = len(args.Entries) //只要返回一个响应就对其matchIndex应该对其做出反应，</span><br>   <span class="hljs-comment">// 但是这么修改是有问题的，如果对某个消息发送了多遍（心跳时就会再发送），那么一条消息会导致n次上涨</span><br>   m_matchIndex[server] = std::<span class="hljs-built_in">max</span>(m_matchIndex[server], args-&gt;<span class="hljs-built_in">prevlogindex</span>() + args-&gt;<span class="hljs-built_in">entries_size</span>());<br>   m_nextIndex[server] = m_matchIndex[server] + <span class="hljs-number">1</span>;<br>   <span class="hljs-type">int</span> lastLogIndex = <span class="hljs-built_in">getLastLogIndex</span>();<br><br>   <span class="hljs-built_in">myAssert</span>(m_nextIndex[server] &lt;= lastLogIndex + <span class="hljs-number">1</span>,<br>            format(<span class="hljs-string">&quot;error msg:rf.nextIndex[%d] &gt; lastLogIndex+1, len(rf.logs) = %d   lastLogIndex&#123;%d&#125; = %d&quot;</span>, server,<br>                   m_logs.<span class="hljs-built_in">size</span>(), server, lastLogIndex));<br>   <span class="hljs-keyword">if</span> (*appendNums &gt;= <span class="hljs-number">1</span> + m_peers.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>) &#123;<br>     <span class="hljs-comment">// 可以commit了</span><br>     <span class="hljs-comment">// 两种方法保证幂等性，1.赋值为0 2.上面≥改为==</span><br><br>     *appendNums = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// todo https://578223592-laughing-halibut-wxvpggvw69qh99q4.github.dev/ 不断遍历来统计rf.commitIndex</span><br>     <span class="hljs-comment">// 改了好久！！！！！</span><br>     <span class="hljs-comment">// leader只有在当前term有日志提交的时候才更新commitIndex，因为raft无法保证之前term的Index是否提交</span><br>     <span class="hljs-comment">// 只有当前term有日志提交，之前term的log才可以被提交，只有这样才能保证“领导人完备性&#123;当选领导人的节点拥有之前被提交的所有log，当然也可能有一些没有被提交的&#125;”</span><br>     <span class="hljs-comment">// rf.leaderUpdateCommitIndex()</span><br>     <span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">entries_size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; args-&gt;<span class="hljs-built_in">entries</span>(args-&gt;<span class="hljs-built_in">entries_size</span>() - <span class="hljs-number">1</span>).<span class="hljs-built_in">logterm</span>() == m_currentTerm) &#123;<br>       <span class="hljs-built_in">DPrintf</span>(<br>           <span class="hljs-string">&quot;---------------------------tmp------------------------- 当前term有log成功提交，更新leader的m_commitIndex &quot;</span><br>           <span class="hljs-string">&quot;from&#123;%d&#125; to&#123;%d&#125;&quot;</span>,<br>           m_commitIndex, args-&gt;<span class="hljs-built_in">prevlogindex</span>() + args-&gt;<span class="hljs-built_in">entries_size</span>());<br><br>       m_commitIndex = std::<span class="hljs-built_in">max</span>(m_commitIndex, args-&gt;<span class="hljs-built_in">prevlogindex</span>() + args-&gt;<span class="hljs-built_in">entries_size</span>());<br>     &#125;<br>     <span class="hljs-built_in">myAssert</span>(m_commitIndex &lt;= lastLogIndex,<br>              format(<span class="hljs-string">&quot;[func-sendAppendEntries,rf&#123;%d&#125;] lastLogIndex:%d  rf.commitIndex:%d\n&quot;</span>, m_me, lastLogIndex,<br>                     m_commitIndex));<br>     <span class="hljs-comment">// fmt.Printf(&quot;[func-sendAppendEntries,rf&#123;%v&#125;] len(rf.logs):%v  rf.commitIndex:%v\n&quot;, rf.me, len(rf.logs),</span><br>     <span class="hljs-comment">// rf.commitIndex)</span><br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="raftsendrequestvote函数">Raft::sendRequestVote()函数</h3><p>函数总览:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Raft::sendRequestVote</span><span class="hljs-params">(<span class="hljs-type">int</span> server, std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; args, std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; reply,</span></span><br><span class="hljs-params"><span class="hljs-function">                           std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; votedNum)</span> </span>&#123;<br><br><br>    <span class="hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="hljs-built_in">RequestVote</span>(args.<span class="hljs-built_in">get</span>(),reply.<span class="hljs-built_in">get</span>());<br><br>    <span class="hljs-keyword">if</span> (!ok) &#123;<br>        <span class="hljs-keyword">return</span> ok;<span class="hljs-comment">//rpc通信失败就立即返回，避免资源消耗</span><br>    &#125;<br><br>    <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m_mtx)</span></span>;<br>    <span class="hljs-keyword">if</span>(reply-&gt;<span class="hljs-built_in">term</span>() &gt; m_currentTerm)&#123;<br>        <span class="hljs-comment">//回复的term比自己大，说明自己落后了，那么就更新自己的状态并且退出</span><br>        m_status = Follower; <span class="hljs-comment">//三变：身份，term，和投票</span><br>        m_currentTerm = reply-&gt;<span class="hljs-built_in">term</span>();<br>        m_votedFor = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//term更新了，那么这个term自己肯定没投过票，为-1</span><br>        <span class="hljs-built_in">persist</span>(); <span class="hljs-comment">//持久化</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( reply-&gt;<span class="hljs-built_in">term</span>()   &lt; m_currentTerm   ) &#123;<br>        <span class="hljs-comment">//回复的term比自己的term小，不应该出现这种情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!reply-&gt;<span class="hljs-built_in">votegranted</span>())&#123;  <span class="hljs-comment">//这个节点因为某些原因没给自己投票，没啥好说的，结束本函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <span class="hljs-comment">//给自己投票了</span><br>    *votedNum = *votedNum + <span class="hljs-number">1</span>; <span class="hljs-comment">//voteNum多一个</span><br>    <span class="hljs-keyword">if</span> (*votedNum &gt;=  m_peers.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//变成leader</span><br>        *votedNum = <span class="hljs-number">0</span>;   <span class="hljs-comment">//重置voteDNum，如果不重置，那么就会变成leader很多次，是没有必要的，甚至是错误的！！！</span><br><br>        <span class="hljs-comment">//第一次变成leader，初始化状态和nextIndex、matchIndex</span><br>        m_status = Leader;<br>        <span class="hljs-type">int</span> lastLogIndex =   <span class="hljs-built_in">getLastLogIndex</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;m_nextIndex.<span class="hljs-built_in">size</span>()  ; i++) &#123;<br>            m_nextIndex[i] = lastLogIndex + <span class="hljs-number">1</span> ;<span class="hljs-comment">//有效下标从1开始，因此要+1</span><br>            m_matchIndex[i] = <span class="hljs-number">0</span>;               <span class="hljs-comment">//每换一个领导都是从0开始，见论文的fig2</span><br>        &#125;<br>        <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;Raft::doHeartBeat, <span class="hljs-keyword">this</span>)</span></span>; <span class="hljs-comment">//马上向其他节点宣告自己就是leader</span><br>        t.<span class="hljs-built_in">detach</span>();<br><br>        <span class="hljs-built_in">persist</span>();  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先发送投票请求，如果失败直接返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="hljs-built_in">RequestVote</span>(args.<span class="hljs-built_in">get</span>(), reply.<span class="hljs-built_in">get</span>());<br><br><br><span class="hljs-keyword">if</span> (!ok) &#123;<br>  <span class="hljs-keyword">return</span> ok; <br>&#125;<br></code></pre></td></tr></table></figure><p>如果成功，加锁后对reply进行处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m_mtx)</span></span>;<br>  <span class="hljs-keyword">if</span> (reply-&gt;<span class="hljs-built_in">term</span>() &gt; m_currentTerm) &#123;<span class="hljs-comment">// 对方任期号比自己大，说明自己应该转变为follower</span><br>    m_status = Follower;  <span class="hljs-comment">// 三变：身份，term，和投票</span><br>    m_currentTerm = reply-&gt;<span class="hljs-built_in">term</span>();<br>    m_votedFor = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">persist</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply-&gt;<span class="hljs-built_in">term</span>() &lt; m_currentTerm) &#123;<span class="hljs-comment">// 对方任期号比自己小，说明是过期的回复</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>如果以上两种情况都不满足，那么就是合法的投票回复：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">if</span> (!reply-&gt;<span class="hljs-built_in">votegranted</span>()) &#123;<span class="hljs-comment">// 如果对方没有给自己投票，直接返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>*votedNum = *votedNum + <span class="hljs-number">1</span>;<span class="hljs-comment">// 投票数 + 1</span><br>  <span class="hljs-keyword">if</span> (*votedNum &gt;= m_peers.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 若得票已经大于一半，转变为leader</span><br>    <span class="hljs-comment">// 变成leader</span><br>    *votedNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (m_status == Leader) &#123;<br>      <span class="hljs-comment">// 如果已经是leader了，那么是就是了，不会进行下一步处理了k</span><br>      <span class="hljs-built_in">myAssert</span>(<span class="hljs-literal">false</span>,<br>               format(<span class="hljs-string">&quot;[func-sendRequestVote-rf&#123;%d&#125;]  term:&#123;%d&#125; 同一个term当两次领导，error&quot;</span>, m_me, m_currentTerm));<br>    &#125;<br>    <span class="hljs-comment">//之前不是leader，现在需要变为leader</span><br>    m_status = Leader;<br><br><br>    <span class="hljs-type">int</span> lastLogIndex = <span class="hljs-built_in">getLastLogIndex</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_nextIndex.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      m_nextIndex[i] = lastLogIndex + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 有效下标从1开始，因此要+1</span><br>      m_matchIndex[i] = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 每换一个领导都是从0开始，见fig2</span><br>    &#125;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;Raft::doHeartBeat, <span class="hljs-keyword">this</span>)</span></span>;  <span class="hljs-comment">// 马上向其他节点宣告自己就是leader</span><br>    t.<span class="hljs-built_in">detach</span>();<br><br>    <span class="hljs-built_in">persist</span>();<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="raftrequestvote函数">Raft::RequestVote()函数</h3><p>函数总览：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Raft::RequestVote</span><span class="hljs-params">( <span class="hljs-type">const</span> mprrpc::RequestVoteArgs *args, mprrpc::RequestVoteReply *reply)</span> </span>&#123;<br>    <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m_mtx)</span></span>;<br><br>    <span class="hljs-function">Defer <span class="hljs-title">ec1</span><span class="hljs-params">([<span class="hljs-keyword">this</span>]() -&gt; <span class="hljs-type">void</span> &#123; <span class="hljs-comment">//应该先持久化，再撤销lock，因此这个写在lock后面</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">this</span>-&gt;persist();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-comment">// 对args的term的三种情况分别进行处理，大于小于等于自己的term都是不同的处理</span><br>    <span class="hljs-comment">// reason: 出现网络分区，该竞选者已经OutOfDate(过时）</span><br>    <span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">term</span>() &lt; m_currentTerm) &#123; <span class="hljs-comment">// 为什么不是小于等于？</span><br>        reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>        reply-&gt;<span class="hljs-built_in">set_votestate</span>(Expire);<br>        reply-&gt;<span class="hljs-built_in">set_votegranted</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 论文fig2:右下角，如果任何时候rpc请求或者响应的term大于自己的term，更新term，并变成follower</span><br>    <span class="hljs-keyword">if</span> (args-&gt;<span class="hljs-built_in">term</span>() &gt; m_currentTerm) &#123;<br><br>        m_status = Follower;<br>        m_currentTerm = args-&gt;<span class="hljs-built_in">term</span>();<br>        m_votedFor = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">//重置定时器：收到leader的ae，开始选举，透出票</span><br>        <span class="hljs-comment">//  这时候更新了term之后，votedFor也要置为-1</span><br>    &#125;<br><br>    <span class="hljs-comment">//现在节点任期都是相同的(任期小的也已经更新到新的args的term了)</span><br>    <span class="hljs-comment">//要检查log的term和index是不是匹配的了</span><br>    <span class="hljs-type">int</span> lastLogTerm = <span class="hljs-built_in">getLastLogIndex</span>();<br>    <span class="hljs-comment">//只有没投票，且candidate的日志的新的程度 ≥ 接受者的日志新的程度 才会授票</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">UpToDate</span>(args-&gt;<span class="hljs-built_in">lastlogindex</span>(), args-&gt;<span class="hljs-built_in">lastlogterm</span>())) &#123;<br><br>        <span class="hljs-comment">//日志太旧了</span><br>        reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>        reply-&gt;<span class="hljs-built_in">set_votestate</span>(Voted);<br>        reply-&gt;<span class="hljs-built_in">set_votegranted</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br><span class="hljs-comment">//    当因为网络质量不好导致的请求丢失重发就有可能！！！！</span><br><span class="hljs-comment">//    因此需要避免重复投票</span><br>    <span class="hljs-keyword">if</span> (m_votedFor != <span class="hljs-number">-1</span> &amp;&amp; m_votedFor != args-&gt;<span class="hljs-built_in">candidateid</span>()) &#123;<br>        reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>        reply-&gt;<span class="hljs-built_in">set_votestate</span>(Voted);<br>        reply-&gt;<span class="hljs-built_in">set_votegranted</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//同意投票</span><br>        m_votedFor = args-&gt;<span class="hljs-built_in">candidateid</span>();<br>        m_lastResetElectionTime = <span class="hljs-built_in">now</span>();  <span class="hljs-comment">//认为必须要在投出票的时候才重置定时器，</span><br>        reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>        reply-&gt;<span class="hljs-built_in">set_votestate</span>(Normal);<br>        reply-&gt;<span class="hljs-built_in">set_votegranted</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志复制心跳">日志复制/心跳</h2><figure><imgsrc="/img/KV-Server%E8%AE%B0%E5%BD%95/Fqql9dbJTAJS5EA6pby_AIIw7mVo.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>可以从流程图看到，函数实现上我尽量将心跳日志复制的流程统一，方便理解和后期统一修改理解AppendEntry相关内容，snapshot的逻辑是类似的。</p></blockquote><p><strong>leaderHearBeatTicker</strong>:负责查看是否该发送心跳了，如果该发起就执行doHeartBeat。</p><p><strong>doHeartBeat</strong>:实际发送心跳，判断到底是构造需要发送的rpc，并多线程调用sendRequestVote处理rpc及其相应。</p><p><strong>sendAppendEntries</strong>:负责发送日志的RPC，在发送完rpc后还需要负责接收并处理对端发送回来的响应。</p><p><strong>leaderSendSnapShot</strong>:负责发送快照的RPC，在发送完rpc后还需要负责接收并处理对端发送回来的响应。</p><p><strong>AppendEntries</strong>:接收leader发来的日志请求，主要检验用于检查当前日志是否匹配并同步leader的日志到本机。</p><p><strong>InstallSnapshot</strong>:接收leader发来的快照请求，同步快照到本机。</p><h3 id="leaderhearbeatticker">leaderHearBeatTicker</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 负责查看是否该发送心跳了，如果该发起就执行doHeartBeat</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Raft::leaderHearBeatTicker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">auto</span> nowTime = <span class="hljs-built_in">now</span>();<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">auto</span> suitableSleepTime = std::chrono::<span class="hljs-built_in">milliseconds</span>(HeartBeatTimeout) + m_lastResetHearBeatTime - nowTime;<br>        m_mtx.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">if</span> (suitableSleepTime.<span class="hljs-built_in">count</span>() &lt; <span class="hljs-number">1</span>) &#123;<br>            suitableSleepTime = std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(suitableSleepTime);<br>        <span class="hljs-keyword">if</span> ((m_lastResetHearBeatTime - nowTime).<span class="hljs-built_in">count</span>() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//说明睡眠的这段时间有重置定时器，那么就没有超时，再次睡眠</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">doHeartBeat</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其基本逻辑和选举定时器electionTimeOutTicker一模一样，不一样之处在于设置的休眠时间不同，这里是根据HeartBeatTimeout来设置，而<code>electionTimeOutTicker中是根据getRandomizedElectionTimeout()</code>设置。</p><h3 id="doheartbeat"><strong>doHeartBeat</strong></h3><blockquote><p>这里目前逻辑写的不统一，发送快照leaderSendSnapShot和发送日志sendAppendEntries的rpc值的构造没有统一，且写在一坨。</p><p>可以抽离出来。目前先将就，关注主要逻辑。</p></blockquote><p>带注释版:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 发送心跳，判断到底是构造需要发送的rpc，并多线程调用sendRequestVote处理rpc及其相应</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Raft::doHeartBeat</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m_mtx)</span></span>;<br>    <span class="hljs-keyword">if</span> (m_status == Leader) &#123;<br>        <span class="hljs-keyword">auto</span> appendNums = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>); <span class="hljs-comment">//正确返回的节点的数量</span><br>        <span class="hljs-comment">//对Follower（除了自己外的所有节点发送AE）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_peers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == m_me)&#123; <span class="hljs-comment">//不对自己发送AE</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//日志压缩加入后要判断是发送快照还是发送AE</span><br>            <span class="hljs-keyword">if</span> (m_nextIndex[i] &lt;= m_lastSnapshotIncludeIndex) &#123;<br><span class="hljs-comment">// 要发送的日志已经被做成快照，必须发送快照了</span><br>                <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;Raft::leaderSendSnapShot, <span class="hljs-keyword">this</span>, i)</span></span>; <br>                t.<span class="hljs-built_in">detach</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 发送心跳，构造发送值</span><br>            <span class="hljs-comment">// 下面都是m_nextIndex[i] &gt; m_lastSnapshotIncludeIndex了</span><br>            <span class="hljs-type">int</span> preLogIndex = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> PrevLogTerm = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">getPrevLogInfo</span>(i, &amp;preLogIndex, &amp;PrevLogTerm);  <span class="hljs-comment">//获取本次发送的一系列日志的上一条日志的信息，以判断是否匹配</span><br>            std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; appendEntriesArgs = std::<span class="hljs-built_in">make_shared</span>&lt;mprrpc::AppendEntriesArgs&gt;();<br>            appendEntriesArgs-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br>            appendEntriesArgs-&gt;<span class="hljs-built_in">set_leaderid</span>(m_me);<br>            appendEntriesArgs-&gt;<span class="hljs-built_in">set_prevlogindex</span>(preLogIndex);<br>            appendEntriesArgs-&gt;<span class="hljs-built_in">set_prevlogterm</span>(PrevLogTerm);<br>            appendEntriesArgs-&gt;<span class="hljs-built_in">clear_entries</span>();<br>            appendEntriesArgs-&gt;<span class="hljs-built_in">set_leadercommit</span>(m_commitIndex);<br>            <span class="hljs-comment">// 作用是携带上prelogIndex的下一条日志及其之后的所有日志</span><br>            <span class="hljs-comment">//leader对每个节点发送的日志长短不一，但是都保证从prevIndex发送直到最后</span><br>            <span class="hljs-comment">// 注意这个preLogIndex和PrevLogTerm是对应follower的index和term</span><br>            <span class="hljs-keyword">if</span> (preLogIndex != m_lastSnapshotIncludeIndex) &#123;<span class="hljs-comment">// follower的preLogIndex &gt; leader快照的最后一条日志index,那么发送从preindex + 1一直到最后</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">getSlicesIndexFromLogIndex</span>(preLogIndex) + <span class="hljs-number">1</span>; j &lt; m_logs.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                    mprrpc::LogEntry *sendEntryPtr = appendEntriesArgs-&gt;<span class="hljs-built_in">add_entries</span>();<br>                    *sendEntryPtr = m_logs[j];  <br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// follower的preLogIndex == leader快照的最后一条日志index，等于要把m_logs的日志全发过去</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item: m_logs) &#123;<br>                    mprrpc::LogEntry *sendEntryPtr = appendEntriesArgs-&gt;<span class="hljs-built_in">add_entries</span>();<br>                    *sendEntryPtr = item;  <br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> lastLogIndex = <span class="hljs-built_in">getLastLogIndex</span>();<br>            <span class="hljs-comment">//初始化返回值</span><br>            <span class="hljs-type">const</span> std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; appendEntriesReply = std::<span class="hljs-built_in">make_shared</span>&lt;mprrpc::AppendEntriesReply&gt;();<br><br>            <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;Raft::sendAppendEntries, <span class="hljs-keyword">this</span>, i, appendEntriesArgs, appendEntriesReply,</span></span><br><span class="hljs-params"><span class="hljs-function">                          appendNums)</span></span>; <span class="hljs-comment">// 创建新线程并执行b函数，并传递参数</span><br>            t.<span class="hljs-built_in">detach</span>();<br>        &#125;<br>        m_lastResetHearBeatTime = <span class="hljs-built_in">now</span>(); <span class="hljs-comment">//leader发送心跳，重置心跳时间，</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加速日志匹配">加速日志匹配</h3><p>​ 这部分在<code>AppendEntries</code> 函数里，涉及代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不匹配，不匹配不是一个一个往前，而是有优化加速</span><br><span class="hljs-comment">// PrevLogIndex 长度合适，但是不匹配，因此往前寻找 矛盾的term的第一个元素</span><br><span class="hljs-comment">// 为什么该term的日志都是矛盾的呢？也不一定都是矛盾的，只是这么优化减少rpc而已</span><br><span class="hljs-comment">// ？什么时候term会矛盾呢？很多情况，比如leader接收了日志之后马上就崩溃等等</span><br>reply-&gt;<span class="hljs-built_in">set_updatenextindex</span>(args-&gt;<span class="hljs-built_in">prevlogindex</span>());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = args-&gt;<span class="hljs-built_in">prevlogindex</span>(); index &gt;= m_lastSnapshotIncludeIndex; --index) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getLogTermFromLogIndex</span>(index) != <span class="hljs-built_in">getLogTermFromLogIndex</span>(args-&gt;<span class="hljs-built_in">prevlogindex</span>())) &#123;<br>        reply-&gt;<span class="hljs-built_in">set_updatenextindex</span>(index + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br>reply-&gt;<span class="hljs-built_in">set_success</span>(<span class="hljs-literal">false</span>);<br>reply-&gt;<span class="hljs-built_in">set_term</span>(m_currentTerm);<br><br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>如果日志不匹配的话可以一个一个往前的倒退。但是这样的话可能会设计很多个rpc之后才能找到匹配的日志，那么就一次多倒退几个数。</p><p>倒退几个呢？这里认为如果某一个日志不匹配，那么这<strong>一个日志所在的term的所有日志大概率都不匹配</strong>，那么就倒退到最后一个日志所在的term的最后那个命令。</p><h2 id="持久化">持久化</h2><p>持久化就是把不能丢失的数据保存到磁盘。</p><p>持久化的内容为两部分：</p><ol type="1"><li>raft节点的部分信息；<ol type="1"><li><code>m_currentTerm</code>：当前节点的Term，避免重复到一个Term，可能会遇到重复投票等问题。</li><li><code>m_votedFor</code>：当前Term给谁投过票，避免故障后重复投票。</li><li><code>m_logs</code> ：raft节点保存的全部的日志信息。</li></ol></li><li>kvDb的快照<ol type="1"><li><code>m_lastSnapshotIncludeIndex</code>：快照的信息，快照最新包含哪个日志Index</li><li><code>m_lastSnapshotIncludeTerm</code>：快照的信息，快照最新包含哪个日志Term，与m_lastSnapshotIncludeIndex是对应的。</li></ol></li></ol><p>不妨想一想，其他的信息为什么不用持久化，比如说：身份、commitIndex、applyIndex等等。</p><blockquote><p>applyIndex不持久化是经典raft的实现，在一些工业实现上可能会优化，从而持久化。</p><p>即applyIndex不持久化不会影响“共识”。</p></blockquote><p>Snapshot是kvDb的快照，也可以看成是日志，因此:全部的日志 = m_logs +snapshot</p><p>因为Snapshot是kvDB生成的，kvDB肯定不知道raft的存在，而什么term、什么日志Index都是raft才有的概念，因此snapshot中肯定没有term和index信息。</p><p>所以需要raft自己来保存这些信息。</p><p>故，快照与m_logs联合起来理解即可。</p><h3id="为什么要持久化这些内容"><strong>为什么要持久化这些内容？</strong></h3><p>两部分原因：共识安全、优化。</p><p>除了snapshot相关的部分，其他部分都是为了共识安全。</p><p>而snapshot是因为日志一个一个的叠加，会导致最后的存储非常大，因此使用snapshot来压缩日志。</p><blockquote><p>不严谨的一种理解方式：</p><p>为什么snashot可以压缩日志？</p><p>日志是追加写的，对于一个变量的重复修改可能会重复保存，理论上对一个变量的反复修改会导致日志不断增大。</p><p>而snapshot是原地写，即只保存一个变量最后的值，自然所需要的空间就小了。</p></blockquote><h3 id="什么时候持久化">什么时候持久化</h3><p>需要持久化的内容发送改变的时候就要注意持久化。</p><p>比如<code>term</code> 增加，日志增加等等。</p><p>具体的可以查看代码仓库中的<code>void Raft::persist()</code>相关内容。</p><h3 id="谁来调用持久化">谁来调用持久化</h3><p>谁来调用都可以，只要能保证需要持久化的内容能正确持久化。</p><p>仓库代码中选择的是raft类自己来完成持久化。因为raft类最方便感知自己的term之类的信息有没有变化。</p><p>注意，虽然持久化很耗时，但是持久化这些内容的时候不要放开锁，以防其他线程改变了这些值，导致其它异常。</p><h3id="具体怎么实现持久化使用哪个函数持久化">具体怎么实现持久化|使用哪个函数持久化</h3><p>其实持久化是一个非常难的事情，因为持久化需要考虑：速度、大小、二进制安全。</p><p>因此仓库实现目前采用的是使用boost库中的持久化实现，将需要持久化的数据序列化转成<code>std::string</code>类型再写入磁盘。</p><blockquote><p>当然其他的序列化方式也少可行的。</p><p>可以看到这一块还是有优化空间的，因此可以尝试对这里优化优化。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">Raft::persistData</span><span class="hljs-params">()</span> </span>&#123;<br>    BoostPersistRaftNode boostPersistRaftNode;<br>    boostPersistRaftNode.m_currentTerm = m_currentTerm;<br>    boostPersistRaftNode.m_votedFor = m_votedFor;<br>    boostPersistRaftNode.m_lastSnapshotIncludeIndex = m_lastSnapshotIncludeIndex;<br>    boostPersistRaftNode.m_lastSnapshotIncludeTerm = m_lastSnapshotIncludeTerm;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: m_logs) &#123;<br>        boostPersistRaftNode.m_logs.<span class="hljs-built_in">push_back</span>(item.<span class="hljs-built_in">SerializeAsString</span>());<br>    &#125;<br><br>    std::stringstream ss;<br>    boost::<span class="hljs-function">archive::text_oarchive <span class="hljs-title">oa</span><span class="hljs-params">(ss)</span></span>;<br>    oa&lt;&lt;boostPersistRaftNode;<br>    <span class="hljs-keyword">return</span> ss.<span class="hljs-built_in">str</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kvserver怎么处理外部请求">kvServer怎么处理外部请求</h2><figure><imgsrc="/img/KV-Server%E8%AE%B0%E5%BD%95/FnyTjtal6byZPaG1eF69NKN57CbM.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图中是raftServer，这里叫成kvServer，是一样的。</p><p>kvServer其实是个中间组件，负责沟通kvDB和raft节点。</p><p>那么外部请求怎么打进来呢？</p><p>哦吼，当然是Server来负责呀，加入后变成了：</p><figure><imgsrc="/img/KV-Server%E8%AE%B0%E5%BD%95/Ft_negDcbLW-DMJbvTGxxGliTxCJ.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>kvServer怎么和上层kvDB沟通，怎么和下层raft节点沟通？</strong></p><p>通过这两个成员变量实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt; &gt; applyChan; <span class="hljs-comment">//kvServer和raft节点的通信管道</span><br>std::unordered_map&lt;std::string, std::string&gt; m_kvDB; <span class="hljs-comment">//kvDB，用unordered_map来替代</span><br></code></pre></td></tr></table></figure><p>kvDB：使用的是unordered_map来代替上层的kvDB，因此没啥好说的.</p><p>raft节点：其中<code>LockQueue</code>是一个并发安全的队列，这种方式其实是模仿的go中的channel机制。</p><p>在raft类中<ahref="https://github.com/youngyangyang04/KVstorageBaseRaft-cpp/blob/e400068e64c3ee01f4e72039dfa9c0f198363441/src/raftCore/include/raft.h#L59C5-L59C56">这里</a>可以看到，raft类中也拥有一个applyChan，kvSever和raft类都持有同一个applyChan，来完成相互的通信。</p><p>从上面的结构图中可以看到kvServer负责与外部clerk通信。</p><p>那么一个外部请求的处理可以简单的看成两步：</p><ol type="1"><li>接收外部请求。</li><li>本机内部与raft和kvDB协商如何处理该请求。</li><li>返回外部响应。</li></ol><h3 id="接收与响应外部请求"><strong>接收与响应外部请求</strong></h3><p>对于1和3，请求和返回的操作我们可以通过http、自定义协议等等方式实现，但是既然我们已经写出了rpc通信的一个简单的实现（源代码可见：<ahref="https://github.com/youngyangyang04/KVstorageBaseRaft-cpp/tree/main/example/rpcExample">这里</a>），那就使用rpc来实现吧。</p><p>而且rpc可以直接完成请求和响应这一步，后面就不用考虑外部通信的问题了，好好处理好本机的流程即可。</p><p>相关函数是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutAppend</span><span class="hljs-params">(google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> ::raftKVRpcProctoc::PutAppendArgs *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ::raftKVRpcProctoc::PutAppendReply *response,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ::google::protobuf::Closure *done)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Get</span><span class="hljs-params">(google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">const</span> ::raftKVRpcProctoc::GetArgs *request,</span></span><br><span class="hljs-params"><span class="hljs-function">             ::raftKVRpcProctoc::GetReply *response,</span></span><br><span class="hljs-params"><span class="hljs-function">             ::google::protobuf::Closure *done)</span> <span class="hljs-keyword">override</span></span>;<br><br></code></pre></td></tr></table></figure><p>见名知意，请求分成两种：get和put（也就是set）。</p><p>如果是putAppend，clerk中就调用<code>PutAppend</code> 的rpc。</p><p>如果是Get，clerk中就调用<code>Get</code> 的rpc。</p><h3 id="与raft节点沟通">与raft节点沟通</h3><p>在正式开始之前我们必须要先了解 <strong>线性一致性</strong>的相关概念。建议阅读<ahref="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-07-raft2/7.6-qiang-yi-zhi-linearizability">线性一致性</a>.</p><p>这里讲一讲raft如何做的。</p><p>每个 client都需要一个唯一的标识符，它的每个不同命令需要有一个顺序递增的commandId，clientId 和这个 commandId，clientId可以唯一确定一个不同的命令，从而使得各个 raft节点可以记录保存各命令是否已应用以及应用以后的结果。</p><p>即对于每个clinet，都有一个唯一标识，对于每个client，只执行递增的命令。</p><h4id="在保证线性一致性的情况下如何写kv">在保证线性一致性的情况下如何写kv</h4><p>具体的思想在上面已经讲过，这里展示一下关键的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//  chForRaftIndex是一个有锁队列</span><br><span class="hljs-keyword">if</span> (!chForRaftIndex-&gt;<span class="hljs-built_in">timeOutPop</span>(CONSENSUS_TIMEOUT, &amp;raftCommitOp)) &#123;<span class="hljs-comment">//通过超时pop来限定命令执行时间，如果超过时间还没拿到消息说明命令执行超时了。</span><br><br>        <span class="hljs-keyword">if</span> (ifRequestDuplicate(op.ClientId, op.RequestId)) &#123;<br>            reply-&gt;<span class="hljs-built_in">set_err</span>(OK);<span class="hljs-comment">// 超时了,但因为是重复的请求，返回ok，实际上就算没有超时，在真正执行的时候也要判断是否重复</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            reply-&gt;<span class="hljs-built_in">set_err</span>(ErrWrongLeader);   <span class="hljs-comment">///这里返回这个的目的让clerk重新尝试</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//没超时，命令可能真正的在raft集群执行成功了。</span><br>        <span class="hljs-keyword">if</span> (raftCommitOp.ClientId == op.ClientId &amp;&amp;<br>            raftCommitOp.RequestId == op.RequestId) &#123;   <span class="hljs-comment">//可能发生leader的变更导致日志被覆盖，因此必须检查</span><br>            reply-&gt;<span class="hljs-built_in">set_err</span>(OK);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            reply-&gt;<span class="hljs-built_in">set_err</span>(ErrWrongLeader);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，这里的命令执行成功是指：本条命令在整个raft集群达到同步的状态，而不是一台机器上的raft保存了该命令。</p><p>全部代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 处理来自clerk的Get RPC</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KvServer::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> raftKVRpcProctoc::GetArgs *args, raftKVRpcProctoc::GetReply *reply)</span> </span>&#123;<br>    Op op;<br>    op.Operation = <span class="hljs-string">&quot;Get&quot;</span>;<br>    op.Key = args-&gt;<span class="hljs-built_in">key</span>();<br>    op.Value = <span class="hljs-string">&quot;&quot;</span>;<br>    op.ClientId = args-&gt;<span class="hljs-built_in">clientid</span>();<br>    op.RequestId = args-&gt;<span class="hljs-built_in">requestid</span>();<br><br><br>    <span class="hljs-type">int</span> raftIndex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> _ = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">bool</span> isLeader = <span class="hljs-literal">false</span>;<br>    m_raftNode-&gt;<span class="hljs-built_in">Start</span>(op, &amp;raftIndex, &amp;_, &amp;isLeader);<span class="hljs-comment">//raftIndex：raft预计的logIndex ，虽然是预计，但是正确情况下是准确的，op的具体内容对raft来说 是隔离的</span><br><br>    <span class="hljs-keyword">if</span> (!isLeader) &#123;<br>        reply-&gt;<span class="hljs-built_in">set_err</span>(ErrWrongLeader);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// create waitForCh</span><br>    m_mtx.<span class="hljs-built_in">lock</span>();<br><br>    <span class="hljs-keyword">if</span> (waitApplyCh.<span class="hljs-built_in">find</span>(raftIndex) == waitApplyCh.<span class="hljs-built_in">end</span>()) &#123;<br>        waitApplyCh.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(raftIndex, <span class="hljs-keyword">new</span> <span class="hljs-built_in">LockQueue</span>&lt;Op&gt;()));<br>    &#125;<br>    <span class="hljs-keyword">auto</span> chForRaftIndex = waitApplyCh[raftIndex];<br><br>    m_mtx.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">//直接解锁，等待任务执行完成，不能一直拿锁等待</span><br><br><br>    <span class="hljs-comment">// timeout</span><br>    Op raftCommitOp;<br><br>    <span class="hljs-keyword">if</span> (!chForRaftIndex-&gt;<span class="hljs-built_in">timeOutPop</span>(CONSENSUS_TIMEOUT, &amp;raftCommitOp)) &#123;<br>        <span class="hljs-type">int</span> _ = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">bool</span> isLeader = <span class="hljs-literal">false</span>;<br>        m_raftNode-&gt;<span class="hljs-built_in">GetState</span>(&amp;_, &amp;isLeader);<br><br>        <span class="hljs-keyword">if</span> (ifRequestDuplicate(op.ClientId, op.RequestId) &amp;&amp; isLeader) &#123;<br>            <span class="hljs-comment">//如果超时，代表raft集群不保证已经commitIndex该日志，但是如果是已经提交过的get请求，是可以再执行的。</span><br>            <span class="hljs-comment">// 不会违反线性一致性</span><br>            std::string value;<br>            <span class="hljs-type">bool</span> exist = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">ExecuteGetOpOnKVDB</span>(op, &amp;value, &amp;exist);<br>            <span class="hljs-keyword">if</span> (exist) &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(OK);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(ErrNoKey);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            reply-&gt;<span class="hljs-built_in">set_err</span>(ErrWrongLeader);  <span class="hljs-comment">//返回这个，其实就是让clerk换一个节点重试</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//raft已经提交了该command（op），可以正式开始执行了</span><br><span class="hljs-comment">//        DPrintf(&quot;[WaitChanGetRaftApplyMessage&lt;--]Server %d , get Command &lt;-- Index:%d , ClientId %d, RequestId %d, Opreation %v, Key :%v, Value :%v&quot;, kv.me, raftIndex, op.ClientId, op.RequestId, op.Operation, op.Key, op.Value)</span><br>        <span class="hljs-comment">//todo 这里还要再次检验的原因：感觉不用检验，因为leader只要正确的提交了，那么这些肯定是符合的</span><br>        <span class="hljs-keyword">if</span> (raftCommitOp.ClientId == op.ClientId &amp;&amp; raftCommitOp.RequestId == op.RequestId) &#123;<br>            std::string value;<br>            <span class="hljs-type">bool</span> exist = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">ExecuteGetOpOnKVDB</span>(op, &amp;value, &amp;exist);<br>            <span class="hljs-keyword">if</span> (exist) &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(OK);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(ErrNoKey);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            reply-&gt;<span class="hljs-built_in">set_err</span>(ErrWrongLeader);<br>        &#125;<br>    &#125;<br>    m_mtx.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">//todo 這個可以先弄一個defer，因爲刪除優先級並不高，先把rpc發回去更加重要</span><br>    <span class="hljs-keyword">auto</span> tmp = waitApplyCh[raftIndex];<br>    waitApplyCh.<span class="hljs-built_in">erase</span>(raftIndex);<br>    <span class="hljs-keyword">delete</span> tmp;<br>    m_mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4id="在保证线性一致性的情况下如何读kv">在保证线性一致性的情况下如何读kv</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 同样使用有锁队列判断超时</span><br><span class="hljs-keyword">if</span> (!chForRaftIndex-&gt;<span class="hljs-built_in">timeOutPop</span>(CONSENSUS_TIMEOUT, &amp;raftCommitOp)) &#123;<br>        <span class="hljs-type">int</span> _ = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">bool</span> isLeader = <span class="hljs-literal">false</span>;<br>        m_raftNode-&gt;<span class="hljs-built_in">GetState</span>(&amp;_, &amp;isLeader);<br><br>        <span class="hljs-keyword">if</span> (ifRequestDuplicate(op.ClientId, op.RequestId) &amp;&amp; isLeader) &#123;<br>            <span class="hljs-comment">//如果超时，代表raft集群不保证已经commitIndex该日志，但是如果是已经提交过的get请求，是可以再执行的。</span><br>            <span class="hljs-comment">// 不会违反线性一致性</span><br>            std::string value;<br>            <span class="hljs-type">bool</span> exist = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">ExecuteGetOpOnKVDB</span>(op, &amp;value, &amp;exist);<br>            <span class="hljs-keyword">if</span> (exist) &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(OK);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(ErrNoKey);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            reply-&gt;<span class="hljs-built_in">set_err</span>(ErrWrongLeader);  <span class="hljs-comment">//返回这个，其实就是让clerk换一个节点重试</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//raft已经提交了该command（op），可以正式开始执行了</span><br>        <span class="hljs-comment">//todo 这里感觉不用检验，因为leader只要正确的提交了，那么这些肯定是符合的</span><br>        <span class="hljs-keyword">if</span> (raftCommitOp.ClientId == op.ClientId &amp;&amp; raftCommitOp.RequestId == op.RequestId) &#123;<br>            std::string value;<br>            <span class="hljs-type">bool</span> exist = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">ExecuteGetOpOnKVDB</span>(op, &amp;value, &amp;exist);<br>            <span class="hljs-keyword">if</span> (exist) &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(OK);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                reply-&gt;<span class="hljs-built_in">set_err</span>(ErrNoKey);<br>                reply-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        &#125;<br>    <br></code></pre></td></tr></table></figure><p>个人感觉读与写不同的是，读就算操作过也可以重复执行，不会违反线性一致性。</p><p>因为毕竟不会改写数据库本身的内容。</p><p><strong>以GET请求为例看一看流程</strong>：</p><p>以一个读操作为例看一看流程：</p><p>首先外部RPC调用GET，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KvServer::Get</span><span class="hljs-params">(google::protobuf::RpcController *controller, <span class="hljs-type">const</span> ::raftKVRpcProctoc::GetArgs *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ::raftKVRpcProctoc::GetReply *response, ::google::protobuf::Closure *done)</span> </span>&#123;<br>    KvServer::<span class="hljs-built_in">Get</span>(request,response);<br>    done-&gt;<span class="hljs-built_in">Run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是根据请求参数生成Op，生成Op是因为raft和raftServer沟通用的是类似于go中的channel的机制，然后向下执行即可。</p><p><strong>注意：在这个过程中需要判断当前节点是不是leader，如果不是leader的话就返回<code>ErrWrongLeader</code>，让其他clerk换一个节点尝试。</strong></p><h2 id="rpc如何实现调用">RPC如何实现调用</h2><p>这里以Raft类为例讲解下如何使用rpc远程调用的。</p><ol type="1"><li><p>写protoc文件，并生成对应的文件，Raft类使用的protoc文件和生成的文件见：<ahref="https://github.com/youngyangyang04/KVstorageBaseRaft-cpp/tree/main/src/raftRpcPro">这里</a></p></li><li><p>继承生成的文件的类<code>class Raft : public raftRpcProctoc::raftRpc</code></p></li><li><p>重写rpc方法即可：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 重写基类方法,因为rpc远程调用真正调用的是这个方法</span><br>    <span class="hljs-comment">//序列化，反序列化等操作rpc框架都已经做完了，因此这里只需要获取值然后真正调用本地方法即可。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AppendEntries</span><span class="hljs-params">(google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> ::raftRpcProctoc::AppendEntriesArgs *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                       ::raftRpcProctoc::AppendEntriesReply *response,</span></span><br><span class="hljs-params"><span class="hljs-function">                       ::google::protobuf::Closure *done)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InstallSnapshot</span><span class="hljs-params">(google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> ::raftRpcProctoc::InstallSnapshotRequest *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                         ::raftRpcProctoc::InstallSnapshotResponse *response,</span></span><br><span class="hljs-params"><span class="hljs-function">                         ::google::protobuf::Closure *done)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequestVote</span><span class="hljs-params">(google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> ::raftRpcProctoc::RequestVoteArgs *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                     ::raftRpcProctoc::RequestVoteReply *response,</span></span><br><span class="hljs-params"><span class="hljs-function">                     ::google::protobuf::Closure *done)</span> <span class="hljs-keyword">override</span></span>;<br></code></pre></td></tr></table></figure><h2 id="一些问题思考">一些问题思考</h2><h3 id="m_nextindex和m_matchindex">m_nextIndex和m_matchIndex</h3><p><code>m_nextIndex</code>保存leader下一次应该从哪一个日志开始发送给follower；<code>m_matchIndex</code>表示follower在哪一个日志是已经匹配了的（由于日志安全性，某一个日志匹配，那么这个日志及其之前的日志都是匹配的）。</p><p><code>m_nextIndex</code> 与<code>m_matchIndex</code>是否有冗余，即使用一个<code>m_nextIndex</code> 可以吗？</p><p>显然是不行的，<code>m_nextIndex</code>的作用是用来寻找<code>m_matchIndex</code>，不能直接取代。我们可以从这两个变量的变化看，在当选leader后，<code>m_nextIndex</code>初始化为最新日志index，<code>m_matchIndex</code>初始化为0，如果日志不匹配，那么<code>m_nextIndex</code>就会不断的缩减，直到遇到匹配的日志，这时候<code>m_nextIndex</code>应该一直为<code>m_matchIndex+1</code> 。</p><p><strong>如果一直不发生故障，那么后期m_nextIndex就没有太大作用了，但是raft考虑需要考虑故障的情况，因此需要使用两个变量。</strong></p><h3id="锁能否在其中的某个地方提前放锁或者使用多把锁来尝试提升性能">锁，能否在其中的某个地方提前放锁，或者使用多把锁来尝试提升性能？</h3><h3id="多线程发送能不能直接在doheartbeat或者doelection函数里面直接一个一个发送消息呢">多线程发送，能不能直接在doHeartBeat或者doElection函数里面直接一个一个发送消息呢？</h3><h3 id="可以有的优化空间">可以有的优化空间</h3><ol type="1"><li>线程池，而不是每次rpc都不断地创建新线程</li><li>日志</li><li>从节点读取日志</li></ol><h2 id="面试问题">面试问题</h2><h3 id="raft算法的基本原理"><strong>Raft算法的基本原理</strong></h3><p><strong>回答要点</strong>：解释Raft算法的基本工作原理，包括领导者选举、日志复制和安全性保障。</p><p><strong>示例回答</strong>：</p><p>Raft算法是一种分布式算法，旨在解决分布式系统中的一致性问题，相对于Paxos算法而言更易于理解和实现。</p><p>Raft算法将系统中的所有节点分为三类角色：领导者（<code>leader</code>）、跟随者（<code>follower</code>）和候选人（<code>candidate</code>）。其选举机制确保系统中的一个节点被选为领导者（<code>leader</code>），领导者负责处理客户端的请求，并将更新复制到其他节点。</p><p>Raft算法的基本原理包括以下几个关键步骤：</p><ol type="1"><li>领导者选举（LeaderElection）：在系统启动时或者当前领导者失效时，节点会发起选举过程。节点会在一个随机的超时时间内等待收到来自其他节点的心跳消息。如果在超时时间内没有收到心跳消息，节点就会成为候选人并发起选举。候选人向其他节点发送投票请求，并在得到大多数节点的投票后成为新的领导者。</li><li>日志复制（LogReplication）：一旦领导者选举完成，新的领导者就会接收客户端的请求，并将更新的日志条目复制到其他节点。当大多数节点都成功复制了这些日志条目时，更新被认为是提交的，并且可以应用到节点的状态机中。</li><li>安全性（Safety）：Raft算法通过确保在选举中只有一个领导者（单一领导者）、大多数节点的一致性以及只有领导者可以处理客户端请求等方式保证分布式系统的安全性。</li></ol><p>通过以上机制，Raft算法确保了分布式系统中的一致性、可用性和分区容错性。</p><p>注意：如果这么回答如果面试官懂一些分布式算法的话，那么后续可能会提问Raft与其他分布式算法的关系。</p><h3 id="领导者选举">领导者选举</h3><p><strong>回答要点</strong>：这里最好结合前面几个章节的流程图，结合自己理解回答。</p><p><strong>示例回答</strong>：</p><figure><imgsrc="/img/KV-Server%E8%AE%B0%E5%BD%95/FpAdl9k9XteDltQkNaxL2k_eU1UD.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Raft中的领导者选举过程如下：</p><ol type="1"><li><strong>候选人状态（Candidate State）</strong>：</li><li>节点在没有检测到领导者的情况下成为候选人，并将自己的任期编号（term）增加1。</li><li>候选人向其他节点发送投票请求，并请求其他节点投票支持自己成为新的领导者。</li><li>如果候选人在规定时间内收到了大多数节点的选票支持（即获得了大多数节点的投票），则成为新的领导者。</li><li><strong>选举过程（Election Process）</strong>：</li><li>在发起选举后，候选人会等待一定的随机时间（选举超时时间）来收集其他节点的投票。</li><li>如果在这个超时时间内没有收到大多数节点的选票，候选人将会重新开始一个新的选举周期，<strong>增加自己的任期编号，并再次发起选举</strong>。</li><li><strong>投票过程（Voting Process）</strong>：</li><li>其他节点收到来自候选人的投票请求后，会检查自己的当前任期编号。如果候选人的任期编号比自己的大，则投票支持候选人，并更新自己的任期编号为候选人的任期编号。</li><li>如果其他节点已经投票给了另一个候选人，或者已经投票给了当前领导者，它将拒绝投票。</li><li><strong>领导者选举完成（Leader Election Complete）</strong>：</li><li>如果候选人收到了大多数节点的投票支持，它就会成为新的领导者。</li><li>新的领导者会开始发送心跳消息以维持其领导地位，并开始进行日志复制操作。</li></ol><h3id="在什么情况下会触发领导者选举">在什么情况下会触发领导者选举？</h3><p><strong>回答要点</strong>：一个节点只要长时间没有收到符合条件的leader发送的心跳就会认为leader掉线，就会发起选举。</p><p><strong>示例回答</strong>：</p><p>在Raft算法中，领导者选举会在以下情况下触发：</p><ol type="1"><li>当系统启动时，所有节点都处于初始状态，没有领导者。</li><li>当领导者节点因网络分区、宕机或其他原因失效时，导致系统中没有活跃的领导者。</li><li>当节点故障恢复或者被网络分区时，它可能会检测到当前没有领导者，因此会成为候选人并发起选举。</li></ol><h3 id="日志复制"><strong>日志复制</strong></h3><p><strong>Raft是如何通过日志复制来保证数据一致性的？</strong></p><p><strong>回答要点</strong>：主要是两个机制（特点）：</p><p>1.Leader AppendEntries：领导者追加日志条目，即只<strong>有leader可以接受外部请求并将请求打包成日志</strong>，并向follower同步自己的日志，这样保证提交过的日志不会被覆盖掉。</p><p>2.commit机制，领导者发现<strong>大多数节点</strong>都已经成功复制了某个日志条目后，该日志条目被视为已经提交，从而保证了数据的一致性。</p><p><strong>示例回答：</strong></p><p>Raft算法通过日志复制来确保数据一致性。在Raft中，每个节点都维护一个日志（log）来记录状态机中的操作指令。领导者负责接收客户端的写请求，将操作指令追加到自己的日志中，并将这些操作指令发送给其他节点，要求它们复制这些日志条目。</p><p>以下是Raft通过日志复制来保证数据一致性的基本流程：</p><ol type="1"><li><strong>Leader Append Entries（领导者追加日志条目）</strong>：</li><li>领导者接收到客户端的写请求后，将这些操作指令追加到自己的日志中。</li><li>领导者将这些操作指令组织成一个日志条目（logentry），并向其他节点发送一个追加日志条目的请求（Append EntriesRPC）。</li><li><strong>Follower Log Replication（跟随者日志复制）</strong>：</li><li>跟随者节点接收到领导者发送的追加日志条目的请求后，会按照领导者的日志条目顺序将这些日志条目追加到自己的日志中。</li><li>如果跟随者节点成功复制了这些日志条目，则向领导者发送成功响应（Response）；如果由于某种原因（例如网络故障）导致复制失败，则向领导者发送失败响应。</li><li><strong>Commit（提交）</strong>：</li><li>当领导者发现大多数节点都已经成功复制了某个日志条目后，该日志条目被视为已经提交。</li><li>领导者将提交的日志条目应用到自己的状态机中，以执行相应的操作指令。</li></ol><h3 id="安全性保障"><strong>安全性保障</strong></h3><p><strong>Raft是如何确保安全性的？讨论一致性、可用性和分区容错性之间的权衡。</strong></p><p><strong>回答要点</strong>：这里主要是想考察分布式CAP理论的一个关键：CAP中如果发生故障，只能CP和AP二选一，无法满足CAP的三角，而Raft选择的是CP，即满足一致性。</p><p><strong>示例回答：</strong></p><p>在权衡一致性、可用性和分区容错性时，Raft算法倾向于优先保证一致性和分区容错性。它通过保证大多数节点的确认和限制领导者选举条件来确保一致性，通过选举机制和日志复制来保证分区容错性。同时，Raft也兼顾了系统的可用性，确保在领导者失效后能够快速进行新的领导者选举，并继续提供服务。</p><h4 id="选举超时"><strong>选举超时：</strong></h4><h5id="什么是选举超时它的作用是什么">什么是选举超时？它的作用是什么？</h5><p><strong>回答要点：</strong>follower和candidate都会有选举超时的机制。</p><p>在follower时：选举超时的意义是发起选举，变成candidate；</p><p>在candidate时：candidate会选举超时，如果选举成功就会变成leader；如果选举失败就会变成candidate（选举超时）或者follower（发现合适的leader）。那么选举超时的作用就很明显了，防止无止境的等待导致所有人都成不了leader。</p><p>拓展：想一想为什么选举超时时间要每次随机设置而不设置成一个固定的值？？？</p><p><strong>示例回答：</strong></p><p>选举超时的作用包括：</p><ol type="1"><li><strong>触发领导者选举</strong>：选举超时用于在当前没有活跃领导者或者领导者失效时触发新的领导者选举。当节点在选举超时时间内没有收到来自当前领导者的心跳消息时，会成为候选人并发起选举过程。</li><li><strong>防止脑裂（Split-Brain）</strong>：选举超时帮助避免了系统中出现多个领导者的情况，从而避免了脑裂问题的发生。如果系统中的节点在选举超时时间内没有收到来自当前领导者的心跳消息，它们会同时成为候选人并发起选举，但只有一个候选人最终会获得大多数节点的选票，成为新的领导者。</li><li><strong>确保领导者切换的及时性</strong>：选举超时可以确保在领导者失效后，系统能够及时地启动新的领导者选举过程，从而减少服务中断的时间，提高系统的可用性。</li></ol><h3 id="选举超时的时间是如何设置的">选举超时的时间是如何设置的？</h3><p><strong>回答要点：</strong>回答要点在上个问题的拓展里面，大家可以先想想。答案是：一个一定范围内的随机值，其要根据心跳时间，rpc延迟，数据操作延迟综合考虑。</p><p>范围：一般来说选举超时时间要大于一次完整心跳的日志同步处理时间。</p><p>为何随机：选举超时的目的是防止无止境的等待导致所有人都成不了leader，如果超时时间又一样，那么大家又一起选举，又会不断循环，那么一个随机值可以让某些节点早点重新发起选举，防止大家一起选举导致死循环。</p><p><strong>示例回答：</strong></p><p>选举超时时间的设置通常包括以下考虑因素：</p><ol type="1"><li><strong>网络延迟和稳定性</strong>：选举超时时间需要足够长以允许节点在正常情况下能够收到来自领导者的心跳消息。考虑到网络的延迟和不稳定性，超时时间应该设置得足够长，以避免因网络延迟而误判领导者失效。</li><li><strong>系统负载和响应速度</strong>：选举超时时间也应考虑系统的负载情况和响应速度。如果系统负载较重或者节点的处理速度较慢，可能需要将选举超时时间设置得稍长一些，以允许节点有足够的时间处理收到的消息。</li><li><strong>避免脑裂问题</strong>：为了避免系统中出现多个领导者导致的脑裂问题，选举超时时间应该设置得足够随机化，以确保不同节点不会在同一时间内触发选举。</li></ol><h3 id="日志条目的提交"><strong>日志条目的提交</strong></h3><p><strong>Raft中的日志条目是如何提交的？</strong></p><p><strong>回答要点：</strong>要半数以上的节点（包括leader）接收了这个日志，那么才能提交（commit），后续才能apply到状态机。</p><p><strong>示例回答：</strong></p><ol type="1"><li><strong>Leader接收客户端请求</strong>：<ul><li>当客户端向Raft系统提交请求时，请求会首先发送到Raft集群中的Leader节点。</li></ul></li><li><strong>Leader将请求转换为日志条目</strong>：<ul><li>Leader将接收到的客户端请求转换为一条日志条目，并附加到其本地日志中。</li></ul></li><li><strong>Leader广播日志条目</strong>：<ul><li>Leader向其它节点发送包含新日志条目的心跳RPC请求（AppendEntriesRPC）。</li></ul></li><li><strong>Follower节点接收并附加日志条目</strong>：<ul><li>Follower节点接收到Leader的附加日志请求后，将新的日志条目附加到其本地日志中。</li></ul></li><li><strong>Follower节点响应Leader</strong>：<ul><li>Follower节点在成功附加日志后，向Leader发送成功的响应。</li></ul></li><li><strong>Leader确认提交</strong>：<ul><li>当Leader收到大多数节点的附加成功响应时，将日志条目视为已提交。</li></ul></li><li><strong>Leader提交到状态机</strong>：<ul><li>Leader将已提交的日志条目应用到其状态机中，以执行相应的操作。</li></ul></li><li><strong>Leader通知Followers提交</strong>：Leader会通知其它节点已提交的日志索引，以便它们也可以将相应的日志条目提交到其状态机中。</li><li><strong>Follower提交到状态机</strong>：Follower节点收到Leader的提交通知后，将对应的已提交日志条目应用到其状态机中。</li></ol><h3id="什么条件下才能够提交一个日志条目">什么条件下才能够提交一个日志条目？</h3><p><strong>回答要点：</strong>一个很容易疏忽的是必须要本term有新的日志提交才能继续提交日志，这个在前面文章中也提醒过。</p><p><strong>示例回答：</strong> 略。</p><h3 id="raft如何处理集群拓扑的变更">Raft如何处理集群拓扑的变更？</h3><p><strong>回答要点：</strong></p><p><strong>示例回答：</strong></p><ol type="1"><li><strong>生成配置变更请求</strong>：当需要改变集群的拓扑结构时，例如添加或移除节点，Leader节点会收到来自客户端的配置变更请求。</li><li><strong>将配置变更请求转化为配置变更日志条目</strong>：Leader节点将配置变更请求转换为一条特殊的日志条目，即配置变更日志条目。该日志条目包含新的集群配置信息。</li><li><strong>向集群中的节点分发配置变更日志条目</strong>：Leader节点通过Raft的日志复制机制将配置变更日志条目发送给所有的Follower节点。</li><li><strong>Follower节点接收配置变更日志条目</strong>：Follower节点收到配置变更日志条目后，将其附加到本地日志中。</li><li><strong>提交配置变更日志条目</strong>：当配置变更日志条目被大多数节点确认并附加到本地日志后，Leader节点将其提交到状态机，实际应用这个配置变更。</li><li><strong>应用配置变更</strong>：Leader节点和所有的Follower节点根据新的配置信息更新其内部状态，以反映集群拓扑结构的变更。这可能涉及到更新节点的角色（Leader、Follower、Candidate）、维护新的节点列表等。</li></ol><h3 id="实际应用"><strong>实际应用</strong></h3><p><strong>Raft算法在实际场景中的应用有哪些？</strong></p><p><strong>回答要点：</strong>列举一些常见的使用Raft算法作为底层的即可。</p><p><strong>示例回答：</strong></p><ol type="1"><li>一些常见的配置中心，为了保证可用会采用Raft，比如zookeeper的底层实现了基于Raft修改的算法，ETCD等。</li><li>一些分布式数据库，比如<ahref="https://docs.pingcap.com/zh/tidb/stable/tikv-overview">TIKV</a></li></ol><h3id="raft与其他分布式的比较"><strong>Raft与其他分布式的比较</strong></h3><h4id="与paxos算法相比raft有哪些优势和不同之处">与Paxos算法相比，Raft有哪些优势和不同之处？</h4><p><strong>回答要点：</strong>Raft相对于Paxos算法来说，更易理解、实现和维护，具有更直观的Leader机制和选举过程。（这个需要大家多了解一下其他分布式算法的设计思想了。）</p><p><strong>示例回答：</strong></p><ol type="1"><li><strong>Leader机制</strong>：<strong>Raft引入了Leader节点，而Paxos中没有Leader节点的概念。</strong>Leader节点负责协调和领导整个一致性过程，而Follower节点只需按照Leader的指示执行操作。</li><li><strong>日志复制</strong>：在Raft中，所有的日志条目都通过Leader节点进行复制和提交，而Paxos中的日志复制是通过多个角色相互协作完成的。</li><li><strong>角色切换</strong>：Raft中Leader节点失效后，集群可以快速选举新的Leader节点，而Paxos中角色的切换较为复杂，需要进行更多的投票和协调。</li><li><strong>更强的可读性</strong>：Raft算法更加直观和易于理解，它的设计目标之一就是提供更好的可读性和可理解性，相比之下，Paxos算法相对更加抽象和复杂。</li></ol><h3 id="常见问题与挑战"><strong>常见问题与挑战：</strong></h3><p><strong>回答要点：</strong>leader的瓶颈（使用多读来解决），节点故障等等</p><p><strong>示例回答：</strong></p><ol type="1"><li><strong>Leader瓶颈</strong>：Raft算法中的Leader节点负责所有的客户端请求的处理和日志复制，这可能会成为系统的瓶颈。如果Leader节点负载过重或者发生故障，会导致整个系统的性能下降。</li><li><strong>网络分区</strong>：Raft算法需要保证在网络分区情况下的一致性，这可能会导致在网络分区恢复后需要进行数据的合并和冲突解决，增加了一致性维护的复杂性。</li><li><strong>节点故障处理</strong>：当节点发生故障时，Raft需要进行Leader的重新选举，这可能导致一段时间内系统的不可用性和性能下降，尤其是在节点频繁发生故障时。</li><li><strong>日志复制延迟</strong>：Raft算法要求日志复制必须在大多数节点上完成后才能提交，这可能导致日志复制的延迟，影响系统的实时性能。</li><li><strong>节点动态变更</strong>：Raft算法在节点动态加入或退出时需要进行配置变更，这可能会导致系统的不稳定和数据的不一致，需要谨慎处理。</li><li><strong>一致性保证</strong>：虽然Raft算法保证了强一致性，但在一些特殊情况下（如网络分区、节点故障等），可能会导致一致性级别的降低或者一致性协议的不满足，需要额外的机制来解决。</li><li><strong>性能调优</strong>：在实际应用中，Raft算法需要根据具体的场景进行性能调优，包括调整心跳超时时间、选举超时时间、日志复制的策略等参数，以满足系统的性能需求。</li></ol><h3 id="如何处理网络分区的情况">如何处理网络分区的情况？</h3><p><strong>回答要点：</strong>这个要结合多种情况分析，比如leader宕机、非leader宕机；少数节点分区、多数节点分区。然后这几种情况还可以相互组合，这个的话就要分类讨论了，面试估计是说不完的。</p><p><strong>示例回答：</strong></p><p>分情况讨论，略。</p><h3 id="容错性"><strong>容错性</strong></h3><p><strong>Raft算法如何处理节点故障？</strong></p><p><strong>回答要点：</strong></p><p>和网络分区是一样的，可以看成是网络分区的一种特殊情况，即一个节点自己是一个分区。</p><p>此外再加上故障恢复后有哪些数据（日志，投票，term等）是需要持久化的，哪些是不需要的（commitIndex，applyIndex等）。</p><p><strong>示例回答：</strong></p><p>略。</p><h3id="在集群中的多个节点同时故障时系统会有什么表现">在集群中的多个节点同时故障时，系统会有什么表现？</h3><p><strong>回答要点：</strong>考虑故障节点的数量，抓住“半数”这个概念。其他同上面的“分区问题”和“故障问题”。</p><p><strong>示例回答：</strong> 略。</p><h3 id="rpc">RPC</h3><p><strong>你的RPC如何设计的？</strong></p><p><strong>回答要点：</strong>这里最好的回答是回答出现有的rpc框架的一些优秀的设计，因为我的rpc实现只是raft-kv的一个配件，所以还是同步阻塞的，这里推荐大家看看异步rpc如何实现，也欢迎来改进项目中的RPC实现参与开源：<ahref="https://github.com/youngyangyang04/KVstorageBaseRaft-cpp">项目地址</a></p><p>列出可以考虑的优化点：异步；rpc长连接短连接的思考；<strong>负载均衡</strong>；服务治理、服务发现。</p><p><strong>示例回答：</strong></p><p>略</p><h3id="负载均衡有没有做用的什么算法如何考虑的">负载均衡有没有做？用的什么算法如何考虑的？</h3><p><strong>回答要点：</strong>1.常见的负载均衡算法及其对比；2.第四层和第七层不同层的负载均衡；3.瘦客户端和胖客户端的不同方式的负载均衡。</p><p><strong>示例回答：</strong></p><p>最开始实现rpc模块的时候实现过负载均衡算法，当然后面用于raft通信，因为raft通信是所有leader与所有节点都要建立连接，所以后面就没有再用负载均衡了，将这个功能关闭了。</p><p>当时实现的负载均衡的算法有：</p><ol type="1"><li><strong>轮询算法（Round Robin）</strong>：</li><li>轮询算法是最简单的负载均衡算法之一，它按照请求的顺序依次将每个请求分配到不同的服务器上。当有新的请求到来时，负载均衡器会依次将请求发送到不同的服务器，直到所有的服务器都被轮询过一遍，然后再从头开始。</li><li><strong>最小连接数算法（Least Connections）</strong>：</li><li>最小连接数算法会将新的请求分配到当前连接数最少的服务器上，以确保各服务器的负载尽可能均衡。这种算法考虑了服务器的负载情况，优先将请求发送到负载较低的服务器上。</li><li><strong>最少响应时间算法（Least Response Time）</strong>：</li><li>最少响应时间算法会将请求发送到响应时间最短的服务器上，以保证响应时间的最小化。这种算法通常需要负载均衡器记录每个服务器的响应时间，并动态调整请求的分配策略。</li><li><strong>哈希算法（Hashing）</strong>：</li><li>哈希算法根据请求的某些属性（如客户端IP地址、URL等）计算哈希值，并将请求发送到对应哈希值的服务器上。这种算法能够确保相同请求始终被发送到同一台服务器上，适用于需要保持会话一致性的场景。</li><li><strong>加权轮询算法（Weighted Round Robin）</strong>：</li><li>加权轮询算法在轮询算法的基础上引入了权重的概念，不同的服务器具有不同的权重值。根据权重值的不同，负载均衡器会调整请求的分配比例，以实现负载均衡。</li><li>拓展：hash环也是一种重要的负载均衡算法，也可以提及。</li></ol><h3id="服务治理和发现有没有做怎么做的">服务治理和发现有没有做？怎么做的？</h3><p><strong>回答要点：</strong>一般是用第三方组件（比如zookeeper）来做，当然raft-kv本身就可以用来做服务治理和服务发现，所以rpc就没有单独做。</p><p><strong>示例回答：</strong></p><p>无</p><h3id="你这个rpc框架的序列化和反序列化中protobuf细节有没有了解">你这个RPC框架的序列化和反序列化中protobuf细节有没有了解</h3><p><strong>回答要点：</strong> 头部变长编码+自定义的压缩算法。</p><p>这里就可以牵扯到rpc中的编码方法，目前是头部定长4字节，可以优化成一个标志位+变长编码的方式：<ahref="https://github.com/youngyangyang04/KVstorageBaseRaft-cpp/issues/19">参与issue链接</a></p><p><strong>示例回答：</strong></p><p>大概了解了一下，主要是其头部的变长编码+Google自己实现的一个高效的压缩算法。</p><h3 id="测试">测试</h3><h4id="在集群数量变多的时候raft性能可能会下降这方面有没有思考过">在集群数量变多的时候，Raft性能可能会下降，这方面有没有思考过？</h4><p><strong>回答要点：</strong>允许从follower读；rpc合并等raft落地的框架的优化。</p><p><strong>示例回答：</strong>无</p><h4id="有没有对性能进行过测试用的什么工具怎么测试的">有没有对性能进行过测试？用的什么工具？怎么测试的？</h4><p><strong>回答要点：</strong> perf火焰图。</p><p><strong>示例回答：</strong></p><p>这里回答一下火焰图的基本使用就差不多了，如果大家没有使用过的话推荐大家去看篇博文入门了解基本操作和原理，我这里给出一个初步的结果，<strong>如果只有一个客户端：并发几十，大部分的损耗在rpc这边。多个客户端的结果没有测试。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft算法</title>
    <link href="/2024/04/22/raft%E7%AE%97%E6%B3%95/"/>
    <url>/2024/04/22/raft%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="raft算法">Raft算法</h1><h2 id="复制状态机">复制状态机</h2><p>一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导人，像GFS、HDFS 和RAMCloud，典型应用就是一个独立的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如Chubby 和 ZooKeeper。</p><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE1.png"alt="图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。" /><figcaption aria-hidden="true">图 1：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</figcaption></figure><p>复制状态机通常都是基于复制日志实现的，如图1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p><h2 id="raft算法概览">Raft算法概览</h2><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE2.png"alt="图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。" /><figcaption aria-hidden="true">图 2：一个关于 Raft一致性算法的浓缩总结（不包括成员变换和日志压缩）。</figcaption></figure><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE3.png"alt="图 3：Raft 在任何时候都保证以上的各个特性。" /><figcaption aria-hidden="true">图 3：Raft在任何时候都保证以上的各个特性。</figcaption></figure><h2 id="raft基础">Raft基础</h2><p>一个 Raft 集群包含若干个服务器节点；5个服务器节点是一个典型的例子，这允许整个系统容忍 2个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导人或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来选举新领导人时使用。下图1展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。</p><figure><imgsrc="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE4-17137515276692.png"alt="图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。" /><figcaption aria-hidden="true">图4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。</figcaption></figure><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE5.png"alt="图 5：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。" /><figcaption aria-hidden="true">图5：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</figcaption></figure><h2 id="raft一致性算法">Raft一致性算法</h2><h3 id="日志内容">日志内容</h3><p>当领导人收到客户端的指令之后，会把指令作为一个新的条目添加到日志中，一条日志需要有三个信息：</p><ol type="1"><li>状态机的指令</li><li>领导人的任期号</li><li>日志号（日志索引）</li></ol><h3 id="领导人选举">领导人选举</h3><p>Raft使用一种<strong>心跳机制</strong>来触发领导人选举。<strong>当服务器程序启动时，他们都是跟随者身份。</strong>一个服务器节点继续保持着跟随者状态只要他从领导人或者候选人处接收到有效的RPCs。领导人周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加条目（AppendEntries）RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导人,并且发起选举以选出新的领导人。</p><p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点发送请求投票的RPCs来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：</p><ol type="1"><li>他自己赢得了这次的选举</li><li>其他的服务器成为领导人</li><li>一段时间之后没有任何一个获胜的人。</li></ol><p>这些结果会分别的在下面的段落里进行讨论。</p><p>当一个候选人从整个集群的<strong>大多数服务器节点</strong>获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。<strong>每一个服务器最多会对一个任期号投出一张选票</strong>，按照先来先服务的原则（注意：1.4.4节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图3中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。</p><p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加条目（AppendEntries）RPC。如果这个领导人的任期号（包含在此次的RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC并且继续保持候选人状态。</p><p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p><h3 id="日志复制">日志复制</h3><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起附加条目RPCs给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全地复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目RPCs（尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE6.png"alt="图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。" /><figcaption aria-hidden="true">图6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。</figcaption></figure><p>日志以图 6展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图3中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。</p><p>领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交</strong>。Raft算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图6 中的条目7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。1.4.3中会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志RPCs（包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p><p>追加日志RPC Request的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">type AppendEntriesRequest <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-type">int</span> term; <span class="hljs-comment">// 自己当前的任期号</span><br>    <span class="hljs-type">int</span> leaderId;<span class="hljs-comment">// 领导人的id</span><br>    <span class="hljs-type">int</span> prevLogIndex;<span class="hljs-comment">// 前一个日志的日志号</span><br>    <span class="hljs-type">int</span> prevLogTerm;<span class="hljs-comment">// 前一个日志的任期号</span><br>    byte[] entries;<span class="hljs-comment">// 当前日志体</span><br>    <span class="hljs-type">int</span> leaderCommit;<span class="hljs-comment">// 当前日志体</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="安全性">安全性</h3><h4 id="选举限制">选举限制</h4><p>Raft使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。<strong>如果候选人的日志至少和大多数的服务器节点一样新</strong>（下段话解释什么叫新）且候选人的任期号比大多数节点都大（必须是严格大于，等于则不会投票），那么他一定持有了所有已经提交的日志条目。即<strong>选举限制</strong>：RPC中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p><p>Raft通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><h4 id="日志提交">日志提交</h4><p>如同 1.4.3节介绍的那样，<strong>只要一条日志被存储到了大多数的服务器上，领导人就可以把这条日志提交</strong>。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图8展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p><p><strong>提交过程：</strong></p><p>领导人收到超过半数节点的复制成功反馈之后，就可以应用日志到自己的状态机了。同时会在下一次日志到来的时候通知跟随者提交（也可以通过下次心跳包通知跟随者）。</p><p><strong>如果领导者提交之后，还没来得及通知跟随者，领导者就宕机了，是不是会出现返回client成功，但是提交状态没有在集群中保留下来？</strong></p><p>我的看法是，raft是一种底层的共识算法，本身只是应用实现高可用的一种方法。而与客户端交互本来应该是属于应用端的事情，理论上不是raft应该担心的，这也是论文不讨论这一点的原因。通常来讲，要避免这个问题，要设置一个集群提交的概念，只有集群中超过半数的节点都完成提交，才认为集群提交完成。实际上在提交阶段领导人宕机是一件很难处理的问题，一旦领导者宕机了，与client的连接就断开了，很容易造成commit状态未知，后续client很难确定提交的最终状态。</p><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE8.png"alt="图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。" /><figcaption aria-hidden="true">图8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在(a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b)中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2处。然后到 (c)，S5 又崩溃了；S1重新启动，选举成功，开始复制日志。在这时，来自任期 2的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e)中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5就不可能选举成功）。这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</figcaption></figure><p>为了消除图 8 里描述的情况，<strong>Raft永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交</strong>；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是Raft 为了简化问题使用一种更加保守的方法。</p><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号,这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p><p><strong>注意</strong>：<strong>为什么图 8.(c) 中S5宕机，然后S1重启后，S1的任期号直接变成4了？</strong></p><p>这里其实是有一个过程的，S5是通过S3、S4成功选举的，也就是说S1重启之后S3、S4保存的最新领导人任期号是3，那么S1在成为候选人之后竞选，S3、S4是不会给S1投票的（候选人的），那么在S1候选人状态结束之后，S1只得到了S2的选票，如下图所示，从而竞选失败。那么又经过一个超时等待时间之后，S1重新竞选，将任期号增加到4，这次竞选成功，S1再次成为领导人。</p><figure><img src="/img/raft%E7%AE%97%E6%B3%95/image-20240422205609009.png"alt="image-20240422205609009" /><figcaption aria-hidden="true">image-20240422205609009</figcaption></figure><h3 id="安全性论证">安全性论证</h3><p>假设领导人完全性特性是不存在的，然后使用反证法。假设任期 T的领导人（领导人T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于T 的最小任期 U 的领导人 U 没有这条日志条目。</p><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE9.png"alt="图 9：如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。" /><figcaption aria-hidden="true">图 9：如果 S1 （任期 T的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1的日志，也给 S5 投票了。</figcaption></figure><ol type="1"><li>在领导人 U选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li><li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人 U 投票了，如图9。这个投票者是产生这个矛盾的关键。</li><li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T的附加日志请求（因为此时他的任期号会比 T 大）。</li><li>投票者在给领导人 U投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。</li><li>投票者把自己选票投给领导人 U 时，领导人 U的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</li><li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U的日志至少和投票者一样长，所以领导人 U的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人U 是不包含的。</li><li>除此之外，领导人 U的最后一条日志的任期号就必须比投票人大了。此外，他也比 T大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T的已提交的日志）。创建了领导人 U最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U一定也包含那条被提交的日志，这里产生矛盾。</li><li>这里出现了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T的已经被提交的日志。</li><li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8(e) 中的索引 2。</li></ol><p>通过领导人完全特性，我们就能证明图 3中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p><h3 id="候选人崩溃">候选人崩溃</h3><p>跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的RPCs 都会失败。Raft中处理这种失败就是简单地通过无限的重试；如果崩溃的机器重启了，那么这些RPC 就会完整的成功。如果一个服务器在完成了一个RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft的 RPCs都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。</p><h3 id="时间和可用性">时间和可用性</h3><p>Raft的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft将无法工作。</p><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 1.4.2节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10毫秒到 500毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p><h3 id="集群成员变更">集群成员变更</h3><p>在需要改变集群配置的时候（如<strong>增减节点</strong>、<strong>替换宕机的机器</strong>或者<strong>改变复制的程度</strong>），raft可以i进行配置变更自动化。</p><p>自动化配置变更机制最大的难点是保证转换过程中不会出现同一任期的两个leader，因为转换期间整个集群可能划分为两个独立的大多数.</p><figure><img src="/img/raft%E7%AE%97%E6%B3%95/raft-%E5%9B%BE10.png"alt="图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。" /><figcaption aria-hidden="true">图10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从3 台机器变成了 5台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</figcaption></figure><p>如上图10,节点3是leader,4和5已经转换为新配置,而1和2仍然在旧配置,如果在这时候节点3宕机了,4和5之间的新配置会重新选举,节点5成为新leader,而1和2的旧配置也会重新选举产生一个新leader,这就会产生脑裂的问题.</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tensort学习记录</title>
    <link href="/2024/03/28/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/03/28/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="tensorrt学习记录">tensorRT学习记录</h1><h2 id="基础概念">基础概念</h2><h3 id="目标检测的map">目标检测的mAP</h3><h4 id="ap-map"><strong>AP &amp; mAP</strong></h4><ul><li>AP：PR 曲线下面积</li><li>mAP：mean Average Precision, 即各类别 AP 的平均值</li></ul><h4 id="tpfpfntn"><strong>TP、FP、FN、TN</strong></h4><ul><li>True Positive (TP)</li><li>False Positive (FP)</li><li>False Negative (FN)</li><li>True Negative (TN)</li></ul><h4 id="查准率查全率">查准率、查全率</h4><ul><li>查准率（Precision）: TP/(TP + FP)</li><li>查全率（Recall）: TP/(TP + FN)</li></ul><p>二者绘制的曲线称为 P-R 曲线</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-0c6661db35cd43e4d18c08dce2512ce1_720w-171231796802316.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="交并比---intersection-over-union-iou"><strong>交并比 -Intersection Over Union (IOU)</strong></h4><p>交并比（IOU）是度量两个检测框（对于目标检测来说）的交叠程度，公式如下：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195312928.png"alt="image-20240405195312928" /><figcaption aria-hidden="true">image-20240405195312928</figcaption></figure><p><span class="math inline">\(B_{gt}\)</span>代表的是目标实际的边框（Ground Truth，GT），<spanclass="math inline">\(B_p\)</span> 代表的是预测的边框，通过计算这两者的IOU，可以判断预测的检测框是否符合条件，IOU 用图片展示如下：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195350834.png"alt="image-20240405195350834" /><figcaption aria-hidden="true">image-20240405195350834</figcaption></figure><h4 id="评价指标-map"><strong>评价指标 mAP</strong></h4><p>先规定两个公式，一个是 Precision，一个是Recall，这两个公式同上面的一样，我们把它们扩展开来，用另外一种形式进行展示，其中<code>all detctions</code> 代表所有预测框的数量，<code>all ground truths</code> 代表所有 GT 的数量。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195530696.png"alt="image-20240405195530696" /><figcaption aria-hidden="true">image-20240405195530696</figcaption></figure><p><strong>AP 是计算某一类 P-R 曲线下的面积，mAP 则是计算所有类别 P-R曲线下面积的平均值。</strong></p><h3 id="object-detection算法">Object Detection算法</h3><h4 id="rcnn">RCNN</h4><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405162152948.png"alt="image-20240405162152948" /><figcaption aria-hidden="true">image-20240405162152948</figcaption></figure><ul><li>使用启发式搜索算法选择锚框</li><li>使用预训练模型对每个锚框抽取特征</li><li>训练一个SVM来对类别分类</li><li>训练一个线性回归模型来预测边缘框偏移</li></ul><p>选择了不同的锚框大小是不一样的，那么怎么让这些锚框最后变成一个batch呢？</p><p>这里使用了ROI pooling：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405162432057.png"alt="image-20240405162432057" /><figcaption aria-hidden="true">image-20240405162432057</figcaption></figure><ul><li>给定一个锚框，均匀分割成n × m块，输出每块里的最大值</li><li>不管锚框多大，总是输出n × m个值</li></ul><p>尽管 R-CNN模型通过预训练的卷积神经网络有效地抽取了图像特征，但是<strong>速度非常慢</strong>（如果从一张图片中选取了上千个提议区域，就需要上千次的卷积神经网络的前向传播来执行目标检测，<strong>计算量非常大</strong>）</p><h4 id="fast-rcnn">Fast RCNN</h4><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405162743100.png"alt="image-20240405162743100" /><figcaption aria-hidden="true">image-20240405162743100</figcaption></figure><ul><li>使用CNN对图片抽取特征</li><li>在原图片上使用启发式搜索算法选择锚框，并将其映射到提取特征后的feature上</li><li>使用RoI池化层对每个锚框生成固定长度特征</li><li>使用全连接层分类</li></ul><p>和RCNN相比，FastRCNN不用使用CNN对每个锚框提取特征了，它是对整个图片进行特征抽取，选出来的有重叠的锚框不需要多次计算。</p><h4 id="faster-rcnn">Faster RCNN</h4><ul><li>使用一个区域提议网络来代替启发式搜索来获得更好的锚框。</li></ul><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405163938102.png"alt="image-20240405163938102" /><figcaption aria-hidden="true">image-20240405163938102</figcaption></figure><p>Faster RCNN和FastRCNN不同的是之前的区域选择算法更换成了一个RPN（Region proposalnetwork）。这个RPN可以理解为一个比较粗糙的目标检测网络，在下面这部分做了一个二分类，判断生成的锚框是否是高质量的锚框,这样一些低质量的锚框就会被过滤掉,然后在剩余的高质量锚框中,使用NMS(非极大值抑制)来渡桥模型预测后的多余框.</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405164342532.png"alt="image-20240405164342532" /><figcaption aria-hidden="true">image-20240405164342532</figcaption></figure><p><strong>区域提议网络的计算步骤</strong>：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/c8e2ae2fdafa952b03e4f43973cb1f86ad102ebf.png@1610w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>区域提议网络作为Faster R-CNN模型的一部分，是和整个模型一起训练得到的（Faster R-CNN的目标函数不仅包括目标检测中的类别和边界框预测，还包括区域提议网络中锚框的二元类别和边界框预测）</li><li>作为端到端训练的结果，区域提议网络能够学习到如何生成高质量的提议区域，从而在减少了从数据中学习的提议区域的数量的情况下，仍然保持了目标检测的精度</li></ul><p><strong>NMS的思路如下</strong>:</p><ol type="1"><li>选取这类box中scores最大的那一个，记为box_best，并保留它</li><li>计算box_best与其余的box的IOU</li><li>如果其IOU&gt;0.5了，那么就舍弃这个box（由于可能这两个box表示同一目标，所以保留分数高的哪一个）</li><li>从最后剩余的boxes中，再找出最大scores的哪一个，如此循环往复</li></ol><p>经过NMS之后留下的锚框才会经过RoI Pooling以及后续阶段.</p><h4 id="mask-r-cnn">Mask R-CNN</h4><p>如果在训练集中还标注了每个目标在图像上的<strong>像素级位置</strong>，MaskR-CNN 能够有效地利用这些相近地标注信息进一步提升目标检测地精度.</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/a80b045c48d1eda6f340ba23870cc60447629176.png@1610w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Mask R-CNN 是基于 Faster R-CNN 修改而来的，改进在于</p><ol type="1"><li>假设有每个像素的标号的话，就可以对每个像素做预测（<strong>FCN</strong>）</li><li>将兴趣区域汇聚层替换成了<strong>兴趣区域对齐层</strong>（RoI pooling-&gt; RoI align），使用<strong>双线性插值</strong>（bilinearinterpolation）保留特征图上的空间信息，进而更适于像素级预测：对于pooling来说，假如有一个3* 3的区域，需要对它进行2 * 2的RoIpooling操作，那么会进行取整从而切割成为不均匀的四个部分，然后进行pooling操作，这样切割成为不均匀的四部分的做法对于目标检测来说没有太大的问题，因为目标检测不是像素级别的，偏移几个像素对结果没有太大的影响。但是<strong>对于像素级别的标号来说，会产生极大的误差</strong>；RoIalign不管能不能整除，如果不能整除的话，会直接将像素切开，切开后的每一部分是原像素的加权（它的值是原像素的一部分）</li><li>兴趣区域对齐层的输出包含了所有与兴趣区域的形状相同的特征图，它们不仅被用于<strong>预测每个兴趣区域的类别和边界框</strong>，还通过额外的全卷积网络<strong>预测目标的像素级位置</strong></li></ol><p><strong>RoIAlign</strong>:引入了一个插值过程，先通过双线性插值到14<em>14，再pooling到7</em>7，很大程度上解决了仅通过 Pooling 直接采样带来的Misalignment 对齐问题。虽然 Misalignment 在分类问题上影响并不大，但在Pixel 级别的 Mask 上会存在较大误差。</p><h4 id="模型精度比较">模型精度比较</h4><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405172221743.png"alt="image-20240405172221743" /><figcaption aria-hidden="true">image-20240405172221743</figcaption></figure><ul><li>x轴表示<strong>模型的运行速度</strong>，越往右表示模型的速度越快，越往左越慢</li><li>y 轴表示<strong>mAP</strong>（可以简单认为是边界框的预测精度），越往上表示精度越高</li><li>图中圆圈的大小表示<strong>内存的使用</strong></li><li>Faster RCNN相对来说精度比较高，但是它在精度提升的同时，样本的处理速度也在变慢（所以只有在对精度</li></ul><h4 id="小结">小结</h4><p>RCNN系列都是两阶段(Two-Stage)的算法,它们的思想都是先做一个粗糙一点的预测,然后做一个更精准的预测.不同的是FastRCNN通过先对图片提取特征来减少重复计算,而FasterRCNN又在这个基础之上通过一个RPN来获得更好的锚框.</p><ul><li>R-CNN 是最早、也是最有名的一类基于锚框和 CNN 的目标检测算法（R-CNN可以认为是使用神经网络来做目标检测工作的奠基工作之一），它对图像选取若干提议区域，使用卷积神经网络对每个提议区域执行前向传播以抽取其特征，然后再用这些特征来预测提议区域的类别和边框</li><li>Fast/Faster R-CNN持续提升性能：Fast R-CNN<strong>只对整个图像做卷积神经网络的前向传播</strong>，还引入了<strong>兴趣区域汇聚层</strong>（RoIpooling），从而为具有不同形状的兴趣区域抽取相同形状的特征；Faster R-CNN将 Fast R-CNN中使用的选择性搜索替换为<strong>参与训练的区域提议网络</strong>，这样可以在减少提议区域数量的情况下仍然保持目标检测的精度；MaskR-CNN 在 Faster R-CNN的基础上引入了一个<strong>全卷积网络</strong>，从而借助目标的<strong>像素级位置</strong>进一步提升目标检测的精度</li><li>Faster R-CNN 和 Mask R-CNN 是在追求高精度场景下的常用算法（MaskR-CNN需要有像素级别的标号，所以相对来讲局限性会大一点，在无人车领域使用的比较多）</li></ul><h4 id="单发多框检测ssd">单发多框检测(SSD)</h4><p>R-CNN系列都是要两阶段(如先过一遍RPN然后再做预测),而下面的一类算法只需要过一遍就可以完成检测.</p><p><strong>对每个像素生成多个以它为中心的多个锚框</strong>:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/393fb24dc90f86d8a2ea5c254ab623e7acbbf8b0.png@984w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/924c747e8134ee2b55e5752dfba9724a2573aede.png@1356w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/f5c0c5a8e98db98da7ed57bc85e242197090d469.png@1376w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>输入图像之后，首先进入一个基础网络来抽取特征，抽取完特征之后对每个像素生成大量的锚框（每个锚框就是一个样本，然后预测锚框的类别以及到真实边界框的偏移）</li><li>SSD在给定锚框之后<strong>直接对锚框进行预测</strong>，而不需要做两阶段（为什么Faster RCNN 需要做两次，而 SSD 只需要做一次？SSD通过做不同分辨率下的预测来提升最终的效果，越到底层的 featuremap，就越大，越往上，feature map越少，因此<strong>底层更加有利于小物体的检测，而上层更有利于大物体的检测</strong>）</li><li>SSD 不再使用 RPN网络，而是<strong>直接在生成的大量样本（锚框）上做预测</strong>，看是否包含目标物体；如果包含目标物体，再预测该样本到真实边缘框的偏移</li></ul><p><strong>模型精度</strong>:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405172827789.png"alt="image-20240405172827789" /><figcaption aria-hidden="true">image-20240405172827789</figcaption></figure><ul><li>上图中绿色的点表示 SSD</li><li>从图中可以看出，SSD 相对于Faster RCNN来讲<strong>速度快很多，但是精度不是太好</strong></li><li>SSD 的实现相对来讲比较简单，R-CNN 系列代码的实现非常困难</li></ul><h4 id="小结-1">小结</h4><ul><li>SSD通过<strong>单神经网络</strong>来检测模型</li><li><strong>以每个像素为中心</strong>产生多个锚框</li><li>在<strong>多个段</strong>的输出上进行<strong>多尺度</strong>的检测（底层检测小物体，上层检测大物体）</li></ul><h4 id="yolo">YOLO</h4><ul><li>yolo 也是一个 single-stage的算法，只有一个<strong>单神经网络</strong>来做预测</li><li>yolo 也需要锚框，这点和 SSD 相同，但是 SSD是对每个像素点生成多个锚框，所以在绝大部分情况下两个相邻像素的所生成的锚框的<strong>重叠率</strong>是相当高的，这样就会导致很大的重复计算量。</li><li>yolo 的想法是<strong>尽量让锚框不重叠</strong>：首先将图片均匀地分成S * S 块，每一块就是一个锚框，每一个锚框预测 B个边缘框（考虑到一个锚框中可能包含多个物体），所以最终就会产生 S ^ 2 * B个样本，因此速度会远远快于 SSD</li><li>yolo在后续的版本（V2,V3,V4...）中有持续的改进，但是核心思想没有变，真实的边缘框不会随机的出现，真实的边缘框的比例、大小在每个数据集上的出现是有一定的规律的，在知道有一定的规律的时候就可以使用<strong>聚类算法</strong>将这个规律找出来（给定一个数据集，<strong>先分析数据集中的统计信息，然后找出边缘框出现的规律</strong>，这样之后在生成锚框的时候就会有先验知识，从而进一步做出优化）</li></ul><h4 id="模型精度">模型精度</h4><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/faed4a83cbfa24f5b4062b5b7f35678faa5ee2df.png@1610w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>上图中表示 yolo v3的直线底端表示论文中的<strong>原始精度</strong>，顶端表示通过改进之后所能达到的<strong>最大精度</strong></li></ul><h4 id="center-net">center net</h4><ul><li>基于<strong>非锚框</strong>的目标检测</li><li>center net 的优点在于简单</li><li>center net 会对<strong>每个像素</strong>做预测，用 FCN对每个像素做预测（类似于图像分割中用 FCN对每个像素标号），<strong>预测该像素点是不是真实边缘框的中心点</strong>（将目标检测的边缘框换算成基于每个像素的标号，然后对每个像素做预测，就免去了一些锚框相关的操作）</li></ul><h3 id="yolo详解">YOLO详解</h3><h4 id="yolov1">YOLOv1</h4><p><strong>step1</strong>:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194511282.png"alt="image-20240405194511282" /><figcaption aria-hidden="true">image-20240405194511282</figcaption></figure><p><strong>step2</strong>:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194528416.png"alt="image-20240405194528416" /><figcaption aria-hidden="true">image-20240405194528416</figcaption></figure><p>每一个grid需要预测2个bounding box。每个boundingbox有5个值，分别是4个位置(x,y,w,h)，和一个yolo系列独有的置信度confidence。confidence简单理解为<code>预测边界框与标注边界框的IOU * 是否有目标</code>，即预测边界框与标注边界框的重合程度。</p><p>以VOC数据集为例,20个类别,每个gridcell需要预测一个长度为30的tensor(2组x,y,w,h,confidence和20个类别分数).</p><p>每个类别分数如下图:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194440217.png"alt="image-20240405194440217" /><figcaption aria-hidden="true">image-20240405194440217</figcaption></figure><ul><li>最终预测目标概率为：目标类别分数*confidece</li></ul><h5 id="网络结构">网络结构</h5><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194359822.png"alt="image-20240405194359822" /><figcaption aria-hidden="true">image-20240405194359822</figcaption></figure><ul><li>网络输入：448×448×3的彩色图片。</li><li>中间层：由若干卷积层和最大池化层组成，用于提取图片的抽象特征。</li><li>全连接层：由两个全连接层组成，用来预测目标的位置和类别概率值。</li><li>网络输出：7×7×30的预测结果。</li></ul><h5 id="损失函数">损失函数</h5><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405194643807.png"alt="image-20240405194643807" /><figcaption aria-hidden="true">image-20240405194643807</figcaption></figure><h5 id="不足之处">不足之处</h5><ul><li>对于群体型的小目标，检测能力很差。</li><li>对于未训练过的新尺寸目标，检测能力很差。</li><li>主要错误原因来自于定位不准确。</li></ul><h4 id="yolov2">YOLOv2</h4><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405195027207.png"alt="image-20240405195027207" /><figcaption aria-hidden="true">image-20240405195027207</figcaption></figure><h5 id="batch-normalization">Batch Normalization</h5><ul><li><strong>BN的本质原理</strong>：在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理（归一化至：均值0、方差为1），它是一个可学习、有参数（γ、β）的网络层。</li><li><strong>作用：</strong>解决在训练过程中，中间层数据分布发生改变的问题，以防止梯度消失或爆炸、加快训练速度，加快算法收敛速度。</li></ul><p>检测系列的网络结构中，BN逐渐变成了标配。在Yolo的每个卷积层中加入BN之后，mAP提升了2%，并且去除了Dropout。</p><p>BN大体可以分为四步：</p><ol type="1"><li>计算出均值</li><li>计算出方差</li><li>归一化处理到均值为0，方差为1</li><li>变化重构，恢复出这一层网络所要学到的分布</li></ol><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405205207083.png"alt="image-20240405205207083" /><figcaption aria-hidden="true">image-20240405205207083</figcaption></figure><h5 id="high-resolution-classifier分类网络高分辨率预训练">HighResolution Classifier（分类网络高分辨率预训练）</h5><ul><li>这里引入迁移学习(Transferlearning)的概念：把已训练好的模型（预训练模型）参数迁移到新的模型帮助新模型训练。</li></ul><blockquote><p>迁移学习有三种方式 <strong>TransferLearning</strong>：冻结预训练模型的全部卷积层，只训练自己定制的全连接层。<strong>Extract FeatureVector</strong>：先计算出预训练模型的卷积层对所有训练和测试数据的特征向量，然后抛开预训练模型，只训练自己定制的简配版全连接网络。<strong>Fine-tuning</strong>：冻结预训练模型的部分卷积层（通常是靠近输入的多数卷积层，因为这些层保留了大量底层信息）甚至不冻结任何网络层，训练剩下的卷积层（通常是靠近输出的部分卷积层）和全连接层。</p></blockquote><ul><li>Fine-tuning原理：利用已知网络结构和已知网络的参数，修改output层为我们自己的层，微调最后一层前的若干层的训练参数，这样就有效利用了深度神经网络强大的泛化能力，又免去了设计复杂的模型以及耗时良久的训练。</li><li>YOLOv1在采用 224×224 分类模型预训练后将分辨率增加到 448×448，并使用这个高分辨率在检测数据集上finetune。但是直接切换分辨率，检测模型可能难以快速适应高分辨率。所以YOLOv2增加了<strong>在ImageNet数据集上使用</strong>448×448<strong>输入来finetune分类网络</strong>这一中间过程（10epochs）.<strong>YOLOv2将预训练分成两步：先用</strong>224×224<strong>的输入从头开始训练网络，大概160个epoch（表示将所有训练数据循环跑160次），然后再将输入调整到</strong>448×448<strong>，再训练10个epoch</strong>，这可以使得模型在检测数据集上finetune之前已经适应高分辨率输入。使用高分辨率分类器后，YOLOv2的mAP提升了约4%。</li></ul><h5 id="convolutional-with-anchor-boxes使用先验框">Convolutional WithAnchor Boxes（使用先验框）</h5><p>YOLOv1每个格点预测两个矩形框，在计算loss时，只让与groundtruth最接近的框产生loss数值，而另一个框不做修正。这样规定之后，作者发现两个框在物体的大小、长宽比、类别上逐渐有了分工。在v2中，神经网络不对预测矩形框的宽高的绝对值进行预测，而是预测与Anchor框的偏差（offset），每个格点指定n个Anchor框。在训练时，最接近groundtruth的框产生loss，其余框不产生loss。在引入AnchorBox操作后，mAP由69.5下降至69.2，原因在于，每个格点预测的物体变多之后，<strong>召回率大幅上升，准确率略微有所下降</strong>，总体mAP略有下降。</p><p>v2中移除了v1最后的两层全连接层，全连接层计算量大，耗时久。文中没有详细描述全连接层的替换方案，这里猜测是利用1*1的卷积层代替.</p><h5 id="dimension-clustersanchor-box的宽高由聚类产生">DimensionClusters（Anchor Box的宽高由聚类产生）</h5><p>这里算是作者的一个创新点。Faster R-CNN中的九个AnchorBox的宽高是事先设定好的比例大小，一共设定三个面积大小的矩形框，每个矩形框有三个宽高比：1:1，2:1，1:2，总共九个框。而在v2中，AnchorBox的宽高不经过人为获得，而是将训练数据集中的矩形框全部拿出来，用kmeans聚类得到先验框的宽和高。例如使用5个AnchorBox，那么kmeans聚类的类别中心个数设置为5。加入了聚类操作之后，引入AnchorBox之后，mAP上升。</p><p>需要强调的是，聚类必须要定义聚类点（矩形框 (<spanclass="math inline">\(w\)</span>,ℎ)）之间的距离函数，文中使用如下函数：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-418f012af6cc4f94db0486cdca8968aa_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>下图是在VOC和COCO数据集上的聚类分析结果，随着聚类中心数目的增加，平均IOU值（各个边界框与聚类中心的IOU的平均值）是增加的，但是综合考虑模型复杂度和召回率，作者最终选取5个聚类中心作为先验框，其相对于图片的大小如右边图所示。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-d1d8b71299bdeddb13243bc537a34f9a_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h5 id="direct-location-prediction">Direct location prediction</h5><p>引入anchorbox的时候遇到的第二个问题：模型不稳定，尤其是在训练刚开始的时候。其位置预测公式为如下图所示：其中 (x,y) 为边界框的实际中心位置，需要预测的坐标偏移值为 (<spanclass="math inline">\(t_x,t_y\)</span>) ,先验框的尺寸为 (<spanclass="math inline">\(w_a,h_a\)</span>) 以及中心坐标 (<spanclass="math inline">\(x_a,y_a\)</span>) (特征图每个位置的中心点)。由于(<span class="math inline">\(t_x,t_y\)</span>)取值没有任何约束，因此预测边框的中心可能出现在任何位置，训练早期不容易稳定。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405211349987.png"alt="image-20240405211349987" /><figcaption aria-hidden="true">image-20240405211349987</figcaption></figure><p>所以，YOLOv2弃用了这种预测方式，而是沿用YOLOv1的方法，就是<strong>预测边界框中心点相对于对应cell左上角位置的相对偏移值</strong>，为了将边界框中心点约束在当前cell中，使用sigmoid函数处理偏移值，这样预测的偏移值在(0,1)范围内（每个cell的尺度看做1）。总结来看，根据边界框预测的4个offsets<spanclass="math inline">\(t_x,t_y,t_w,t_h\)</span>,可以按如下公式计算出边界框实际位置和大小：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405211424051.png"alt="image-20240405211424051" /><figcaption aria-hidden="true">image-20240405211424051</figcaption></figure><p>其中 (<span class="math inline">\(c_x, c_y\)</span>)为cell的左上角坐标，在计算时每个cell的尺度为1，所以当前cell的左上角坐标为(1,1)，由于sigmoid（<spanclass="math inline">\(\sigma(x)=\frac{1}{1 +e^{-x}}\)</span>）函数的处理，边界框的中心约束会在cell内部，防止偏移过多。(<span class="math inline">\(p_w,p_h\)</span>)是先验框的宽度和长度，其值是相对于特征图大小的。在特征图中每个cell的长和宽均为1。这里记特征图的大小为(W,H)，（在文中是(13,13)），这样我们就可以将边界框相对于整张图片的位置和大小计算出来（4个值均在0和1之间）：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405213543725.png"alt="image-20240405213543725" /><figcaption aria-hidden="true">image-20240405213543725</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-5709a4695997d975d0e8bf0bafd714d8_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如果再将上面的4个值分别乘以图片的宽度和长度（像素点值）就可以得到边界框的最终位置和大小了。</p><h5 id="fine-grained-features">Fine-Grained Features</h5><p>YOLOv2的输入图片大小是416<em>416，经过5次2</em>2 maxpooling之后得到13* 13大小的特征图，并以此特征图采用卷积做预测。虽然13*13的featuremap对于预测大的object以及足够了，但是对于预测小的object就不一定有效。这里主要是添加了一个层：<strong>passthroughlayer</strong>。这个层的作用就是<strong>将前面一层的26*26的featuremap和本层的13*13的feature map进行连接</strong>，有点像ResNet。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-3ba1a8ab912c8f10061929f08a7e0755_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>一拆四的方法如下：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-0055f985ded26205e3bb29b096ccfa63_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h5 id="multi-scale-training多尺度的图像训练">Multi-ScaleTraining(多尺度的图像训练)</h5><p>为了让YOLOv2模型更加robust，作者引入了Muinti-ScaleTraining，简单讲就是在训练时输入图像的size是动态变化的，注意这一步是<strong>在检测数据集上finetune时候</strong>采用的，不要跟前面在Imagenet数据集上的两步预训练分类模型混淆。</p><p>由于YOLOv2模型中<strong>只有卷积层和池化层</strong>，所以YOLOv2的输入可以不限于416*416大小的图片。</p><p>具体来讲，在训练网络时，每训练10个batch(在一个epoch中，batch数和迭代数是相等的，例如500个样本为1batch，总样本2000，则一个epoch包含4个batch或者说4个iteration),<strong>网络就会随机选择另一种size的输入</strong>,然后只需要修改对最后检测层的处理就可以重新训练。也就是说downsample的factor是32，因此采用32的倍数作为输入的size:{320,352,…,608}。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-8179e6363bc489268e9ff58281ee3311_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>总结来看，虽然YOLOv2做了很多改进，但是大部分都是借鉴其它论文的一些技巧，如FasterR-CNN的anchor boxes，YOLOv2采用anchorboxes和卷积做预测，这基本上与SSD模型（单尺度特征图的SSD）非常类似了，而且SSD也是借鉴了FasterR-CNN的RPN网络。从某种意义上来说，YOLOv2和SSD这两个one-stage模型与RPN网络本质上无异，只不过RPN不做类别的预测，只是简单地区分物体与背景。在two-stage方法中，RPN起到的作用是给出regionproposals，其实就是作出粗糙的检测，所以另外增加了一个stage，即采用R-CNN网络来进一步提升检测的准确度（包括给出类别预测）。而对于one-stage方法，它们想要一步到位，直接采用“RPN”网络作出精确的预测，要因此要在网络设计上做很多的tricks。YOLOv2的一大创新是采用Multi-ScaleTraining策略，这样同一个模型其实就可以适应多种大小的图片了。</strong></p><h5 id="fasternew-networkdarknet-19">Faster:new Network:Darknet-19</h5><p>在YOLOv1中，作者采用的训练网络是基于GooleNet,YOLOv2采用了一个新的基础模型（特征提取器），称为Darknet-19，包括19个卷积层和5个maxpooling层.</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-f6a7dc0f4941a754c205b0e0d2978687_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Darknet-19与VGG16模型设计原则是一致的，<strong>主要采用 3×3卷积，采用 2×2的maxpooling层，特征图维度降低2倍，同时特征图的channles增加两倍</strong>。与NIN类似，Darknet-19最终<strong>采用globalavgpooling做预测</strong>，并且在 3×3 卷积之间使用 1×1卷积来压缩特征图channles以降低模型计算量和参数。Darknet-19<strong>每个卷积层后面使用了batchnorm层</strong>以加快收敛速度，降低模型过拟合。</p><p><strong>整体网络结构</strong>:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405214852338.png"alt="image-20240405214852338" /><figcaption aria-hidden="true">image-20240405214852338</figcaption></figure><h4 id="yolov3">YOLOv3</h4><p>详细见<ahref="https://blog.csdn.net/qq_37541097/article/details/81214953?ops_request_misc=%7B%22request%5Fid%22%3A%22171232888516800227454500%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=171232888516800227454500&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-81214953-null-null.nonecase&amp;utm_term=YOLO&amp;spm=1018.2226.3001.4450">YOLOv3网络结构分析_yolov3网络结构-CSDN博客</a>.</p><p><strong>网络结构</strong>:</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240405215233904.png"alt="image-20240405215233904" /><figcaption aria-hidden="true">image-20240405215233904</figcaption></figure><h4 id="yolov3-spp">YOLOv3 SPP</h4><p>改进见<ahref="https://blog.csdn.net/qq_38109282/article/details/117293611">YOLO-V3-SPP详细解析_yolov3-spp-CSDN博客</a>.</p><h4 id="yolov4">YOLOv4</h4><p>见<ahref="https://blog.csdn.net/qq_37541097/article/details/123229946">YOLOv4网络详解_yolov4网络结构图-CSDN博客</a>.</p><h3 id="fermikepler架构">Fermi、Kepler架构</h3><ol type="1"><li><strong>Fermi架构</strong>：<ul><li>Fermi架构是NVIDIA的第一代统一架构，推出于2010年。</li><li>它引入了CUDA（Compute Unified DeviceArchitecture）计算架构，使GPU不仅仅用于图形处理，还能进行通用计算。</li><li>Fermi架构支持双精度浮点运算，这对于科学计算和一些专业应用来说是至关重要的。</li><li>Fermi GPU的代表产品包括GTX 400和500系列。</li></ul></li><li><strong>Kepler架构</strong>：<ul><li>Kepler架构是NVIDIA的第二代统一架构，推出于2012年。</li><li>它进一步提升了CUDA计算性能，并引入了一些新技术，如GPUBoost（动态超频）和NVENC（NVIDIA视频编码器）。</li><li>Kepler架构在能效方面有所改进，使得GPU在相同功耗下能提供更高的性能。</li><li>Kepler GPU的代表产品包括GTX 600和700系列。</li></ul></li></ol><h3 id="sm">SM</h3><p><strong>GPU实际上是一个SM的阵列，每个SM包含N个计算核</strong>，现在我们的常用GPU中这个数量一般为128或192。一个GPU设备中包含一个或多个SM，这是处理器具有可扩展性的关键因素。如果向设备中增加更多的SM，GPU就可以在同一时刻处理更多的任务，或者对于同一任务，如果有足够的并行性的话，GPU可以更快完成它。</p><p>具体而言，以Fermi架构的GPU为例，其结构如下图。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-3b479ba08f0f5003dc001b3757377625_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>左边是GPU的整体结构，其主要是由大量的SM（Streaming-Multiprocessor）和DRAM存储等构成的。右图是对单个SM进行放大，可以看到SM由大量计算核（有时也称SP或CUDA核）、LDU（Load-StoreUnits）、SFU（Special-FunctionUnits）、寄存器、共享内存等构成。这种结构正是GPU具有高并行度计算能力的基础。<strong>通过一定的层级结构组织大量计算核，并给各级都配有相应的内存系统</strong>，GPU获得了出色的计算能力。</p><p>其中流式多处理器（SM）是GPU架构的核心。GPU中的每一个SM都能支持数百个线程并发执行，每个GPU通常有多个SM，所以在一个GPU上并发执行数千个线程是有可能的。当启动一个内核网络时，它的线程块会被分布在可用的SM上来执行。当线程块一旦被调度到一个SM上，其中的线程只会在那个指定的SM上并发执行。多个线程块可能会被分配到同一个SM上，而且是根据SM资源的可用性进行调度的。</p><p>再多提一嘴，稍微说说计算核以外的部分。线程束调度器（WarpScheduler）顾名思义是进行线程束的调度，负责将软件线程分配到计算核上；LDU（Load-StoreUnits）负责将值加载到内存或从内存中加载值；SFU（Special-FunctionUnits）用来处理sin、cos、求倒数、开平方特殊函数。</p><h3 id="heatmap">Heatmap</h3><p>CenterNet<strong>将目标当成一个点</strong>来检测，即用<strong>目标box的中心</strong>点来表示这个目标。<strong>预测目标中心的偏移量(offset),宽高size来得到物体实际box</strong>，而heatmap则是表示分类信息。每个类别都有一张heatmap，每一张heatmap上，若某个坐标处有物体目标的中心点，即在该坐标处产生一个keypoint(用高斯圆表示)，如下图所示：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-34ea0c5ba8f21a319745706b2aae63e1_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="focal-loss">Focal Loss</h3><p>FocalLoss（焦点损失）是一种用于解决类别不平衡问题的损失函数，特别是在目标检测任务中常常被使用。它由Linet al.在2017年的论文《Focal Loss for Dense ObjectDetection》中提出。</p><p>在目标检测任务中，由于背景类别的样本数量远远超过目标类别的样本数量，导致了类别不平衡问题。传统的交叉熵损失函数在面对这种不平衡时可能会导致模型过度关注于容易分类的背景样本，而忽视了目标样本的分类。</p><p>FocalLoss通过引入一个可调节的参数，有效地降低了容易分类的样本（例如背景样本）的权重，从而更加关注难以分类的样本。具体来说，焦点损失函数通过降低易分类样本的权重来减少易分类样本对总体损失的贡献，并且对于错误分类的样本给予了更大的权重，这样可以使模型更加关注于难以分类的样本，从而提高了模型对于少数类别目标的检测能力。</p><h3 id="loss">loss</h3><p>训练的时候应该控制loss的初始值，最好在10以内，才可以控制训练不会飞。</p><h2 id="driver-api的层次">Driver API的层次</h2><ol type="1"><li><p>CUDA Driver是与GPU沟通的驱动级别底层API</p></li><li><p>对DriverAPI的理解，有利于理解后续的RuntimeAPI</p></li><li><p>CUDADriver<strong>随显卡驱动发布</strong>，与cudatoolkit<strong>分开看</strong></p></li><li><p>CUDA Driver对应于cuda.h和libcuda.so文件</p></li><li><p>主要知识点是<strong>Context的管理机制</strong>，以及<strong>CUDA系列接口的开发习惯</strong>（错误检查方法），还有<strong>内存模型</strong></p></li></ol><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328221536121.png"alt="image-20240328221536121" /><figcaption aria-hidden="true">image-20240328221536121</figcaption></figure><h2 id="context">Context</h2><p>有两种：</p><ol type="1"><li>手动管理的context，cuCtxCreate（手动管理，以堆栈方式push/pop）</li><li>自动管理的context，cuDevicePrimaryCtxRetain（自动管理，runtimeapi以此为基础）</li></ol><h3 id="手动管理cuctxcreate">手动管理cuCtxCreate</h3><p>context是一种上下文，关联对GPU的所有操作。context与一块显卡关联，一个显卡可以被多个context关联。<strong>每个线程都有一个栈结构储存context</strong>，<strong>栈顶是当前使用的context</strong>，对应有push、pop函数操作context的栈，<strong>所有api都以当前context为操作目标</strong>。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328222527402.png"alt="image-20240328222527402" /><figcaption aria-hidden="true">image-20240328222527402</figcaption></figure><p><strong>context只是为了方便控制device的一种手段而提出来的，栈的存在是为了方便控制多个设备</strong>。</p><h3id="自动管理cudeviceprimaryctxretain">自动管理cuDevicePrimaryCtxRetain</h3><p>由于高频操作，是一个线程基本固定访问一个显卡不变，且只使用一个context，很少会用到多context，这时候CreateContext、PushCurrent、PopCurrent这种多context管理就显得麻烦，还得再简单，因此推出了cuDevicePrimaryCtxRetain，为设备关联主context，分配、释放、设置、栈都不用你管。primaryContext：给我设备id，给你context并设置好，此时<strong>一个显卡对应一个primarycontext</strong>。不同线程，只要设备id一样，primarycontext就一样。context是线程安全的。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328222751887.png"alt="image-20240328222751887" /><figcaption aria-hidden="true">image-20240328222751887</figcaption></figure><h2 id="内存">内存</h2><p>有两大类：</p><ol type="1"><li><p>CPU内存，称之为Host Memory</p><ol type="1"><li>Pageable Memory：可分页内存</li><li>Page-Locked Memory/pinned memory：页锁定内存</li></ol><p>可以理解为Page lock memory是vip房间，锁定给你一个人用。而Pageablememory是普通房间，</p><p>在酒店房间不够的时候，选择性的把你的房间腾出来给其他人交换用，这就可以容纳更多人了。<strong>造成房</strong></p><p><strong>间很多的假象，代价是性能降低</strong>。</p><p>pageablememory没有锁定特性，对于第三方设备（比如GPU），去访问时，因为无法感知内存是否被交换，可能得不到正确的数据（每次去房间找，说不准你的房间被人交换了）。所以<strong>GPU可以直接访问pinnedmemory而不能访问pageable memory</strong>。</p></li><li><p>GPU内存，称之为Device Memory</p><ol type="1"><li><strong>全局内存</strong>(3)：Global Memory<ol type="1"><li>速度：普通</li><li>读写</li><li>显存大小（11GB etc.）</li></ol></li><li>寄存器内存(1)：Register Memory<ol type="1"><li>速度：最快</li><li>读写</li></ol></li><li>纹理内存(2)：Texture Memory<ol type="1"><li>速度：快</li><li>只读</li></ol></li><li><strong>共享内存</strong>(2)：Shared Memory<ol type="1"><li>速度快</li><li>读写</li><li>大小：2080Ti有48kb</li></ol></li><li><strong>常量内存</strong>(2)：Constant Memory<ol type="1"><li>速度：快</li><li>只读不能写</li><li>大小：一般64kb，16bit寻址</li><li>通常放一些不修改的东西，速度很快</li></ol></li><li>本地内存(3)：Local Memory，其实是全局内存，<ol type="1"><li>速度普通</li><li>读写</li><li>大小：可用内存 / (SM数量 *SM最大常驻线程数)，动态计算的，可用越少值越小</li><li>C++中分配的栈空间变量就存在这里，localmemory可以认为是栈空间，为什么说其实是全局内存，因为它和全局内存用的是同一块内存，在cuda核定义一个变量就是在这的</li></ol></li></ol></li></ol><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240328221707001.png"alt="image-20240328221707001" /><figcaption aria-hidden="true">image-20240328221707001</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329213005234.png"alt="image-20240329213005234" /><figcaption aria-hidden="true">image-20240329213005234</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329213032531.png"alt="image-20240329213032531" /><figcaption aria-hidden="true">image-20240329213032531</figcaption></figure><h3 id="内存方面总结">内存方面总结</h3><ol type="1"><li>GPU可以直接访问pinned memory，称之为（DMA Direct MemoryAccess）</li><li>对于GPU访问而言，距离计算单元越近，效率越高，所以PinnedMemory&lt;GlobalMemory&lt;SharedMemory</li><li>代码中，由new、malloc分配的，是pageablememory，由cudaMallocHost分配的是PinnedMemory，由cudaMalloc分配的是GlobalMemory</li><li>尽量多用PinnedMemory储存host数据，或者显式处理Host到Device时，用PinnedMemory做缓存，都是提高性能的关键</li></ol><h3 id="各函数申请的内存类型">各函数申请的内存类型</h3><ol type="1"><li><p>通过cudaMalloc分配GPU内存，分配到setDevice指定的当前设备上</p></li><li><p>通过cudaMallocHost分配page locked memory，即pinnedmemory，页锁定内存</p><ol type="1"><li>页锁定内存是主机内存，CPU可以直接访问</li><li>页锁定内存也可以被GPU直接访问，使用DMA（Direct Memory Access）技术<ul><li>注意这么做的性能会比较差，因为主机内存距离GPU太远，隔着PCIE等，不适合大量数据传输</li></ul></li><li>页锁定内存是物理内存，过度使用会导致系统性能低下（导致虚拟内存等一系列技术变慢）</li></ol></li><li><p>cudaMemcpy</p><ol type="1"><li><p>如果host不是页锁定内存，则：</p><ul><li>Device To Host的过程，等价于<ul><li>pinned = cudaMallocHost</li><li>copy Device to pinned</li><li>copy pinned to Host</li><li>free pinned</li></ul></li><li>Host To Device的过程，等价于<ul><li>pinned = cudaMallocHost</li><li>copy Host to pinned</li><li>copy pinned to Device</li><li>free pinned</li></ul></li></ul></li><li><p>如果host是页锁定内存，则：</p><ul><li>Device To Host的过程，等价于<ul><li>copy Device to Host</li></ul></li><li>Host To Device的过程，等价于<ul><li>copy Host to Device</li></ul></li></ul></li></ol></li></ol><h3 id="culnit-驱动初始化">culnit 驱动初始化</h3><ol type="1"><li>cuInit的意义是，初始化驱动API，如果不执行，则所有API都将返回错误，全局执行一次即可</li><li>没有对应的cuDestroy，不需要释放，程序销毁自动释放</li></ol><h2 id="cuda-runtime">cuda-runtime</h2><h3 id="stream-流">stream-流</h3><ol type="1"><li>流是一种基于context之上的任务管道抽象，一个context可以创建n个流</li><li>流是异步控制的主要方式</li><li>nullptr表示默认流，每个线程都有自己的默认流</li></ol><p>不用流：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404145003423.png"alt="image-20240404145003423" /><figcaption aria-hidden="true">image-20240404145003423</figcaption></figure><p>用流：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404145019727.png"alt="image-20240404145019727" /><figcaption aria-hidden="true">image-20240404145019727</figcaption></figure><ol type="1"><li>上面的例子中，男朋友的微信消息，就是任务队列，流的一种抽象</li><li>女朋友发出指令后，他可以做任何事情，无需等待指令执行完毕，（指令发出的耗时也是极短的）</li><li>即，异步操作，执行的代码，加入流的队列后，立即返回，不耽误时间</li><li>女朋友发的指令被送到流中排队，男朋友根据流的队列，顺序执行</li><li>女朋友选择性，在需要的时候等待所有的执行结果</li><li>新建一个流，就是新建一个男朋友，给他发指令就是给他发微信，你可以新建很多个男朋友</li><li>通过cudaEvent可以选择性等待任务队列中的部分任务是否就绪</li></ol><h4 id="注意事项">注意事项</h4><ol type="1"><li>要十分注意，指令发出后，流队列中储存的是指令参数，<strong>不能加入队列后立即释放参数指针</strong>，这会导致流队列执行该指令时指针失效而出错</li><li>应当在十分肯定流已经不需要这个指针后，才进行修改或者释放，否则会有非预期结果出现</li><li>举个粒子：你给钱让男朋友买西瓜，他刚到店拿好西瓜，你把转的钱撤回去了。此时你无法预知他是否会跟店家闹起来矛盾，还是屁颠的回去。如果想得到预期结果，必须得让卖西瓜结束再处理钱的事情</li></ol><h3 id="核函数">核函数</h3><p>核函数是cuda编程的关键，通过xxx.cu创建一个cudac程序文件，并把cu交给nvcc编译，才能识别cuda语法</p><ul><li><strong>线程(Thread)：</strong>一般通过GPU的一个核进行处理;</li><li><strong>线程块(Block)：</strong>由多个线程组成；各block是并行执行的，block间无法通信，也没有执行顺序。</li><li><strong>线程格(Grid)：</strong>由多个线程块组成。</li><li><strong>核函数(Kernel)：</strong>在GPU上执行的函数通常称为核函数;一般通过标识符__global__修饰，调用通过&lt;&lt;&lt;参数1,参数2&gt;&gt;&gt;，用于说明内核函数中的线程数量，以及线程是如何组织的。</li><li>host调用核函数：function&lt;&lt;&lt;<strong>gridDim</strong>,<strong>blockDim</strong>, sharedMemorySize,stream&gt;&gt;&gt;(args…);</li></ul><p>画个图直观理解一下，下图是1个线程格，里面包含了27块线程块(蓝色的格子)，每个线程块里面又包含了64个线程(绿色的格子)。线程是最小的单位了，虽然这边我画的还是立方体，但通常是看做一个点。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-f8638235a4047c36053028e0150a46c0_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4id="threadidxblockidxblockdim和griddim">threadIdx、blockIdx、blockDim和gridDim</h4><p>gridDim、blockDim为维度，启动核函数后是固定的</p><p><code>gridDim.x</code>、<code>gridDim.y</code>、<code>gridDim.z</code>分别表示<strong>线程格</strong>各个维度的大小，所以有</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">gridDim.x=3    gridDim.y=3   gridDim.z=3<br></code></pre></td></tr></table></figure><p><strong><code>blockDim.x</code>、<code>blockDim.y</code>、<code>blockDim.z</code>分别表示</strong>线程块<strong>中各个维度的大小，所以有</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">blockDim.x=4   blockDim.y=4  blockDim.z=4<br></code></pre></td></tr></table></figure><p>blockIdx、threadIdx为索引，启动核函数后，枚举每一个维度值，不同线程取值不同</p><p>blockIdx.x、blockIdx.y、blockIdx.z分别表示<strong>当前线程块所处的线程格的坐标位置</strong>，threadIdx.x、threadIdx.y、threadIdx.z分别表示<strong>当前线程所处的线程块的坐标位置</strong>。</p><p><strong>线程格里面总的线程个数N即可通过下面的公式算出</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">N = gridDim.x * gridDim.y * gridDim.z * blockDim.x * blockDim.y * blockDim.z<br></code></pre></td></tr></table></figure><p><strong>还有一点要注意</strong>：<strong>blocksize的最大值是1024</strong>，即<code>blockDim.x * blockDim.y * blockDim.z</code>的最大值是1024.</p><p>dim和index之间也是有关系的</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404203336452.png"alt="image-20240404203336452" /><figcaption aria-hidden="true">image-20240404203336452</figcaption></figure><p>如果gridDim.x为n， 那么对应blockIdx.x的取值范围就是[0, n -1],其他dim和idx的对应关系也是同理。</p><h4 id="线程索引的计算">线程索引的计算</h4><p>上面说了线程个数由下面的公式计算：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">N = gridDim.x * gridDim.y * gridDim.z * <span class="hljs-built_in">block</span>Dim.x * <span class="hljs-built_in">block</span>Dim.y * <span class="hljs-built_in">block</span>Dim.z<br></code></pre></td></tr></table></figure><p>那么如何计算每个线程对应的索引？对于这样的dim和index</p><p>口诀：<strong>左乘右加</strong></p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404204539979.png"alt="image-20240404204539979" /><figcaption aria-hidden="true">image-20240404204539979</figcaption></figure><p>伪代码如下：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404204109523.png"alt="image-20240404204109523" /><figcaption aria-hidden="true">image-20240404204109523</figcaption></figure><h4 id="参数">&lt;&lt;&lt;&gt;&gt;&gt;参数</h4><p>通常的参数是这样的，function&lt;&lt;&lt;<strong>gridDim</strong>,<strong>blockDim</strong>, sharedMemorySize,stream&gt;&gt;&gt;(args…);</p><p>&lt;&lt;&lt;&gt;&gt;&gt;至少有两个参数，因为gridDim和blockDim是必须的，而后边两个参数是可选的。gridDim和blockDim都是一个三维的向量，有三个维度x,y,z，如果在传参的时候没有传递三维向量会怎么样？</p><p>比如传递一个数值，那么会将其解释为x维度，而y和z维度被默认为1。同理，如果传递一个二维向量(1,2)，那么会将其解释为x和y维度，其中x为1，y为2，而z维度被默认为1。</p><p>最后一个参数steam传递nullptr则表示使用默认流。</p><h4 id="注意事项-1">注意事项</h4><ol type="1"><li>调用核函数是传值的，不能传引用，可以传递类、结构体等，核函数可以是模板</li><li>__global__表示为核函数，由host调用。__device__表示为设备函数，由device调用</li><li>__host__表示为主机函数，由host调用。__shared__表示变量为共享变量</li><li>host调用核函数：function&lt;&lt;&lt;<strong>gridDim</strong>,<strong>blockDim</strong>, sharedMemorySize,stream&gt;&gt;&gt;(args…);</li><li>只有__global__修饰的函数才可以用&lt;&lt;&lt;&gt;&gt;&gt;的方式调用</li><li>调用核函数是<strong>传值的，不能传引用</strong>，可以传递类、结构体等，核函数可以是模板</li><li>核函数的执行，是<strong>异步</strong>的，也就是立即返回的</li><li>核函数内访问<strong>线程索引</strong>主要用到threadIdx、blockIdx、blockDim、gridDim这些内置变量</li></ol><h3 id="cudagetdeviceproperties函数">cudaGetDeviceProperties函数</h3><p>cudaGetDeviceProperties得到的prop有很多属性，常见的有：</p><ul><li><code>totalGlobalMem</code>: 全局内存的总大小</li><li><code>sharedMemPerBlock</code>: 每个block的共享内存大小</li><li><code>regsPerBlock</code>: 每个block的寄存器数量</li><li><code>warpSize</code>: warp的大小</li><li><code>memPitch</code>: 内存中允许的最大间距字节数</li><li><code>maxThreadsPerBlock</code>: 每个block的最大线程数</li><li><code>maxThreadsDim[3]</code>: 块中每个维度的最大线程数</li><li><code>maxGridSize[3]</code>: 网格中每个维度的块数量</li><li><code>totalConstMem</code>: 可用的常量内存量</li></ul><h3 id="shared_memory共享内存">shared_memory共享内存</h3><p>共享内存是片上内存，更靠近计算单元，因此比globalMem速度更快，通常可以充当缓存使用</p><p>定义方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__shared__ <span class="hljs-type">char</span> static_shared_memory;<span class="hljs-comment">// 静态共享变量</span><br><span class="hljs-keyword">extern</span> __shared__ <span class="hljs-type">char</span> dynamic_shared_memory[]; <span class="hljs-comment">// 动态共享变量</span><br></code></pre></td></tr></table></figure><p>动态共享内存需要使用extern来声明，同时静态共享变量的地址会随着定义的变量个数而随之叠加，而动态共享变量无论定义多少个，地址都一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> static_shared_memory_num_element = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 6KB</span><br>__shared__ <span class="hljs-type">char</span> static_shared_memory[static_shared_memory_num_element]; <br>__shared__ <span class="hljs-type">char</span> static_shared_memory2[<span class="hljs-number">2</span>]; <br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">demo1_kernel</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 这里大小不能设定，它的大小是由&lt;&lt;&lt;&gt;&gt;&gt;的第三个参数确定的</span><br>    <span class="hljs-comment">// 动态共享内存和静态共享内存的区别在于动态使用了extern</span><br>    <span class="hljs-keyword">extern</span> __shared__ <span class="hljs-type">char</span> dynamic_shared_memory[];      <span class="hljs-comment">// 静态共享变量和动态共享变量在kernel函数内/外定义都行，没有限制</span><br>    <span class="hljs-keyword">extern</span> __shared__ <span class="hljs-type">char</span> dynamic_shared_memory2[];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;static_shared_memory = %p\n&quot;</span>,   static_shared_memory);   <span class="hljs-comment">// 静态共享变量，定义几个地址随之叠加</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;static_shared_memory2 = %p\n&quot;</span>,  static_shared_memory2); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dynamic_shared_memory = %p\n&quot;</span>,  dynamic_shared_memory);  <span class="hljs-comment">// 动态共享变量，无论定义多少个，地址都一样</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dynamic_shared_memory2 = %p\n&quot;</span>, dynamic_shared_memory2); <br><br>    <span class="hljs-keyword">if</span>(blockIdx.x == <span class="hljs-number">0</span> &amp;&amp; threadIdx.x == <span class="hljs-number">0</span>) <span class="hljs-comment">// 第一个thread</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Run kernel.\n&quot;</span>);<br>&#125;<br><br><br>demo1_kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">nullptr</span>&gt;&gt;&gt;();<br></code></pre></td></tr></table></figure><p>可以看到以下输出：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240404215109458.png"alt="image-20240404215109458" /><figcaption aria-hidden="true">image-20240404215109458</figcaption></figure><p>可以看到，定义的两个静态共享变量的地址是不一样的，而两个动态共享变量的地址是一样的。</p><h4 id="指定共享内存大小">指定共享内存大小</h4><p>如上面代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">demo_kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">nullptr</span>&gt;&gt;&gt;(); <span class="hljs-comment">// 其中第三个参数12，是指定动态共享内存，而在函数里定义动态共享内存时候不能指定大小</span><br></code></pre></td></tr></table></figure><p>另外，如果配置的各类共享内存总和大于sharedMemPerBlock，则核函数执行出错，Invalidargument</p><ul><li>不同类型的静态共享变量定义，其内存划分并不一定是连续的</li><li>中间会有内存对齐策略，使得第一个和第二个变量之间可能存在空隙</li><li>因此你的变量之间如果存在空隙，可能小于全部大小的共享内存就会报错</li></ul><h2 id="tensorrt基础">tensorRT基础</h2><ol type="1"><li>TensorRT的核心在于对模型算子的优化（<strong>合并算子</strong>、利用GPU特性<strong>选择特定核函数</strong>等多种策略），通过tensorRT，能够在Nvidia系列GPU上获得最好的性能</li><li>因此tensorRT的模型，需要在目标GPU上<strong>实际运行</strong>的方式选择最优算法和配置</li><li>也因此tensorRT生成的模型只能在<strong>特定条件</strong>下运行（编译的trt版本、cuda版本、编译时的GPU型号）</li><li>主要知识点，是<strong>模型结构定义方式、编译过程配置、推理过程实现、插件实现、onnx理解</strong><ol type="1"><li>模型结构定义方式：我现在有一个模型我怎么去告诉tensorRT（权重是多少？）</li><li>onnx是一个中间的结构，比如pytorch可以导出到onnx</li></ol></li></ol><h3 id="tensorrt优化原理">tensorRT优化原理</h3><p><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225449969.png"alt="image-20240407225449969" />左侧是没有经过优化的网络，那么在tensorRT执行的时候发现有很多操作（左侧圆圈中的操作)可以简化。</p><p>tensorRT提供了C++和python接口，可以通过这些接口定义模型结构（如权重参数）</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225641869.png"alt="C++ tensorRT接口" /><figcaption aria-hidden="true">C++ tensorRT接口</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225659751.png"alt="python tensorRT接口" /><figcaption aria-hidden="true">python tensorRT接口</figcaption></figure><p>但是如果每次都这样那么需要修改的时候就很麻烦，而且不方便调试，因此就提出了几种高级的方式：</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407225811793.png"alt="image-20240407225811793" /><figcaption aria-hidden="true">image-20240407225811793</figcaption></figure><ul><li>UFF：tensorflow可以直接转出为UFF格式，UUF格式里边存储了该有的网络结构以及权重，tensorRT通过libnvparsers.so可以解析UFF格式，然后去调用刚才提到的C++接口去创建网络结构并设置权重，然后交给builder编译，最后得到engine</li><li>ONNX：同样，pytorch可以转出为onnx格式，onnx格式存储了网络结构、数据流转以及权重参数，tensorRT通过libonnxparsers.so可以解析onnx模型，然后创建每个layer，设置权重参数，然后进一步编译得到engine</li><li>caffe：同样如此，但是这条路用的人已经很少了。</li></ul><h3 id="常见方案">常见方案</h3><p>基于tensorRT的发布，又有人在之上做了工作https://github.com/wang-xinyu/tensorrtx。</p><p>tensorRT的api没有实现常见的模型，那么就需要每次自己去设置，所以有人在基础之上为每个模型写硬代码，并已写好了大量的常见模型代码。</p><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407230506860.png"alt="image-20240407230506860" /><figcaption aria-hidden="true">image-20240407230506860</figcaption></figure><figure><imgsrc="/img/tensort%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240407230511427.png"alt="image-20240407230511427" /><figcaption aria-hidden="true">image-20240407230511427</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题</title>
    <link href="/2024/03/11/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2024/03/11/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面试问题">面试问题</h1><h2 id="c">C++</h2><h3 id="c编译生成可执行文件的顺序">C++编译生成可执行文件的顺序</h3><ol type="1"><li><strong>预处理</strong>：在编译之前，源代码会经过预处理器的处理。预处理器执行诸如宏替换、包含头文件等操作。预处理器生成一个经过预处理的源代码文件。</li><li><strong>编译</strong>：预处理后的源代码会被编译器编译成汇编代码（Assemblycode），汇编代码是与特定架构相关的低级代码。</li><li><strong>汇编</strong>：汇编器将汇编代码转换为机器代码（Objectcode），这是由二进制表示的机器可执行代码。</li><li><strong>链接</strong>：在链接阶段，编译器将所有的对象文件和库文件链接在一起，生成最终的可执行文件。这个过程包括解析符号引用、符号重定位和符号表的生成等操作。</li><li><strong>生成可执行文件</strong>：最终，链接器生成可执行文件，该文件包含了所有必要的机器代码和元数据，可以在相应的操作系统上运行。</li></ol><h3id="c语言指针需要注意的地方腾讯云">C语言，指针需要注意的地方（腾讯云）</h3><ol type="1"><li>要避免使用未初始化的指针</li><li>指针赋值时一定要保证类型匹配，由于指针类型确定指针所指向对象的类型，因此初始化或赋值时必须保证类型匹配，这样才能在指针上执行相应的操作。</li><li>void *类型的指针，其实这种形式只是记录了一个地址罢了，如上所说，由于不知道所指向的数据类型是什么所以不能进行相应的操作。其实void* 指针仅仅支持几种有限的操作：<ol type="1"><li>与另外的指针进行比较，因为void*类型里面就是存的一个地址，所以这点很好理解；</li><li>向函数传递void <em>指针或从函数返回void</em>指针，举个例子吧，我们平时常用的库函数qsort中的比较函数cmp（个人习惯于用这个名字）中传递的两个参数就是constvoid *类型的，用过的应该很熟了；</li><li>给另一个void * 类型的指针赋值。还是强调一下不能使用void *指针操纵它所指向的对象。</li></ol></li><li>在为一个指针再次分配内存之前要保证它原先没有指向其他内存，防止出现内存泄漏。</li></ol><h3 id="编译链接过程了解过吗腾讯云">编译链接过程了解过吗（腾讯云）</h3><h3 id="多态怎样实现的腾讯云">多态怎样实现的（腾讯云）</h3><h3id="字符串中变量的地址相差多少腾讯云">字符串中变量的地址相差多少（腾讯云）</h3><h3id="静态存储区的变量什么时候销毁腾讯云">静态存储区的变量什么时候销毁（腾讯云）</h3><h3id="类中同名对象地址相同吗腾讯云">类中同名对象地址相同吗（腾讯云）</h3><h3id="类中不同类型对象地址相差多少腾讯云">类中不同类型对象地址相差多少（腾讯云）</h3><h3 id="listensocketaccpet函数参数">listen、socket、accpet函数参数</h3><h3 id="c-vector-sizecapacity-的区别如何缩容">C++ vector size/capacity的区别，如何缩容？</h3><ol type="1"><li><strong>size()</strong>：返回向量中当前存储的元素数量，即实际使用的元素个数。</li><li><strong>capacity()</strong>：返回向量当前分配的内存空间大小，即向量的容量。容量可以大于或等于实际存储的元素数量。</li></ol><p>如果需要手动缩减向量的容量，可以使用<code>shrink_to_fit()</code>方法。这个方法会释放多余的内存，使得向量的容量等于实际存储的元素数量。</p><h3 id="cpp---可执行文件的过程追问链接阶段的详细过程">.cpp -&gt;可执行文件的过程，追问：链接阶段的详细过程</h3><ol type="1"><li><strong>预处理阶段</strong>：<ul><li>预处理器会处理源文件，包括执行宏替换、包含头文件、去除注释等操作，生成预处理后的源文件。</li></ul></li><li><strong>编译阶段</strong>：<ul><li>编译器会将预处理后的源文件编译成目标文件（objectfile），包括词法分析、语法分析、语义分析、优化等步骤。每个源文件对应一个目标文件。</li></ul></li><li><strong>汇编阶段</strong>：<ul><li>汇编器将编译生成的目标文件转换成机器码，生成可重定位的机器代码文件。</li></ul></li><li><strong>链接阶段</strong>：<ul><li>链接器将多个目标文件和库文件链接成可执行文件，包括以下步骤：<ul><li><strong>符号解析（SymbolResolution）</strong>：链接器会将目标文件中的符号与其定义关联起来，包括函数和全局变量的定义与引用。</li><li><strong>地址重定位（AddressBinding）</strong>：链接器会将目标文件中的符号地址与实际内存地址关联起来，生成可执行文件中的地址映射表。</li><li><strong>符号合并（SymbolMerging）</strong>：如果多个目标文件中存在相同的符号，则链接器会将这些符号合并为一个，以避免重复定义。</li></ul></li></ul></li><li><strong>生成可执行文件</strong>：<ul><li>链接器根据符号解析、地址重定位和符号合并生成可执行文件，其中包含了所有的目标文件和库文件，并且解析了所有的符号引用。</li></ul></li></ol><h3 id="有哪些键值型的存储结构">有哪些键值型的存储结构</h3><h3 id="stl-的sort是怎么实现的">STL 的sort是怎么实现的？</h3><p>STL的sort算法，数据量大时采用<strong>QuickSort快排算法</strong>，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用<strong>InsertionSort插入排序</strong>。如果递归层次过深，还会改用<strong>HeapSort堆排序</strong>。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-8fa032e195365f77fb6b980a4ed71958_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="数据库存储为什么-b-树不-avl-树">数据库存储为什么⽤ B+ 树，不⽤AVL 树。</h3><p>思路和不用B树一样，B+树方便遍历，方便范围查找，而且AVL树数据量大的时候可能会频繁旋转调整平衡。</p><h3 id="int-和const不同位置代表什么意思">int*和const不同位置代表什么意思</h3><ul><li>当<code>const</code>位于指针类型前面时，如<code>const int* ptr</code>，表示指针指向的数据是常量，不能通过指针修改所指向的数据，但指针本身可以修改，即指针是可变的，但指向的数据是不可变的。</li><li>当<code>const</code>位于指针类型后面时，如<code>int* const ptr</code>，表示指针本身是常量，不能修改指针指向的内存地址，但指针所指向的数据可以修改。</li></ul><h3 id="为什么栈的速度比堆快">为什么栈的速度比堆快</h3><p>栈是操作系统提供的数据结构，计算机底层对他提供了一系列的支持：分配专门的寄存器存储寄存器地址，压栈和出栈都有相应的指令；而堆是C/C++库函数提供的，机制复杂，需要一些分配内存，合并内存，释放内存的算法，所以效率低。</p><h3 id="detach和join有什么区别">detach和join有什么区别</h3><p><code>detach()</code>方法将一个线程从原始线程中分离出来，使其独立运行；而<code>join()</code>方法用于等待一个线程执行完毕后再继续执行原始线程。</p><h3 id="c有哪些锁">C++有哪些锁</h3><p>线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong>。一般而言，锁的功能与性能成反比。</p><h4 id="互斥锁mutex">互斥锁（Mutex）</h4><p>互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。</p><h5 id="mutex">mutex</h5><p>对于 <code>std::mutex</code>对象，任意时刻最多允许一个线程对其进行上锁</p><ul><li>mtx.lock()：调用该函数的线程尝试加锁。如果上锁不成功，即：其它线程已经上锁且未释放，则当前线程<code>block</code>。如果上锁成功，则执行后面的操作，操作完成后要调用<code>mtx.unlock()</code> 释放锁，否则会导致死锁的产生</li><li>mtx.unlock()：释放锁，<code>std::mutex</code>还有一个操作：<code>mtx.try_lock()</code>，字面意思就是：“尝试上锁”，与<code>mtx.lock()</code>的不同点在于：如果上锁不成功，当前线程不阻塞。</li></ul><h5 id="lock_guard">lock_guard</h5><p>虽然 <code>std::mutex</code>可以对多线程编程中的共享变量提供保护，但是直接使用<code>std::mutex</code> 的情况并不多。因为仅使用 <code>std::mutex</code>有时候会发生死锁。</p><p>考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2“永久的等待下去”，此时就发生了死锁。</p><p><code>std::lock_guard</code>只有构造函数和析构函数。简单的来说：当调用构造函数时，会自动调用传入的对象的lock()函数，而当调用析构函数时，自动调用<code>unlock()</code> 函数（这就是所谓的RAII）。</p><p><code>lock_guard</code> 还有一个构造函数<code>lock_guard( mutex_type&amp; m, std::adopt_lock_t t );</code>其中第二个参数类型为：<code>std::adopt_lock_t</code>。<strong>这个构造函数假定：当前线程已经上锁成功，所以不再调用lock()函数</strong>。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用互斥元保护列表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br> <br>std::list&lt;<span class="hljs-type">int</span>&gt; some_list;<br>std::mutex some_mutex;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_list</span><span class="hljs-params">(<span class="hljs-type">int</span> new_value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(some_mutex)</span></span>;<br>    some_list.<span class="hljs-built_in">push_back</span>(new_value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="条件锁">条件锁</h4><p>当需要死循环判断某个条件成立与否时【true orfalse】，我们往往需要开一个线程死循环来判断，这样<strong>非常消耗CPU</strong>。使用条件变量，可以让当前线程<code>wait</code>，释放CPU，如果条件改变时，我们再<code>notify</code>退出线程，再次进行判断。</p><p>条件锁就是所谓的条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程(常和互斥锁配合使用)，唤醒后，需要检查变量，避免虚假唤醒。</p><p>最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</p><p><strong>c++用法</strong>：</p><p>任意要等待 <code>std::condition_variable</code> 的线程必须获取<code>std::unique_lock&lt;std::mutex&gt;</code>，这个 <code>mutex</code>正是用来保护共享变量（即“条件”）的。执行 <code>wait</code> ,<code>wait_for</code> 或者<code>wait_until</code>。这些等待动作原子性地释放<code>mutex</code>，并使得线程的执行暂停。</p><p>当前线程调用 <code>wait()</code>后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁lck)，直到另外某个线程调用 <code>notify_*</code> 唤醒了当前线程。</p><p>在线程被阻塞时，该函数会自动调用 <code>lck.unlock()</code>释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知<code>(notified</code>，通常是另外某个线程调用<code>notify_*</code> 唤醒了当前线程)，wait() 函数也是自动调用lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>std::mutex mu;<br>std::condition_variable cond;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span> <span class="hljs-comment">//生产者</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>        q.<span class="hljs-built_in">push_front</span>(count);<br>        locker.<span class="hljs-built_in">unlock</span>();<br>        cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// Notify one waiting thread, if there is one.</span><br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>        count--;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span> <span class="hljs-comment">//消费者</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">empty</span>())<br>            cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// Unlock mu and wait to be notified</span><br>        data = q.<span class="hljs-built_in">back</span>();<br>        q.<span class="hljs-built_in">pop_back</span>();<br>        locker.<span class="hljs-built_in">unlock</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(function_1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(function_2)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自旋锁">自旋锁</h4><p>假设我们有一个两个处理器<code>core1</code>和<code>core2</code>计算机，现在在这台计算机上运行的程序中有两个线程：<code>T1</code>和<code>T2</code>分别在处理器<code>core1</code>和<code>core2</code>上运行，两个线程之间共享着一个资源。</p><p>首先我们说明互斥锁的工作原理，互斥锁是是一种<code>sleep-waiting</code>的锁。假设线程<code>T1</code>获取互斥锁并且正在<code>core1</code>上运行时，此时线程<code>T2</code>也想要获取互斥锁（pthread_mutex_lock），但是由于<code>T1</code>正在使用互斥锁使得<code>T2</code>被阻塞。当<code>T2</code>处于阻塞状态时，<code>T2</code>被放入到等待队列中去，处理器<code>core2</code>会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。</p><p>而自旋锁就不同了，自旋锁是一种 <code>busy-waiting</code>的锁。也就是说，如果<code>T1</code>正在使用自旋锁，而<code>T2</code>也去申请这个自旋锁，此时<code>T2</code>肯定得不到这个自旋锁。与互斥锁相反的是，此时运行<code>T2</code>的处理器<code>core2</code>会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。</p><p>从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。</p><p>当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用户空间用 atomic_flag 实现自旋互斥</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br> <br>std::atomic_flag lock = ATOMIC_FLAG_INIT;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; cnt &lt; <span class="hljs-number">100</span>; ++cnt) &#123;<br>        <span class="hljs-keyword">while</span> (lock.<span class="hljs-built_in">test_and_set</span>(std::memory_order_acquire))  <span class="hljs-comment">// 获得锁</span><br>             ; <span class="hljs-comment">// 自旋</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        lock.<span class="hljs-built_in">clear</span>(std::memory_order_release);               <span class="hljs-comment">// 释放锁</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;std::thread&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">10</span>; ++n) &#123;<br>        v.<span class="hljs-built_in">emplace_back</span>(f, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : v) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>atomic</code> 是C标准程序库中的一个头文件，定义了 C11标准中的一些表示线程、并发控制时原子操作的类与方法等。此头文件主要声明了两大类原子对象：<code>std::atomic</code>和<code>std::atomic_flag</code>。</p><ul><li><p><code>atomic_flag</code> 类</p><p>是一种简单的原子布尔类型，只支持两种操作：<code>test_and_set(flag=true)</code>和 <code>clear(flag=false)</code>。</p></li><li><p><code>std::atomic</code> 类模板</p></li><li><p><code>std::atomic</code>既不可复制亦不可移动。<code>atomic</code> 对<code>int</code>、<code>char</code>、<code>bool</code>等数据结构进行了原子性封装，在多线程环境中，对 <code>std::atomic</code>对象的访问不会造成竞争-冒险。利用 <code>std::atomic</code>可实现数据结构的无锁设计。</p></li></ul><p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。<strong>使用原子操作能大大的提高程序的运行效率</strong>。</p><h4 id="读写锁">读写锁</h4><p>先看互斥锁，它只有两个状态，要么是加锁状态，要么是不加锁状态。假如现在一个线程<code>a</code> 只是想读一个共享变量<code>i</code>，因为不确定是否会有线程去写它，所以我们还是要对它进行加锁。但是这时又有一个线程<code>b</code>试图去读共享变量<code>i</code>，发现被锁定了，那么<code>b</code>不得不等到<code>a</code>释放了锁后才能获得锁并读取<code>i</code>的值，但是两个读取操作即使是同时发生的，也并不会像写操作那样造成竞争，因为它们不修改变量的值。所以我们期望在多个线程试图读取共享变量的时候，它们可以立刻获取因为读而加的锁，而不是需要等待前一个线程释放。</p><p>读写锁可以解决上面的问题。它提供了比互斥锁更好的并行性。因为以读模式加锁后，当有多个线程试图再以读模式加锁时，并不会造成这些线程阻塞在等待锁的释放上。</p><p>读写锁是多线程同步的另外一个机制。在一些程序中存在读操作和写操作问题，对某些资源的访问会存在两种可能情况，一种情况是访问必须是排他的，就是独占的意思，这种操作称作<strong>写操作</strong>，另外一种情况是访问方式是可以共享的，就是可以有多个线程同时去访问某个资源，这种操作称为<strong>读操作</strong>。这个问题模型是从对文件的读写操作中引申出来的。把对资源的访问细分为读和写两种操作模式，这样可以大大增加并发效率。读写锁比互斥锁适用性更高，并行性也更高。</p><p>需要注意的是，这里只是说<strong>并行效率比互斥高，并不是速度一定比互斥锁快，读写锁更复杂，系统开销更大</strong>。并发性好对于用户体验非常重要，假设互斥锁需要0.5秒，使用读写锁需要0.8秒，在类似学生管理系统的软件中，可能90%的操作都是查询操作。如果突然有20个查询请求，使用的是互斥锁，则最后的查询请求被满足需要10秒，估计没人能接受。使用读写锁时，因为读锁能多次获得，所以20个请求中，每个请求都能在1秒左右被满足，用户体验好的多。</p><p><strong>特点</strong>：</p><ol type="1"><li>如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样可以有多个线程并行操作。这个时候如果再用写锁加锁就会发生阻塞。写锁请求阻塞后，后面继续有读锁来请求时，这些后来的读锁都将会被阻塞。这样避免读锁长期占有资源，防止写锁饥饿。</li><li>如果一个线程用写锁锁住了临界区，那么其他线程无论是读锁还是写锁都会发生阻塞。</li></ol><p><strong>c++用法</strong>：</p><p>STL本身并没有提供读写锁（Read-WriteLock）的实现。Boost中的<code>boost::shared_mutex</code>和<code>unique_lock</code>提供了读写锁的实现，可以用于实现多读单写的并发控制。</p><p>简单的说：</p><ol type="1"><li><code>shared_lock</code> 是<code>read_lock</code>。被锁后仍允许其他线程执行同样被<code>shared_lock</code> 的代码。这是一般做读操作时的需要。</li><li><code>unique_lock</code> 是<code>write_lock</code>。被锁后不允许其他线程执行被<code>shared_lock</code> 或 <code>unique_lock</code>的代码。在写操作时，一般用这个，可以同时限制 <code>unique_lock</code>的写和 <code>share_lock</code> 的读。</li></ol><p>注：C++ 11中提供了<code>unique_lock</code>且功能和用法与<code>boost::unique_lock</code>一直，但是C++11并没有提供<code>shared_lock</code>。</p><h4 id="递归锁">递归锁</h4><p><code>std::recursive_mutex</code> 与 <code>std::mutex</code>一样，也是一种可以被上锁的对象，但是和 <code>std::mutex</code>不同的是，<code>std::recursive_mutex</code>允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，<code>std::recursive_mutex</code>释放互斥量时需要调用与该锁层次深度相同次数的<code>unlock()</code>，可理解为 <code>lock()</code> 次数和<code>unlock()</code>次数相同，除此之外，<code>std::recursive_mutex</code> 的特性和<code>std::mutex</code> 大致相同。</p><p>例如函数 <code>a</code> 需要获取锁 <code>mutex</code>，函数<code>b</code> 也需要获取锁 <code>mutex</code>，同时函数 <code>a</code>中还会调用函数 <code>b</code>。如果使用<code>std::mutex</code>必然会造成死锁。但是使用 <code>std::recursive_mutex</code>就可以解决这个问题。</p><p>参考<ahref="https://www.zywvvd.com/notes/coding/cpp/cpp-lock/cpp-lock/#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89">C++多线程 —— 锁</a></p><h3 id="了解哪些c-11-的新特性">了解哪些C++ 11 的新特性</h3><ol type="1"><li><strong>自动类型推断（auto）</strong>:可以使用<code>auto</code>关键字来声明变量，让编译器根据初始化表达式的类型推断变量的类型。</li><li><strong>范围-based for循环</strong>：使用<code>for</code>循环可以遍历容器中的元素，语法更简洁直观。</li><li><strong>nullptr</strong>:引入了空指针常量<code>nullptr</code>，用于表示空指针。</li><li><strong>Lambda表达式</strong>:可以使用Lambda表达式来创建匿名函数，使得在函数式编程风格中更方便地使用。</li><li><strong>移动语义和右值引用</strong>：引入了右值引用和移动语义，可以通过移动而不是复制来提高程序的性能。</li><li><strong>智能指针</strong>：引入了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>等智能指针，用于管理动态分配的内存，避免内存泄漏和悬空指针问题。</li><li><strong>初始化列表</strong>：引入了初始化列表语法，可以通过<code>&#123;&#125;</code>来初始化数组、容器、结构体等。</li></ol><h3 id="weakptr如何获得sharedptr">weakPtr如何获得sharedPtr</h3><p><code>weak_ptr</code>对象不能直接被用于获取指向的对象，因为其不拥有所指向对象的所有权。但是可以通过<code>weak_ptr</code>对象的<code>lock()</code>成员函数获得一个指向所指对象的<code>shared_ptr</code>对象，前提是该对象还存在，如果对象不存在，<code>lock()</code>返回空.</p><h3 id="右值引用的用途">右值引用的用途</h3><p><strong>移动语义（Move Semantics）</strong>：右值引用使得移动语义成为可能。传统的复制操作会对资源进行深拷贝，而移动语义则允许将资源从一个对象“移动”到另一个对象，而不是进行昂贵的深拷贝操作。这在动态内存管理、容器类的元素操作以及返回临时对象等场景下都有很大的性能提升。</p><p><strong>完美转发（Perfect Forwarding）</strong>：右值引用可以在函数模板中实现完美转发，即<strong>保持原始参数类型的引用类型</strong>。这使得函数模板可以将参数完全转发给其他函数，而不会对参数类型造成额外的包装或变化，保持了原始参数的准确性。</p><h3 id="函数重载底层原理">函数重载底层原理</h3><p>首先C语言不支持函数重载，程序在预编译阶段会经历预<strong>处理、编译、汇编和链接生成可执行程序</strong>的过程，在汇编过程中编译器会收集<strong>全局符号</strong>并生成全局符号表（将符号和其相应地址一一对应的表格称为符号表）。C语言不支持函数重载的原因是符号表中的出现了两个具有有效地址的函数名，所以发生了冲突。</p><p><strong>C++对写入符号表的函数具有一个修正的过程</strong>，Linux下的命名规则做如下总结：</p><blockquote><p>**_Z + 函数名长度 + 函数名 + 类型首字母的小写**</p></blockquote><h3 id="c-编译器都做了哪些优化">C++ 编译器都做了哪些优化？</h3><ul><li>常量折叠（constantfolding）。编译器将编译期能计算为常量的表达式直接替换为计算结果。</li><li>常量传播（constantpropagation）。编译器追踪到一个值的源头，发现它是常量后，会将所有地方出现的这个值替换为常量。</li><li>公共子表达式消除（common subexpressionelimination）。将重复的计算过程重写掉，只算一次，其它地方复制结果。</li><li>移除死代码（dead coderemoval）。用许多其它方法优化后，可能有些代码对输出不产生影响，就可以移除这些代码。这里包含了对没用到的值的读写操作，以及完全没用到的整个函数或表达式。</li><li>指令选择（instructionselection）。这个不算是通常意义的优化，但既然编译器会将程序转换为它的内部表示形式，并生成CPU指令，编译器通常有一个庞大的等效指令序列的集合可供选择。编译需要知道目标处理器架构的细节以作出正确选择。</li><li>移动循环中的不变代码（loop invariant codemovement）。编译器能识别一块代码在循环过程中值不变，并将这块代码移出循环。其于此，编译器还能将循环中不变的条件检查移出循环外，再将循环体复制两次：一次针对条件为真，一次针对条件为假。之后还能做进一步优化。</li><li>窥孔优化（peepholeoptimization）。编译器取一小段指令序列并做局部优化。</li><li>尾调用移除（tail callremoval）。一个在结尾处调用自身的递归函数通常可被重写为循环，从而降低函数调用开销，并减小栈溢出的可能。</li></ul><h3 id="大端小端">大端小端</h3><h3 id="大端模式与小端模式">大端模式与小端模式</h3><ol type="1"><li>大端模式是指<strong>数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中</strong>.</li><li>小端模式是指<strong>数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中</strong>。</li></ol><p>例如：</p><p>一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122。那么0x11为数据高字节，0x22为数据低字节。</p><ol type="1"><li>对于大端模式，就将0x11放在内存低地址中，即0x0010中；0x22放在内存高地址中，即0x0011中。</li><li>小端模式，就将0x11放在内存高地址中，即0x0011中；0x22放在内存低地址中，即0x0010中。</li></ol><p>怎么判断大端小端？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLittleEndian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 将整数强制转换为字符指针，然后检查第一个字节的值</span><br>    <span class="hljs-comment">// 如果是小端序，最低有效字节会被存储在低地址处</span><br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">char</span> *)&amp;num == <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLittleEndian</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This system is Little Endian.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This system is Big Endian.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何让哈希表按插入的顺序有序">如何让哈希表按插入的顺序有序</h3><p>设置一个哈希表和一个双向链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; umap;<br>list&lt;<span class="hljs-type">int</span>&gt; l;<br></code></pre></td></tr></table></figure><p>取值可以使用<code>umap[key]-&gt;val</code>做到<code>O(1)</code>,同时<code>l</code>中也按照插入顺序有序。</p><h3id="make_shared与直接创建shared_ptr的区别">make_shared与直接创建shared_ptr的区别</h3><p>make_shared 只需要分配一次内存，而直接创建 shared_ptr需要分配两次内存。</p><p>make_shared也存在缺陷，只有当 _Weaks 为 0 时，控制块才会调用_Delete_this() 释放自己，weak_ptr会拖延整块内存释放时间。</p><h3id="dynamic_cast把父类指针转为void会怎么样">dynamic_cast把父类指针转为void*会怎么样</h3><p>在C++中，<code>dynamic_cast</code>用于在运行时进行安全的类型转换，通常用于将基类指针或引用转换为派生类指针或引用。如果将父类指针转换为<code>void*</code>，会丢失类型信息，因此无法在后续代码中准确地确定其类型。具体表现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::foo()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived derivedObj;<br>    Base* basePtr = &amp;derivedObj;<br><br>    <span class="hljs-comment">// 将父类指针转换为 void*</span><br>    <span class="hljs-type">void</span>* voidPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(basePtr);<br><br>    <span class="hljs-comment">// 尝试将 void* 转换回父类指针</span><br>    Base* newBasePtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Base*&gt;(voidPtr); <span class="hljs-comment">// 非法，无法使用 dynamic_cast 将 void* 转换回指针类型</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>dynamic_cast</code> 无法将 <code>void*</code>转换回指针类型，因为在将 <code>Base*</code> 转换为 <code>void*</code>时，类型信息已经丢失。因此，将父类指针转换为 <code>void*</code>后，再转换回去是不可行的。通常情况下，不建议将指针转换为<code>void*</code>，除非有特殊的需求。如果你需要从<code>void*</code>转换回具体的类类型指针，应该使用<code>static_cast</code>或<code>reinterpret_cast</code>，但这需要你确保转换的安全性。</p><h3id="什么样的数据类型需要关注大小端字节序">什么样的数据类型需要关注大小端字节序？</h3><p>只有超过一个字节的基本数据类型才需要考虑字节序</p><h3id="free释放内存的时候是怎么知道释放内存的大小的">free释放内存的时候是怎么知道释放内存的大小的？</h3><p>glibc:<strong>空间的大小记录在参数指针指向地址的前面，free的时候通过这个记录即可知道要释放的内存有多大。</strong></p><h3id="utf-8知道吗了解utf-8与gbk有什么不一样吗">utf-8知道吗？了解utf-8与gbk有什么不一样吗？</h3><ul><li><strong>ASCII</strong>：ASCII只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</li><li><strong>Unicode</strong>：由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常<strong>两个字节表示一个字符</strong>，而<strong>ASCII是一个字节表示一个字符</strong>，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</li><li><strong>UTF-8</strong>：为了解决上述问题，又出现了把Unicode编码转化为“<strong>可变长编码</strong>”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6个字节</strong>，<strong>英文字母被编码成一个字节，常用汉字被编码成三个字节</strong>，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</li><li>UTF-8是一种Unicode字符集的变长字符编码方式，支持包括英文、拉丁文、中文、日文、韩文等在内的几乎所有字符。</li><li>GBK是一种针对汉字的字符编码方式，它是在GB2312字符集的基础上扩展而来，支持汉字和一些常用的符号、数字等。</li></ul><h3id="static局部变量与普通局部变量区别">static局部变量与普通局部变量区别？</h3><ul><li>static局部变量只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在。普通局部变量，只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li><li>静态局部变量在静态存储区分配空间，局部变量在栈里分配空间。</li></ul><h3id="socket写过吗tcp三次握手发生在哪个函数">socket写过吗？tcp三次握手发生在哪个函数？</h3><ul><li>客户端调用connect()函数，此时客户端会向服务端发送SYN</li><li>服务端收到SYN后，会从listen()函数返回SYN+ACK</li><li>客户端收到connect()函数的返回，之后向服务端发送最后一个ACK</li><li>服务端收到最后一个ACK以后，将该连接请求从未完成连接队列放入已完成连接队列中，等待accept()从该队列中取出</li></ul><h3 id="半连接队列和全连接队列">半连接队列和全连接队列</h3><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>服务端收到客户端发起的 SYN请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p><h3 id="内存对齐的好处坏处">内存对齐的好处/坏处</h3><h3 id="c浮点数存储方式">C++浮点数存储方式</h3><h4 id="float大小为4字节即32位">float：大小为4字节，即32位</h4><ol type="1"><li>最高位 31 位 ,保存符号位 S，“0”表示正数 ,“1”表示负数</li><li>第30 位～23 位 ,共 8 位 ,保存指数部分(指数值加上偏移量127),称为阶码</li><li>第22 位～0 位 ,共 23 位 ,保存系数部分（整数位的1不保存），称为尾数</li></ol><h4 id="double大小为8字节即64位">double：大小为8字节，即64位</h4><ol type="1"><li>最高位 63 位 ,保存符号位 S，“0”表示正数 ,“1”表示负数</li><li>第 62 位～52 位 ,共 11 位 ,保存指数部分(指数值加上偏移量1023),称为阶码</li><li>第 51 位～0 位 ,共 52 位 ,保存系数部分（整数位的1不保存），称为尾数</li></ol><h3id="动态链接库和静态链接库的区别都是有多份拷贝吗">动态链接库和静态链接库的区别？都是有多份拷贝吗？</h3><p><strong>静态链接库用来和所有的目标文件一起组织成可执行文件，生成的可执行文件可以独立运行</strong>。存在诸多缺点：</p><ul><li>首先，<strong>可执行文件内部拷贝了所有目标文件和静态链接库的指令和数据，文件本身的体积会很大</strong>。当<strong>系统中存在多个链接同一个静态库的可执行文件时</strong>，<strong>每个可执行文件中都存有一份静态库的指令和数据</strong>，就会造成内存空间的极大浪费。</li><li>此外，<strong>一旦程序中有模块更新，整个程序就必须重新链接后才能运行</strong>。假设一个程序有20 个模块构成，每个模块的大小为 1MB，那么每次更新任何一个模块，用户就必须重新获取 20 MB的程序，<strong>对用户很不友好</strong>。</li></ul><p><strong>动态链接，指的是将链接的时机推迟到程序运行时再进行</strong>。具体来讲，<strong>对于一个以动态链接方式运行的项目，</strong>：</p><ul><li><strong>首先由静态链接器将所有的目标文件组织成一个可执行文件</strong></li><li><strong>运行时将所需的动态链接库全部载入内存，由动态链接器完成可执行文件和动态库文件的链接工作</strong>。</li></ul><p>和静态链接库相比，动态链接库可以很好地<strong>解决空间浪费</strong>和<strong>更新困难的问题</strong>。</p><ul><li>动态链接库和可执行文件是分别载入内存的，因此动态链接库的体积通常会小一些。<strong>当有多个程序使用同一个动态链接库时，所有程序可以共享一份动态链接库的指令和数据，避免了空间的浪费</strong>。</li><li>采用动态链接的方式<strong>也可以方便程序的更新和升级</strong>，当程序的某个模块更新后，只需要将旧的模块替换掉，程序运行时会自动将所有模板载入内存并动态地链接在一起。</li></ul><h3 id="动态绑定和静态绑定">动态绑定和静态绑定</h3><p>说起静态绑定和动态绑定，我们⾸先要知道<strong>静态类型和动态类型</strong>，静态类型就是它在程序中被声明时所采用的类型，在编译期间确定。动态类型则是指“目前所指对象的实际类型”，在运行期间确定。</p><p><strong>静态绑定</strong>，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期间。</p><p><strong>动态绑定</strong>，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发生在运行期间。</p><p>⽐如说，virtual函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意，我们<strong>不应该重新定义继承而来的缺省参数，因为即使我们重定义了，也不会起到效果</strong>。因为一个基类的指针指向一个派生类对象，在派生类的对象中针对虚函数的参数缺省值进行了重定义，但是<strong>缺省参数值是静态绑定的</strong>，静态绑定绑定的是静态类型相关的内容，所以会出现一种派生类的虚函数实现方式结合了基类的缺省参数值的调用效果，这个与所期望的效果不同。</p><h3 id="虚函数的额外开销">虚函数的额外开销</h3><ol type="1"><li>空间开销首先，由于需要为每一个包含虚函数的类生成一个虚函数表，所以程序的二进制文件大小会相应的增大；其次，对于包含虚函数的类的实例来说，每个实例都包含一个虚函数表指针用于指向对应的虚函数表，所以每个实例的空间占用都增加一个指针大小（32位系统4字节，64位系统8字节）。这些空间开销可能会造成缓存的不友好，在一定程度上影响程序性能。</li><li>时间开销虚函数的时间开销主要是增加了一次内存寻址，通过虚函数表指针找到虚函数表，虽对程序性能有一些影响，但是影响并不大。</li></ol><p>上述虚函数表面上的开销其实是<strong>微不足道</strong>的，真正影响虚函数性能的是隐藏在背后的,关键点在于<strong>分支预测器</strong>,对于直接调用而言，是不存在分支跳转的，因为跳转地址是编译器确定的，CPU直接去跳转地址取后面的指令即可，不存在分支预测，这样可以保证CPU流水线不被打断。而对于间接寻址，由于跳转地址不确定，所以此处会有多个分支可能，这个时候需要分支预测器进行预测，如果分支预测失败，则会导致流水线冲刷，重新进行取指、译码等操作，对程序性能有很大的影响。</p><h3 id="如何避免虚函数额外开销">如何避免虚函数额外开销</h3><p>使用模板泛型编程,但是这样会导致代码膨胀.</p><h3 id="new-operator和operator-new的区别">New operator和operatornew的区别</h3><h4 id="operator-new">operator new</h4><p>operate new 是一个分配原始内存的函数——至少在概念上，它与 malloc()没有太大区别。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><p>它的函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>当然，重载operator new（全局或类），还需要/需要重载匹配的operatordelete。</p><h4 id="new-operator">new operator</h4><p>new operate通常用于创建对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">my_class *x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">my_class</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>两者的区别在于 operator new 只分配原始内存，没有别的。newoperator首先使用 operator new分配内存，然后它调用正确类型的对象的构造函数，因此结果是在该内存中创建的真实活动对象。如果该对象包含任何其他对象（嵌入的或作为基类），则这些构造函数也会被调用。</p><p>new operator：它先调用operatornew分配内存，然后调用构造函数初始化那段内存。</p><p>operator new：可以重载，用于实现不同的内存分配行为。</p><h3 id="c的exception机制底层原理">C++的exception机制底层原理</h3><p>原理见<ahref="https://baiy.cn/doc/cpp/inside_exception.htm">C++异常机制的实现方式和开销分析</a>。</p><p>主要是在栈框架中添加了一些东西：</p><ul><li>piPrev成员指向链表的上一个节点，它主要用于在函数调用栈中逐级向上寻找匹配的catch 块，并完成<strong>栈回退</strong>工作。</li><li>piHandler成员指向完成异常捕获和栈回退所必须的数据结构（主要是两张记载着关键数据的表：“try”块表：tblTryBlocks及“栈回退表”：tblUnwind）。</li><li>nStep 成员用来定位 try 块，以及在栈回退表中寻找正确的入口。</li></ul><h3 id="c有哪些可重入锁">C++有哪些可重入锁</h3><p>std::recursive_mutex，同一个线程可以多次对std::recursive_mutex进行加锁。</p><h3 id="智能指针是线程安全的吗">智能指针是线程安全的吗</h3><p>总结:不是</p><p>情况一：多线程代码操作的是同一个shared_ptr的对象,这时候不是线程安全的;</p><p>情况二：多线程代码操作的不是同一个shared_ptr的对象,这时候是线程安全的.但是这只是说对shared_ptr对象来说是线程安全的,但是这并不意味着shared_ptr所管理的对象是线程安全的.</p><h3 id="c与c指针的区别">C与C++指针的区别</h3><p>C++和C语言对空指针的定义不同,c++11引入了nullptr</p><h3 id="什么情况下需要重载new">什么情况下需要重载new</h3><p>比如内存泄露检测，重载operatornew就可以记录下内存申请的具体位置。</p><h3 id="shared_ptr怎么实现引用计数">shared_ptr怎么实现引用计数</h3><p><code>hared_ptr</code>通过一个引用计数机制来管理对象的生命周期。每个<code>shared_ptr</code>都包含两个指针：一个指向对象，另一个指向控制块（controlblock）。控制块包含两个计数器：一个用于<code>shared_ptr</code>实例（_M_use_count），另一个用于<code>weak_ptr</code>实例（_M_weak_count）。</p><h3 id="unique_ptr怎么实现独占">unique_ptr怎么实现独占</h3><p>把拷贝构造函数和赋值操作符都声明为delete或private，这样每一个智能指针要指向一个对象时只能是指向一个新实例化的对象而不能通过“=”或者拷贝去指向前面已经创建了的对象。</p><h3 id="vector.push_back时间复杂度">vector.push_back时间复杂度</h3><p>平均O（1），但是在某些情况下是O（n），因为可能插入的时候涉及到vector扩容。</p><h3 id="static可以修饰虚函数吗">static可以修饰虚函数吗</h3><p>虚函数是用于实现多态性的关键概念，在继承体系中，派生类可以重写（覆盖）基类中的虚函数，从而实现特定的行为。当你声明一个函数为虚函数时，编译器将会创建一个虚函数表（vtable），用于存储各个虚函数的地址，以便在运行时进行动态分派。</p><p>而 <code>static</code>关键字会使成员变量或成员函数与类的实例独立，与类本身关联。因此，将<code>static</code>关键字用于虚函数是没有意义的，因为虚函数的调用是动态的，而<code>static</code> 成员函数在编译时就确定了调用的目标。</p><p>所以<strong>不能</strong>。</p><h3id="weak_ptr指向的对象可能不存在怎么处理这种情况">weak_ptr指向的对象可能不存在，怎么处理这种情况</h3><p>为了安全地使用<code>weak_ptr</code>指向的对象，你应该先将它转换为<code>shared_ptr</code>，这样可以确保在使用对象时对象是存在的。你可以使用<code>weak_ptr</code>的<code>lock()</code>方法来实现这一点。如果<code>weak_ptr</code>指向的对象已经不存在了，<code>lock()</code>会返回一个空的<code>shared_ptr</code>。</p><h3 id="c四种类型转换">C++四种类型转换</h3><h4 id="static_cast">static_cast</h4><p>没有运行时类型检查来保证转换的安全性，进行上行转换（把派生类指针或引用转为基类表示）是安全的；进行下行转换（把积累的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。</p><h4 id="dynamic_cast">dynamic_cast</h4><p>在进行下行转换的时候具有类型检查（信息在虚函数中）的功能，比static_cast安全。</p><p>dynamic_cast本身只能用于存在虚函数的父子关系的强制类型转换；对于指针，转换失败则返回nullptr；对于引用，转换失败会抛出异常。</p><h4 id="reinterpret_cast">reinterpret_cast</h4><p>可以将整形转换为指针，也可以把指针转为数组；可以在指针和引用里进行肆无忌惮的转换，平台一致性比较差。</p><h4 id="const_cast">const_cast</h4><p>常量指针转换为非常量指针，并且仍然指向原来的对象。常量引用转换为非常量引用，并且仍然指向原来的对象。去掉类型的const或volatile属性。</p><h3 id="哪些场景会遇到悬空指针">哪些场景会遇到悬空指针？</h3><ol type="1"><li>在函数中返回指向局部变量的指针。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* p = &amp;a;<span class="hljs-comment">// 指针指向局部变量，函数返回后</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>要避免这种情况，可以使用动态内存分配。</p><ol start="2" type="1"><li><p>在函数中定义局部容器变量，然后返回容器中元素的指针</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vetcor&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-keyword">return</span> &amp;vec[<span class="hljs-number">2</span>];<span class="hljs-comment">// 函数返回后vec会被销毁，所以返回的指针会成为选空指针</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="c的union">C++的union</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">float</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    U u;<br>    u.x = <span class="hljs-number">114</span>;<br>    cout &lt;&lt; u.x &lt;&lt; endl;<br>    u.y = <span class="hljs-number">5.14</span>;<br>    cout &lt;&lt; u.y &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>unoin的多个变量共用一块内存，如果是多个变量的话，union的大小就是站内存最大的那个。</p><h3 id="虚函数表是在什么时候建立的">虚函数表是在什么时候建立的？</h3><p>虚函数表是在编译的过程中创建。对于虚函数指针来说，由于虚函数指针是基于对象的，所以对象在实例化的<em>时候</em>，虚函数指针就会<em>创建</em>，所以是在运行时<em>创建</em>。</p><h3 id="c-什么情况下会出现堆栈溢出的情况">C++什么情况下会出现堆栈溢出的情况？</h3><ol type="1"><li>递归调用过深</li><li>局部变量空间所需大小超过栈的大小</li></ol><h3 id="栈溢出问题怎么解决">栈溢出问题怎么解决</h3><ol type="1"><li>使用迭代算法</li><li>适用动态内存分配</li></ol><h2 id="linux">Linux</h2><h2id="linux系统查看cpu占用的命令腾讯云">linux系统查看cpu占用的命令（腾讯云）</h2><ol type="1"><li><p>top命令可以看到总体的系统运行状态和cpu的使用率</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>top -u root<br></code></pre></td></tr></table></figure></p></li><li><p>htop命令是top命令的增强版(默认情况htop没有安装在linux上，所以要先安装)</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">htop<br></code></pre></td></tr></table></figure></p></li><li><p>使用ps命令来查看cpu使用率</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps aux | sort -nrk 3,3 | head -n 5<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="gdb如何调试">gdb如何调试</h3><ol type="1"><li><p><strong>编译程序时加上调试信息</strong>：在使用GDB进行调试之前，需要确保编译程序时包含调试信息。通常可以通过在编译命令中添加<code>-g</code>选项来生成调试信息，例如：</p><p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -g -o my_program my_program.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>启动GDB</strong>：在命令行中输入<code>gdb</code>命令，然后在GDB提示符下输入要调试的可执行文件的名称，例如：</p><p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb my_program</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>设置断点</strong>：在GDB中设置断点，以便在程序执行到指定位置时停止执行。可以通过以下命令设置断点：</p><ul><li><code>break function_name</code>：在指定函数的入口处设置断点。</li><li><code>break line_number</code>：在指定行号处设置断点。</li><li><code>break file_name:line_number</code>：在指定文件的指定行号处设置断点。</li></ul></li></ol><h3id="gdb运行报错如何通过core件找到错误">gdb运行报错如何通过core⽂件找到错误</h3><ol type="1"><li><p><strong>编译程序时包含调试信息</strong>：在编译程序时确保包含了调试信息，以便在后续调试时能够查看到源代码的信息。使用编译器选项<code>-g</code>来生成调试信息。</p></li><li><p><strong>使用GDB调试core文件</strong>：在命令行中输入以下命令：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb &lt;executable_file&gt; &lt;core_file&gt;<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;executable_file&gt;</code>是你编译的可执行文件的名称，<code>&lt;core_file&gt;</code>是core文件的名称。</p><p><strong>分析core文件</strong>：在GDB中加载core文件后，可以使用<code>bt</code>命令查看堆栈回溯信息，以确定程序崩溃时的函数调用栈。例如：</p><ol start="3" type="1"><li><strong>分析core文件</strong>：在GDB中加载core文件后，可以使用<code>bt</code>命令查看堆栈回溯信息，以确定程序崩溃时的函数调用栈。例如：</li></ol><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> bt<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><strong>查看变量值</strong>：在确定了程序崩溃的位置后，可以使用GDB中的命令查看局部变量、全局变量等的值，以帮助分析错误。例如：</li></ol><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">(gdb) p <span class="hljs-keyword">variable</span><span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><strong>分析源代码</strong>：使用GDB中的命令在源代码中查看程序崩溃的位置以及附近的代码，帮助理解问题所在。例如：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) list<br></code></pre></td></tr></table></figure><h3 id="如何加断点具体api调">如何加断点，具体api调⽤</h3><p>使用break命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break example.c:20<br></code></pre></td></tr></table></figure><p>调用api不会</p><h3 id="gdb如何查看函数调用栈">gdb如何查看函数调用栈</h3><ol type="1"><li><p>在终端中启动 GDB 并加载你的可执行文件：</p><p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb your_executable</span><br></code></pre></td></tr></table></figure></p></li><li><p>运行程序，直到你想要查看函数调用栈的地方。</p></li><li><p>在 GDB 提示符下，输入 <code>bt</code> 或 <code>backtrace</code>命令：</p><p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> bt<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="epoll函数参数">epoll函数参数</h3><p>在使用 Linux 中的 epoll API 进行事件驱动编程时，主要使用的函数是<code>epoll_create</code>、<code>epoll_ctl</code> 和<code>epoll_wait</code>。下面是它们的基本参数：</p><ol type="1"><li><strong>epoll_create(int size)：</strong><ul><li><code>size</code>：指定需要监听的文件描述符的数量的估计值。这个参数在epoll实例被内核创建时用于分配内部数据结构的大小。通常情况下，你可以将其设置为大于0 的任意值，因为内核会根据需要调整大小。但是，对于 Linux 2.6.8及更早版本的内核，这个参数被忽略，可以设置为任意值。</li></ul></li><li><strong>epoll_ctl(int epfd, int op, int fd, struct epoll_event*event)：</strong><ul><li><code>epfd</code>：epoll 实例的文件描述符，由<code>epoll_create</code> 返回。</li><li><code>op</code>：表示要执行的操作，可以是以下值之一：<ul><li><code>EPOLL_CTL_ADD</code>：向 epoll实例中添加一个要监听的文件描述符。</li><li><code>EPOLL_CTL_MOD</code>：修改 epoll实例中某个文件描述符的监听事件。</li><li><code>EPOLL_CTL_DEL</code>：从 epoll实例中删除一个不再需要监听的文件描述符。</li></ul></li><li><code>fd</code>：要添加、修改或删除的文件描述符。</li><li><code>event</code>：指向 <code>struct epoll_event</code>结构的指针，描述了要监听的事件类型。</li></ul></li><li><strong>epoll_wait(int epfd, struct epoll_event *events, intmaxevents, int timeout)：</strong><ul><li><code>epfd</code>：epoll 实例的文件描述符，由<code>epoll_create</code> 返回。</li><li><code>events</code>：用于存储发生事件的文件描述符和事件类型的数组。</li><li><code>maxevents</code>：<code>events</code>数组的大小，表示最多可以存储多少个事件。</li><li><code>timeout</code>：等待事件的超时时间，以毫秒为单位。可以有以下几种取值：<ul><li><code>-1</code>：无限等待，直到有事件发生。</li><li><code>0</code>：立即返回，不等待事件。</li><li><code>&gt;0</code>：等待指定的毫秒数后返回，即使没有事件发生。</li></ul></li></ul></li></ol><h3id="个件有千万有ip地址访问时间url访问topk出现频率的ip或url的命令">⼀个⽂件，有⼏千万⾏，有IP地址、访问时间、url，访问topk出现频率的IP或url的命令</h3><p>假设文件名为 <code>access.log</code>，文件内容类似于：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">15</span> /page1<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">20</span> /page2<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">25</span> /page1<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">30</span> /page3<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">35</span> /page2<br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">40</span> /page1<br></code></pre></td></tr></table></figure><h3 id="统计-ip-地址的频率">统计 IP 地址的频率：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> access.log | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | <span class="hljs-built_in">head</span> -n K<br></code></pre></td></tr></table></figure><p>这个命令的含义是：</p><ul><li>使用 <code>awk '&#123;print $1&#125;'</code> 提取每行的第一个字段（即 IP地址）。</li><li>使用 <code>sort</code> 对 IP 地址进行排序。</li><li>使用 <code>uniq -c</code> 对排序后的 IP 地址进行统计，并输出每个 IP地址出现的次数。</li><li>使用 <code>sort -nr</code> 对统计结果进行逆序排序。</li><li>使用 <code>head -n K</code> 只输出前 K 个结果，即 Top K 出现频率的IP 地址。</li></ul><h3 id="awk命令">awk命令</h3><p><code>awk</code>是一种文本处理工具，通常用于对文本文件进行行处理和字段处理。它以行为单位逐行读取输入文件，并根据用户指定的模式和动作对每行进行处理。<code>awk</code>的语法比较灵活，可以用于过滤、转换和格式化文本数据。</p><p>例如，以下是一个简单的 <code>awk</code>命令示例，用于提取文本文件中的第二列：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">awk</span> <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$2</span>&#125;&#x27;</span> filename.txt<br></code></pre></td></tr></table></figure><p>这个命令会读取 <code>filename.txt</code>文件的每一行，并将每行的第二列打印输出。</p><h3 id="linux的进程调度腾讯云">Linux的进程调度（腾讯云）</h3><h3 id="gdb-调试遇到stackovlerflow怎么办">GDB调试遇到stackovlerflow怎么办？</h3><p>如果按照一般的方式编译：</p><p>gcc –o stackoverflow stackoverflow.c</p><p>linux系统能够探测到程序中的stackoverflow，从而终止程序，如下图所示：</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820337928.jpg"alt="Linux下的栈溢出案例分析-GDB调试操练" /><figcaptionaria-hidden="true">Linux下的栈溢出案例分析-GDB调试操练</figcaption></figure><p>那有没有办法让系统不探测到stackoverflow，此处可以在编译时，禁用堆栈保护，具体命令如下：</p><p><code>gcc –fno-stack-protector –o stackoverflow stackoverflow.c</code></p><p>然后采用gdb调试stackoverflow。</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/14100820334293.jpg"alt="Linux下的栈溢出案例分析-GDB调试操练" /><figcaptionaria-hidden="true">Linux下的栈溢出案例分析-GDB调试操练</figcaption></figure><h3 id="fork函数">fork函数</h3><p>fork就会复制一份原来的进程即就是创建一个新进程,我们称子进程，而原来的进程我们称为父进程，此时父子进程是共存的，他们一起向下执行代码。</p><p>fork的返回值问题:</p><p>在父进程中，fork返回新创建子进程的进程ID；</p><p>在子进程中，fork返回0；</p><p>如果出现错误，fork返回一个负值；</p><p>getppid():得到一个进程的父进程的PID;</p><p>getpid():得到当前进程的PID;</p><h3 id="linux查看现在运行的所有进程">linux查看现在运行的所有进程</h3><p>ps aux</p><h3 id="linux日志查询">linux日志查询</h3><p>cat /var/log/syslog</p><h3id="linux如何在日志中查找某个数据">linux如何在日志中查找某个数据</h3><p>grep "keyword" /var/log/syslog</p><h3 id="fork-的原理哪里体现了fork分配资源">fork()的原理，哪里体现了fork分配资源？</h3><p>复制堆栈段，数据段，栈段等内存布局，但是代码段是映射的父进程的代码段以节省空间</p><h3id="fork是把进程从1个变成2个那么最初的进程是从哪里来的">fork()是把进程从1个变成2个，那么最初的进程是从哪里来的？</h3><p>系统启动时先加载内核，然后通过引导程序启动初始进程init或者叫systemd进程，是整个进程树的根节点</p><h4 id="启动进程是用户态还是内核态">启动进程是用户态还是内核态？</h4><p>systemd进程是内核直接创建的，因此是内核态进程</p><h3id="栈和堆大小是多少堆动态开辟的话能和内存一样大吗">栈和堆大小是多少，堆动态开辟的话能和内存一样大吗</h3><p><strong>Linux下进程栈的默认大小是10M</strong>，可以通过ulimit-s查看并修改默认栈大小。默认一个线程要预留1M左右的栈大小，所以进程中有N个线程时，Windows下大概有N*M的栈大小。堆的大小理论上大概等于<strong>进程虚拟空间大小-内核虚拟内存</strong>大小。</p><h3 id="多线程的线程栈分配在哪里">多线程的线程栈分配在哪里？</h3><h3 id="什么是协程">什么是协程？</h3><p>协程是另一种轻量级的执行单元。协程不是进程或线程，协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p>协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和线程切换相比，线程数量越多，协程的性能优势就越明显。不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。此外，一个线程的内存在MB级别，而协程只需要KB级别。</p><h3 id="磁盘空间使用情况可以">磁盘空间使用情况可以</h3><p>通过df -h命令查看</p><h3id="linux如何让程序后台运行又如何让后台的程序来到前台">linux如何让程序后台运行，又如何让后台的程序来到前台</h3><h4 id="将程序后台运行">将程序后台运行</h4><ol type="1"><li><p><strong>使用 <code>&amp;</code> 符号</strong>：在运行程序的命令行末尾添加 <code>&amp;</code>符号可以将程序放入后台运行，例如：</p><p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">bashCopy code<br>./my_program <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>使用 <code>nohup</code> 命令</strong>： 使用<code>nohup</code>命令可以让程序在后台运行，并且在用户退出登录时仍然保持运行。示例：</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bashCopy code<br><span class="hljs-built_in">nohup</span> ./my_program &amp;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>使用 <code>screen</code> 或 <code>tmux</code></strong>：使用 <code>screen</code> 或 <code>tmux</code>可以创建一个会话，并在其中运行程序，然后可以断开终端连接而不中断程序执行。示例：</p><p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">bashCopy codescreen -S session<span class="hljs-emphasis">_name</span><br><span class="hljs-emphasis">./my_</span>program<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="将后台的程序切换到前台">将后台的程序切换到前台</h4><ol type="1"><li><p><strong>使用 <code>fg</code> 命令</strong>： <code>fg</code>命令用于将最近放入后台的作业切换到前台。示例：</p><p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">bashCopy</span> <span class="hljs-meta">code</span><br><span class="hljs-symbol">fg</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>使用 <code>jobs</code> 和 <code>fg</code> 命令</strong>：<code>jobs</code> 命令用于列出后台运行的作业，然后使用<code>fg %job_number</code> 将特定的作业切换到前台。示例：</p><p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bashCopy</span> codejobs<br><span class="hljs-attribute">fg</span> %<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>使用 <code>screen</code> 或 <code>tmux</code></strong>：如果使用了 <code>screen</code> 或<code>tmux</code>，可以重新连接到会话并恢复程序运行。使用<code>screen -r</code> 或 <code>tmux attach</code>命令来重新连接到会话。</p></li></ol><h3id="linux下rm正在写入的文件会发生什么">Linux下rm正在写入的文件会发生什么</h3><p>只会删除文件名，并不会删除文件内容，只有所有打开此文件的进程都关闭此文件后（注意当进程退出时，会自动关闭所有打开的文件），文件内容才会被真正删除。</p><h3 id="linux开机过程">Linux开机过程</h3><ul><li>内核的引导。</li><li>运行 init。</li><li>系统初始化。</li><li>建立终端 。</li><li>用户登录系统。</li></ul><h3id="tcp一二三次握手报文丢失分别会发生什么">TCP一二三次握手报文丢失分别会发生什么？</h3><h4 id="第一次握手丢失"><strong>第一次握手丢失</strong></h4><p>客户端发送SYN请求连接报文，如果迟迟等不到服务器的请求确认报文段，那么就会进行超时重传，具体重传几次，要看tcp_syn_retries内核参数，一般默认是5次。要注意的是，重传的请求连接报文的seq序列号字段还是之前的seq，不会重新生成哦。</p><h4 id="第二次握手丢失">第二次握手丢失</h4><p>第二次握手丢失就有意思了，因为服务器发送的第二次握手是连接确认报文段，既包括对第一次握手的ACK确认，同时还有SYN字段表示要建立连接，所以第二次握手也可以成为SYN-ACK报文。所以当第二次握手丢失，客户端迟迟等不到第一次握手的确认，就会触发超时重传机制，进行超时重传；服务器等不到自己SYN连接的确认，也会进行超时重传。客户端和服务器具体的超时重传次数还是由内核参数决定。</p><h4 id="第三次握手丢失">第三次握手丢失</h4><p>第三次握手丢失，此时客户端已经处于established状态了，因为它通过两次握手已经验证了自己的发送和接收能力嘛。但是此时第三次握手丢失，服务器迟迟得不到ACK报文，但是ACK报文丢失，<strong>ACK报文是不会有重传的，当 ACK丢失了，就由对方重传对应的报文。</strong>所以当到达服务器的超时重传时间后，服务器会超时重传第二次报文，当达到最大超时重传次数还没得到ACK报文，服务器就会断开连接。</p><h2 id="计算机网络"><strong>计算机网络</strong></h2><h3 id="http协议里-301-304啥用处腾讯云">http协议里 301304啥用处（腾讯云）</h3><p>301永久重定向；302临时重定向；304未修改，重定向到已存在的缓存文件</p><h3 id="http请求过程腾讯云">http请求过程(腾讯云)</h3><ol type="1"><li>⾸先，我们在浏览器地址栏中，输⼊要查找⻚⾯的URL，按下Enter</li><li>浏览器依次在 浏览器缓存 --&gt;&gt;系统缓存--&gt;&gt;路由器缓存中去寻找匹配的URL，若有，就会直接在屏幕中显示出⻚⾯内容。若没有，则跳到第三步操作</li><li>发送HTTP请求前，浏览器需要先进⾏域名解析(即DNS解析)，以获取相应的IP地址;（浏览器DNS缓存、路由器缓存、DNS缓存）</li><li>获取到IP地址之后，浏览器向服务器发起TCP连接，与浏览器建⽴TCP三次握⼿</li><li>握⼿成功之后，浏览器就会向服务器发送HTTP请求，来请求服务器端的数据包</li><li>服务器处理从浏览器端收到的请求，接着将数据返回给浏览器</li><li>浏览器收到HTTP响应</li><li>查询状态，状态成功则进⾏下⼀步，不成功则弹出相应指示</li><li>再读取⻚⾯内容、进⾏浏览器渲染、解析HTML源码;（⽣成DOM树、解析CCS样式、处理JS交互，客户端和服务器交互）进⾏展示</li><li>关闭TCP连接（四次挥⼿）</li></ol><h3id="tcp三次握手过程为什么不是两次腾讯云">Tcp三次握手过程，为什么不是两次(腾讯云)</h3><h3 id="tcp为什么四次挥手腾讯云">TCP为什么四次挥手（腾讯云）</h3><h3 id="tcp的稳定性机制">TCP的稳定性机制</h3><p>TCP协议通过以下几种机制来确保数据的可靠传输和接收：</p><p><strong>三次握手四次挥手保证建立和断开连接的有效性</strong></p><p><strong>序列号和确认应答</strong>：发送方将每个数据包进行编号，并且接收方要对每个数据包进行确认应答。这样可以确保数据包的顺序和完整性。</p><p><strong>超时重传</strong>：如果发送方在一定时间内没有收到接收方的确认应答，就会重新发送数据包，以确保数据的可靠传输。</p><p><strong>流量控制</strong>：TCP协议使用滑动窗口机制来控制发送方和接收方之间的数据流量，避免发送过多的数据导致接收方无法处理。</p><p><strong>拥塞控制</strong>：TCP协议通过拥塞窗口机制来避免网络拥塞，当网络出现拥塞时，发送方会减小发送窗口的大小，以减缓数据包的发送速度。</p><p>综合上述机制，TCP协议能够确保数据的可靠传输和接收，从而保证了网络通信的稳定性和可靠性。</p><p>关键字：序列号，确认应答，超时重传，流量控制，拥塞控制</p><h3id="服务端出现大量close_wait-的原因可能是什么">服务端出现大量close_wait的原因可能是什么？</h3><p>  <code>close_wait</code>按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送<code>FIN</code>包告知客户端关闭关闭连接，之后迁移到<code>Last_ACK</code>状态。但是<code>close_wait</code>过多只能说明没有迁移到<code>Last_ACK</code>，也就是服务端是否发送<code>FIN</code>包，只有发送<code>FIN</code>包才会发生迁移，所以问题定位在是否发送<code>FIN</code>包。<code>FIN</code>包的底层实现其实就是调用socket的<code>close</code>方法，这里的问题出在没有执行<code>close</code>方法。说明<strong>服务器CPU处理不过来（CPU太忙）</strong>或者<strong>服务器端忘记调用<code>close</code>函数</strong>或者<strong>应用程序一直睡眠得不到调度</strong>。</p><h3id="解释一下time_wait作用腾讯云">解释一下time_wait作用（腾讯云）</h3><ul><li><strong>可靠地实现TCP全双工连接的终止</strong></li></ul><p>在进行关闭连接四次挥手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允许它重发最终的ACK。如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误（在java中会抛出connectionreset的SocketException)。</p><p>因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭的客户端必须维持状态信息进入TIME_WAIT状态。</p><ul><li><strong>允许老的重复分节在网络中消逝</strong></li></ul><p>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lostduplicate。</p><p>在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。</p><p>为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。</p><h3 id="tcp为什么会粘包腾讯云">TCP为什么会粘包（腾讯云）</h3><p>由于Nagle算法的优化会将多个小数据合成大数据发送</p><h4 id="粘包的包是在哪合成的">粘包的包是在哪合成的</h4><p>TCP粘包的包是在发送方的操作系统合成的。当应用程序通过TCP发送数据时，数据首先会被放入缓冲区。操作系统根据网络条件和其他因素决定何时发送这些缓冲区中的数据。如果一段时间内多个小数据包被放入缓冲区，而发送方的操作系统认为可以发送数据时，它可能会将这些小数据包合并成一个较大的数据包，然后发送到网络中。</p><h4id="nagle算法开启有什么好处和坏处">Nagle算法开启有什么好处和坏处</h4><p><strong>好处：</strong></p><ol type="1"><li><strong>减少网络流量：</strong>通过合并小数据包，减少了网络传输中的数据包数量，降低了网络拥塞的可能性，提高了网络的利用率。</li><li><strong>减轻网络负载：</strong>减少了发送小数据包的频率，降低了网络设备的负载，有助于提高网络的性能。</li></ol><p><strong>坏处：</strong></p><ol type="1"><li><strong>引入延迟：</strong>Nagle算法会等待一小段时间，尝试合并多个小数据包成一个大的数据包再进行发送。这样会导致数据的传输延迟增加，尤其是在对实时性要求较高的应用中，如在线游戏或实时视频流。</li><li><strong>小消息传输受阻：</strong>在某些情况下，如果有一些小数据包需要立即发送，启用Nagle算法可能导致这些小数据包被延迟发送，影响了实时性。</li></ol><h3 id="拆包的原因">拆包的原因</h3><p>如果发送端缓冲区的长度大于网卡的MTU时，TCP会将这次发送的数据拆成几个数据包发送出去。也就是说，发送端可能只发送了一次数据，接收端却要分好几次才能收到完整的数据。</p><h3 id="粘包问题怎么解决">粘包问题怎么解决？</h3><p><strong>发送方</strong>：通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p><p><strong>接收方</strong>：没有办法直接处理粘包问题，只能交给应用层解决.</p><ul><li>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</li><li>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</li><li>将包封装为固定长度，不够长度的用0填充。</li></ul><p><strong>注意</strong>:TCP头部字段是<strong>头部长度,</strong>并没有标识数据长度的字段.</p><h3 id="tcp的重传机制腾讯云">TCP的重传机制（腾讯云）</h3><p>数据发送之后会等待对方的确认，如果定时器超时而没有收到确认，发送方就假设数据丢失，触发重传机制。</p><p>TCP还采用了一种称为快速重传的机制。如果发送方连续收到三个相同序列号的确认，它会认为在这个序列号之前的数据段已经丢失，会立即重传该数据段，而不等待定时器超时。</p><h3id="拥塞窗口与流量窗口有什么区别腾讯云">拥塞窗口与流量窗口有什么区别（腾讯云）</h3><p>拥塞窗口（Congestion Window）和流量窗口（WindowSize）是TCP协议中的两个概念，<strong>它们用于控制和调整数据的传输速率</strong>，但有一些关键的区别。</p><ul><li>拥塞控制是指根据网络的拥塞程度来调节发送数据的速率，以避免网络拥塞导致丢包和网络性能下降。</li><li>流量控制是指接收方通知发送方自己的缓冲区大小，发送方根据接收方的缓冲区大小来控制发送数据的速率，以防止接收方的缓冲区溢出。</li></ul><h3 id="http状态码">HTTP状态码</h3><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315201411599.png"alt="image-20240315201411599" /><figcaption aria-hidden="true">image-20240315201411599</figcaption></figure><h3id="ssltls建立的时候和域名绑定还是ip绑定">SSL/TLS建立的时候和域名绑定还是ip绑定</h3><p>SSL/TLS 建立时是与域名绑定的，而不是 IP 绑定。</p><h3 id="dns和域名绑定还是ip绑定">DNS和域名绑定还是ip绑定</h3><p>域名</p><h3 id="http多个tcp连接怎么实现">HTTP多个TCP连接怎么实现</h3><h3 id="http一定要用tcp实现吗">HTTP一定要用TCP实现吗</h3><p>不一定，HTTP3就是用UDP实现的。QUIC是谷歌开发的基于UDP的传输协议，旨在提供更快的连接建立和更低的延迟。HTTP/3标准使用了QUIC作为传输层协议，因此可以说HTTP/3是基于QUIC实现的。与TCP相比，QUIC具有更快的连接建立速度和更好的拥塞控制，但也存在部署和兼容性等方面的挑战。</p><h3 id="https建立连接的过程">HTTPs建立连接的过程</h3><ol type="1"><li><strong>客户端发起连接请求</strong>：<ul><li>客户端向服务器发起连接请求，请求建立安全连接。客户端会发送一个HTTPS请求，其中包含了一些与SSL/TLS相关的信息，如支持的加密算法和SSL/TLS版本等。</li></ul></li><li><strong>服务器返回证书</strong>：<ul><li>服务器收到客户端的连接请求后，会向客户端发送服务器的数字证书，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等信息。服务器的证书是由可信任的证书颁发机构（CertificateAuthority，CA）签发的，客户端可以通过CA证书来验证服务器的证书的真实性和合法性。</li></ul></li><li><strong>客户端验证证书</strong>：<ul><li>客户端收到服务器发送的证书后，会进行证书的验证。客户端会检查证书的有效性、是否由可信任的CA签发、证书的有效期等信息，以确保服务器的身份和证书的合法性。如果证书验证失败，客户端会中断连接，否则继续连接。</li></ul></li><li><strong>客户端生成随机密钥</strong>：<ul><li>客户端生成一个随机数作为对称密钥，并使用服务器的公钥加密该密钥，然后发送给服务器。对称密钥是用于对数据进行加密和解密的密钥，这样可以保证数据的机密性。</li></ul></li><li><strong>服务器使用私钥解密密钥</strong>：<ul><li>服务器收到客户端发送的加密后的对称密钥后，使用自己的私钥进行解密，得到对称密钥。</li></ul></li><li><strong>建立安全通道</strong>：<ul><li>客户端和服务器都使用协商好的对称密钥来加密和解密通信中的数据，从而建立安全的通信通道。此后，客户端和服务器之间的所有数据传输都会通过这个加密通道进行加密和解密，保证了数据的机密性和完整性。</li></ul></li></ol><h3id="https客户端是怎么验证ca证书的有效性的">HTTPS客户端是怎么验证CA证书的有效性的</h3><p>首先 CA会把持有者的<strong>公钥、用途、颁发者、有效时间</strong>等信息打成一个包，然后对这些信息进行<strong>Hash 计算</strong>，得到一个 Hash 值；</p><p>然后 CA 会使用自己的<strong>私钥</strong>将该 Hash 值加密，生成Certificate Signature，也就是 CA 对证书做了签名；</p><p>最后将 Certificate Signature添加在文件证书上，形成<strong>数字证书</strong>；</p><p>客户端会使用同样的 <strong>Hash 算法获取</strong>该证书的 Hash 值H1；</p><p>通常<strong>浏览器和操作系统</strong>中集成了 <strong>CA的公钥</strong>信息，浏览器收到证书后可以使用 <strong>CA 的公钥解密Certificate Signature</strong> 内容，得到一个 Hash 值 H2 ；</p><p><strong>最后比较 H1 和H2，如果值相同，则为可信赖的证书，否则则认为证书不可信</strong>。</p><h3 id="很多closewait状态是什么原因">很多closewait状态是什么原因</h3><p>服务端的程序没有调用close 函数关闭连接。</p><h3id="客户端close了服务端发送数据会发什么">客户端close了服务端发送数据会发⽣什么</h3><p>根据TCP协议，客户端会向服务器发送一个RST（重置）报文，表明这是一个不再有效的连接。服务器端在收到RST报文后，应该意识到连接已经被客户端关闭，并停止尝试发送数据。</p><h3 id="vpn在哪层络模型实现的">VPN在哪⼀层⽹络模型实现的</h3><p>VPN（虚拟专用网络）可以在不同的网络层次上实现，具体取决于它使用的技术和协议。以下是VPN的一些常见实现层次：</p><ul><li>应用层：例如SSL VPN</li><li>网络层：例如IPSEC VPN、GRE VPN</li><li>数据链路层：例如L2TP VPN、PPTP VPN</li></ul><h3 id="王者荣耀是tcp还是udp链接">王者荣耀是Tcp还是Udp链接？</h3><p>王者荣耀游戏的启动和登录采用TCP连接，客户端操作与界面显示是通过UDP数据流与服务器进行交互的。</p><h3 id="如何判断tcp还是udp呢">如何判断tcp还是udp呢？</h3><ul><li><strong>端口号</strong>：一些常见的端口号被分配给了特定的协议，例如HTTP 使用 TCP 的端口 80，DNS 使用 UDP 的端口 53。</li><li><strong>包头标识</strong>：TCP 和 UDP数据包的包头中包含了不同的字段和标识符。例如，TCP的包头中有一个字节的标识符字段，用于指示该数据包是 TCP 数据包；而 UDP的包头中没有类似的标识符字段。因此，可以通过解析数据包的包头来确定其所使用的协议。</li><li><strong>协议类型字段</strong>：数据包的协议类型可能会被直接指定在 IP包头中的协议字段中。TCP 使用值 6 表示，UDP 使用值 17 表示。</li></ul><h3id="什么是网络地址转换network-address-translationnat请解释-nat-的原理和应用场景">什么是网络地址转换（NetworkAddress Translation，NAT）？请解释 NAT 的原理和应用场景。</h3><p>网络地址转换（Network AddressTranslation，NAT）是一种网络技术，用于将私有网络中的 IP地址映射到公共网络中的 IP地址，以便实现私有网络中的多个主机共享一个或多个公共 IP 地址的功能。</p><p>NAT 的工作原理如下：</p><ol type="1"><li><strong>内部网络</strong>：在私有网络（如家庭网络、企业网络）中，主机通常使用私有IP 地址（例如 192.168.x.x、10.x.x.x、172.16.x.x等）来进行通信，这些地址在全球范围内并不唯一。</li><li><strong>NAT 设备</strong>：在私有网络和公共网络之间，存在一个 NAT设备（通常是路由器或防火墙），它负责管理私有网络和公共网络之间的数据传输。</li><li><strong>地址映射</strong>：当内部网络中的主机尝试与外部网络通信时，NAT设备会将内部主机的私有 IP 地址转换成路由器的公共 IP地址，然后将数据包发送到外部网络。在数据包返回时，NAT 设备会将公共 IP地址转换回相应的私有 IP 地址，然后将数据包传递给内部主机。</li><li><strong>端口转换</strong>：除了进行 IP 地址的转换之外，NAT设备还可以进行端口转换，通过修改数据包中的端口号来实现多个内部主机共享一个公共IP 地址的功能。</li></ol><p>NAT 的应用场景包括但不限于以下几个方面：</p><ol type="1"><li><strong>节省 IP 地址</strong>：NAT 允许多个内部主机共享一个公共 IP地址，从而节省了公共 IP 地址的使用，特别是在 IPv4地址资源日益枯竭的情况下，NAT 可以有效地延长 IPv4 地址的使用寿命。</li><li><strong>网络隔离</strong>：NAT设备可以将内部网络与外部网络隔离开来，从而提高了网络的安全性和隐私保护。</li><li><strong>访问控制</strong>：NAT设备可以实现端口转发和端口过滤等功能，对内部网络的访问进行控制和管理。</li><li><strong>动态地址分配</strong>：NAT 设备可以为内部主机动态分配公共 IP地址，从而实现了灵活的网络配置和管理。</li></ol><h3id="什么是虚拟专用网络virtual-private-networkvpn请解释-vpn-的原理和使用场景">什么是虚拟专用网络（VirtualPrivate Network，VPN）？请解释 VPN 的原理和使用场景。</h3><p>虚拟专用网络（VPN）是一种通过公共网络（通常是互联网）在远程位置之间创建安全连接的技术。它允许用户通过加密通道安全地传输数据，就像在私有网络中一样。</p><h4 id="原理">原理：</h4><ol type="1"><li><strong>隧道协议</strong>：虚拟专用网络本质上是在您的本地设备和位置远隔千里的另一台VPN 服务器之间创建一个安全数据隧道。当您联机时，此 VPN服务器将成为您接收所有数据的来源。您的网络服务提供商（ISP）和其他第三方将无法再看到您的互联网流量的内容。</li><li><strong>加密</strong>：IPSec 等 VPN协议会对数据进行加密，然后再通过数据隧道发送数据。IPsec是一个协议套件，通过验证和加密数据流的每个 IP 数据包来保护 Internet协议（IP）通信。VPN服务就好比一个筛选器，使您的数据在一端无法读取，并且只在另一端进行解码 –这可防止个人数据滥用，即使您的网络连接被破坏时也是如此。网络流量不再容易受到攻击，您的互联网连接也是安全的。</li></ol><h4 id="使用场景">使用场景：</h4><ol type="1"><li><strong>远程访问：</strong>允许用户通过互联网安全地访问公司内部网络资源。远程工作者可以通过 VPN连接到公司网络，并访问文件、应用程序和其他资源，就像他们在办公室内一样。</li><li><strong>绕过地理限制：</strong> 通过连接到不同地区的 VPN服务器，用户可以绕过地理限制，访问被限制的内容，如特定国家或地区的网站、流媒体服务等。</li><li><strong>保护隐私：</strong> 在连接到公共 Wi-Fi 热点时，使用 VPN可以增加安全性和隐私保护，防止黑客窃取敏感信息。</li></ol><h3id="长连接和短链接以及他们各自的应用场景如何实现一个长连接">长连接和短链接，以及他们各自的应用场景，如何实现一个长连接</h3><p><strong>长连接</strong>：长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</p><p><strong>短连接</strong>：短连接（shortconnnection）是相对于长连接而言的概念，指的是在数据传送过程中，只在需要发送数据时，才去建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。</p><h4 id="应用场景">应用场景</h4><p><strong>长连接</strong>：长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。</p><p><strong>短连接</strong>：而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源。</p><h3 id="http报文组成">http报文组成</h3><p>HTTP报文分为请求报文和响应报文。</p><h4 id="请求报文request-message">请求报文（Request Message）</h4><ol type="1"><li><p><strong>请求行（RequestLine）</strong>：包括请求方法、请求的URL和HTTP协议版本。</p><p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">请求方法 <span class="hljs-built_in">URL</span> HTTP协议版本<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">code<br>GET /index.html HTTP/1.1<br></code></pre></td></tr></table></figure></p></li><li><p><strong>请求头部（RequestHeaders）</strong>：包括多个键值对，描述了请求的各种属性和参数。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">codeHeaderName1: HeaderValue1<br>HeaderName2: HeaderValue2<br>...<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">codeHost</span>: www.example.com<br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">88</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4324</span>.<span class="hljs-number">190</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,application/signed-exchange;v=b3;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>空行（BlankLine）</strong>：请求行和请求头部之后的一个空行，用于分隔请求头部和请求体。</p></li><li><p><strong>请求体（RequestBody）</strong>：可选部分，用于传输请求相关的数据。在GET请求中通常为空，而在POST等请求中包含具体的数据。</p></li></ol><h4 id="响应报文">响应报文</h4><ol type="1"><li><p><strong>状态行（StatusLine）</strong>：包括HTTP协议版本、状态码和状态消息。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP协议版本 状态码 状态消息<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure></p></li><li><p><strong>响应头部（ResponseHeaders）</strong>：与请求头部类似，包括多个键值对，描述了响应的各种属性和参数。</p></li><li><p><strong>空行（BlankLine）</strong>：状态行和响应头部之后的一个空行，用于分隔响应头部和响应体。</p></li><li><p><strong>响应体（ResponseBody）</strong>：包含实际的响应数据，例如HTML文档、JSON数据等。</p></li></ol><p>HTTP报文的组成部分是根据HTTP协议规范定义的，它们共同构成了HTTP通信中传输的数据格式。</p><h3id="http3和http2的区别quic协议原理">HTTP3和HTTP2的区别？QUIC协议原理？</h3><p>QUIC:基于UDP,不需要握手和挥手,同时<strong>实现了类似TCP的流量控制、传输可靠性的功能</strong>,<strong>集成了TLS加密功能</strong>,使用TLS1.3,TLS1.2需要1-2RRT才可以建立连接,而1.3完全建立连接需要1个RTT,而恢复会话需要0个RTT;<strong>多路复用，彻底解决TCP中队头阻塞的问题</strong>.</p><p><a href="https://juejin.cn/post/6995109407545622542">解读HTTP1/HTTP2/HTTP3</a>.</p><h3id="你了解的网络攻击方式有哪些syn攻击的防范方法">你了解的网络攻击方式有哪些？SYN攻击的防范方法？</h3><p><strong>攻击方式</strong>：</p><ol type="1"><li><strong>DDoS攻击</strong>：分布式拒绝服务（DDoS）攻击旨在通过同时向目标系统发送大量请求来耗尽目标系统的资源，使其无法正常工作。</li><li><strong>SQL 注入攻击</strong>：SQL注入攻击是通过向应用程序的输入字段插入恶意 SQL代码来利用应用程序对数据库的不安全输入验证，从而执行未经授权的数据库操作。</li></ol><p><strong>SYN攻击</strong>是一种常见的DoS攻击，利用 TCP协议中的三次握手过程的漏洞，向目标服务器发送大量的伪造 SYN请求，使目标服务器资源耗尽，无法响应正常用户的请求。防范 SYN攻击的常用方法包括：</p><ol type="1"><li><strong>SYN攻击检测与过滤</strong>：通过网络防火墙、入侵检测系统（IDS）等设备，对网络流量进行实时监控，识别并过滤掉恶意的SYN 请求。</li><li><strong>SYN Cookie 技术</strong>：服务器端可以使用 SYN Cookie技术来减轻 SYN 攻击带来的影响，该技术在处理 TCP连接请求时不会为每个请求都创建一个完整的连接状态，而是根据请求信息生成一个特殊的Cookie 值，只有当客户端发送 ACK 确认时，服务器才会创建真正的连接。</li><li><strong>增加连接数限制</strong>：在服务器端配置最大连接数限制，防止单个IP 地址同时建立过多的连接。</li><li><strong>使用反向代理</strong>：通过将服务器后面添加反向代理，将真实的服务器地址隐藏起来，减轻攻击对服务器的直接影响。</li><li><strong>增加系统资源</strong>：增加服务器的网络带宽、CPU和内存等资源，提高服务器抵御 SYN 攻击的能力。</li></ol><h3 id="syn-cookie技术">SYN Cookie技术</h3><p>我们知道，<code>TCP</code>连接建立时，双方的起始报文序号是可以任意的。<code>SYN cookies</code>利用这一点，按照以下规则构造初始序列号：</p><ul><li>设<code>t</code>为一个缓慢增长的时间戳(典型实现是每64s递增一次)</li><li>设<code>m</code>为客户端发送的<code>SYN</code>报文中的<code>MSS</code>选项值</li><li>设<code>s</code>是连接的元组信息(源IP,目的IP,源端口，目的端口)和<code>t</code>经过密码学运算后的<code>Hash</code>值，即<code>s = hash(sip,dip,sport,dport,t)</code>，<code>s</code>的结果取低24 位</li></ul><p>则初始序列号<code>n</code>为：</p><ul><li>高 5 位为<code>t mod 32</code></li><li>接下来3位为<code>m</code>的编码值</li><li>低 24 位为<code>s</code></li></ul><p>当客户端收到此<code>SYN+ACK</code>报文后，根据<code>TCP</code>标准，它会回复<code>ACK</code>报文，且报文中<code>ack = n + 1</code>，那么在服务器收到它时，将<code>ack - 1</code>就可以拿回当初发送的<code>SYN+ACK</code>报文中的序号了！服务器巧妙地通过这种方式间接保存了一部分<code>SYN</code>报文的信息。</p><p>接下来，服务器需要对<code>ack - 1</code>这个序号进行检查：</p><ul><li>将高 5位表示的<code>t</code>与当前之间比较，看其到达地时间是否能接受。</li><li>根据<code>t</code>和连接元组重新计算<code>s</code>，看是否和低 24一致，若不一致，说明这个报文是被伪造的。</li><li>解码序号中隐藏的<code>mss</code>信息</li></ul><p>到此，连接就可以顺利建立了。</p><p><strong>缺点</strong>：</p><ul><li><code>MSS</code>的编码只有3位，因此最多只能使用 8种<code>MSS</code>值</li><li>增加了密码学运算</li><li>服务器必须拒绝客户端<code>SYN</code>报文中的其他只在<code>SYN</code>和<code>SYN+ACK</code>中协商的选项，原因是服务器没有地方可以保存这些选项，比如<code>Wscale</code>和<code>SACK</code>。</li></ul><h3 id="time_wait状态过多要怎么解决">TIME_WAIT状态过多要怎么解决？</h3><p>编辑内核文件/etc/sysctl.conf，加入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间<br></code></pre></td></tr></table></figure><h3 id="udp如何变得安全">udp如何变得安全</h3><ol type="1"><li><strong>实现多路径传输</strong>：通过利用多个网络路径同时进行文件传输，分散数据流量，避免单一路径的拥堵问题，提高UDP协议的传输速度和稳定性。</li><li><strong>应用数据重传机制</strong>：当接收端收到不完整的数据时，可以请求发送端重新发送丢失的数据段，保证数据的完整性和可用性。</li><li><strong>加入安全认证机制</strong>：通过使用加密算法和数字签名等技术，保证数据信息的机密性和完整性，防止黑客攻击和数据泄露。</li></ol><h3 id="为什么dns协议不用tcp">为什么DNS协议不用TCP？</h3><p>UDP更快，TCP还需要三次握手，四次挥手；三次握手的时间UDP已经传完了。</p><p>另外，如果本地查询没有查到，需要本地DNS服务器迭代向顶级域名DNS服务器、权威域名DNS服务器迭代查询，如果每次都需要TCP三次握手，四次挥手，那么跟UDP的差距就很大了。</p><h3id="tcp连接如果客户端拔掉网线会怎么样">TCP连接如果客户端拔掉网线会怎么样？</h3><ol type="1"><li>如果网线断开的时间短暂，在SO_KEEPALIVE设定的探测时间间隔内，并且两端在此期间没有任何针对此长连接的网络操作。当连上网线后此TCP连接可以自动恢复，继续进行正常的网络操作。</li><li>如果网线断开的时间很长，超出了SO_KEEPALIVE设定的探测时间间隔，或者两端期间在此有了任何针对此长连接的网络操作。当连上网线时就会出现ETIMEDOUT或者ECONNRESET的错误。你必须重新建立一个新的长连接进行网络操作。</li></ol><h3id="客户端与服务器端建立连接如果服务器端进程崩了会怎么样">客户端与服务器端建立连接，如果服务器端进程崩了会怎么样？</h3><p>TCP的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有TCP 连接资源，于是内核会发送第一次挥手 FIN报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成TCP四次挥手的过程。</p><h3id="服务端主机宕机后客户端会发生什么">服务端主机宕机后，客户端会发生什么？</h3><p>分为客户端向服务器端发送数据和不发送数据两种情况：</p><h4id="服务端主机宕机后如果客户端会发送数据"><strong>服务端主机宕机后，如果客户端会发送数据</strong></h4><p>在服务端主机宕机后，客户端发送了数据报文，由于得不到响应，在等待一定时长后，客户端就会触发超时重传机制，重传未得到响应的数据报文。</p><p>当重传次数达到达到一定阈值后，内核就会判定出该 TCP连接有问题，然后通过 Socket 接口告诉应用程序该 TCP连接出问题了，于是客户端的 TCP 连接就会断开。</p><p>那 TCP 的数据报文具体重传几次呢？</p><p>在 Linux 系统中，<strong>提供了个叫 tcp_retries2 配置项，默认值是15</strong>。</p><h4id="服务端主机宕机后如果客户端一直不发数据"><strong>服务端主机宕机后，如果客户端一直不发数据</strong></h4><p>在服务端主机发送宕机后，如果客户端一直不发送数据，那么还得看是否开启了TCP keepalive 机制 （TCP 保活机制）。</p><p>如果没有开启 TCP keepalive机制，在服务端主机发送宕机后，如果客户端一直不发送数据，那么客户端的 TCP连接将一直保持存在，所以我们可以得知一个点，在没有使用 TCP保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED状态时，并不代表另一方的 TCP 连接还一定是正常的。</p><p>而如果开启了 TCP keepalive机制，在服务端主机发送宕机后，即使客户端一直不发送数据，在持续一段时间后，TCP就会发送探测报文，探测服务端是否存活：</p><ul><li>如果对端是正常工作的。当 TCP 保活的探测报文发送给对端,对端会正常响应，这样TCP 保活时间会被重置，等待下一个 TCP保活时间的到来。</li><li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP会报告该 TCP 连接已经死亡。</li></ul><h3 id="dns缓存存在哪些问题">DNS缓存存在哪些问题？</h3><ul><li>缓存刷新不受控：当企业的域名发生变更时，并没有办法刷新全球各地的递归服务器缓存以及客户端上的DNS缓存，因此在每个缓存TTL值超时之前，客户发起请求仍然会按照缓存记录的原有映射关系发起请求，这就可能会出现站点不可达或者访问到错误的网站。只有等递归服务器和客户端上的DNS缓存失效后，才能重新发起请求，得到最新的映射关系。</li></ul><h3 id="http怎么做断点续传">HTTP怎么做断点续传</h3><p>而所谓断点续传，也就是要从文件已经下载的地方开始继续下载。所以在客户端浏览器传给Web 服务器的时候要多加一条信息 -- 从哪里开始。</p><p>请求包可以这样：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">RANGE： bytes=2000070-<br></code></pre></td></tr></table></figure><h3 id="quic协议">QUIC协议</h3><p>Quic 全称 quick udp internet connection [1]，“快速 UDP互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp进行多路并发传输的协议。</p><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：</p><ol type="1"><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。</li></ol><h4 id="rtt-握手"><strong>0-RTT 握手</strong></h4><p>其实原理很简单：客户端缓存了ServerConfig（B=b*G%P），下次建连直接使用缓存数据计算通信密钥：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-3862b1eeb75898f4f32de223b6123ddb_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（1）客户端：生成随机数 c，选择公开的大数 G 和 P，计算 A=c * G %P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算通信密钥 KEY = c *B = c * b * G%P，加密发送应用数据</p><p>（3）服务器：根据 Client Hello 消息计算通信密钥 KEY = b<em>A = b</em> c * G % P</p><p>也就是说，客户端不需要经过握手就可以发送应用数据，这就是 0-RTT握手。再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数（A1=a *G%P，A2=c * G%P，......），一旦服务器的随机数b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。</p><p>为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性</p><h4 id="前向安全"><strong>前向安全</strong></h4><p>前向安全：是指用来产生会话密钥的长期密钥泄露出去，不会泄漏以前的通讯内容。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-d5e6bf3b74ae07927b0d62bccfa3c095_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A=a*G%P，将 A和 G 发送给服务器，也就是 Client Hello 消息</p><p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算初始密钥 initKey =a<em>B = a</em>b*G%P，加密发送应用数据 1</p><p>（3）服务器：根据 Client Hello 消息计算初始密钥 initKey = b * A = b *a * G%P</p><p>（4）服务器：生成随机数 c，计算 C=c*G%P，使用 initKey 加密C，发送给客户端，也就是 Server Hello 消息</p><p>（5）客户端：使用 initKey 解码获取 C，计算会话密钥 sessionKey = a * C= a * c * G%P，加密发送应用数据 2</p><p>（6）服务器：计算会话密钥 sessionKey = c * A = c *a*G%P，解密获取应用数据 2</p><p>客户端缓存的 ServerConfig是服务器静态配置的，是可以长期使用的。客户端通过 ServerConfig 实现 0-RTT握手，使用会话密钥 sessionKey 保证通信数据的前向安全。</p><h4 id="可靠传输"><strong>可靠传输</strong></h4><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-aace93419dd55c73ab4b5fd2976e1375_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（1）客户端：发送 3 个数据包给服务器（PKN = 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN=4）</p><p>由此可以看出，QUIC的数据包号是单调递增的。也就是说，之前发送的数据包（PKN=2）和重传的数据包（PKN=4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-e6abef5bc9316fd87905a5e97b547050_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK包到底是原始包的，还是重传包的。但 QUIC的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h4 id="流量控制"><strong>流量控制</strong></h4><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制，但是和 TCP不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection流量控制：规定了所有数据流的总窗口大小；Stream流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-a5f95afac0935ae11f4672d3fdf9bf3e_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>则整个 Connection 的可用窗口大小为：20+30+10 = 60</p><h4 id="拥塞控制">拥塞控制</h4><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd = min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h4 id="多路复用">多路复用</h4><p>多路复用是 HTTP/2 的主要特性之一。</p><p>概念：单条 TCP 连接上可以同时发送多个 HTTP 请求，解决了 HTTP1.1中单个连接 1 次只能发送 1 个请求的性能瓶颈。HTTP/2能实现多路复用的根本原因是采用了二进制帧格式的数据结构。</p><p>一个请求就对应一条流，通过 Stream ID就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-33cc6b4531a4de38b94da1b2a7b6ee8a_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>HTTP/2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在TCP 层的队头阻塞。</strong>那 QUIC 是如何解决 TCP层的队头阻塞问题的呢？其实很简单，HTTP/2 之所以存在 TCP层的队头阻塞，是因为<strong>所有请求流都共享一个滑动窗口</strong>，那如果给每个请求流都分配一个独立的滑动窗口，是不是就可以解决这个问题了？</p><p>QUIC 就是这么做的：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-b5a52474167933083a90ff8baa040005_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>A 请求流上的丢包不会影响 B请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC声明的无队头阻塞的多路复用。</p><h4 id="连接迁移"><strong>连接迁移</strong></h4><p>连接迁移：当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信，对于TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源IP、源端口、目的 IP、目的端口，只要其中 1个发生变化，就需要重新建立连接。但 QUIC 的连接是基于 <strong>64 位的Connection ID</strong>，网络切换并不会影响 Connection ID的变化，连接在逻辑上仍然是通的。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-f82f920a417188160d2354757db44567_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID字段可以判断这 4 个包是来自于同一个客户端。QUIC能实现连接迁移的根本原因是底层使用 UDP 协议就是面向无连接的。</p><h3 id="socket服务端编程流程">socket服务端编程流程</h3><ol type="1"><li>客户端调用connect()函数，此时客户端会向服务端发送SYN</li><li>服务端收到SYN后，会从listen()函数返回SYN+ACK</li><li>客户端收到connect()函数的返回，之后向服务端发送最后一个ACK</li><li>服务端收到最后一个ACK以后，将该连接请求从未完成连接队列放入已完成连接队列中，等待accept()从该队列中取出</li></ol><h3 id="tcp连接复用">TCP连接复用</h3><p>即多个客户端的HTTP请求复⽤到⼀个服务端的TCP连接上。具体做法如下：</p><p>采用TCP连接复用技术后，客户端（如：ClientA）与负载均衡设备之间进行三次握手并发送HTTP请求。负载均衡设备收到请求后，会检测服务器是否存在空闲的长连接，如果不存在，服务器将建立一个新连接。当HTTP请求响应完成后，客户端则与负载均衡设备协商关闭连接，而负载均衡则保持与服务器之间的这个连接。当有其它客户端（如：ClientB）需要发送HTTP请求时，负载均衡设备会直接向与服务器之间保持的这个空闲连接发送HTTP请求，避免了由于新建TCP连接造成的延时和服务器资源耗费。</p><h3id="tcp的mss字段是在什么阶段协商的">TCP的MSS字段是在什么阶段协商的？</h3><p>在TCP三次握手阶段，在TCP头部的选项里。</p><h3 id="https有什么方法破解吗">HTTPS有什么方法破解吗？</h3><p>https安全通信分三个阶段：</p><p>1）<strong>认证服务器</strong></p><p>2）<strong>交换加密key</strong></p><p>3）<strong>https流量传输</strong></p><p>如果想攻击https，可以分别从这三个阶段入手。</p><h4 id="认证阶段虚假证书欺骗">认证阶段—虚假证书欺骗</h4><p>诱导用户安装根证书，一旦根证书（CA公钥）安装好，一个信任链就形成了，CA可以用自己的私钥给任何服务器签署证书，只要CA愿意。</p><p>举例：</p><p>一公司想监控用户的流量，包括https流量，只要预先给员工电脑里安装一个根证书，然后在公司网络出口有监控软件，有根证书的私钥。</p><p>当用户访问https服务器时，监控软件欺骗用户自己就是https服务器，与用户建立SSL连接。</p><p>然后监控软件再与真正的https服务器建立SSL连接。</p><p>用户与服务器的加密流量监控软件可以一览无余。</p><h4 id="交换key阶段攻击dh算法">交换key阶段—攻击DH算法</h4><p>采用超级计算机，离线计算DH算法素数对，经过常年累月的计算，形成一个庞大的素数对数据库，用这个数据库来比对捕获到的DH交换，一旦匹配到，用户的sessionkey 就获得了，可以解密https流量。</p><p>斯诺登团队就是这么干的！</p><h4 id="加密key暴力破解">加密key暴力破解</h4><p>目前加密算法使用AES256块式加密，如果不知道key，而使用暴力破解，理论上需要2^256次才能破解，这个计算量是一个不可能完成的任务。</p><p>所以现实的做法是使用第一、第二种方法破解SSL流量。</p><p>Https只加密http报文，IP层完全是明文，所以谈不上任何的隐身。</p><p><strong>Https安全注意事项</strong></p><p>浏览器里的安全选项-SSL，只勾选TLS 1.2，其它统统不要。</p><p>不随意安装根证书，遇到可疑证书删掉为好！</p><h3 id="dns使用的是tcp还是udp协议">DNS使用的是TCP还是UDP协议？</h3><p><strong>TCP和UDP。</strong><strong>DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议</strong>.</p><p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。<strong>当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传输（zonetransfer）。</strong></p><p><strong>为什么既使用TCP又使用UDP？</strong></p><p>首先了解一下TCP与UDP传送字节的长度限制：UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。区域传送时使用TCP，主要有一下两点考虑：</p><ol type="1"><li>辅助域名服务器会定时（一般是3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。</li><li>TCP是一种可靠的连接，保证了数据的准确性。</li></ol><p><strong>域名解析时使用UDP协议</strong></p><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h3id="四次挥手的第二三次为什么不合并">四次挥手的第二三次为什么不合并</h3><ol type="1"><li>服务器可能还有报文未发送</li><li>ack和syn是不同时机触发的 ack是内核完成,会在收到fin的时候第一时间返回而fin则是应用程序代码块控制,在调用到socket的close方法才会触发fin</li></ol><h2 id="数据库">数据库</h2><h3id="一条mysql语句的执行过程腾讯云">一条MySQL语句的执行过程(腾讯云)</h3><ol type="1"><li><p>连接器:连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p></li><li><p>查询缓存:MySQL拿到 个查询请求后，会先到查询缓存看看，之前是不是执过这条语句。之前执过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。</p></li><li><p>分析器:你输的是由多个字符串和空格组成的条SQL语句，MySQL需要识别出的字符串分别是什么，代表什么。</p></li><li><p>优化器:优化器是在表<strong>有多个索引的时候，决定使哪个索引</strong>;或者在多个语句有多表关联(join)的时候，决定各个表的连接顺序。</p></li><li><p>执行器:MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进了执器阶段，开始执行语句。</p></li></ol><h3id="mysql-中如果修改了个-4kb-的的内容存磁盘时修改的是完整的还是中的段">MySQL中如果修改了⼀个 4kb的⻚的内容，存⼊磁盘时修改的是完整的⻚还是⻚中的⼀段</h3><p>在MySQL中，如果修改了一个4KB的页（Page）的内容，存入磁盘时通常是修改整个页而不是页中的一段。MySQL使用页作为存储数据的基本单位，通常是以固定大小的4KB为一页。当需要更新页中的数据时，MySQL通常会将整个页加载到内存中进行修改，然后再将整个页写回磁盘。</p><p>这样做的原因有几点：</p><ol type="1"><li><strong>简化管理</strong>：通过将整个页作为最小单位进行读取和写入，简化了数据管理和维护操作。</li><li><strong>减少I/O开销</strong>：相比于仅写入一页中的一小部分数据，写入整个页可以减少磁盘I/O操作次数，提高性能。</li><li><strong>保证数据一致性</strong>：通过整页写入，可以确保页的所有数据都是一致的，避免了部分数据更新而导致的数据不一致问题。</li></ol><h3 id="b树和b树腾讯云客户端">B树和B+树（腾讯云客户端）</h3><h3id="lru预读失效和缓存污染改进腾讯云">LRU预读失效和缓存污染改进（腾讯云）</h3><h4 id="预读失效">预读失效</h4><h5 id="什么是预读机制">什么是预读机制？</h5><p>Linux 操作系统为基于 Page Cache的读缓存机制提供预读机制，一个例子是：</p><ul><li>应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB范围内的数据，由于磁盘的基本读写单位为block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page中装下。</li><li>但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB)都加载到内存，于是额外在内存中申请了 3 个 page；</li></ul><p>预读失效会带来什么问题？</p><p>如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。</p><h5 id="解决方案">解决方案</h5><ul><li>Linux 操作系统和 MySQL Innodb 通过改进传统 LRU链表来避免预读失效带来的影响，具体的改进分别如下：</li><li>Linux 操作系统实现两个了 LRU 链表：活跃 LRU链表（active_list）和非活跃 LRU 链表（inactive_list）；</li><li>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：young区域 和 old 区域。</li></ul><p><strong>Linux</strong>：</p><p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU链表（active_list）和非活跃 LRU 链表（inactive_list）。</p><ul><li>activelist活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li>inactivelist不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li></ul><p>有了这两个 LRU 链表后，预读页就只需要加入到 inactive list区域的头部，当页被真正访问的时候，才将页插入 active list的头部。如果预读的页一直没有被访问，就会从 inactive list移除，这样就不会影响 active list 中的热点数据。</p><p><strong>MySQL</strong>：</p><p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，young区域 和 old 区域。</p><p>young 区域在 LRU 链表的前半部分，old区域则是在后半部分，这两个区域都有各自的头和尾节点，如下图：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/c5ec9c08462a2dd89d1038a144556a47c2b519.png"alt="图片" /><figcaption aria-hidden="true">图片</figcaption></figure><p>young 区域与 old 区域在 LRU链表中的占比关系并不是一比一的关系，而是是 7 比 3（默认比例）的关系。</p><p>划分这两个区域后，预读的页就只需要加入到 old区域的头部，当页被真正访问的时候，才将页插入 young区域的头部。如果预读的页一直没有被访问，就会从 old区域移除，这样就不会影响 young 区域中的热点数据。</p><h4 id="缓存污染">缓存污染</h4><h5 id="什么是缓存污染">什么是缓存污染？</h5><p>虽然 Linux （实现两个 LRU 链表）和 MySQL（划分两个区域）通过改进传统的 LRU数据结构，避免了预读失效带来的影响。</p><p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU链表头部（或者 young区域）」这种方式的话，那么还存在缓存污染的问题。</p><p>当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃LRU 链表（或者 young 区域）就被污染了。</p><h4 id="解决方案-1">解决方案</h4><p>前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者young 区域），这种 LRU 算法<strong>进入活跃 LRU链表的门槛太低了</strong>！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃LRU 链表里的热点数据淘汰了。</p><p>所以，只要我们提高进入到活跃 LRU 链表（或者 young区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young区域）里的热点数据不会被轻易替换掉。</p><p>Linux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：</p><ul><li>Linux 操作系统：在内存页被访问第二次的时候，才将页从 inactive list升级到 active list 里。</li><li>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：</li></ul><h3 id="说说你了解的mvcc机制">说说你了解的MVCC机制</h3><ol type="1"><li><strong>事务ID</strong>：每个事务都有一个唯一的ID，用于标识事务的版本。</li><li><strong>隐藏列</strong>：在支持MVCC的数据库表中，每行数据通常会有隐藏的列来存储事务ID和回滚指针。</li><li><strong>回滚指针</strong>：指向该行数据的前一个版本，这样就形成了一个版本链。</li><li><strong>ReadView</strong>：在查询时，数据库会为事务创建一个ReadView，这是一个逻辑上的快照，包含了在查询时刻活跃的所有事务ID。</li></ol><h3id="数据库是一阶段提交还是两阶段为什么是两阶段">数据库是一阶段提交还是两阶段？为什么是两阶段？</h3><p>数据库日志分为三种：</p><ul><li>undo log（回滚⽇志）：是 Innodb存储引擎层⽣成的⽇志，实现了事务中的<strong>原⼦性</strong>，主要⽤于<strong>事务回滚和MVCC</strong>。</li><li>redo log（重做⽇志）：是 Innodb存储引擎层⽣成的⽇志，实现了事务中的<strong>持久性</strong>，主要⽤于掉电等<strong>故障恢复</strong>；</li><li>binlog （归档⽇志）：是 Server层⽣成的⽇志，主要⽤于<strong>数据备份</strong>和<strong>主从复制</strong>；</li></ul><p>事务提交后，redo log 和 binlog都要持久化到磁盘，但是这两个是独⽴的逻辑，可能出现半成功的状态，造成两份⽇志之间的逻辑不⼀致。</p><ul><li>如果在将 redo log 刷⼊到磁盘之后， MySQL 突然宕机了，⽽ binlog还没有来得及写⼊。MySQL 重启后，通过 redo log 能将 Buffer Pool恢复到新值，但是 binlog ⾥⾯没有记录这条更新语句，在主从架构中，binlog会被复制到从库，由于 binlog丢失了这条更新语句，从库的这⼀⾏是旧值，主从不⼀致。</li><li>如果在将 binlog 刷⼊到磁盘之后， MySQL 突然宕机了，⽽ redo log还没有来得及写入。由于 redo log还没写，崩溃恢复以后这个事务无效，数据是旧值，⽽ binlog⾥⾯记录了这条更新语句，在主从架构中，binlog会被复制到从库，从库执⾏了这条更新语句，这⼀行字段是新值，与主库的值不⼀致性。</li></ul><p>所以会造成主从环境的数据不⼀致性。因为 redo log影响主库的数据，binlog 影响从库的数据，redo log 和binlog必须保持⼀致。</p><p>两阶段提交把单个事务的提交拆分成了 2个阶段，分别是准备(Prepare)阶段和提交(Commit)阶段，每个阶段都由协调者(Coordinator)和参与者(Participant)共同完成。</p><h4 id="两阶段提交的过程">两阶段提交的过程</h4><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护binlog ⽇志与 InnoDB 的 redo log，为了保证这两个⽇志的⼀致性，MySQL使⽤了<strong>内部 XA 事务</strong>，<strong>内部 XA 事务由 binlog作为协调者，存储引擎是参与者</strong>。</p><p>当客户端执⾏ commit 语句或者在⾃动提交的情况下，MySQL 内部开启⼀个 XA事务，分两阶段来完成 XA 事务的提交。</p><p>事务的提交过程有两个阶段，将 redo log 的写⼊拆成了两个步骤：prepare和 commit，中间再穿插写⼊binlog：</p><ul><li>prepare 阶段：将内部 XA 事务的 ID写⼊到 redo log，同时将 redo log对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘。</li><li>commit 阶段：把内部 XA 事务的 ID写⼊到 binlog，然后将 binlog持久化到磁盘，接着调⽤引擎的提交事务接⼝，将 redo log 状态设置为commit，此时该状态并不需要持久化到磁盘，只需要 write 到⽂件系统的pagecache 成功，只要 binlog 写磁盘成功，redo log 的状态还是 prepare也没有关系，⼀样会被认为事务已经执行成功。</li></ul><h3 id="mysql调优">MySQL调优</h3><h4 id="explain语句">explain语句</h4><p><code>EXPLAIN</code>是MySQL中的一个关键字，用于分析查询语句的执行计划。通过<code>EXPLAIN</code>关键字，可以查看MySQL执行查询的方法和顺序，帮助优化查询性能。</p><p>使用<code>EXPLAIN</code>可以获取查询执行计划的相关信息，包括以下内容：</p><ol type="1"><li>type：显示查询使用了何种类型</li><li>rows：预估搜索行数</li><li>extra:<ul><li>using index：是否使用了覆盖索引</li><li>using filesort：是否使用了外排序</li><li>distinct：是否在select部分使用了distinc关键字</li><li>Using index condition:使用索引下推</li></ul></li></ol><h4 id="建立索引"><strong>建立索引</strong></h4><ul><li>为经常被查询的列建立索引，特别是在 WHERE 和 ORDER BY子句中经常出现的列。</li><li>对于经常用于连接的列，考虑创建联合索引。</li><li>避免为稀疏列创建索引，因为这会增加索引维护的开销。</li></ul><h4 id="覆盖查询"><strong>覆盖查询</strong></h4><p>尽量避免全表扫描，即使使用索引也需要访问数据行。如果查询只需要索引列的值，可以创建覆盖索引，这样就不需要额外访问数据行了，从而提高查询性能。</p><h4 id="避免索引失效"><strong>避免索引失效</strong></h4><p>见索引失效。</p><h4 id="优化查询语句"><strong>优化查询语句</strong></h4><ul><li>使用 EXPLAIN关键字分析查询执行计划，查看是否使用了索引，以及索引的选择器是否合理。</li><li>避免一次性返回大量数据，尽量限制查询返回的数据量。</li><li>使用合适的 JOIN 类型，避免不必要的笛卡尔积。</li></ul><h3 id="mysql什么情况下不走索引">MySQL什么情况下不走索引</h3><ul><li><strong>索引列参与表达式计算</strong></li><li><strong>索引列使用了函数</strong></li><li><strong>对索引隐式类型转换</strong>：如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</li><li><strong>不等号条件</strong>：当查询中包含不等号条件（&lt;&gt;）时。</li><li><strong>表连接中的列类型不匹配</strong>：如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。</li><li><strong>索引列使用了左右模糊匹配</strong>，<code>Like %xxx</code>或者<code>like %xx%</code></li><li><strong>字符串列与数字直接比较</strong></li><li><strong>or条件</strong>：除非每个列都建立了索引才会走索引</li><li><strong>ORDER BY 操作</strong>：在ORDERBY操作中，排序的列同时也在WHERE中时，MYSQL将无法使用索引；</li><li><strong>联合索引非最左匹配</strong></li><li>使用了<code>select *</code></li></ul><h3id="为什么要建立索引索引为什么能够加快查询速度">为什么要建立索引？索引为什么能够加快查询速度？</h3><p>数据库索引能够加快查询的速度，主要是因为它提供了一种<strong>快速定位数据</strong>的方法，减少了数据库系统需要扫描的数据量。具体来说，数据库索引能够加快查询速度的原因包括以下几点：</p><ol type="1"><li><strong>减少数据扫描量</strong>：数据库索引可以将数据按照索引列的顺序进行组织，<strong>形成一种类似于字典的数据结构。当执行查询操作时，数据库系统可以利用索引快速定位到满足条件的记录</strong>，而不需要扫描整个表的数据。</li><li><strong>快速定位数据</strong>：数据库索引通常采用树状结构（如B+树）或哈希表等高效的数据结构来组织索引数据，使得数据库系统能够以O(logn)或O(1)的时间复杂度快速定位到目标记录，而不受数据量的影响。</li><li><strong>避免全表扫描</strong>：在没有索引的情况下，数据库系统可能需要对整个表进行扫描以寻找满足条件的记录，这样的全表扫描会消耗大量的时间和系统资源。而有了索引之后，数据库系统可以通过索引快速定位到符合条件的记录，避免了全表扫描，提高了查询效率。</li><li><strong>支持排序和聚合操作</strong>：数据库索引不仅可以加速查询操作，还可以加速排序和聚合操作。例如，在有序索引的情况下，数据库系统可以利用索引的有序性进行高效的范围查询和排序操作；而在哈希索引的情况下，数据库系统可以利用哈希表的快速查找特性进行高效的聚合操作。</li></ol><h3 id="数据库的几大范式">数据库的几大范式</h3><p>数据库的三大范式（Normalization）是关系型数据库设计中的基本原则，旨在帮助设计者有效地组织数据库结构，减少数据冗余和插入、更新、删除异常，提高数据库的数据完整性和灵活性。三大范式包括：</p><ol type="1"><li><strong>第一范式（1NF）</strong>：确保每个字段都是<strong>原子性</strong>的，即确保每<strong>个字段的值都是不可再分的基本单位</strong>，不包含多个值或重复的组合。换句话说，每个字段中不应该有多个值，而是单一的值。这样可以消除重复的数据，并确保每个字段具有唯一性和原子性。</li><li><strong>第二范式（2NF）</strong>：在<strong>满足第一范式的基础上，要求表中的非主键字段完全依赖于主键</strong>，而不是依赖于主键的一部分。简单来说，就是要保证表中的每个非主键字段都完全依赖于表的主键，而不是依赖于主键的某个子集。这样可以避免数据冗余和插入、更新、删除异常。</li><li><strong>第三范式（3NF）</strong>：在<strong>满足第二范式的基础上，要求表中的每个非主键字段之间不存在传递依赖关系</strong>。换句话说，就是要保证表中的每个非主键字段都直接依赖于主键，而不是依赖于其他非主键字段。这样可以进一步减少数据冗余，确保数据的更新操作不会导致数据不一致。</li><li><strong>BC范式（BCNF）</strong>:在第三范式的基础上，如果关系模型R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R为BCNF的模式。</li><li><strong>第四范式（4NF）</strong>：如果关系模式 R中的每一个非平凡多值依赖 A -&gt;&gt; B 都满足以下条件之一，则关系模式 R符合第四范式：<ol type="1"><li>A 是 R 的一个超码。</li><li>B 是 R 的一个超码。</li></ol></li></ol><h3 id="可重复读级别为什么还会有幻读">可重复读级别为什么还会有幻读</h3><p>可重复读隔离级别通常只针对已有数据的读操作，而不是针对整个查询结果集的完整性。因此，如果其他事务在同一事务中执行了插入、删除等操作，可能会导致幻读的出现。</p><h3 id="mysql主从数据一致性怎么保持">MySQL主从数据一致性怎么保持</h3><ul><li><strong>异步复制</strong>：也是默认的主从同步方式。这种方式的优点是效率高。缺点是不能保证数据一定会到达slave。可能会受到网络等原因出现延迟，导致主从数据不一致。当前对master中的表进行数据操作，master将事务Binlog事件写入到Binlog文件中，此时主库<strong>只会通知一下Dump线程发送这些新的Binlog到slave（</strong>slave的I/O线程读取并将事件写入relay-log中）然后主库就会继续处理提交操作，而此时不会保证这些Binlog传到任何一个从库节点上。</li><li><strong>全同步复制</strong>：优点是能够保证数据的强一致性，缺点是效率太低。当master上有提交事务之后，D<strong>ump线程发送这些新的Binlog到slave上</strong>，<strong>并且必须等待所有的slave回复成功</strong>（所有从库将事件写入中继日志，并将数据写入数据库）才能继续下一步操作。</li><li><strong>半同步复制</strong>：优点是在耗费少量性能的基础上能在一定程度上保证数据的一致性。当master上有提交事务之后，<strong>Dump线程发送这些新的Binlog到slave上，并且必须等待其中一个slave回复成功</strong>（slave将事件写入relay-log）才能继续下一步操作。</li></ul><h3 id="乐观锁悲观锁使用场景">乐观锁悲观锁使用场景</h3><p>乐观锁：适用于读操作频繁、写操作少量的场景，如大部分情况下读操作不会被写操作影响的情况下。</p><p>悲观锁：适用于写操作频繁、读操作少量的场景，或者需要保证资源的排他性访问的场景。</p><h3id="数据库的四大隔离级别分别是怎么实现的">数据库的四大隔离级别？分别是怎么实现的？</h3><h4 id="四大隔离级别">四大隔离级别</h4><p>四大隔离级别：读未提交（read uncommitted）、读提交（readcommitted）、可重复读（repeatable read）和串行化（serializable ）</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指， 一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h4 id="实现">实现</h4><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **ReadView * 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把Read View理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个Read View，而「可重复读」隔离级别是「启动事务时」生成一个 ReadView，然后整个事务期间都在用这个 Read View**。</li></ul><h3 id="什么是索引">什么是索引</h3><p>在数据库中，索引是一种数据结构，用于提高数据的检索速度和查询效率。索引可以看作是数据库表中一个或多个列的快速查找表，类似于书籍的目录，它们帮助数据库系统快速定位和访问表中的特定数据行。</p><h3 id="mysql怎么避免回表">MySQL怎么避免回表</h3><ul><li>覆盖索引</li><li>索引下推</li></ul><h3 id="索引下推的原理">索引下推的原理</h3><p>我们先简单了解一下MySQL大概的架构：</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/20210908213037.png"alt="MySQL大概架构" /><figcaption aria-hidden="true">MySQL大概架构</figcaption></figure><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul><h3 id="mysql的null值是怎么存储的">MySQL的NULL值是怎么存储的</h3><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL值并不会存储在行格式中的真实数据部分。</p><h3 id="mysql查询优化">mysql查询优化</h3><ol type="1"><li>使用索引</li><li>覆盖索引</li><li>避免索引失效的情况</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能</li><li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li><li>索引并不是越多越好，索引固然可以提高相应的 select的效率，但同时也降低了 insert 及 update 的效率</li></ol><h3 id="sql-分页查询如何实现offset过大怎么优化">SQL分页查询如何实现？offset过大怎么优化</h3><p>分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。</p><p>例如，如果一页为3条数据，那么第一页就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id, name, gender, score<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>; # 从<span class="hljs-number">0</span>开始显示<span class="hljs-number">3</span>条<br></code></pre></td></tr></table></figure><p>第二页为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id, name, gender, score<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">3</span>; # 从<span class="hljs-number">3</span>开始显示<span class="hljs-number">3</span>条<br></code></pre></td></tr></table></figure><p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code></p><h4 id="offset过大怎么优化">offset过大怎么优化？</h4><p>问题来了，<strong>limit 1451231,30</strong>就会<strong>扫描145万</strong>行，然后丢掉前145万条只取30条，<strong>数据库压力</strong>能不大么，相对来说limit30只会扫描30行，速度当然快。</p><ol type="1"><li><p><strong>子查询优化法</strong>先找出第一条数据，然后大于等于这条数据的id就是要获取的数据缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性</p></li><li><p><strong>倒排表优化法</strong></p><p>倒排表法类似建立索引，用一张表来维护页数，然后通过高效的连接得到数据</p><p>缺点：只适合数据数固定的情况，数据不能删除，维护页表困难</p></li><li><p><strong>反向查找优化法</strong></p><p>当偏移超过一半记录数的时候，先用排序，这样偏移就反转了</p><p>缺点：orderby优化比较麻烦，要增加索引，索引影响数据的修改效率，并且要知道总记录数，偏移大于数据的一半</p></li><li><p><strong>limit限制优化法</strong></p><p>把limit偏移量限制低于某个数。超过这个数等于没数据，我记得alibaba的dba说过他们是这样做的</p></li></ol><h3 id="数据库与缓存一致性问题">数据库与缓存一致性问题</h3><p>见<ahref="https://gstarmin.github.io/2023/12/25/%5B%5BRedis%5D%5D/#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BA%94%E6%98%9F%E9%AB%98%E9%A2%91">如何保证缓存与数据库双写时的数据一致性</a>.</p><h3id="为什么b数比红黑树更适合做索引数据结构">为什么B+数比红黑树更适合做索引数据结构</h3><p>AVL树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。</p><p>在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p><p><strong>B+树</strong>的子节点大于<strong>红黑树</strong>，<strong>红黑树</strong>只能有2个子节点，<strong>B树</strong>子节点大于2，子节点数多这一特点保证了存储相同大小的<strong>数据</strong>，<strong>树</strong>的高度更小，<strong>数据</strong>局部更加紧凑，而硬盘读取有局部加载的优化</p><p>B+树所有数据都在叶子节点，更方便遍历，而红黑树遍历要用中序。</p><h3 id="mysql是什么隔离级别">MySQL是什么隔离级别</h3><p>MySQL是可重复读级别，但是它很⼤程度上可以避免幻读现象。解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过<strong>MVCC</strong> ⽅式解决了幻读</li><li>针对当前读：（select ... for update 等语句），是通过 next-keylock（记录锁+间隙锁）⽅式解决了幻读，因为当执⾏ select ... for update语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock锁范围内插⼊。</li></ul><h3 id="表连接注意事项">表连接注意事项</h3><ol type="1"><li>应该用小表驱动大表</li><li>如果左表比较大，并且业务要求驱动表必须是左表，那么我们可以通过where条件语句，使得<strong>左表</strong>被过滤的小一些</li><li>关联字段给索引，因为在mysql的嵌套循环算法中，是通过关联字段进行关联，并查询的，所以给关联字段索引很必要</li><li>如果sql里面有排序，请给排序字段加上索引，不然会造成排序使用全表扫描；</li><li>能用inner join 就用 inner join</li></ol><h3 id="mysql-有哪些锁">mysql 有哪些锁？</h3><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/1090617-20211123091527322-1401355583.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>见<ahref="https://cloud.tencent.com/developer/article/2296117">细说MySQL锁机制</a>.</p><h4 id="加锁模式">加锁模式·</h4><ul><li><p><strong>记录锁</strong>：用于锁一行，分为共享和排他。</p></li><li><p><strong>意向锁</strong>：意向锁属于表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。分为意向共享锁和意向排他锁。<strong>意向锁之间是相互兼容的，但是意向锁和普通锁之间是可以互斥的。</strong></p><ul><li>作用：如果另一个任务试图在该<strong>表级别</strong>上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在<strong>锁定该表</strong>前不必检查各个页或行锁，而只需检查表上的意向锁。</li></ul></li><li><p><strong>间隙锁</strong>：<strong>间隙锁是一个在两个索引记录之间的间隙上的锁。</strong>不锁记录本身</p></li><li><p><strong>临键锁</strong>：记录锁和间隙锁的结合，不仅锁了区间，也锁了记录本身，区间是左开右闭。</p></li><li><p><strong>插入意向锁</strong>：间隙锁形式的意向锁，是一个<strong>间隙锁</strong>，<strong>行锁</strong>。当执行插入操作时，总会检查当前插入操作的下一条记录（已存在的主索引节点）上是否存在锁对象，判断是否锁住了gap，如果锁住了，则判定和插入意向锁冲突，当前插入操作就需要等待，也就是配合上面的间隙锁或者临键锁一起防止了幻读操作。</p></li><li><p><strong>自增锁</strong>：用于自增主键的锁，是一个表锁。</p></li></ul><h4 id="锁粒度">锁粒度</h4><ul><li><strong>全局锁</strong>：通过flush tables with read lock语句会将整个数据库就处于只读状态了，这时其他线程执行以下操作，增删改或者表结构修改都会阻塞。全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li><li><strong>表级锁</strong>：MySQL 里面表级别的锁有这几种：<ul><li>表锁：通过lock tables语句可以对表加表锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</li><li>自增锁：自增锁是一种比较特殊的<strong>表级锁</strong>。并且在事务向包含了<code>AUTO_INCREMENT</code> 列的表中新增数据时就会去持有自增锁。</li><li>意向锁：当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</li></ul></li><li><strong>行级锁</strong>：InnoDB 引擎是支持行级锁的，而 MyISAM引擎并不支持行级锁。<ul><li>记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X锁之分的，满足读写互斥，写写互斥</li><li>间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li><li>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock的组合，锁定一个范围，并且锁定记录本身。</li><li>插入意向锁：插入意向锁是一种特殊的<strong>间隙锁</strong> ——间隙锁可以锁定<strong>开区间</strong>内的部分记录。<ul><li>插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<strong>主键</strong>、<strong>唯一索引</strong>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong>。</li></ul></li></ul></li></ul><h3id="一个事务里有特别多sql的弊端即大事务的弊端">一个事务里有特别多sql的弊端（即大事务的弊端）</h3><h4 id="大事务产生的原因">大事务产生的原因</h4><ul><li>操作的数据比较多</li><li>大量的锁竞争</li><li>事务中有其他非DB的耗时操作</li></ul><h4 id="大事务造成的影响">大事务造成的影响</h4><ul><li>并发情况下，数据库连接池容易被撑爆</li><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>执行时间长，容易造成主从延迟</li><li>回滚所需要的时间比较长</li><li>undo log膨胀</li></ul><h3 id="mysql是什么隔离级别-1">MySQL是什么隔离级别？</h3><p>MySQL是可重复读，但是在很大程度上解决了幻读，解决方案有两种：</p><ul><li>针对快照读（普通 select 语句），是通过 MVCC ⽅式解决了幻读</li><li>针对当前读：（select ... for update 等语句），是通过 next-keylock（记录锁+间隙锁）⽅式解决了幻读，因为当执⾏ select ... for update语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock锁范围内插入。</li></ul><h3 id="sql数据库如何解决死锁">sql数据库如何解决死锁</h3><ol type="1"><li><strong>设置合理的锁超时时间</strong>：当尝试获取锁超过设定的时间后，放弃锁请求，避免长时间等待导致死锁。</li><li><strong>优化事务设计</strong>：尽量减小事务的大小和持续时间，减少锁的持有时间，从而降低死锁的风险。</li><li><strong>使用低隔离级别</strong>：如果可能，使用较低的隔离级别，以减少锁的需求和冲突。</li></ol><h3 id="mvcc有什么用">MVCC有什么用</h3><p>MVCC（Multiple Version ConcurrencyControl）的主要作用是解决读-写和写-写冲突，使得大多数读操作不用加锁，从而提高了并发性能。通过保存数据的多个版本来实现并发访问，避免了读操作之间的锁竞争。</p><h3 id="事务的原理">事务的原理</h3><p>事务是并发控制的单位，是用户定义的一个操作序列。这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务通常是以BEGINTRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，即将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。ROLLBACK表示回滚，即在事务运行的过程中发生了某种故障，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态。</p><h3id="如果数据库短时间有大量数据存储比如10分钟存50w条该如何设计">如果数据库短时间有大量数据存储，比如10分钟存50w条，该如何设计</h3><h4 id="读写分离">读写分离</h4><p>在绝大部分面向用户的系统中，都是读多写少的模型，比如电商，大部分的时候是在搜索和浏览，比如抖音，大部分是在加载短视频，所以我们需要考虑的问题是，数据库如何扛住查询请求。一般的解决方法是<strong>读写分离.</strong></p><p>所谓<strong>读写分离</strong>，就是把同一个数据库分离成两份，一份专门用来做事务操作，另一份专门用来做读操作，如图。</p><figure><imgsrc="https://img2020.cnblogs.com/other/1666682/202110/1666682-20211020105318832-483361882.png"alt="image-20210625142110740" /><figcaption aria-hidden="true">image-20210625142110740</figcaption></figure><p>做了<strong>主从复制</strong>之后，我们就可以在<strong>写入时只写主库</strong>，在<strong>读数据时只读从库</strong>，这样即使写请求会锁表或者锁记录，也不会影响到读请求的执行。同时呢，在读流量比较大的情况下，我们可以部署多个从库共同承担读流量，这就是所说的<strong>一主多从</strong>部署方式，在你的垂直电商项目中就可以通过这种方式来抵御较高的并发读流量。另外，从库也可以当成一个备库来使用，以避免主库故障导致数据丢失。</p><h3 id="数据库主从不一致解决方案">数据库主从不一致解决方案</h3><p><strong>方案一：忽略。</strong></p><p>任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。</p><p>画外音：如果业务能接受，最推崇此法。</p><p>如果业务能够接受，别把系统架构搞得太复杂。</p><p><strong>方案二：放弃主从架构，强制读主。</strong></p><p>（1）不采用读写主从架构，只使用一个高可用主库提供数据库服务；</p><p>（2）读和写都落到主库上；</p><p>（3）采用缓存来提升系统读性能 存储；</p><p>这是很常见的微服务架构，可以避免数据库主从一致性问题。</p><p><strong>方案三：半同步复制</strong></p><p>修改主库后至少同步修改完成一个从库，才返回请求，缓存每次都从那个同步更新的从库中读数据。</p><p>方案优点：利用数据库原生功能，比较简单</p><p>方案缺点：主库的写请求时延会增长，吞吐量会降低</p><h4 id="k-v数据库">K-V数据库</h4><p>典型的代表就是Redis，也是目前业内非常主流的Nosql数据库。</p><p>之所以在IO性能方面比传统关系型数据库高，有两个点</p><ul><li>数据基于内存，读写效率高</li><li>KV型数据，时间复杂度为O(1)，查询速度快</li></ul><h3 id="dropdeletetruncated的区别">drop，delete，truncated的区别</h3><p>数据恢复方面：delete 可以恢复删除的数据，而 truncate 和 drop不能恢复删除的数据。</p><p>执行速度方面：drop &gt; truncate &gt; delete。</p><p>删除数据方面：drop 是删除整张表，包含行数据和字段、索引等数据，而truncate 和 drop 只删除了行数据。</p><p>添加条件方面：delete 可以使用 where 表达式添加查询条件，而 truncate和 drop 不能添加 where 查询条件。</p><p>重置自增列方面：在 InnoDB 引擎中，truncate 可以重置自增列，而 delete不能重置自增列。</p><h3id="数据库插入大量数据怎么优化插入速度">数据库插入大量数据怎么优化插入速度？</h3><ul><li>禁用索引：在插入数据前暂时禁用索引，数据插入完毕后再启用索引。可以通过<code>ALTER TABLE tb_name DISABLE KEYS;</code>和<code>ALTER TABLE tb_name ENABLE KEYS;</code>来实现。</li><li>禁用唯一性检查：插入数据时，MySQL会对插入的数据进行唯一性检查。这种唯一性检验会降低插入数据的速度。为了降低这种情况对查询速度的影响，可以在插入数据前禁用唯一性检查，等到插入数据完毕后在开启。语句为<code>SET UNIQUE_CHECKS=0;</code>和<code>SET UNIQUE_CHECKS=1;</code></li><li>禁用外键检查</li><li>禁止自动提交：<code>SET AUTOCOMMIT=0;</code>插入之后再设置<code>SET AUTOCOMMIT=1;</code></li><li>使用批量插入:<code>INSERT INTO items(name,city,price,number,picture) VALUES ('耐克运动鞋','广州',500,1000,'001.jpg'),('耐克运动鞋2','广州2',500,1000,'002.jpg');</code>，这样比一句一句执行insert少了与数据库之间的连接等操作</li></ul><h3 id="一条update语句的执行流程">一条update语句的执行流程</h3><h4 id="select语句的执行流程">select语句的执行流程</h4><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240428201517031.png"alt="image-20240428201517031" /><figcaption aria-hidden="true">image-20240428201517031</figcaption></figure><ol type="1"><li>连接器：管理连接和权限验证</li><li>查询缓存：执⾏查询语句前，先看下查询缓存中是否有结果</li><li>解析器：解析SQL</li><li>执⾏SQL：<ol type="1"><li>预处理：判断表和字段是否存在</li><li>优化：比如有多个索引的时候决定使用哪个索引？</li><li>执行</li></ol></li></ol><h3 id="一条update语句的执行流程-1">一条update语句的执行流程</h3><p>select语句的流程要先走一遍，即：</p><ol type="1"><li>server层验证身份，然后到引擎层</li><li>调用存储引擎接口后，会先从BufferPool获取数据页，如果没有就从磁盘中读入BufferPool，然后判断更新前后的记录是否一样</li><li>开启事务，修改数据之前先记录undo log，写入Buffer Pool的undopage</li><li>开始更新pagedata中的记录，被修改的数据页称为脏页，修改会被记录到内存中的 redo logbuffer中，再刷盘到磁盘的redo log文件，此时事务是 perpare阶段</li><li>这个时候更新就完成了，当时脏页不会立即写入磁盘，而是由后台线程完成，这里会用doublewrite来保证脏页刷盘的可靠性</li><li>还没结束呢，这时候可以通知Server层，可以正式提交数据了，执行器记录binlogcache，事务提交时才会将该事务中的binglog刷新到磁盘中</li><li>这个时候Update语句完成了Buffer Pool中数据页的修改、undo日志、redolog缓存记录，以及记录binlog cache缓存</li><li>commit阶段，这个阶段是将redo log中事务状态标记为commit</li><li>此时binlog和redolog都已经写入磁盘，如果触发了刷新脏页的操作，先把脏页copy到double writebuffer里，Double Write Buffer 的内存数据刷到磁盘中的共享表空间ibdata，再刷到数据磁盘上数据文件 ibd</li><li>流程完结</li></ol><h3id="高并发下库存超卖怎么解决如何实现高并发">高并发下库存超卖怎么解决？如何实现高并发？</h3><p><strong>综合使用数据库和Redis满足高并发扣减：</strong></p><p>扣减库存其实包含两个过程：第一步是超卖校验，第二步是扣减数据的持久化；在传统数据库扣减中，两步是一起完成的。<strong>抗写的实现原理其实是巧妙的利用了分离的思想</strong>，分离开防超卖和数据持久化；首先防超卖是由Redis来完成的；通过Redis防超卖后，只要落库就可以；落库通过任务引擎，业务数据库使用商品分库分表，任务引擎任务通过单据号分库分表，热点商品的落库会被状态机分散开，消除热点。</p><p>第一关解决超卖检验：我们可以把数据放入Redis中，每次扣减库存，都对Redis中的数据进行incryby扣减，如果返回的数量大于0，说明库存够，因为Redis是单线程，可以信任返回结果。第一关是Redis，可以抗高并发，性能Ok。超卖校验通过后，进入第二关。</p><p>第二关解决库存扣减：经过第一关后，第二关不需要再判断数量是否足够，只需要傻瓜扣减库存就行，对数据库执行如下语句,当然还是需要处理防重幂等的，不需要判断数量是否大于0了，扣减SQL只要如下写就可以。</p><p><strong>要点</strong>：最终还是要使用数据库，热点怎么解决的呢？任务库使用订单号进行分库分表，这样针对同一个商品的不同订单会散列在任务库的不同库存，虽然还是数据库抗量，但已经消除了数据库热点。</p><h3 id="undo-logredo-logbinlog是哪个层实现的">Undo log、redolog、binlog是哪个层实现的？</h3><ol type="1"><li><strong>Redo Log在引擎层实现</strong>，用来恢复数据的，保障已提交事务的持久化特性，记录的是物理级别的数据页(包括datapage和undo page)做的修改</li><li><strong>Undo Log在引擎层实现的逻辑日志</strong>，用于数据回滚到之前状态，对于每个UPDATE语句，对应一条相反的UPDATE的undolog</li><li><strong>BinLog是Server实现的逻辑日志</strong>，用于复制和恢复数据，记录了所有的 DDL 和DML 语句（除了数据查询语句select、show等）</li></ol><h3 id="如何排查慢查询">如何排查慢查询</h3><p>查看数据库服务慢查询日志是否开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘slow_query_log’;<br></code></pre></td></tr></table></figure><p>开启慢查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br></code></pre></td></tr></table></figure><p>查看并设置慢查询阈值（超过这个时间sql就会被记录在慢查询日志中）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘long_query_time’; # 查看慢查询阈值<br><span class="hljs-keyword">set</span> long_query_time<span class="hljs-operator">=</span><span class="hljs-number">5</span>; # 设置慢查询阈值为<span class="hljs-number">5</span>s，默认是<span class="hljs-number">10</span>s<br></code></pre></td></tr></table></figure><h3id="有两个索引一个索引识别度高例如唯一索引另一个是普通索引但是查询语句可能会选择普通索引这是为什么">有两个索引，一个索引识别度高（例如唯一索引），另一个是普通索引，但是查询语句可能会选择普通索引，这是为什么？</h3><ol type="1"><li><strong>统计信息</strong>：数据库优化器依赖于统计信息来决定使用哪个索引。如果普通索引的统计信息更加全面或更新，优化器可能会认为它更适合当前的查询。</li><li><strong>索引覆盖</strong>：如果查询只需要索引中已有的列，优化器可能会选择那个能够“覆盖”查询的索引，即使它不是唯一索引。</li><li><strong>查询条件</strong>：查询中使用的特定条件可能与普通索引更匹配，例如，如果查询涉及到索引的前缀或范围查询。</li></ol><h3 id="mysql索引选择的策略">Mysql索引选择的策略</h3><ol type="1"><li><strong>选择唯一性高的字段作为索引</strong>：唯一性高的字段可以更好地帮助MySQL快速定位到符合条件的数据行，从而减少全表扫描的时间。</li><li><strong>尽量选择字段长度较小的字段作为索引</strong>：长度较小的字段在索引和查询时占用的空间更小，能够提高索引的效率。</li><li><strong>考虑使用复合索引</strong>：复合索引是指同时对多个字段创建索引，可以提高查询效率。但是需要注意不要创建过多的复合索引，以免影响数据库性能。</li><li><strong>避免在列上进行函数操作</strong>：在查询条件中尽量不要对字段进行函数操作，否则无法使用索引，导致查询性能下降。</li></ol><h2 id="操作系统">操作系统</h2><h3id="用户态和内核态的互换条件腾讯云">用户态和内核态的互换、条件（腾讯云）</h3><h4 id="切换条件">切换条件</h4><p>从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：</p><ul><li>系统调用，其实系统调用本身就是中断，但是软件中断，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如Linux 的 int 80h 中断。</li><li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li><li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li></ul><h4 id="切换过程">切换过程</h4><p>当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）</p><ul><li>设置处理器至内核态。</li><li>保存当前寄存器（栈指针、程序计数器、通用寄存器）。</li><li>将栈指针设置指向内核栈地址。</li><li>将程序计数器设置为一个事先约定的地址上，该地址上存放的是系统调用处理程序的起始地址。</li></ul><p>而之后从内核态返回用户态时，又会进行类似的工作。</p><h3 id="io-频繁发生内核态和用户态切换怎么解决腾讯云"><strong>I/O频繁发生内核态和用户态切换，怎么解决</strong>（腾讯云）</h3><p>I/O会导致系统调用，从而导致内核态和用户态之间的切换。因为对I/O设备的操作是发生在内核态。那如何减少因为I/O导致的系统调用呢？</p><p><strong>答案是：用户进程缓冲区。</strong></p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDUyOTU2,size_16,color_FFFFFF,t_70.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>用户进程缓冲区</strong>：</p><p>程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p><p><strong>内核缓存区</strong>：</p><p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p><h3id="网卡收到一个包之后到用户读取这个包经历了多少次系统调用有多少次拷贝操作">网卡收到一个包之后到用户读取这个包经历了多少次系统调用，有多少次拷贝操作</h3><ol type="1"><li><strong>网络中断处理：</strong>当网卡接收到数据包时，会触发网络中断，导致内核调用中断处理程序。这一步并不直接计算在系统调用的范畴内。</li><li><strong>协议栈处理：</strong>数据包会被传递给协议栈中的相应层（例如TCP/IP协议栈）。在这个过程中，内核可能执行一些系统调用来处理网络协议，如<code>ip_rcv</code>和<code>tcp_rcv</code>等。</li><li><strong>套接字缓冲区：</strong>数据包被放置在套接字缓冲区中，等待应用程序读取。这一步可能涉及到一次数据拷贝，将数据从协议栈缓冲区拷贝到套接字缓冲区。</li><li><strong>应用程序读取：</strong>应用程序通过系统调用（例如<code>read</code>或<code>recv</code>）从套接字缓冲区中读取数据。这一步可能涉及到一次数据拷贝，将数据从套接字缓冲区拷贝到用户空间缓冲区。</li></ol><p>总的来说，通常情况下，至少有两次拷贝操作：一次是从协议栈缓冲区到套接字缓冲区，另一次是从套接字缓冲区到用户空间缓冲区。系统调用的次数会涉及到中断处理、协议栈处理和应用程序读取。每个系统调用都可能涉及到上下文切换和内核态与用户态之间的切换，这可能会引入一些额外的开销。</p><h3id="操作系统如何进行进程的上下文切换">操作系统如何进行进程的上下文切换</h3><ol type="1"><li><strong>保存当前进程状态：</strong>当操作系统决定需要切换到另一个进程时，首先会保存当前进程的状态。这个状态通常包括CPU寄存器的内容（如程序计数器、栈指针、通用寄存器等）、进程控制块（PCB）中的进程信息（如进程ID、进程状态、程序计数器等）以及其他可能的状态信息。</li><li><strong>选择下一个进程：</strong>操作系统根据调度算法从就绪队列中选择下一个要运行的进程。这个选择可以根据不同的调度算法进行，例如先来先服务（FCFS）、轮转法（RoundRobin）、优先级调度等。</li><li><strong>加载下一个进程状态：</strong>一旦选择了下一个要运行的进程，操作系统就会从该进程的 PCB中获取其状态信息。这些信息包括进程的程序计数器、栈指针、寄存器值等。然后，操作系统将这些状态加载到CPU 中，准备开始执行该进程。</li><li><strong>切换内存空间：</strong>在多任务操作系统中，不同进程可能会运行在不同的内存空间中，因此在切换进程时，操作系统可能还需要执行内存空间的切换操作。这包括<strong>更新页表、切换地址空间</strong>等。</li><li><strong>恢复运行：</strong> 最后，操作系统会将 CPU控制权转移到新选择的进程，开始执行其代码。此时，该进程的状态被加载到 CPU中，从之前保存的状态中恢复，并继续执行其上一次被暂停的位置。</li></ol><h3 id="线程崩溃进程会崩溃吗">线程崩溃进程会崩溃吗？</h3><p>一般情况下，<strong>如果一个线程崩溃，那么整个进程很可能会崩溃</strong>。这是因为线程之间共享地址空间，一个线程的崩溃可能导致内存的不确定性，进而影响到其他线程的执行。</p><h3id="遇到过死锁吗怎么解决的不要背那四条">遇到过死锁吗？怎么解决的，不要背那四条。</h3><p>鸵鸟策略，遇到死锁的时候把进程kill掉。</p><h3 id="cpu中断后进程的处理流程">cpu中断后，进程的处理流程</h3><p>当 CPU接收到中断信号后，会暂停当前正在执行的进程，并执行中断处理程序。下面是CPU 中断后进程的处理流程的一般步骤：</p><ol type="1"><li>关中断。CPU关闭中断，即不再接受其他<strong>外部</strong>中断请求。</li><li>保存断点。将发生中断处的指令地址压入堆栈，以使中断处理完后能正确的返回（注意，有可能保存中断处的指令地址，也有可能是中断处的指令的下一条指令的地址，具体情况视中断的类型）。</li><li>识别中断源。CPU识别中断的来源，确定中断类型号，从而找到相应的中断处理程序的入口地址</li><li>（以上三步一般由处理中断的硬件电路完成）保存现场。将发生中断处的有关寄存器（中断服务程序要使用的寄存器）以及标志寄存器的内容压入堆栈。</li><li>执行中断服务程序。转到中断服务程序入口开始执行，可在适时时刻重新开放中断，以便允许响应较高优先级的外部中断。</li><li>（后三步一般由软件，即中断处理程序完成）恢复现场并返回。把“保护现场”时压入堆栈的信息弹回寄存器，然后执行中断返回指令，从而返回主程序继续运行。（IRET指令，无操作数，从栈顶弹出3个字，分别送入IP、CS和FLAGS寄存器）</li></ol><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E4%B8%AD%E6%96%AD-17112032380592.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="说说你对信号量的理解">说说你对信号量的理解</h3><p>信号量是一种用于进程间同步和互斥的同步原语。它通常用于解决多个进程或线程之间共享资源的并发访问问题。信号量可以是计数器或标志，用于控制对临界区的访问。</p><p>在操作系统中，信号量通常分为两种类型：</p><ol type="1"><li><strong>二进制信号量（BinarySemaphore）</strong>：也称为互斥锁，只能取两个值，通常为 0 或1。它用于实现临界区的互斥访问，保证在同一时刻只有一个进程可以访问临界资源。</li><li><strong>计数信号量（CountingSemaphore）</strong>：可以取多个值，通常用于控制共享资源的访问数量。它允许多个进程同时访问临界资源，但是需要限制资源的数量。</li></ol><p>信号量的基本操作包括：</p><ul><li><strong>初始化</strong>：创建信号量，并设置其初始值。</li><li><strong>P 操作（Wait操作）</strong>：尝试获取信号量资源，如果资源不可用，则进入等待状态，直到资源可用。如果是二进制信号量，P操作会将信号量值减 1。</li><li><strong>V 操作（Signal操作）</strong>：释放信号量资源，如果有等待的进程，通知它们资源可用。如果是二进制信号量，V操作会将信号量值加 1。</li></ul><p>信号量的使用场景包括：</p><ul><li><strong>临界区的互斥访问</strong>：多个进程需要对临界资源进行互斥访问，防止竞争条件（RaceCondition）的发生。</li><li><strong>生产者消费者问题</strong>：多个生产者和消费者共享一个有限的缓冲区，需要控制缓冲区的访问数量。</li><li><strong>读者写者问题</strong>：多个读者和写者共享一个数据资源，需要控制读写操作的并发访问。</li></ul><h3id="说说你对虚拟内存的理解尽可能多">说说你对虚拟内存的理解，尽可能多</h3><p>虚拟内存是一种计算机操作系统的内存管理技术，它将物理内存（RAM）和磁盘存储结合起来，为每个进程提供了一个连续的、私有的地址空间。虚拟内存使得多个进程可以同时运行，并且可以让每个进程感觉自己拥有整个系统的内存空间。</p><p>以下是对虚拟内存的更详细理解：</p><ol type="1"><li><strong>地址映射</strong>：虚拟内存将进程中的逻辑地址（虚拟地址）映射到物理内存中的物理地址。这样，进程看到的地址空间是连续的，但实际上数据可能存储在物理内存中的不同位置，或者甚至存储在磁盘上。</li><li><strong>页面</strong>：虚拟内存将地址空间分割成固定大小的页面（Page），通常为4KB 或8KB。物理内存也被分割成相同大小的页面。每个页面都有一个对应的页表（PageTable）记录它在物理内存中的位置。</li><li><strong>页面置换</strong>：当物理内存不足以容纳所有进程的数据时，虚拟内存使用页面置换算法将一部分数据从物理内存中换出到磁盘上的交换空间（SwapSpace），以释放物理内存供其他进程使用。常见的页面置换算法有最近最少使用（LRU）、先进先出（FIFO）等。</li><li><strong>虚拟内存管理</strong>：虚拟内存管理包括地址映射、页面分配、页面置换等功能。操作系统负责管理虚拟内存的分配和释放，以及页面置换算法的选择和执行。</li><li><strong>内存保护</strong>：虚拟内存可以为每个页面设置不同的访问权限，如读、写、执行等，以保护进程的内存安全。</li><li><strong>内存共享</strong>：虚拟内存允许多个进程共享内存页面，这些页面可以映射到不同的进程地址空间中，实现共享数据或代码。</li></ol><h3id="操作系统通过什么方式向用户提供系统调用">操作系统通过什么方式向用户提供系统调用</h3><p>操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境，但是计算机系统的各种硬件资源是有限的，因此为了保证每一个进程都能安全的执行。处理器设有两种模式：“用户模式”与“内核模式”。一些容易发生安全问题的操作都被限制在只有内核模式下才可以执行，例如I/O操作，修改基址寄存器内容等。<strong>而连接用户模式和内核模式的接口称之为系统调用。</strong></p><p><strong>应用程序代码运行在用户模式下，当应用程序需要实现内核模式下的指令时，先向操作系统发送调用请求。操作系统收到请求后，执行系统调用接口，使处理器进入内核模式。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。</strong></p><ol type="1"><li><strong>系统调用接口</strong>：<ul><li>操作系统会提供一组系统调用接口，这些接口定义了用户程序可以调用的操作系统服务和功能。这些接口通常以函数的形式提供给用户空间的应用程序，用户程序可以通过调用这些函数来请求操作系统执行特定的任务，如文件操作、进程管理、网络通信等。</li></ul></li><li><strong>软中断或陷阱指令</strong>：<ul><li>当用户程序调用系统调用接口时，通常会触发一个软中断（SoftwareInterrupt）或者陷阱指令（TrapInstruction）。这些指令会使处理器从用户态切换到内核态，进入操作系统的执行环境。在这个过程中，操作系统会检测到这个中断或者陷阱，并根据用户请求执行相应的系统调用服务。</li></ul></li></ol><h3 id="应用程序到磁盘读写完整流程">应用程序到磁盘读写完整流程</h3><p>在Linux系统中，应用程序到磁盘的读写流程是一个复杂的过程，涉及多个系统层面的交互。以下是一个简化的描述：</p><ol type="1"><li><strong>应用程序发起读写请求</strong>：当应用程序需要读取或写入数据时，它会通过系统调用（如<code>read()</code>或<code>write()</code>）请求操作系统进行数据传输。</li><li><strong>系统调用转换为内核操作</strong>：系统调用将用户空间的请求转换为内核空间的操作。在内核空间，数据会被写入到页缓存（PageCache）中，这是一种利用内存作为缓冲区的机制，可以提高数据访问速度。</li><li><strong>页缓存和磁盘交互</strong>：如果是读操作，内核会检查页缓存中是否有请求的数据。如果没有，它会从磁盘读取数据并加载到页缓存中。如果是写操作，数据首先被写入页缓存，并标记为“脏”，之后在适当的时候由flusher线程写回磁盘。</li><li><strong>DMA控制器参与数据传输</strong>：为了减轻CPU的负担，直接内存访问（DMA）控制器会被用来在内存和磁盘之间传输数据，无需CPU的直接干预。</li><li><strong>数据写入磁盘</strong>：最终，数据会被写入磁盘。这个过程可能是由flusher线程触发的，也可能是应用程序通过调用如<code>fsync()</code>的系统调用显式请求的。</li></ol><h3 id="数据在操作系统中的存储形式">数据在操作系统中的存储形式</h3><ol type="1"><li><strong>文件系统</strong>：操作系统通过文件系统管理数据的存储和组织。文件系统将数据以文件的形式存储在存储设备（如硬盘、固态硬盘等）上，并提供对这些文件的管理、访问和操作。</li><li><strong>数据库</strong>：数据库系统是一种专门用于管理和组织数据的软件。数据库中的数据以表格的形式进行组织，可以使用结构化查询语言（SQL）等方式对数据进行查询、更新和操作。</li><li><strong>内存</strong>：操作系统使用内存来存储正在运行的程序和它们所需的数据。内存是临时存储，当计算机关闭时，其中的数据通常会丢失。</li><li><strong>缓存</strong>：为了提高数据访问的速度，操作系统通常会使用缓存来临时存储最近访问过的数据。缓存位于内存中，可以减少对存储设备的访问次数，加快数据的访问速度。</li><li><strong>寄存器</strong>：寄存器是位于处理器内部的存储单元，用于暂存和处理指令和数据。寄存器的访问速度非常快，但容量较小，通常用于存储临时数据和处理器状态信息。</li></ol><h3 id="如何解决死锁">如何解决死锁</h3><ol type="1"><li><strong>预防死锁</strong>：通过一次性分配所有资源、按序请求资源等方式来预防死锁的发生。</li><li><strong>避免死锁</strong>：通过银行家算法等来判断并避免系统进入不安全状态，从而避免死锁。</li><li><strong>检测与解除死锁</strong>：定期检测系统中是否发生死锁，一旦发生死锁，则采取解除死锁的措施。解除死锁通常涉及撤销一些进程，以便回收它们的资源，从而使得其他进程能够继续执行。<ol type="1"><li>死锁定理：系统处于死锁的<strong>充分条件</strong>是：当且仅当次状态的进程－资源分配图是不可简化的。</li></ol></li></ol><h3 id="软连接和硬链接的区别">软连接和硬链接的区别</h3><p><strong>物理实现</strong>：</p><ul><li>软链接：软链接是⼀个独⽴的⽂件，它包含了指向⽬标⽂件或⽬录的路径。软链接实际上是⼀个特殊的⽂件，其中包含有关⽬标⽂件的引⽤。</li><li>硬链接：硬链接是⽬标⽂件的⼀个<strong>额外的⽬录项</strong>。⽬录项指向相同的物理数据块，实际上只是⽂件系统中的两个或多个⽬录项指向相同的inode。</li></ul><p><strong>链接的目标</strong>：</p><ul><li>软链接：软链接可以链接到⽂件或⽬录，甚⾄可以链接到不存在的⽂件。</li><li>硬链接： 硬链接只能链接到⽂件，⽽且必须是同⼀⽂件系统中的。</li></ul><p><strong>对链接的影响</strong>：</p><ul><li>软链接：如果原始⽂件被删除或移动，软链接仍然存在，但链接将失效。软链接可以跨⽂件系统，但如果⽬标⽂件被删除，软链接将成为坏链接（danglinglink）。</li><li>硬链接：删除或移动原始⽂件并不会影响硬链接，因为硬链接只是inode的另⼀个引⽤。只有当所有硬链接都被删除后，inode的数据块才会被释放。</li></ul><p><strong>创建方式</strong>：</p><ul><li>软链接： 使⽤ln -s 命令创建软链接。例如， ln -s target_filelink_name 。</li><li>硬链接： 使⽤ln 命令创建硬链接。例如， ln target_file link_name。</li></ul><p><strong>链接数量</strong>：</p><ul><li>软链接：软链接只会增加⽬标⽂件的链接计数，⽽不会增加inode的链接计数。</li><li>硬链接：硬链接会增加⽬标⽂件的链接计数，也会增加inode的链接计数。当链接计数为零时，⽂件系统才会释放相关的数据块。</li></ul><h3 id="位和32位的区别及原理">64位和32位的区别及原理</h3><p>我们通常说的64位技术是相对于32位而言的，这个位数指的是CPUGPRs(General-PurposeRegisters，通用寄存器)的数据宽度为64位，64位指令集就是运行64位数据的指令，也就是说处理器一次可以运行64bit数据。</p><p>32位处理器一次只能处理32位，也就是4个字节的数据；而64位处理器一次就能处理64位，即8个字节的数据。如果将总长128位的指令分别按16位、32位、64位为单位进行编辑的话：32位的处理器需要4个指令，而64位处理器则只要两个指令。显然，在工作频率相同的情况下，64位处理器的处理速度比32位的更快。除了运算能力之外，与32位处理器相比，64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，而64位处理器的一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。传统32位处理器的寻址空间最大为4GB，而64位的处理器在理论上则可以达到1800万个TB（1TB=1024GB）。</p><h3 id="多进程和多线程如何选择">多进程和多线程如何选择？</h3><ul><li><strong>需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）</strong></li><li><strong>需要进行大量计算的优先使用线程（CPU频繁切换）</strong></li></ul><h3 id="不同进程通信方式的适用场景">不同进程通信方式的适用场景</h3><ul><li>管道：管道的通信方式效率低，不适合进程间频繁地交换数据。</li><li>消息队列：<strong>通信不及时</strong>，<strong>不适合比较大数据的传输</strong><ul><li>缺点：<strong>通信不及时</strong>，不适合比较大数据的传输，<strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>。</li><li>优点：可以频繁地交换数据</li></ul></li><li>共享内存</li><li>信号量：适用与不同进程之间的同步和互斥</li><li>socket：常用于网络通信</li></ul><h3 id="守护进程的作用和原理">守护进程的作用和原理</h3><p>守护进程（Daemon）是在操作系统中运行的一种特殊类型的后台进程。它在系统启动时启动，并在系统关闭时终止，与用户交互的终端会话无关。守护进程通常在后台运行，不会与用户进行直接的交互，也不会被用户终止。</p><p>创建守护进程的三种方式：</p><ol type="1"><li>使用nohup命令</li><li>使用fork()函数按步骤创建</li><li>daemon() 函数直接创建守护进程</li></ol><h4 id="作用">作用</h4><ol type="1"><li><p>提供服务：守护进程通常负责提供某种服务，例如：Web服务器、数据库服务、打印服务等。</p></li><li><p>系统管理：守护进程可以执行系统管理任务，例如：日志记录、监控系统状态、自动备份等。</p></li><li><p>定时任务：守护进程可以定期执行某些任务，例如：定时清理临时文件、执行定时脚本等。</p></li></ol><h4 id="原理-1">原理</h4><ol type="1"><li>创建子进程<strong>，</strong>父进程退出，<strong>在Linux中父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程是，就会自动由1号进程（init）收养它，这样，原先的子进程就会变成init进程的子进</strong></li><li>为了避免守护进程成为孤儿进程，需要使用setid创建一个新的会话，并担任该会话组的组长。<strong>从而让子进程摆脱原会话的控制</strong>，<strong>让进程摆脱原进程组的控制</strong>，<strong>让进程摆脱原控制终端的控制</strong></li></ol><p>那么，在创建守护进程时为什么要调用setsid函数呢？由于创建守护进程的第一步调用了fork函数来创建子进程，再将父进程退出。<strong>由于在调用了fork函数时，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，还还不是真正意义上的独立开来，而setsid函数能够使进程完全独立出来，从而摆脱其他进程的控制</strong></p><h3 id="文件系统">文件系统</h3><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux最经典的一句话是：「<strong>一切皆文件</strong>」，不仅普通的文件和目录，就连块设备、管道、socket等，也都是统一交给文件系统管理的。</p><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（indexnode）和目录项（directoryentry）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p><ul><li>索引节点，也就是 inode，用来记录文件的元信息，比如 inode编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</li><li>目录项，也就是<em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li></ul><p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p>目录项和目录是一个东西吗？</p></blockquote><p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p><p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p><p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。</p><blockquote><p>那文件数据是如何存储在磁盘的呢？</p></blockquote><p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有<code>512B</code>大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。</p><p>所以，文件系统把多个扇区组成了一个<strong>逻辑块</strong>，每次读写的最小单位就是逻辑块（数据块），Linux中的逻辑块大小为 <code>4KB</code>，也就是一次性读写 8个扇区，这将大大提高了磁盘的读写的效率。</p><p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-9d77e25913894df26b0374ceae25c605_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。</p><p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p><ul><li><em>超级块</em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。</li><li><em>索引节点区</em>，用来存储索引节点；</li><li><em>数据块区</em>，用来存储文件或目录数据；</li></ul><p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：</p><ul><li>超级块：当文件系统挂载时进入内存；</li><li>索引节点区：当文件被访问时进入内存；</li></ul><h3 id="用户态和内核态之间通信方式">用户态和内核态之间通信方式</h3><ul><li>sysctl</li><li>sysfs</li><li>netlink</li><li>procfs(/proc)</li></ul><h3 id="页面置换算法">页面置换算法</h3><ol type="1"><li>OPT：标杆，实际上不能实现</li><li>FIFO：先进先出，效果最差，有颠簸</li><li>LRU：最近最久未使用，根据⻚⾯未被访问时⻓⽤升序列表将⻚⾯排列，每次将最久未被使⽤⻚⾯置换出去。</li><li>LFU：最少频次使用，每次淘汰使用频次最少的页面</li><li>Clock：时钟算法，为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。<ol type="1"><li>当需要淘汰一个页面时，只需检查页的访问位：如果是0，选择此页换出；如果是1，将它置0，暂不换出，继续检查下一个页面</li></ol></li><li>改进的clock算法：除了设置访问位，还考虑到页面有没有被修改，同时设置(访问位，标志位)。然后找到第一个(访问位， 标志位)为(0, 0)的位置。<ol type="1"><li>第一轮：从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位</li><li>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</li><li>第三轮:若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位</li><li>第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0,1）的帧用于替换</li></ol></li></ol><h3 id="lru-k算法和2q算法">LRU-K算法和2Q算法</h3><h4 id="lru-k算法">LRU-K算法</h4><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/webp.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>(1). 数据第一次被访问，加入到访问历史列表；</p><p>(2).如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p><p>(3).当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p><p>(4). 缓存数据队列中被再次访问后，重新排序；</p><p>(5).需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p><p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p><h4 id="q算法">2Q算法</h4><p>该算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p><p>当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/webp-17139454032892.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>(1). 新访问的数据插入到FIFO队列；</p><p>(2).如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p><p>(3). 如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p><p>(4). 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p><p>(5). LRU队列淘汰末尾的数据。</p><h3 id="虚拟内存">虚拟内存</h3><p>虚拟内存是一种扩展了物理内存的概念，它允许计算机将硬盘上的一部分空间作为虚拟内存，用于存储暂时不被使用的程序或数据。当程序需要更多内存空间时，虚拟内存会将不常用的数据暂时保存到硬盘上，从而释放出内存空间供其他程序使用。</p><p>虚拟内存的工作原理包括以下几个步骤：</p><ol type="1"><li><strong>地址映射</strong>:操作系统将每个程序的内存地址映射到物理内存或虚拟内存中的某个位置。程序访问内存时，操作系统会根据映射关系将程序指令或数据加载到内存中。</li><li><strong>页面置换</strong>:当物理内存不足以容纳所有程序的数据时，操作系统会将不常用的页面（内存中的一段数据）转移到硬盘上的虚拟内存中，从而为其他程序释放出空间。这个过程称为页面置换，常用的置换算法包括最近最少使用（LRU）和先进先出（FIFO）等。</li><li><strong>页面调度</strong>:当程序需要访问虚拟内存中的数据时，操作系统会将所需的页面从硬盘上调入内存，并更新地址映射表，以便程序能够正确地访问数据。</li></ol><p>虚拟内存的优点在于它可以扩展物理内存的容量，使计算机能够同时运行更多的程序，提高了系统的整体性能和稳定性。然而，虚拟内存也会带来一定的性能开销，因为数据需要在内存和硬盘之间频繁地传输。</p><h3id="内核里面有进程和线程的区分吗">内核里面有进程和线程的区分吗？</h3><p><strong>没有</strong>，在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct 进行管理，这个task_struct数据结构非常复杂，囊括了进程管理生命周期中的各种信息。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-f85eb7314f9227c8c32ca1bd64458607_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="自旋锁的适用场景">自旋锁的适用场景</h3><p>因为自旋锁加锁失败不用阻塞，而是忙等，所以<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><p><strong>需要注意，在单核 CPU上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><h2 id="设计模式">设计模式</h2><h3 id="面向对象设计的六大原则">面向对象设计的六大原则</h3><ol type="1"><li><strong>单一职责（Single ResponsibilityPrinciple）</strong>:一个类应该只负责一个职责，术语叫：仅有一个引起其变化的原因。</li><li><strong>开闭原则（Open ClosePrinciple）</strong>:一个类一旦开发完成，后续增加新的功能就不应该通过修改这个类来完成，而是通过继承，增加新的类。</li><li><strong>里氏替换原则（Liskov SubstitutionPrinciple）</strong>:一个软件系统中所有用到一个类的地方都替换成其子类，系统应该仍然可以正常工作。</li><li><strong>依赖倒置原则（Dependence InversionPrinciple）</strong>:是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。<ol type="1"><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol></li><li><strong>接口隔离原则(Interface Segregation Principle,ISP)</strong>：客户端不应该依赖它不需要的接口。</li><li><strong>迪米特法则(Law of Demeter, LoD)</strong>,最少知识原则(Principle of Least Knowledge)： 1.每个对象应该对其他对象尽可能最少的知道 2.每个对象应该仅和其朋友通信；不和陌生人通信 3. 仅仅和直接朋友通信</li></ol><h3 id="常见设计模式和使用场景">常见设计模式和使用场景、</h3><p>设计模式分为三大类：创建型模式、结构型模式、行为型模式。</p><h4 id="单例模式">单例模式</h4><p>一般使用于整个程序只需要一个类的实例，可以节省资源，并提供一个全局访问函数来访问该实例。</p><p><strong>应用场景</strong>：</p><ul><li>缓存</li><li>线程池</li><li>⽇志记录器</li></ul><h4 id="工厂模式">工厂模式</h4><p>细分为简单工厂、工厂方法和抽象工厂。在创建对象时，不会对客户端暴露对象的创建逻辑，而是通过使⽤共同的接口来创建对象。其⽤来封装和管理类的创建，本质是对获取对象过程的抽象。</p><p><strong>应用场景</strong>：</p><ul><li>当⼀个类不知道它所需要的类的时候。</li><li>当⼀个类希望通过其子类来指定创建对象的时候。</li><li>当类将创建对象的职责委托给多个帮助⼦类中的某⼀个，并且希望将哪⼀个帮助⼦类是代理者的信息局部化时。</li></ul><p><strong>场景举例</strong>：</p><ul><li>在数据库操作中，通过⼯⼚模式可以根据不同的数据库类型（MySQL、Oracle等）创建对应的数据库连接对象</li><li>通过⼯⼚模式可以根据配置⽂件或其他条件选择不同类型的⽇志记录器，如⽂件⽇志记录器、数据库⽇志记录器等。</li><li>在图形⽤户界⾯（GUI）库中，可以使⽤⼯⼚模式创建不同⻛格或主题的界⾯元素，如按钮、⽂本框等。</li><li>在加密算法库中，可以使⽤⼯⼚模式根据需要选择不同的加密算法，例如对称加密、⾮对称加密等。</li><li>在⽂件解析过程中，可以使⽤⼯⼚模式根据⽂件类型选择不同的解析器，如XML解析器、JSON解析器等。</li><li>在⽹络通信库中，可以使⽤⼯⼚模式创建不同类型的⽹络连接对象，如TCP连接、UDP连接等。</li></ul><h4 id="观察者模式">观察者模式</h4><p>属于行为型模式的⼀种，它定义了⼀种⼀对多的依赖关系，让多个观察者对象同时监听某⼀个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p><strong>使用场景</strong>：</p><ul><li><strong>事件处理</strong>：当⼀个对象的状态发⽣改变时，观察者模式可以⽤于通知和处理与该对象相关的事件。这在图形⽤户界⾯（GUI）开发中是很常⻅的，例如按钮点击事件、⿏标移动事件等。</li><li><strong>发布订阅</strong>：观察者模式可以⽤于实现发布-订阅模型，其中⼀个主题（发布者）负责发送通知，⽽多个观察者（订阅者）监听并响应这些通知。这种模型在消息队列系统、事件总线等场景中经常使⽤。</li><li>MVC架构：观察者模式常被⽤于实现MVC架构中的模型和视图之间的通信。当模型的状态发⽣改变时，所有相关的视图都会得到通知并更新显示。</li><li><strong>异步编程</strong>：观察者模式可以⽤于处理异步任务的完成事件。任务完成时，通知所有相关的观察者进⾏后续处理。</li></ul><h4 id="代理模式">代理模式</h4><p>代理模式（ProxyPattern）是⼀种结构型设计模式，其主要⽬的是在访问某个对象时引⼊⼀种代理对象，通过代理对象控制对原始对象的访问。代理模式可以⽤于实现懒加载、控制访问、监控对象等场景。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240424211906167.png"alt="image-20240424211906167" /><figcaption aria-hidden="true">image-20240424211906167</figcaption></figure><p><strong>应用场景</strong>：</p><ol type="1"><li>远程代理：⼀个对象在不同的地址空间提供局部代表。这样可以隐藏⼀个对象存在于不同地址空间的事实。</li><li>虚拟代理：根据需要创建开销很⼤的对象。通过它来存放实例化需要很⻓时间的真实对象，这样就可以达到性能的最优化。⽐如说你打开⼀个很⼤的HTML⽹⻚时，⾥⾯可能有很多的⽂字和图⽚，但你还是可以很快打开它，此时你所看到的是所有的⽂字，但图⽚却是⼀张⼀张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺⼨。</li><li>安全代理：⽤来控制真实对象访问时的权限。⼀般⽤于对象应该有不同的访问权限的时候。</li><li>智能指引：指当调⽤真实的对象时，代理处理另外⼀些事。如计算真实对象的引⽤次数，这样当该对象没有引⽤时，可以⾃动释放它；或当第⼀次引⽤⼀个持久对象时，将它装⼊内存；或在访问⼀个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问⼀个对象时附加⼀些内务处理。</li></ol><h4 id="策略模式">策略模式</h4><p>策略模式（StrategyPattern）是⼀种⾏为设计模式，它定义了⼀系列算法，，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独⽴于使⽤它的客户端⽽变化，也是说这些算法所完成的功能类型是⼀样的，对外接⼝也是⼀样的，只是不同的策略为引起环境⻆⾊表现出不同的⾏为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 策略接⼝</span><br><span class="hljs-keyword">public</span> interface PricingStrategy &#123;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span></span>;<br>&#125;<br><span class="hljs-comment">// 具体策略类：⽆折扣</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDiscountStrategy</span> implements PricingStrategy &#123;<br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> </span>&#123;<br><span class="hljs-keyword">return</span> price;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 具体策略类：打九折</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategy</span> implements PricingStrategy &#123;<br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.9</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 具体策略类：满减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashbackStrategy</span> implements PricingStrategy &#123;<br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">calculatePrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (price &gt;= <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-number">50</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> price;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCart</span> &#123;<br>    <span class="hljs-keyword">private</span> PricingStrategy pricingStrategy;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setPricingStrategy</span><span class="hljs-params">(PricingStrategy pricingStrategy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pricingStrategy = pricingStrategy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">checkout</span><span class="hljs-params">(<span class="hljs-type">double</span> totalPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pricingStrategy.<span class="hljs-built_in">calculatePrice</span>(totalPrice);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ShoppingCart cart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ShoppingCart</span>();<br>        <span class="hljs-comment">// 选择⽆折扣策略</span><br>        cart.<span class="hljs-built_in">setPricingStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">NoDiscountStrategy</span>());<br>        <span class="hljs-type">double</span> price1 = cart.<span class="hljs-built_in">checkout</span>(<span class="hljs-number">100</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Total Price: &quot;</span> + price1); <span class="hljs-comment">// 输出：Total Price: 100.0</span><br>        <span class="hljs-comment">// 选择打九折策略</span><br>        cart.<span class="hljs-built_in">setPricingStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">DiscountStrategy</span>());<br>        <span class="hljs-type">double</span> price2 = cart.<span class="hljs-built_in">checkout</span>(<span class="hljs-number">100</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Total Price: &quot;</span> + price2); <span class="hljs-comment">// 输出：Total Price: 90.0</span><br>        <span class="hljs-comment">// 选择满减策略</span><br>        cart.<span class="hljs-built_in">setPricingStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CashbackStrategy</span>());<br>        <span class="hljs-type">double</span> price3 = cart.<span class="hljs-built_in">checkout</span>(<span class="hljs-number">200</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Total Price: &quot;</span> + price3); <span class="hljs-comment">// 输出：Total Price: 150.0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="装饰模式">装饰模式</h4><p>装饰模式（DecoratorPattern）是⼀种结构型设计模式，它允许在不改变原始类接⼝的情况下，动态地添加功能或责任。<strong>装饰模式通过创建⼀个装饰类，包裹原始类的实例，并在保持原始类接⼝不变的情况下，提供额外的功能。</strong>就增加功能来说，装饰模式⽐⽣成⼦类更为灵活。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240424212726692.png"alt="image-20240424212726692" /><figcaption aria-hidden="true">image-20240424212726692</figcaption></figure><h4 id="适配器模式">适配器模式</h4><p>将⼀个类的接⼝转换成⽤户希望得到的另⼀个接⼝。它使原本不相容的接⼝得以协同⼯作——速记关键字:转换接⼝2。</p><h3 id="单例模式实现的优点">单例模式实现的优点</h3><ol type="1"><li>因为单例模式在内存中就只有一个实例，其主要优点可以<strong>减少内存的开支</strong>。尤其是一个对象需要频繁地创建销毁时，毕竟创建或销毁时性能又无法优化,那么单例模式就非常合适了；</li><li>因为单例模式只生成一个实例，所以，其主要优点可以<strong>减少系统的性能开销</strong>，当一个对象产生需要比较多的资源时，比如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决；</li><li>同时单例模式可以<strong>避免对资源的多重占用</strong>，比如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写的操作；</li><li>单例模式可以在系统设置全局的访问点，<strong>优化和共享资源</strong>访问，可以设计一个单例类，负责所有数据表的映射处理等。</li></ol><h3id="怎么提前销毁懒汉式局部静态变量">怎么提前销毁懒汉式局部静态变量？</h3><h3 id="三种工厂模式的区别">三种工厂模式的区别</h3><ul><li>简单工厂模式只有一个抽象产品类，只有一个具体的工厂类。</li><li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。</li><li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个具体产品类的实例。</li></ul><h3 id="使用工厂模式的好处">使用工厂模式的好处？</h3><p>可以将对象的创建和实现解耦。</p><h4 id="总结-1">总结</h4><p><strong>简单工厂模式</strong>：让一个工厂类负责创建所有对象；但没有考虑后期扩展和维护，修改违背开闭原则，静态方法不能被继承。</p><p><strong>工厂方法模式</strong>：主要思想是继承，修改符合开闭原则；但每个工厂只能创建一种类型的产品。</p><p><strong>抽象工厂模式</strong>：主要思想是组合，本质是产品族，实际包含了很多工厂方法，修改符合开闭原则；但只适用于增加同类工厂这种横向扩展需求，不适合新增功能方法这种纵向扩展。</p><h2 id="redis">Redis</h2><p>常见的有五种数据结构：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315221909012.png"alt="image-20240315221909012" /><figcaption aria-hidden="true">image-20240315221909012</figcaption></figure><h4 id="redis底层数据结构">redis底层数据结构</h4><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20240315223431452.png"alt="image-20240315223431452" /><figcaption aria-hidden="true">image-20240315223431452</figcaption></figure><h3id="redis做缓存有哪些问题如何解决">redis做缓存有哪些问题？如何解决？</h3><p>从缓存穿透，缓存击穿，缓存雪崩，缓存⼀致性等⽅⾯来答。参考<ahref="https://gstarmin.github.io/2023/12/25/Redis/#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">缓存雪崩、缓存穿透、缓存预热、缓存击穿、服务降级</a></p><h3 id="跳表的插入与删除">跳表的插入与删除</h3><h4 id="插入">插入</h4><p>向一个跳跃表中插入元素可以分为三步：</p><ol type="1"><li>找到各层的插入位置 。</li></ol><p>和单链表一样，要插入一个元素，需要找到前驱节点。跳跃表是多层链表，那么需要找到各层的前驱节点。</p><p>下图中，要插入一个新元素 20 ，其中数组 last[k] 表示找到的第 k阶上的前驱节点。</p><p>找的方法和查找过程一样，只需要记住每一层可以向右考察到的最后一个节点即可。</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.1.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="2" type="1"><li>决定新节点的阶 。</li></ol><p>用上面提到的 随机函数 RandLevel 决定它的阶。如果得到比整个跳跃表还要高的阶，需要把头节点的阶增高，与之对齐。以便任何节点都可以从左上角的头节点出发找到。</p><p>由于 last数组的含义是各层的插入位置，而且，接下来将要把头节点在新增高的这些层上指向新节点，于是把头节点 head 记为 last 数组在这些层上的值。</p><p>下图中，假如生成了一个大的阶 4 ，那么跳跃表的阶将会增高到 4， 并设置last[4] = head 。</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.2.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="3" type="1"><li>各层执行插入动作 。</li></ol><p>仍然和单链表一样，插入一个新节点的过程，就是把新节点和前驱、后驱节点分别搭线。只不过跳跃表是在多层上进行。</p><p>在每一层，前驱节点 last[k] 指向新节点，新节点指向 last[k]原来的后驱节点。</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.3.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="删除">删除</h4><p>同样地，从一个跳跃表中删除元素可以也可以分为三步：</p><ol type="1"><li>找到各层的前驱节点和要删除的节点 。</li></ol><p>从单链表中删除一个元素，需找到前驱节点。跳跃表是多层链表，也需找到各层的前驱节点。</p><p>和前面一样，last 数组来存放各层的前驱节点。 查找元素的过程，即可记录last 数组。</p><p>同时查找结束后，亦可判断要删除的元素是否存在于表中。</p><p>下图以删除元素 22 为例：</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.4.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="2" type="1"><li>各层执行删除 。</li></ol><p>仍然与单链表是类似。在各层上，前驱节点直接指向要删除的节点的后驱节点。最终释放要删除的节点的内存即可。</p><p>不过，并非 last 数组的每一项都是待删除节点的前驱节点，在删除时需要注意过滤。</p><p>以删除 22 为例，具体的删除动作就是，如果 last[k] 的后驱是 22， 则将last[k] 的后驱指向 22 的后驱。</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.5.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="3" type="1"><li>抹去删除节点后可能残留的孤零的高阶 。</li></ol><p>如果删除的元素是一个高阶节点，可能让跳跃表的头节点残留下孤零零的高阶。</p><p>这一步是可选的，即使不清理也无大碍。</p><p>以删除高阶节点 33 为例，删除 33 后，头节点的阶可以由 4 降为 3 。</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/3.6.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3id="什么情况使用mysql什么情况使用redis">什么情况使用MySQL，什么情况使用Redis</h3><p>Redis适合处理高性能读写、缓存、实时通信等场景，而MySQL适合存储和处理结构化数据、支持复杂查询和事务处理的场景。</p><h2 id="项目">项目</h2><h3 id="muduo">muduo</h3><p>服务器通信网络库重写并简化了muduo网络库，使用C++11去除了boost库的依赖，使用基于OOP思想，reactor模型。oneloop per thread的模型，通过epoll +线程池，使用多线程和事件循环机制实现高并发处理。</p><h3 id="channel">channel</h3><p><strong>Channel类其实相当于一个文件描述符的保姆</strong>,想要IO多路复用监听某个文件描述符，就要把这个fd和该fd感兴趣的事件通过epoll_ctl<strong>注册</strong>到IO多路复用模块（我管它叫<strong>事件监听器</strong>）上。当事件监听器监听到该fd发生了某个事件。事件监听器返回[发生事件的fd集合]以及[每个fd都发生了什么事件].Channel类则封装了一个[fd] 和这个 [fd感兴趣事件] 以及事件监听器监听到[该fd实际发生的事件].</p><h3 id="poller">Poller</h3><p><strong>负责监听文件描述符事件是否触发</strong>以及<strong>返回发生事件的文件描述符以及具体事件</strong>的模块就是Poller。所以<strong>一个Poller对象对应一个事件监听器</strong>（这里我不确定要不要把Poller就当作事件监听器）。在multi-reactor模型中，有多少reactor就有多少Poller。(这个Poller是个抽象虚类，由EpollPoller和PollPoller继承实现)</p><ul><li><code>epollfd_</code>就是用<code>epoll_create</code>方法返回的epoll句柄，这个是常识。</li><li><code>channels_</code>：这个变量是<code>std::unordered_map&lt;int, Channel*&gt;</code>类型，负责记录文件描述符 ---&gt;Channel的映射，也帮忙保管所有注册在你这个Poller上的Channel。</li><li><code>ownerLoop_</code>：所属的EventLoop对象，看到后面你懂了。</li></ul><p><strong>EpollPoller给外部提供的最重要的方法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TimeStamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span></span><br></code></pre></td></tr></table></figure><p>这个函数可以说是<strong>Poller的核心</strong>了，当外部调用<code>poll</code>方法的时候，该方法底层其实是通过<code>epoll_wait</code>获取这个事件监听器上发生事件的fd及其对应发生的事件，我们知道每个fd都是由一个Channel封装的，通过哈希表<code>channels_</code>可以根据fd找到封装这个fd的Channel。<strong>将事件监听器监听到该fd发生的事件写进这个Channel中的revents成员变量中。</strong>然后把这个Channel装进<code>activeChannels</code>中（它是一个vector&lt;Channel*&gt;）。这样，当外界调用完<code>poll</code>之后就能拿到事件监听器的<strong>监听结果（<code>activeChannels_</code>）</strong></p><h3 id="eventloop">EventLoop</h3><p>EventLoop就是负责实现<strong>“循环”</strong>，负责驱动<strong>“循环”</strong>的重要模块！！Channel和Poller其实相当于EventLoop的手下，EventLoop整合封装了二者并向上提供了更方便的接口来使用。</p><p>每个EventLoop对象都唯一绑定了一个线程，这个线程其实就在一直执行这个函数里面的while循环，这个while循环的大致逻辑比较简单。就是调用<code>Poller::poll</code>方法获取事件监听器上的监听结果。接下来在loop里面就会调用监听结果中每一个Channel的处理函数<code>HandlerEvent( )</code>。每一个Channel的处理函数会根据Channel类中封装的实际发生的事件，执行Channel类中封装的各事件处理函数。（比如一个Channel发生了可读事件，可写事件，则这个Channel的<code>HandlerEvent( )</code>就会调用提前注册在这个Channel的可读事件和可写事件处理函数，又比如另一个Channel只发生了可读事件，那么<code>HandlerEvent( )</code>就只会调用提前注册在这个Channel中的可读事件处理函数)</p><h3id="acceptor-接受新用户连接并分发连接给subreactorsubeventloop"><strong>Acceptor:接受新用户连接并分发连接给SubReactor（SubEventLoop）</strong></h3><h3 id="tcpconnection类">TcpConnection类</h3><p><strong>主要</strong>封装了一个已建立的TCP连接，以及控制该TCP连接的方法（连接建立和关闭和销毁），以及该连接发生的各种事件（读/写/错误/连接）对应的处理函数，以及这个TCP连接的服务端和客户端的套接字地址信息等。</p><p><strong>我个人觉得TcpConnection类和Acceptor类是兄弟关系，Acceptor用于mainEventLoop中，对服务器监听套接字fd及其相关方法进行封装（监听、接受连接、分发连接给SubEventLoop等），TcpConnection用于SubEventLoop中，对连接套接字fd及其相关方法进行封装（读消息事件、发送消息事件、连接关闭事件、错误事件等）。</strong></p><h3 id="项目的流程">项目的流程</h3><ol type="1"><li>建立连接：创建<code>TcpServer</code>对象，并在<code>TcpServer</code>的构造函数实例化了一个<code>Acceptor</code>对象，并往这个<code>Acceptor</code>对象注册了一个回调函数<code>TcpServer::newConnection()</code>。实例化Acceptor对象时，Acceptor的构造函数中实例化了一个Channel对象，即<code>acceptChannel_</code>，该Channel对象封装了服务器监听套接字文件描述符（尚未注册到mainEventLoop的事件监听器上）。接着Acceptor构造函数将<code>Acceptor::handleRead( )</code>方法注册进<code>acceptChannel_</code>中，这也意味着，日后如果事件监听器监听到<code>acceptChannel_</code>发生可读事件，将会调用<code>Acceptor::handleRead( )</code>函数。当有连接到来的时候，会在<code>Acceptor::handleRead( )</code>中调用<code>TcpServer::newConnection()</code>将建立好的连接封装成TcpConnection对象然后发送到subEventloop上。</li><li>消息读取：sub eventloop和maineventloop一样，也是用Poller调用poll函数获取事件监听结果，然后同样调用channel监听到的事件并调用提前注册好的事件处理函数。这里<code>readCallback_</code>保存的函数其实是<code>TcpConnection::handleRead( )</code>，<strong>消息读取的处理逻辑也就是由这个函数提供的</strong>。函数首先调用<code>Buffer_.readFd(channel_-&gt;fd(), &amp;saveErrno)</code>，该函数底层调用linux的<code>readv()</code>将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中（<code>inputBuffer_</code>）。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在<code>savedErrno</code>中。如果当<code>readFd( )</code>返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用<code>messageCallback_</code>中保存的用户自定义的读取消息后的处理函数。</li><li>消息发送：<code>TcpConnection::send(buf)</code>函数内部其实是调用了Linux的函数<code>write( )</code>，如果TCP发送缓冲区能一次性容纳buf，那这个<code>write( )</code>函数将buf全部拷贝到发送缓冲区中。<strong>如果TCP发送缓冲区内不能一次性容纳buf：</strong><ol type="1"><li>这时候<code>write( )</code>函数<code>buf</code>数据尽可能地拷贝到TCP发送缓冲区中，并且将errno设置为<code>EWOULDBLOCK</code>。</li><li>剩余未拷贝到TCP发送缓冲区中的<code>buf</code>数据会被存放在<code>TcpConnection::outputBuffer_</code>中。并且向事件监听器上<strong>注册该<code>TcpConnection::channel_</code>的可写事件</strong>。</li><li>事件监听器监听到该Tcp连接可写事件，就会调用<code>TcpConnection::handleWrite( )</code>函数把<code>TcpConnection::outputBuffer_</code>中剩余的数据发送出去。</li><li>在<code>TcpConnection::handleWrite( )</code>函数中，通过调用<code>Buffer::writeFd()</code>函数将<code>outputBuffer_</code>的数据写入到Tcp发送缓冲区，如果Tcp发送缓冲区能容纳全部剩余的未发送数据，那最好不过了。如果Tcp发送缓冲区依旧没法容纳剩余的未发送数据，那就尽可能地将数据拷贝到Tcp发送缓冲区中，继续保持可写事件的监听。</li><li>当数据全部拷贝到Tcp发送缓冲区之后，就会调用用户自定义的【写完后的事件处理函数】，并且<strong>移除该TcpConnection在事件监听器上的可写事件</strong>。（移除可写事件是为了提高效率，不会让<code>epoll_wait()</code>毫无意义的频繁触发可写事件。因为大多数时候是没有数据需要发送的，频繁触发可写事件但又没有数据可写。）</li></ol></li><li>断开连接：<ol type="1"><li>被动断开：服务端<code>TcpConnection::handleRead()</code>中感知到客户端把连接断开了。<code>TcpConnection::handleRead( )</code>函数内部调用了Linux的函数<code>readv( )</code>，当<code>readv( )</code>返回0的时候，服务端就知道客户端断开连接了。然后就接着调用<code>TcpConnection::handleClose( )</code>。<code>TcpServer::removeConnection( )</code>函数调用了<code>remvoveConnectionInLoop( )</code>函数，把unordered_map中该tcpconnection的对象映射删除，该函数的运行是在MainEventLoop线程中执行的，这里涉及到线程切换。因为该函数主要是从TcpServer对象中删除某条数据。而TcpServer对象是属于MainEventLoop的。这也是贯彻了OneLoop PerThread的理念。<code>TcpConnection::connectDestroyed( )</code>函数的执行是又跳回到了subEventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外SubEventLoop中的Poller类对象还保存着这条Tcp连接的<code>channel_</code>，所以调用<code>channel_.remove( )</code>将这个Tcp连接的channel对象从Poller内的数据结构中删除。</li><li>主动断开：服务器主动关闭时，调用<code>TcpServer::~TcpServer()</code>析构函数。不断循环的让这个TcpConnection对象所属的SubEventLoop线程执行<code>TcpConnection::connectDestroyed()</code>函数，同时在MainEventLoop的<code>TcpServer::~TcpServer()</code>函数中调用<code>item.second.reset()</code>释放保管TcpConnection对象的共享智能指针，以达到释放TcpConnection对象的堆内存空间的目的。</li></ol></li></ol><h3 id="channel的生命周期">channel的生命周期</h3><p>从Acceptor的构造函数开始被构造，然后在断开连接时候的<code>TcpConnection::connectDestroyed( )</code>中被删除。</p><h3 id="tcpconnection的生命周期">TcpConnection的生命周期</h3><p>连接到来的时候<code>Acceptor::handleRead( )</code>中调用<code>TcpServer::newConnection()</code>将建立好的连接封装成TcpConnection对象然后发送到subEventloop上。在断开连接的时候<code>TcpConnection::connectDestroyed</code>执行完毕就销毁。详细看https://www.cnblogs.com/Qiu-Bai/p/17127757.html，之后再补充。</p><h3id="如果tcpconnection中有正在发送的数据怎么保证在触发tcpconnection关闭机制后能先让tcpconnection先把数据发送完再释放tcpconnection对象的资源">如果<strong>TcpConnection中有正在发送的数据，怎么保证在触发TcpConnection关闭机制后，能先让TcpConnection先把数据发送完再释放TcpConnection对象的资源？</strong></h3><p>TcpConnection类继承了enable_shared_from_this类，继承了这个类之后能使用shared_from_this()函数。假如我们在TcpConnection对象（我们管这个对象叫TCA）中的成员函数中调用了<code>shared_from_this()</code>，该函数可以返回一个shared_ptr，并且这个shared_ptr指向的对象是TCA。</p><p>接着这个shared_ptr就作为channel_的<code>Channel::tie()</code>函数的函数参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****  Channel.h   ******/</span><br>std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; tie_; <br><span class="hljs-comment">/*****  Channel.cc   ******/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::tie</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;<span class="hljs-type">void</span>&gt;&amp; obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    tie_ = obj;<br>    tied_ = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::HandlerEvent</span><span class="hljs-params">(TimeStamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tied_)&#123;<br>        shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>            <span class="hljs-built_in">HandleEventWithGuard</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        。。。。一般不会执行到这里其实。我实在想不到正常运行的情况下怎么会执行到这里，可能是我比较菜。<br>        <span class="hljs-built_in">HandleEventWithGuard</span>(receiveTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当事件监听器返回监听结果，就要对每一个发生事件的channel对象调用他们的<code>HandlerEvent()</code>函数。在这个<code>HandlerEvent</code>函数中，会先把<code>tie_</code>这个weak_ptr提升为强共享智能指针。这个强共享智能指针会指向当前的TcpConnection对象。就算你外面调用删除析构了其他所有的指向该TcpConnection对象的智能指针。你只要<code>HandleEventWithGuard()</code>函数没执行完，你这个TcpConnetion对象都不会被析构释放堆内存。而<code>HandleEventWithGuard()</code>函数里面就有负责处理消息发送事件的逻辑。当<code>HandleEventWithGuard()</code>函数调用完毕，这个<code>guard</code>智能指针就会被释放。</p><h3 id="buffer类">buffer类</h3><p><strong>readv和writev允许单个系统调用读入到或写出自一个或多个缓冲区</strong>。</p><h4id="bufferreadfd函数剖析"><strong>Buffer::readFd()函数剖析</strong></h4><p>这个readFd巧妙的设计，可以让用户一次性把所有TCP接收缓冲区的所有数据全部都读出来并放到用户自定义的缓冲区Buffer中。用户自定义缓冲区Buffer是有大小限制的，我们一开始不知道TCP接收缓冲区中的数据量有多少，如果一次性读出来会不会导致Buffer装不下而溢出。所以在<code>readFd( )</code>函数中会在栈上创建一个临时空间<code>extrabuf</code>，然后使用<code>readv</code>的分散读特性，将TCP缓冲区中的数据先拷贝到Buffer中，如果Buffer容量不够，就把剩余的数据都拷贝到<code>extrabuf</code>中，然后再调整Buffer的容量(动态扩容)，再把<code>extrabuf</code>的数据拷贝到Buffer中。当这个函数结束后，<code>extrabuf</code>也会被释放。另外<code>extrabuf</code>是在栈上开辟的空间，速度比在堆上开辟还要快。</p><h3 id="线程池的好处">线程池的好处</h3><p>线程池<strong>为避免频繁创建、销毁线程</strong>，提供一组子线程，能从工作队列取任务、执行任务，而用户可以向工作队列加入任务，从而完成用户任务。可以更加高效。</p><h3 id="跳表和红黑树的优劣">跳表和红黑树的优劣</h3><h4 id="红黑树">红黑树</h4><ol type="1"><li>节点要么是黑色，要么是红色</li><li>根节点和叶子节点（NIL）都是黑色</li><li>每个红色结点的两个子结点一定都是黑色。</li><li><strong>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li><li>从上一条可以推出，如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ol><h4 id="为什么不使用红黑树">为什么不使用红黑树</h4><p>跳表和红黑树复杂度一样，但是并发环境下，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。</p><h3id="reactor和proactor区别以及适用场景">reactor和proactor区别以及适用场景</h3><p>Reactor 是非阻塞同步网络模式，而 Proactor 是异步网络模式。</p><ul><li><strong>Reactor是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用read 方法来完成数据的读取，也就是要应用进程主动将 socket接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式，感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像Reactor 那样还需要应用进程主动发起 read/write来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul><p>因此，<strong>Reactor可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而<strong>Proactor可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p><p>详见<ahref="https://www.xiaolincoding.com/os/8_network_system/reactor.html#proactor">reactor和proactor详解</a>。</p><h3 id="内存池">内存池</h3><p>内存缓存模块仿写了Google的tcmalloc，实现了高效的多线程内存管理，使用基于页面的内存分配机制，用于替换系统的内存分配相关函数malloc 和 free、使用三层 Cache结构，ThreadCache：主要解决锁竞争的问题；Central Cache：主要负责居中调度的问题；PageCache：主要负责提供以页为单位的大块内存；减少多线程场景下的锁竞争和系统开销，提高内存分配和释放的速度和效率。</p><p>span管理以页为单位的大内存块。</p><p>线程局部存储通过thread_local声明即可，例如<strong><em>int thread_local errCode;</em></strong></p><h3 id="内存池的实现">内存池的实现</h3><p>该项目所使用的内存池原型是 Google 的开源项目 tcmalloc，其全称为Thread-Caching Malloc，即线程缓存的malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数，即malloc 和 free。</p><p>内存池主要解决的就是效率问题，它能够避免让程序频繁的向系统申请和释放内存。其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题，内存碎片分为如下两种：</p><ul><li><strong>外部碎片</strong>：指的是空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配的需求。</li><li><strong>内部碎片</strong>：指的是由于一些对齐的需求，导致分配出去的空间中一些内存无法被充分利用。</li></ul><blockquote><p>内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p></blockquote><p>该内存池的整体架构如下图所示：</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/mempool.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>其主要由以下三个部分组成：</p><ul><li><code>Thread Cache</code>: 线程缓存是每个线程独有的，用于小于等于256KB 的内存分配，每个线程独享一个 ThreaCache了。</li><li><code>Central Cache</code>: 中心缓存是所有线程共享的，当 ThreadCache需要内存时会按需从 CentralCache 中获取内存，而当 ThreadCache中的内存满足一定条件时，CentralCache 也会在合适的时机对其进行回收。</li><li><code>Page Cache</code>:页缓存中存储的内存是以页为单位进行存储及分配的，当 CentralCache需要内存时，PageCache 会分配出一定数量的页给 CentralCache，而当CentralCache 中的内存满足一定条件时，PageCache也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</li></ul><p>上述三个部分的主要作用如下：</p><ul><li>Thread Cache: 主要解决锁竞争的问题；</li><li>Central Cache: 主要负责居中调度的问题；</li><li>Page Cache: 主要负责提供以页为单位的大块内存；</li></ul><h3 id="threadcache">1.ThreadCache</h3><p>Thread Cache 的结构如下图所示：</p><p><ahref="https://github.com/Kohirus/Apollo/blob/main/screenshot/threadcache.png"><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/threadcache.png"alt="img" /></a></p><p>通过使用<strong>字节对齐</strong>的方法来减少哈希桶的数目，并且进一步增加内存利用率，在设计时，让不同的范围的字节数按照不同的对齐数进行对齐，具体的对齐方式如下：</p><table><thead><tr class="header"><th>字节数</th><th>对齐数</th><th>哈希桶下标</th><th>自由链表数目</th></tr></thead><tbody><tr class="odd"><td>[1, 128]</td><td>8</td><td>[0, 16)</td><td>16</td></tr><tr class="even"><td>[129, 1024]</td><td>16</td><td>[16, 72)</td><td>56</td></tr><tr class="odd"><td>[1025, 8 * 1024]</td><td>128</td><td>[72, 128)</td><td>56</td></tr><tr class="even"><td>[8 * 1024+1, 64 * 1024]</td><td>1024</td><td>[128, 184)</td><td>56</td></tr><tr class="odd"><td>[64 * 1024+1, 256 * 1024]</td><td>8*1024</td><td>[184, 208)</td><td>24</td></tr></tbody></table><p>为了实现每个线程无锁访问属于自己的 ThreadCache，就需要用到<strong>线程局部存储</strong>(Thread Local Storage,TLS)，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其它线程访问到，这样就保证了数据的线程独立性。</p><p>当某个线程申请的对象不用了，可以将其释放给 Thread Cache，然后 ThreadCache 将该对象插入到哈希桶的自由链表当中即可。</p><p>但是随着线程不断地释放，对应自由链表中的长度也会越来越长，这些内存堆积在一个Thread Cache 中就是一种浪费，此时应该将这些内存还给 CentralCache，这样一来，这些内存对于其它线程来说就是可申请的，因此当 ThreadCache 中某个桶当中的自由链表太长时，可以将其释放给 Central Cache。</p><h3 id="centralcache">2. CentralCache</h3><p>当线程申请某一大小的内存时，如果 Thread Cache中对应的自由链表不为空，那么直接取出一个内存块返回即可，但如果此时该自由链表为空，那么这时Thread Cache 就需要向 Central Cache 申请内存了。</p><p>Central Cache 的结构与 Thread Cache是一样的，都是哈希桶结构，并且所遵循的对齐规则也一致。这样做的好处是当Thread Cache 的某个桶中没有内存时，就可以直接到 Central Cache中相对应的哈希桶中取内存。</p><p>Central Cache 与 Thread Cache 不同之处有两点：</p><ol type="1"><li>Central Cache 是所有线程共享的，而 Thread Cache 是线程独享的；</li><li>Central Cache 的哈希桶中挂载的是 Span，而 Thread Cache的哈希桶中挂载的是切好的内存块；</li></ol><p>其结构如下所示：</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/centralcache.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由于 Central Cache 是所有线程共享的，多个 Thread Cache可能在同一时刻向 Central Cache申请内存块，因此为了保证线程安全，需要<strong>加锁控制</strong>。此外，由于只有多个线程同时访问Central Cache的同一个桶时才会存在锁竞争，因此无需用锁来锁住所有哈希桶，只需锁住当前所访问的哈希桶即可。</p><p>当 Thread Cache 向 Central Cache 申请内存时，如果给的太少，那么Thread Cache 在短时间用完了又会再来申请；但是如果给的太多，那么 ThreadCache可能用不完而浪费大量的空间。为此，此处采用<strong>慢反馈调节算法</strong>，当Thread Cache 向 Central Cache申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p><p>当 Thread Cache 中的某个自由链表太长时，会将自由链表中的对象归还给Central Cache 中的 Span。但是需要注意的是，归还给 Central Cache的这些对象不一定都属于同一个 Span 的，且 Central Cache中的每个哈希桶中都可能不止一个Span，因此归还时不仅需要知道该对象属于哪一个桶，还需要知道它属于这个桶中的哪一个Span。为了建立页号和 Span之间的映射，需要使用一种哈希表结构进行管理，一种方式是采用 C++ 中的unordered_map，另一种方式是采用<strong>基数树</strong>数据结构。</p><h3 id="pagecache">3. PageCache</h3><p>Page Cache 的结构与 Central Cache 一样，都是哈希桶的结构，并且 PageCache 的每个哈希桶中都挂的是一个个的 Span，这些 Span也是按照双向链表的结构连接起来的。</p><p>但是，Page Cache 的映射规则与 Central Cache 和 Thread Cache不同，其采用的是<strong>直接定址法</strong>，比如 1 号桶挂的都是 1 页的Span，2 号桶挂的都是 2 页的 Span，以此类推。</p><p>其次，Central Cache 每个桶中的 Span都被切为了一个个对应大小的对象，以供 Thread Cache 申请。而 Page Cache服务的是 Central Cache，当 Central Cache 中没有 Span 时，向 Page Cache申请的是某一固定页数的 Span。而如果切分这个申请到的 Span 就应该由Central Cache 自己来决定。</p><p>其结构如下图所示：</p><figure><img src="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/pagecache.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当每个线程的 Thread Cache 没有内存时都会向 Central Cache申请，此时多个线程的 Thread Cache 如果访问的不是 Central Cache的同一个桶，那么这些线程是可以同时进行访问的。这时 Central Cache的多个桶就可能同时向 Page Cache 申请内存，所以 Page Cache也是存在线程安全问题的，因此在访问 Page Cache 时也必须要加锁。</p><p>但是此处的 Page Cache 不能使用桶锁，因为当 Central Cache 向 PageCache 申请内存时，Page Cache 可能会将其他桶中大页的 Span 切小后再给Central Cache。此外，当 Central Cache 将某个 Span 归还给 Page Cache时，Page Cache 也会尝试将该 Span 与其它桶当中的 Span 进行合并。</p><p>也就是说，在访问 Page Cache时，可能同时需要访问多个哈希桶，如果使用桶锁则可能造成大量频繁的加锁和解锁，导致程序的效率底下。因此在访问Page Cache 时没有使用桶锁，而是用一个大锁将整个 Page Cache 锁住。</p><p>如果 Central Cache 中有某个 Span 的 <code>useCnt_</code> 减到 0了，那么 Central Cache 就需要将这个 Span 归还给 Page Cache了。为了缓解内存碎片问题，Page Cache 还需要尝试将还回来的 Span与其它空闲的 Span 进行合并。</p><h3 id="基数树">4. 基数树</h3><p>由于在 PageCache 中最初建立页号与 Span 之间的映射关系时，采用的是unordered_map 数据结构，但是通过性能测试发现，内存池的性能并未优于原生的malloc/free 接口，因此通过 Visual Studio 的性能分析工具发现性能瓶颈位于unordered_map 处。</p><p>这主要是因为 unordered_map不是线程安全的，在多线程环境下需要加锁，而大量的加锁则会导致资源的消耗和性能的下降，因此在映射页号与Span 之间的关系时，采用基数树（Radix Tree）数据结构来进行优化。</p><p>当采用如下图所示的单层基数树时，在 32 位平台下，以一页大小为 8K(<spanclass="math inline">\(2^{13}\)</span>) 为例，此时页的数目就是 <spanclass="math inline">\(2^{32}\div2^{13}=2^{19}\)</span>，因此存储页号最多需要 19 个比特位，同时由于 32位平台下的指针大小为 4 字节，因此该数组的大小就是 <spanclass="math inline">\(2^{19}\times4=2^{21}=2M\)</span>，内存消耗不大，是可行的。但是如果是在 64位平台下，此时该数组的大小就是 <span class="math inline">\(2^{51}\times8=2^{54}=2^{24}G\)</span>，这显然是不可行的：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225048027-1025596599.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如下图所示，为二层基数树，同样在 32 位平台下，以一页的大小为 8K为例来说明，此时存储页号最多需要 19 个比特位。而二层基数树实际上就是把这19 个比特位分为两次进行映射。例如，前 5个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号所对应的Span 指针。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225105536-756632135.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在二层基数树中，第一层的数组占用 <spanclass="math inline">\(2^5\times 4=2^7\)</span> Bytes空间，第二层的数组最多占用 <span class="math inline">\(2^5\times2^{14}\times4=2^{21}=2M\)</span>。二层基数树相比与一层基数树的好处就是，一层基数树必须一开始就把2M的数组开辟出来，而二层基数树一开始只需要将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p><p>在 32 位平台下，一层基数树和二层基数树都是适用的，但是在 64位平台下，就需要使用下图所示的三层基数树了。三层基数树类似于二层基数树，实际上就是把存储页号的若干比特分为三次进行映射，而且只有当需要建立某一页号的映射关系时，才会开辟对应的数组空间，在一定程度上节约了内存空间：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/2026333-20230421225124800-503935249.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="简单介绍一下你的项目"><strong>简单介绍一下你的项目</strong></h3><p>我的这个项目是一个分布式K-V缓存系统，基于CS架构，服务器由一个中心节点和一系列存储节点构成。为客户端提供数据的基于内存的数据缓存功能。底层存储结构是通过跳表实现的。</p><h3 id="为什么要做这个项目"><strong>为什么要做这个项目？</strong></h3><p>这个项目综合性比较强，包括分布式缓存系统、服务器通信网络库以及内存池，主要是为了学习跳表、分布式存储、网络编程以及内存池等知识，将学习的东西综合应用。</p><h3 id="项目是为了解决什么问题">项目是为了解决什么问题？</h3><p>为了解决在高并发场景中的通过分布式横向扩展节点来处理更多的数据和请求，从而提高系统的容量和吞吐量。并且通过一致性哈希实现负载均衡，防止单个节点的性能瓶颈。</p><h3 id="有什么亮点难点"><strong>有什么亮点？难点？</strong></h3><p>亮点是通过一致性哈希能够实现负载均衡，并且把数据备份到下一个节点。有单一节点故障的恢复能力，能够灵活增添节点。</p><p>难点是在处理增添节点的时候数据的备份问题，还有服务器之间的数据传递问题。</p><h3 id="项目遇到哪些困难怎么解决的">项目遇到哪些困难，怎么解决的？</h3><h3 id="运用了哪些技术"><strong>运用了哪些技术?</strong></h3><p>用了一致性哈希，跳表，LRU缓存，重写Muduo网络库，以及重写了google的tcmalloc内存池。</p><h3 id="有什么收获"><strong>有什么收获？</strong></h3><p>主要是学习到了网络编程、还有分布式缓存的相关的知识，主要就是提高了C++的编码能力，没做项目之前对这些还比较陌生。</p><h3id="web服务器里怎么设计的io复用"><strong>Web服务器里怎么设计的IO复用</strong></h3><p>使用的epoll，通过EventLoop循环调用实现。</p><h3id="项目里用了线程池线程池怎么建立起来的为什么要用线程池"><strong>项目里用了线程池，线程池怎么建立起来的，为什么要用线程池</strong></h3><p>Muduo是one Loop perthread模式，也就是一个线程一个事件循环。通过封装一个事件循环的线程类EventLoopThread，底层的线程通过C++11的thread类创建。然后通过for循环创新事件循环线程类，创建指定个数，会返回相应的EventLoop。当有新连接到来的时候，会调用getnextloop函数在主线程中通过轮询分配EventLoop。</p><p>因为单线程处理能力有限，如果多CPU的话可以并行处理数据，实现服务器的高并发。</p><h3id="为什么需要使用内存池"><strong>为什么需要使用内存池？</strong></h3><p>因为这是基于内存的缓存系统，频繁的内存申请和释放会影响效率，而且还会出现内存碎片的问题，所以使用内存池解决这些问题。</p><h3id="web服务器这个项目你用了线程池线程池开多大的呢"><strong>Web服务器这个项目你用了线程池，线程池开多大的呢</strong></h3><p>线程池一般是根据CPU的数量来开的，有一个主线程，线程池一般就是CPU数量- 1个。</p><h3id="整个开发过程中有没有遇到困难怎么解决的"><strong>整个开发过程中有没有遇到困难，怎么解决的</strong></h3><p>在数据迁移或者数据恢复的出现与预期不对的情况，通过画图，模拟哪些数据应该备份到哪里，然后调试一步一步观察数据的流动进行排错。</p><h3id="能介绍一下在web服务器项目中做了什么样的测试和学习有什么样的体会"><strong>能介绍一下在web服务器项目中做了什么样的测试和学习，有什么样的体会</strong></h3><p>通过手动模拟计算哈希和画图查看数据迁移过程，手动添加新的节点以及Kill掉某一个节点查看系统是否正常运行。</p><h3id="web服务器最主要的一个考量指标是并发处理能力想问你为了提高并发量做了怎么样的操作"><strong>web服务器最主要的一个考量指标是并发处理能力，想问你为了提高并发量做了怎么样的操作</strong></h3><p>网络服务器中，通过IO多路用以及线程池提高并发，存储通节点并且过内存池管理内存。</p><h3 id="什么是跳表"><strong>什么是跳表</strong></h3><p>跳表其实就是多层的有序链表，在最底层跳跃长度是1也就是普通的链表，越往上层走，跳表的下一个节点跳得越远，每一层成指数级增长。所以增删改查只需要log(N)的复杂度。</p><h3id="为什么不用哈希算法或者红黑树"><strong>为什么不用哈希算法或者红黑树</strong></h3><p>相比哈希表，跳表是有序的，对于范围查询更有优势。而且也无需重新哈希。相比红黑树，插入和删除操作的简便性，无需红黑树复杂的平衡操作，而且范围查询更加容易。</p><h3id="一致性哈希算法是什么是用什么数据结构实现的"><strong>一致性哈希算法是什么，是用什么数据结构实现的</strong></h3><p>一致性哈希算法是用于分布式数据分片的做法，利用一个哈希环，将服务器节点名字哈希后注册到哈希环中。当有数据存储或者查询操作时通过哈希算法选择对应的存储节点。当发送数据迁移或者新增节点时无需进行大量数据迁移，而是只需要迁移在哈希环中有影响的节点数据即可。使用的数据结构是红黑树（c++的map结构），方便快速寻找指定哈希值的前后节点。</p><h3 id="基数树是什么">基数树是什么</h3><p>基数树的特点是它在树中的每个节点上都存储了一串位数字或者字母，而不是单一的元素。使用三层，第一层存储0-6字节。</p><h3 id="为什么需要-io-多路复">为什么需要 I/O 多路复⽤？</h3><ol type="1"><li><strong>提高性能</strong>：使用I/O多路复用可以减少I/O操作的开销。相比于每个I/O操作都创建一个线程或进程来处理，多路复用可以使用少量的线程或进程同时监视多个I/O通道，从而减少了上下文切换的开销，提高了系统的性能。</li><li><strong>节省资源</strong>：创建和管理线程或进程需要消耗系统资源，而且线程或进程的数量受到系统资源的限制。通过使用I/O多路复用，可以减少同时活跃的线程或进程数量，从而节省了系统资源。</li><li><strong>支持高并发</strong>：在高并发的场景下，使用I/O多路复用可以更有效地处理大量的并发连接。通过复用少量的线程或进程来处理多个I/O通道，可以更好地支持高并发的需求，提高系统的扩展性和稳定性。</li><li><strong>支持非阻塞I/O</strong>：I/O多路复用通常与非阻塞I/O配合使用，可以实现非阻塞的I/O操作。这样可以避免因为I/O操作阻塞导致的线程或进程被长时间挂起，提高了系统的响应速度和吞吐量。</li><li><strong>简化编程模型</strong>：使用I/O多路复用可以简化编程模型。开发人员不需要关注多个I/O操作的具体细节，而是可以使用简单的事件驱动模型来处理I/O事件。这样可以降低编程复杂度，提高代码的可读性和可维护性。</li></ol><h3 id="创建线程用什么api">创建线程用什么api</h3><p>std::thread</p><h3id="如何销毁线程detach和join有什么区别">如何销毁线程，detach和join有什么区别？</h3><ol type="1"><li><strong>调用<code>std::thread::join()</code></strong>：在主线程中调用<code>std::thread</code> 对象的 <code>join()</code>方法可以等待该线程执行完成。主线程会阻塞，直到被等待的线程执行完成。在被等待的线程执行完成后，<code>join()</code>方法返回，线程对象被销毁。</li><li><strong>调用<code>std::thread::detach()</code></strong>：在创建线程后，可以调用<code>std::thread</code> 对象的 <code>detach()</code>方法将该线程“分离”出来。分离后，线程将在后台运行，不再与主线程同步。当线程执行完成后，其资源会自动释放，线程对象也会被销毁。</li></ol><h3id="怎么保证线程安全互斥锁粒度大怎么办">怎么保证线程安全？互斥锁粒度大怎么办？</h3><p>使用互斥锁，锁粒度大可以使用细粒度锁。</p><h3id="怎么压测压测的瓶颈在哪里是如何检测这个瓶颈的">怎么压测，压测的瓶颈在哪里，是如何检测这个瓶颈的</h3><p>使用webbench，例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">webbench -c 并发数 -t 运行测试时间 URL<br>例子:webbench -c 500 -t 600 http://192.168.15.112:8006/  <br></code></pre></td></tr></table></figure><p><strong>webbench做压力测试时，该软件自身也会消耗CPU和内存资源，为了测试准确，请将webbench 安装在别的服务器上。</strong></p><p><strong>测试时并发应当由小逐渐加大，比如并发100时观察一下网站负载是多少、打开页面是否流畅，并发200时又是多少、网站打开缓慢时并发是多少、网站打不开时并发又是多少；</strong></p><h4 id="瓶颈来源">瓶颈来源</h4><ol type="1"><li><strong>数据库瓶颈</strong></li><li><strong>应用瓶颈</strong></li><li><strong>压测工具瓶颈</strong></li><li><strong>Linux 机器出现异常</strong></li></ol><h4 id="cpu"><strong>cpu</strong></h4><p>下面以 top 命令的输出例，对 CPU 各项主要指标进行说明：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-282ff76264cb6195e0c1cd794910ac07_720w-17112667882629.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><strong>us(user)：运行（未调整优先级的）用户进程所消耗的 CPU时间的百分比。</strong>像 shell 程序、各种语言的编译器、数据库应用、web服务器和各种桌面应用都算是运行在用户地址空间的进程。这些程序如果不是处于idle 状态，那么绝大多数的 CPU 时间都是运行在用户态。</li><li><strong>sy(system)：运行内核进程所消耗的 CPU时间的百分比。</strong>所有进程要使用的系统资源都是由 Linux内核处理的。当处于用户态（用户地址空间）的进程需要使用系统的资源时，比如需要分配一些内存、或是执行I/O操作、再或者是去创建一个子进程，此时就会进入内核态（内核地址空间）运行。事实上，决定进程在下一时刻是否会被运行的进程调度程序就运行在内核态。对于操作系统的设计来说，消耗在内核态的时间应该是越少越好。通常sy比例过高意味着被测服务在用户态和系统态之间切换比较频繁，此时系统整体性能会有一定下降。<strong>在实践中有一类典型的情况会使sy 变大，那就是大量的 I/O 操作，因此在调查 I/O相关的问题时需要着重关注它。大部分后台服务使用的 CPU 时间片中 us 和 sy的占用比例是最高的。同时这两个指标又是互相影响的，us 的比例高了，sy的比例就低，反之亦然。另外，在使用多核 CPU 的服务器上，CPU 0 负责 CPU各核间的调度，CPU 0 上的使用率过高会导致其他 CPU核心之间的调度效率变低。因此测试过程中需要重点关注 CPU 0。</strong></li><li><strong>id(idle)：空闲的 CPU 时间百分比。</strong>一般情况下， us +ni + id 应该接近 100%。线上服务运行过程中，需要保留一定的 id冗余来应对突发的流量激增。在性能测试过程中，如果 id一直很低，吞吐量上不去，需要检查被测服务线程/进程配置、服务器系统配置等。</li><li><strong>wa(I/O wait)：CPU 等待 I/O 完成时间百分比。</strong>和 CPU的处理速度相比，磁盘 I/O 操作是非常慢的。有很多这样的操作，比如：CPU在启动一个磁盘读写操作后，需要等待磁盘读写操作的结果。在磁盘读写操作完成前，CPU只能处于空闲状态。<strong>Linux 系统在计算系统平均负载时会把 CPU 等待I/O 操作的时间也计算进去，所以在我们看到系统平均负载过高时，可以通过 wa来判断系统的性能瓶颈是不是过多的 I/O 操作造成的。磁盘、网络等 I/O操作会导致 CPU 的 wa 指标提高。通常情况下，网络 I/O 占用的 wa资源不会很高，而频繁的磁盘读写会导致 wa 激增。</strong>如果被测服务不是I/O 密集型的服务，那需要检查被测服务的日志量、数据载入频率等。如果 wa高于 10% 则系统开始出现卡顿；若高于 20% 则系统几乎动不了；若高于 50%则很可能磁盘出现故障。</li></ul><h5 id="分析思路">分析思路</h5><ul><li>wa（IO wait）的值过高，表示硬盘存在 I/O 瓶颈。</li><li>id（idle）值高，表示 CPU 较空闲。</li><li>如果 id 值高但系统响应慢时，有可能是 CPU等待分配内存，此时应加大内存容量。</li><li>如果 id 值持续低于 10，那么系统的 CPU处理能力相对较低，表明系统中最需要解决的资源是 CPU。</li></ul><h4 id="磁盘-io">磁盘 I/O</h4><p><strong>iostat 参数详解</strong></p><p>Linux 下可以用 iostat 命令来监控磁盘状态。</p><p>iostat -d 2 10 表示每 2 秒统计一次基础数据，统计 10 次：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-5b2e0bd8593a1a5aca9c13f2d9ea7e2f_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>tps：该设备每秒的传输次数。“一次传输”意思是“一次 I/O请求”。多个逻辑请求可能会被合并为“一次 I/O请求”。“一次传输”请求的大小是未知的。</li><li>kB_read/s：每秒从设备（driveexpressed）读取的数据量，单位为Kilobytes。</li><li>kB_wrtn/s：每秒向设备（driveexpressed）写入的数据量，单位为Kilobytes。</li><li>kB_read：读取的总数据量，单位为 Kilobytes。</li><li>kB_wrtn：写入的总数量数据量，单位为 Kilobytes。</li></ul><h4 id="数据库-1">数据库</h4><p>首先找<strong>慢查询</strong></p><ol type="1"><li><p>通过 SQL 语句定位到慢查询日志的所在目录，然后查看日志。</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;slow%&quot;;<br></code></pre></td></tr></table></figure></p></li><li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题时，查询慢查询日志并不能定位问题。这时可以使用<strong>showprocesslist</strong>命令查看当前 MySQL正在进行的线程状态，可以实时地查看 SQL 的执行情况。</p></li><li><p>找到慢查询 SQL 后可以用执行计划（explain）进行分析</p></li></ol><h3id="单reactor单线程到多reactor多线程">单reactor单线程到多reactor多线程</h3><h4 id="单reactor单线程">单reactor单线程</h4><p>这种模型在Reactor中处理事件，并分发事件，如果是连接事件交给acceptor处理，如果是读写事件和业务处理就交给handler处理，但始终只有一个线程执行所有的事情。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-a3a7f2b064f424fbb11e77f019123e62_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>该线程模型的不足</p><ol type="1"><li>仅用一个线程处理请求，对于多核资源机器来说是有点浪费的</li><li>当处理读写任务的线程负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差</li><li>单线程也会有可靠性的问题</li></ol><h4 id="单reactor多线程">单reactor多线程</h4><p>这种模型和第一种模型到的主要区别是把业务处理从之前的单一线程脱离出来，换成线程池处理，也就是Reactor线程只处理连接事件和读写事件，业务处理交给线程池处理，充分利用多核机器的资源、提高性能并且增加可靠性。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-d60a5c2c930e3ec611855d387d2429ec_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>该线程模型的不足</p><p>Reactor线程承担所有的事件，例如监听和响应，高并发场景下单线程存在性能问题</p><h4 id="多reactor多线程">多reactor多线程</h4><p>这种模型下和第二种模型相比是把Reactor线程拆分了mainReactor和subReactor两个部分，mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-ca0ee6f64ec8654ba143c30548874095_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>mainRactor只处理连接事件，用一个线程来处理就好。处理读写事件的subReactor个数一般和CPU数量相等，一个subReactor对应一个线程，业务逻辑由线程池处理</p><p>这种模型使各个模块职责单一，降低耦合度，性能和稳定性都有提高。这种模型在许多项目中广泛应用，比如Netty的主从线程模型等</p><h4id="reactor三种模式形象比喻"><strong>Reactor三种模式形象比喻</strong></h4><p>餐厅一般有接待员和服务员，接待员负责在门口接待顾客，服务员负责全程服务顾客Reactor的三种线程模型可以用接待员和服务员类比</p><ol type="1"><li>单Reactor单线程模型：接待员和服务员是同一个人，一直为顾客服务。客流量较少适合</li><li>单Reactor多线程模型：一个接待员，多个服务员。客流量大，一个人忙不过来，由专门的接待员在门口接待顾客，然后安排好桌子后，由一个服务员一直服务，一般每个服务员负责一片中的几张桌子</li><li>多Reactor多线程模型：多个接待员，多个服务员。这种就是客流量太大了，一个接待员忙不过来了</li></ol><h3id="free函数如何知道要释放的空间大小">free()函数如何知道要释放的空间大小？</h3><p>free()函数如何知道要释放的空间大小？ - 卡麦哈麦哈的回答 - 知乎https://www.zhihu.com/question/302440083/answer/544571934</p><h3id="epoll一定要比select快吗能举个例子吗">epoll一定要比select快吗，能举个例子吗？</h3><p><strong>不一定</strong>，文件描述符非常多时，每次都要对文件描述符进行一些操作并对参数读入时内核和用户态的切换操作导致select效率比较低。</p><p>但是网络环境非常好，即干扰很少，某个服务器只接受固定的计算机发来的数据(例如10台），这种情况下连接非常少，使得epoll高效的上述因素显然不能成立了，此时可以认为epoll和select效率近似。</p><h3id="epoll最多能有多少个连接这个了解吗">epoll最多能有多少个连接这个了解吗？</h3><p>8G内存，一个epoll服务端，15个客户端（通过增加虚拟IP，每个客户端5万个连接），能支持的并发连接数是接近70万。</p><h3id="客户端与服务器端建立tcp连接当服务器端进程core-dump之后会发生什么">客户端与服务器端建立TCP连接，当服务器端进程coredump之后会发生什么</h3><p>当服务器端进程发生coredump后，TCP连接通常会因为服务器进程的终止而关闭。客户端可能会收到一个错误，如<code>ECONNRESET</code>，表明连接被对方重置。此外，客户端的任何后续尝试发送或接收数据都会失败，因为TCP连接不再有效。</p><h3 id="有没有避免死锁的机制">有没有避免死锁的机制</h3><h3 id="介绍以下内存池怎么实现的">介绍以下内存池怎么实现的？</h3><h3 id="介绍以下muduo库">介绍以下muduo库</h3><h3id="你了解什么是负载均衡吗腾讯云">你了解什么是负载均衡吗？（腾讯云）</h3><h3 id="解释一下epoll腾讯云">解释一下epoll（腾讯云）</h3><h3 id="红黑树腾讯云">红黑树（腾讯云）</h3><h3 id="跳表红黑树avl树的区别">跳表、红黑树、AVL树的区别</h3><h3id="跳表红黑树avl树分别适用于什么场景">跳表、红黑树、AVL树分别适用于什么场景</h3><h2 id="手撕代码">手撕代码</h2><h3 id="线程安全的循环队列">线程安全的循环队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;T&gt; queue;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-type">int</span> rear;<br>    std::mutex mtx;<br>    std::condition_variable not_full;<br>    std::condition_variable not_empty;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CircularQueue</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity</span>(capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">front</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">rear</span>(<span class="hljs-number">-1</span>) &#123;<br>        queue.<span class="hljs-built_in">resize</span>(capacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        not_full.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-keyword">return</span> size &lt; capacity; &#125;);<br><br>        rear = (rear + <span class="hljs-number">1</span>) % capacity;<br>        queue[rear] = item;<br>        size++;<br><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        not_empty.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        not_empty.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-keyword">return</span> size &gt; <span class="hljs-number">0</span>; &#125;);<br><br>        T item = queue[front];<br>        front = (front + <span class="hljs-number">1</span>) % capacity;<br>        size--;<br><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        not_full.<span class="hljs-built_in">notify_one</span>();<br><br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_full</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="无锁队列">无锁队列</h3><p>每个节点的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueNode</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>        val;<br>    QueueNode* next;<br>    <span class="hljs-built_in">QueueNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">val</span>(val) &#123;<br>        next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而对于一个无锁队列对象而言，包含以下部分</p><ul><li>数据：队列的最大长度、链表头结点、链表尾节点</li><li>函数：初始化（构造函数）、入队、出队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">lass LockFreeQueue &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LockFreeQueue</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">dequeue</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">LockFreeQueue</span>();<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>        queue_size; <span class="hljs-comment">// 暂时未使用，论文里并没有提及最大资源数</span><br>    QueueNode* tail;<br>    QueueNode* head;<br>&#125;;<br></code></pre></td></tr></table></figure><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/20201221172747323.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h5 id="入队操作">入队操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LockFreeQueue::enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    QueueNode* cur_node;<br>    QueueNode* add_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueNode</span>(val);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cur_node = tail;<br>        <span class="hljs-keyword">if</span> (__sync_bool_compare_and_swap(&amp;(cur_node-&gt;next), <span class="hljs-literal">NULL</span>, add_node)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            __sync_bool_compare_and_swap(&amp;tail, cur_node, cur_node-&gt;next);<br>        &#125;<br>    &#125;<br>    __sync_bool_compare_and_swap(&amp;tail, cur_node, add_node);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol type="1"><li>加入成功，那么退出循环进入倒数第三行</li><li>加入不成功，说明这时候有其他线程抢先往里面插入了一个节点，那么就把当前节点的位置更新为尾节点，再次进入循环直到能正确更新</li></ol><p>到了最后一个CAS的时候，只需要进行一次置尾操作，并不需要循环，原因是：如果当前线程将节点已经加进去了的话，那么其他所有线程的操作都会失败，只有当前线程更新尾节点完成后，其他线程的第二个CAS操作才能成功。</p><p>这里有一个小trick，明明第6行每次循环时都会更新节点，为什么还需要第二个CAS操作呢？因为在极端情况下，一个线程已经完成了增加节点操作，在置尾操作（第三个CAS）之前突然挂了，这时候就导致其他所有线程全部不能更新。</p><p>在左耳朵耗子的博客中，对于上述问题的解决方法描述是选用了《ImplementingLock-FreeQueues》论文中提到的第二个方法，该方法采用的是一开始在head，然后不断找next直到找尾节点（通过多个线程共用fetch来减少开销）。本文以论文中提到的第一个方法为例进行描述（因为我觉得它更优雅）。</p><h5 id="出队操作">出队操作</h5><p>与入队操作类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LockFreeQueue::dequeue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QueueNode* cur_node;<br>    <span class="hljs-type">int</span>        val;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cur_node = head;<br>        <span class="hljs-keyword">if</span> (cur_node-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (__sync_bool_compare_and_swap(&amp;head, cur_node, cur_node-&gt;next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    val = cur_node-&gt;next-&gt;val;<br>    <span class="hljs-keyword">delete</span> cur_node;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="o1时间复杂度内删除链表中的一个节点">O(1)时间复杂度内删除链表中的一个节点</h3><p>给你头节点head和待删除节点node，要求在O(1)时间复杂度删除node</p><h4 id="若node不是最后一个节点">若node不是最后一个节点</h4><p>把node的值与node-&gt;next的值交换，然后删除node-&gt;next即可。</p><h4 id="若node是最后一个节点">若node是最后一个节点</h4><p>仍然需要从head遍历到node的上一个节点，然后删除node，但是只有这一种个情况是O(n)，所以平均时间复杂度仍然是O（1）</p><h3id="string类实现包括构造函数拷贝构造函数赋值构造析构函数">string类实现，包括构造函数，拷贝构造函数，赋值构造，析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str; <span class="hljs-comment">// 字符串指针</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">String</span>() &#123;<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 空字符串</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 空指针处理</span><br>            str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>            str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(str, s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; other) &#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(other.str);<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(str, other.str);<br>    &#125;<br><br>    <span class="hljs-comment">// 赋值构造函数</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 检查自赋值</span><br>        <span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 释放原有的内存空间</span><br><br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(other.str);<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(str, other.str);<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">String</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 释放内存空间</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取字符串</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="实现vector类要求实现这些方法初始化整体拷贝push_backpop_backvectorpos获取指定位置的元素">实现Vector类，要求实现这些方法：初始化、整体拷贝、push_back、pop_back、vector[pos]获取指定位置的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T *data; <span class="hljs-comment">// 存储元素的数组</span><br>    <span class="hljs-type">size_t</span> capacity; <span class="hljs-comment">// 数组容量</span><br>    <span class="hljs-type">size_t</span> size; <span class="hljs-comment">// 元素个数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Vector</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">capacity</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">size_t</span> initialCapacity) : <span class="hljs-built_in">capacity</span>(initialCapacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        data = <span class="hljs-keyword">new</span> T[capacity];<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">const</span> Vector&amp; other) : <span class="hljs-built_in">capacity</span>(other.capacity), <span class="hljs-built_in">size</span>(other.size) &#123;<br>        data = <span class="hljs-keyword">new</span> T[capacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            data[i] = other.data[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Vector</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加元素到末尾</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size &gt;= capacity) &#123;<br>            <span class="hljs-built_in">resize</span>(capacity * <span class="hljs-number">2</span>); <span class="hljs-comment">// 如果容量不足，扩大数组</span><br>        &#125;<br>        data[size++] = value;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除末尾元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            --size;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取指定位置的元素</span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取指定位置的元素（const版本）</span><br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前元素个数</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 调整数组容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> newCapacity)</span> </span>&#123;<br>        T *newData = <span class="hljs-keyword">new</span> T[newCapacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            newData[i] = data[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        data = newData;<br>        capacity = newCapacity;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="快乐数每一位平方求和循环操作是否可以变为1">快乐数，每一位平方求和，循环操作是否可以变为1</h3><p>见<ahref="https://leetcode.cn/problems/happy-number/description/">LC.202快乐数</a>.</p><h3 id="链表快排">链表快排</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">solve</span><span class="hljs-params">(ListNode* head, ListNode* pend)</span></span>&#123;<br>    <span class="hljs-comment">// 链表是空或者只有一个元素就返回</span><br>    <span class="hljs-keyword">if</span>(!head||head-&gt;next==pend) <span class="hljs-keyword">return</span> head;<br>    <span class="hljs-type">int</span> val = head-&gt;val; <span class="hljs-comment">//哨兵值</span><br>    ListNode* p = head; <span class="hljs-comment">//记录“哨兵”的位置</span><br>    ListNode* q = p-&gt;next; <span class="hljs-comment">//用于遍历待排序链表的指针</span><br>    <span class="hljs-keyword">while</span>(q!=pend)&#123;<br>        <span class="hljs-comment">//发现比哨兵结点小的值就交换。从而保证p指针所指的结点比哨兵值小</span><br>        <span class="hljs-keyword">if</span>(q-&gt;val &lt; val)&#123;<br>            p = p-&gt;next;<br>            <span class="hljs-built_in">swap</span>(p-&gt;val, q-&gt;val);<br>        &#125;<br>        q = q-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//交换哨兵和p指针指向值，至此哨兵的位置就固定了</span><br>    <span class="hljs-built_in">swap</span>(head-&gt;val, p-&gt;val);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断一个点是否在三角形内">判断一个点是否在三角形内</h3><p>使用叉乘判断点是否在三角形内:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInsideTriangle</span><span class="hljs-params">(Point p, Point A, Point B, Point C)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> AB = (B.x - A.x) * (p.y - A.y) - (B.y - A.y) * (p.x - A.x);<br><span class="hljs-type">double</span> BC = (C.x - B.x) * (p.y - B.y) - (C.y - B.y) * (p.x - B.x);<br><span class="hljs-type">double</span> CA = (A.x - C.x) * (p.y - C.y) - (A.y - C.y) * (p.x - C.x);<br><br><span class="hljs-keyword">if</span> (((AB &gt; <span class="hljs-number">0</span> &amp;&amp; BC &gt; <span class="hljs-number">0</span> &amp;&amp; CA &gt; <span class="hljs-number">0</span>) || (AB &lt; <span class="hljs-number">0</span> &amp;&amp; BC &lt; <span class="hljs-number">0</span> &amp;&amp; CA &lt; <span class="hljs-number">0</span>)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point p = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>Point A = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;;<br>Point B = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;;<br>Point C = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsInsideTriangle</span>(p, A, B, C))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Point is inside the triangle.&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Point is outside the triangle.&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="反转链表倒数k个节点前的节点">反转链表倒数k个节点前的节点</h3><h3 id="lc151.-反转字符串中的单词要求原地翻转">LC151.反转字符串中的单词（要求原地翻转）</h3><p>见<ahref="https://leetcode.cn/problems/reverse-words-in-a-string/description/">LC151.反转字符串中的单词</a>.</p><h3 id="lc236.-二叉树的最近公共祖先">LC236. 二叉树的最近公共祖先</h3><p>见<ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">LC236.二叉树的最近公共祖先</a>.</p><h3 id="lc39.-组合总和">LC39. 组合总和</h3><p>见<ahref="https://leetcode.cn/problems/combination-sum/description/">LC39.组合总和</a>.</p><h3 id="lc7.-整数反转">LC7. 整数反转</h3><p>见<ahref="https://leetcode.cn/problems/reverse-integer/description/">整数反转</a>.</p><h3 id="稀疏矩阵乘法要优化之后的">稀疏矩阵乘法（要优化之后的）</h3><p>见<ahref="https://developer.aliyun.com/article/346625">稀疏矩阵相乘</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 执行矩阵乘法的函数</span><br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixMul2</span>(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; A, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; B) &#123;<br>    <span class="hljs-comment">// 获取矩阵的维度</span><br>    <span class="hljs-type">int</span> m = A.<span class="hljs-built_in">size</span>();    <span class="hljs-comment">// 矩阵 A 的行数</span><br>    <span class="hljs-type">int</span> n = A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 矩阵 A 的列数 / 矩阵 B 的行数</span><br>    <span class="hljs-type">int</span> p = B[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 矩阵 B 的列数</span><br><br>    <span class="hljs-comment">// 向量用于跟踪全零的行和列</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">r_all0</span><span class="hljs-params">(m, <span class="hljs-literal">true</span>)</span></span>; <span class="hljs-comment">// 最初将所有行标记为全零</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">c_all0</span><span class="hljs-params">(p, <span class="hljs-literal">true</span>)</span></span>; <span class="hljs-comment">// 最初将所有列标记为全零</span><br><br>    <span class="hljs-comment">// 检查矩阵 A 的每一行是否有非零元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (A[i][j] != <span class="hljs-number">0</span>) &#123;<br>                r_all0[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将行标记为非全零</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不需要检查剩余元素</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查矩阵 B 的每一列是否有非零元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; p; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (B[i][j] != <span class="hljs-number">0</span>) &#123;<br>                c_all0[j] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将列标记为非全零</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不需要检查剩余元素</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 用零初始化结果矩阵</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(m, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(p, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 执行矩阵乘法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; p; ++j) &#123;<br>            <span class="hljs-comment">// 如果整行或整列都是零，则跳过计算</span><br>            <span class="hljs-keyword">if</span> (r_all0[i] || c_all0[j]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> sum_ = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于存储乘积和的变量</span><br>            <span class="hljs-comment">// 计算矩阵 A 的第 i 行与矩阵 B 的第 j 列的点积</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>                sum_ += A[i][k] * B[k][j];<br>            &#125;<br>            ans[i][j] = sum_; <span class="hljs-comment">// 存储结果</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回结果矩阵</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lc343.-整数拆分割绳子">LC343. 整数拆分(割绳子)</h3><p>见<ahref="https://leetcode.cn/problems/integer-break/">整数拆分</a>.</p><h3 id="lc54.-螺旋矩阵">LC54. 螺旋矩阵</h3><p>见<ahref="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">螺旋矩阵</a>.</p><h3id="手撕代码将一个字符串转换成字符加出现次数的形式比如aaabb转换成a3b2要求不能用任何int转str的api腾讯云">手撕代码：将一个字符串转换成字符加出现次数的形式，比如aaabb转换成a3b2（要求不能用任何int转str的api）（腾讯云）</h3><h3 id="手写线程池腾讯云">手写线程池（腾讯云）</h3><h3 id="手写智能指针腾讯云">手写智能指针（腾讯云）</h3><h3 id="手写读者写者">手写读者写者</h3><h3 id="口算99999995">口算(9^999999)%5=?</h3><p>求（a^b）%n。本质是快速幂，只写出递归。a、b、n都很⼤，int会爆，必须⽤long</p><h2 id="比赛">比赛</h2><h3 id="金融科技建模大赛">金融科技建模大赛</h3><h4 id="赛题设置">赛题设置</h4><p>比赛的主题是“<strong>客户复购行为预测</strong>”。银行不仅关注新客户获客，也关注老客户的复购行为，希望增加客户黏性。客户在金融产品和服务上的重复购买行为越多，客户黏性越大。银行可以通过识别这些黏性客户，更好地分析他们的需求，并向他们推送新产品，进行客户关系管理。本次比赛的目标是对客户复购频率的三分类预测。比赛选手需要根据客户信息（包括基础客户画像信息、产品购买行为信息以及第三方客户画像补充信息）预测客户复购行为标签：<strong>低频（0）、中频（1）、高频（2），并根据客户平均价值（低频1、中频3、高频5），在独立样本上检验预测准确性（加权准确性）。</strong></p><h4 id="数据">数据</h4><p>分为3个表，X1表为客户基本信息，X2表为客户消费相关信息，X3为其他信息</p><p>初赛训练集</p><p>复赛训练集15000条，测试集8000条</p><h4 id="特征工程">特征工程</h4><ul><li>缺失值填充：对于连续型数值特征使用均值填充，对于离散型数值使用众数填充，对于类别特征使用unknown填充</li><li>特征经过脱敏，比如像X1表很多只写了基本特征，可以根据其格式判断是省份，身份证号。然后可以进一步根据省份划分出东中西部地区。身份证号其实就跟省份冲突。</li><li>根据catboost的特征重要性分析提取出强特征，然后对强特征做交叉特征（加减乘除），然后过滤掉重要性比较低的衍生特征</li><li>每个客户都有多条消费记录，把这些消费记录按照客户编号进行分桶，然后统计诸如消费次数，消费平均金额，并对里边如果是数值的特征做众数、中位数、平均数、最大最小值作为新特征，以及连续消费的天数，如果是字符串的话统计不同字符串的个数，等特征（这个对于性能提升是很大的）</li><li>对一些重要性不是特别重要的特征但是之间可能有关联的特征，这些特征单个可能不是很重要，但是做交叉之后重要性会更高（客户货款偿付比例与收入增长的关系。这可能反映了客户的财务稳定性和收入增长的能力）</li></ul><h4 id="训练">训练</h4><p>使用catboost模型，使用GridSearchCV网格搜索最优参数</p><h3 id="xgboostcatboostlightgbm">xgboost、catboost、lightgbm</h3><p>选择哪个算法取决于数据集的规模、特征的类型以及任务的要求。LightGBM适用于大规模数据和高维特征，XGBoost 适用于一般规模的数据和任务，而CatBoost 则适用于处理类别型特征和稀疏数据的场景。</p><h3id="第五届全国大学生计算机能力挑战赛">第五届全国大学生计算机能力挑战赛</h3><h4 id="赛题描述">赛题描述</h4><p>给予一批随机目标图片，选手需要将这些图片中的目标进行检测目标位置并识别目标类别。</p><h4 id="数据集描述">数据集描述</h4><p>提供少量训练集（训练集1500张图片、测试集500张图片），会在数据开放下载后陆续公布，总体为低资源的竞赛任务。训练集用于选手的模型训练，测试集存在服务器后台，用于最终结果的评测提交，不提供给选手。</p><p>训练集包含：1.图片文件;2.描述图片目标位置和类别文件。</p><h4 id="yolov8结构">YOLOv8结构</h4><ul><li>输入端：缩放图片尺寸数据、适应模型训练；</li><li>Backbone：模型主网络，通过卷积层数的增加，提取P1-P5不同感受野的featuremap，依次感受野逐渐增加；</li><li>Neck：呈现FPN和PAN结构，其中FPN (feature pyramidnetworks)：特征金字塔网络，采用多尺度来对不同size的目标进行检测；PAN：自底向上的特征金字塔。这样结合操作，FPN层自顶向下传达强语义特征，而特征金字塔则自底向上传达强定位特征，两两联手，从不同的主干层对不同的检测层进行特征聚合。</li><li>Prediction：为model框架中的Head头，用于最终的预测输出，P3 -&gt; P4-&gt; P5过程中，感受野是增大的，所以依次预测目标为小 -&gt; 中 -&gt;大。</li></ul><h4 id="使用的优化方法">使用的优化方法</h4><h2 id="场景题">场景题</h2><h3id="一个数据流中随机抽样固定大小样本字节懂车帝">一个数据流中随机抽样固定大小样本（字节懂车帝）</h3><p>蓄水池抽样：</p><ol type="1"><li>从数据流中读取前k个元素，依次放入水塘中。</li><li>对于第i个元素（i &gt;k），以1/i的概率随机选择是否将其替换水塘中的某个元素。如果被选择，则随机选择水塘中的一个位置，用当前元素替换该位置的元素。</li><li>处理完整个数据流后，水塘中的k个元素即为随机抽样得到的样本。</li></ol><h3id="圆上三个点构成锐角三角形的概率">圆上三个点构成锐角三角形的概率</h3><p>1 / 4</p><h3id="美团用户点外卖场景-如何快速筛选距离比较近的商家不要求很精确">美团用户点外卖场景，如何快速筛选距离比较近的商家，不要求很精确</h3><p>ElasticSearch，倒排索引(inverted index)。</p><p><strong>正排索引</strong>是从文档角度来找其中的单词，表示每个文档（用文档ID标识）都含有哪些单词，以及每个单词出现了多少次（词频）及其出现位置（相对于文档首部的偏移量）。所以每次搜索都是遍历所有文章。</p><p><strong>倒排索引</strong>是从单词角度找文档，标识每个单词分别在那些文档中出现(文档ID)，以及在各自的文档中每个单词分别出现了多少次（词频）及其出现位置（相对于该文档首部的偏移量）。</p><h4 id="搜索的过程">搜索的过程：</h4><p>当用户输入任意的词条时，</p><ol type="1"><li>首先对用户输入的数据进行分词，得到用户要搜索的所有词条。</li><li>然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。</li><li>最后根据这些编号去文档列表中找到文档</li></ol><h4 id="创建倒排索引分为以下几步">创建倒排索引，分为以下几步：</h4><ol type="1"><li>创建文档列表：lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表</li><li>创建倒排索引列表：然后对文档中数据进行分词，得到词条。对词条进行编号，以词条创建索引。然后记录下包含该词条的所有文档编号（及其它信息）。</li></ol><h3id="我有1t空间的url怎么考虑统计出现top10000的url">我有1T空间的url，怎么考虑统计出现top10000的url</h3><p>处理1TB数据以找到出现次数最多的前10000个URL是一个大数据问题。这里有一个可能的解决方案，使用MapReduce编程模型：</p><ol type="1"><li><strong>Map阶段</strong>：将数据分割成更小的块，每个块由一个Map任务处理。Map任务读取URL，然后为每个URL生成键值对，键是URL，值是1。</li><li><strong>Shuffle阶段</strong>：系统将所有键值对按键（URL）进行排序和合并，以便所有相同的键（URL）都在一起。</li><li><strong>Reduce阶段</strong>：每个Reduce任务处理一组具有相同键的键值对，累加值以计算每个URL的总出现次数。</li><li><strong>最后处理</strong>：所有Reduce任务的输出被合并，然后可以使用一个排序算法来找到出现次数最多的前10000个URL。</li></ol><h4id="如果是分布式的场景即有多个机子上都有很多url现在怎么考虑">如果是分布式的场景，即有多个机子上都有很多url，现在怎么考虑</h4><p>在分布式系统中处理大量URL的情况，你可以采用以下步骤：</p><ol type="1"><li><strong>数据分片</strong>：首先，将1TB的数据均匀分配到多个机器上。</li><li><strong>本地统计</strong>：每台机器上运行<strong>MapReduce</strong>任务，本地统计每个URL出现的次数。</li><li><strong>全局合并</strong>：将所有机器上的本地统计结果合并，这通常涉及到一个中心节点或使用另一个MapReduce作业来完成。</li><li><strong>Top K算法</strong>：在合并后的全局数据上运行TopK算法（如Min-Heap或<strong>MapReduce</strong>中的SecondarySort）来找到出现次数最多的前10000个URL。</li></ol><h3id="有140g沙子现在有7g和2g的砝码各一个并有一个天平用最少次数把沙子分为50g和90g">有140g沙子，现在有7g和2g的砝码各一个，并有一个天平，用最少次数把沙子分为50g和90g</h3><ol type="1"><li>用7 + 2 = 9g称两次得到18g</li><li>用7g称一次加上之前的18g一共是25g</li><li>用这25g沙子再称25g沙子得到50g</li></ol><p>一共4次。</p><h2 id="其他">其他</h2><h3 id="你都知道哪些消息队列">你都知道哪些消息队列</h3><ul><li>Kafka</li><li>RocketMQ</li><li>RabbitMQ</li></ul><h3 id="如何判断一个图里是否存在环">如何判断一个图里是否存在环</h3><p>使用深度优先搜索算法（DFS）来判断一个图是否存在环的基本思路：</p><ol type="1"><li>从图中的任意一个顶点开始进行深度优先搜索。</li><li>在搜索过程中，如果遇到一个已经被访问过的顶点，而且这个顶点不是当前顶点的父节点（在搜索树中），则说明存在环。</li></ol><h3 id="git-pull和git-pull---rebasegit-fetch的区别">git pull和git pull--rebase，git fetch的区别</h3><h4 id="git-fetch和git-pull的区别">git fetch和git pull的区别</h4><p>在执行 <code>git pull</code> 后，代码会自动 merge 到本地的分支中，而<code>git fetch</code> 会忽略掉这个 merge 操作，因此简单来说：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull = git fetch + git merge<br></code></pre></td></tr></table></figure><h4 id="git-pull和git-pull---rebase的区别">git pull和git pull--rebase的区别</h4><p><code>git pull</code> 命令默认包含了一个 <code>--merge</code>参数，因此二者的区别其实就是 <code>merge</code> 和 <code>rebase</code>的区别。</p><p><strong>merge</strong>:</p><p><code>merge</code> 会创建一个新的commit，如果合并时遇到了冲突，需要解决冲突后重新 commit。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/175befc2f02f4d1f909ad5fd541cebfftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>rebase</strong>：</p><p><code>rebase</code> 会将两个分支进行合并，同时合并之前的 commit历史。如果出现冲突，解决冲突后执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add<br>git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/ec7db69f93ee440a8a5b9b62dd68668ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3id="现在我们来实现一个多线程环境下的任务执行器你觉得应该如何设计呢">现在我们来实现一个多线程环境下的任务执行器，你觉得应该如何设计呢？</h3><p>可以首先设计一个任务队列，用来存放待执行的任务。然后创建多个线程，这些线程会从任务队列中取出任务并执行。任务执行完成后，将结果存放到一个共享的列表中。需要注意的是，在多线程环境下，要确保线程安全，可以使用同步机制或锁来保证共享资源的安全访问。</p><h3 id="git-rebase-git-merge-git-squash的区别">git rebase, git merge,git squash的区别</h3><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-d788def8f1d3a97ff0c9b4fee80e6d6d_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>git merge</strong>：</p><p>这是最基本的merge，就是把提交历史原封不动的拷贝过来，包含完整的提交历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge dev<br></code></pre></td></tr></table></figure><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-42076e03447bfaf473c8f73a044db7ce_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>此时还会生产一个 <code>merge commit (D')</code>，这个<code>merge commit</code>不包含任何代码改动，而包含在dev分支上的几个commit列表(A,B和C)。查看git的提交历史(git log)可以看到所有的这些提交历史记录。</p><p><strong>git squash merge</strong>:</p><p>根据字面意思，这个操作完成的是压缩的提交，解决的是什么问题呢？由于在dev分支上执行的是开发工作，有一些很小的提交，或者是纠正前面的错误的提交，对于这类提交对整个工程来说不需要单独显示出来一次提交，不然导致项目的提交历史过于复杂。所以基于这种原因，我们可以把dev上的所有提交都合并成一个提交；然后提交到主干。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-055cd40632a48014f2651ac262edfc59_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这个例子中，我们把A，B和C的改动合并成了一个D。</p><p>注意，squash merge并不会替我们产生提交D，它只是把所有原本属于A、B和C的改动合并，然后放在本地文件，需要你再次手动执行<code>git commit</code> 操作。</p><p>此时又要注意了，因为你要你手动 commit，也就是说这个 commit是你产生的，不是有原来 dev分支上的开发人员产生的，提交者本身发生了变化。也可以这么理解，就是你把dev 分支上的所有代码改动一次性提交到 master 分支上而已。</p><p><strong>git rebase merge</strong>:</p><p>由于 <code>squash merge</code>会变更提交者作者信息，这是一个很大的问题，后期问题追溯不好处理(当然也可以由分支dev的所有者来执行<code>squash merge</code>操作，以解决部分问题)，<code>rebase merge</code>可以保留提交的作者信息，同时可以合并commit历史，完美的解决了上面的问题。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">$ git checkout dev<br>$ git rebase -i master<br>$ git checkout master<br>$ git merge dev<br></code></pre></td></tr></table></figure><p><code>rebase merge</code> 分两步完成：</p><p><strong>第一步：</strong>执行rebase操作，结果是看起来dev分支是从主分支的提交3拉出来的，而不是从提交2拉出来的，然后使用-i参数手动调整commit历史，是否合并如何合并。例如<code>rebase -i</code> 命令会弹出文本编辑框：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">pick &lt;A&gt; Message for commit #1<br>pick &lt;B&gt; Message for commit #2<br>pick &lt;C&gt; Message for commit #3<br></code></pre></td></tr></table></figure><p>假设提交B是对提交A的一个拼写错误修正，因此可以不需要显式的指出来，我们把B修改为fixup：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">pick &lt;A&gt; Message for commit #1<br>fixup &lt;B&gt; Message for commit #2<br>pick &lt;C&gt; Message for commit #3<br></code></pre></td></tr></table></figure><p>rebase之后的状态变为：</p><p><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-2a870e3f8e10df8c5dbdb70ca4536f50_720w.webp"alt="img" /> A' 是A和B的合并。</p><p>第二步：再执行merge操作，把dev分支合并到master分支：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/v2-61227468d7c1fe05d529f36ed491e849_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注意：</p><ol type="1"><li>在执行 <code>rebase</code>的时候可能会出现冲突的问题，此时需要手工解决冲突的问题，然后执行(gitadd)命令；</li><li>所有冲突解决完之后，这时不需要执行(git commit)命令，而是运行(gitrebase--continue)命令，一直到rebase完成；如果中途想放弃rebase操作，可以运行(gitrebase --abort)命令回到rebase之前的状态。</li></ol><h3 id="cap理论">CAP理论</h3><p>一个分布式系统最多只能同时满足<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong>和<strong>分区容错性（Partitiontolerance）这</strong>三项中的两项。</p><p>Raft专注于解决<strong>一致性</strong>和<strong>分区容错性</strong>问题，而将可用性问题留给其他机制处理。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>海量数据处理</title>
    <link href="/2024/01/10/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>/2024/01/10/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理">海量数据处理</h1><h2 id="如何从大量的-url-中找出相同的-url">如何从大量的 URL 中找出相同的URL？</h2><p><strong>题目描述</strong>：给定 a、b 两个文件，各存放 50 亿个URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的URL。</p><p>解答思路：每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为320GB。</p><blockquote><p>5, 000, 000, 000 _ 64B ≈ 5GB _ 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过4G，这样就可以把这个小文件读到内存中进行处理了。</p><ol type="1"><li><p>哈希取余</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ...,a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的URL 分别存储到文件 b0, b1, b2, ..., b999中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0,..., a999 对应 b999，不对应的小文件不可能有相同的URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet集合中。然后遍历 bi 中每个 URL，看在 HashSet集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL保存到一个单独的文件中。</p></li><li><p>前缀树</p><p>一般而言，URL的长度差距不会不大，而且前面几个字符，绝大部分相同。这种情况下，非常适合使用<strong>字典树</strong>（trietree）这种数据结构来进行存储，降低存储成本的同时，提高查询效率。</p></li></ol><h2 id="如何从大量数据中找出高频词">如何从大量数据中找出高频词？</h2><h3 id="题目描述">题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)</p><p><strong>解答思路</strong>：由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于1MB，进而直接将单个小文件读取到内存中进行处理。</p><h3 id="解决方法">解决方法</h3><p>首先遍历大文件，对遍历到的每个词 x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用HashMap 来实现。其中 key 为词，value为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行<code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的100个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的100 个词。</p><h2id="如何找出某一天访问百度网站最多的-ip">如何找出某一天访问百度网站最多的IP？</h2><h3 id="题目描述-1">题目描述</h3><p><strong>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个IP。</strong></p><h3 id="解答思路">解答思路</h3><p>这道题只关心某一天访问百度最多的IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对IP 进行哈希映射，接着使用 HashMap 统计重复 IP的次数，最后计算出重复次数最多的 IP。</p><div class="admonition note"><p class="admonition-title">note</p><p>这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max即可。</p></div><h2id="如何在大量的数据中找出不重复的整数">如何在大量的数据中找出不重复的整数？</h2><p>### 题目描述</p><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5亿个整数。</p><h3 id="解答思路-1">解答思路</h3><h4 id="方法一分支法">方法一：分支法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用HashSet/HashMap找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二位图法">方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。假设我们要对<code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5)进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1个字节。首先将每个位都置 0：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 0 0 0 0 0 0 0<br></code></pre></td></tr></table></figure><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 0 0 0 1 0 1 0<br></code></pre></td></tr></table></figure><p>依次遍历，结束后，位数组是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 1 1 0 1 1 1 0<br></code></pre></td></tr></table></figure><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 <spanclass="math inline">\(2^32\)</span>。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit来表示各个数字的状态：</p><ul><li>00 表示这个数字没出现过；</li><li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>10 表示这个数字出现了多次。</li></ul><p>那么这 <span class="math inline">\(2^32\)</span>个整数，总共所需内存为 <spanclass="math inline">\(2^32\)</span>*2b=1GB。因此，当可用内存超过 1GB时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01的整数输出即可。</p><p>当然，本题中特别说明：<strong>内存不足以容纳这 2.5亿个整数</strong>，2.5 亿个整数的内存大小为：2.5e8/1024/1024/1024 *4=3.72GB， 如果内存大于 1GB，是可以通过位图法解决的。</p><h2id="如何在大量的数据中判断一个数是否存在">如何在大量的数据中判断一个数是否存在？</h2><h3 id="题目描述-2">题目描述</h3><p>给定 40 亿个不重复的没排过序的 unsigned int型整数，然后再给定一个数，如何快速判断这个数是否在这 40亿个整数当中？</p><h3 id="解答思路-2">解答思路</h3><h4 id="方法一分治法">方法一：分治法</h4><p>方法与前面类似，就不再次赘述了</p><h4 id="方法二位图法-1">方法二：位图法</h4><p>与上个问题类似</p><h2 id="毒药毒老鼠">毒药毒老鼠</h2><h3 id="题目描述-3">题目描述</h3><p>有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？</p><h3 id="解答思路-3">解答思路</h3><p>这个问题可以通过二进制和小白鼠的组合来解决。具体步骤如下：</p><ol type="1"><li>首先，将1000个瓶子编号为1到1000。</li><li>然后，将这些编号转换为二进制。例如，瓶子编号1在二进制中是0000000001，瓶子编号2在二进制中是0000000010，以此类推，直到瓶子编号1000在二进制中是1111101000。</li><li>接下来，将10只小白鼠分别对应二进制编号的10位。例如，第一只小白鼠对应最低位（最右边的位），第二只小白鼠对应第二位，以此类推，第十只小白鼠对应最高位（最左边的位）。</li><li>对于每一个瓶子，如果其二进制编号在某一位上是1，就让对应的小白鼠喝那个瓶子的水。例如，对于编号为3（二进制为0000000011）的瓶子，第一只和第二只小白鼠会喝这个瓶子的水。</li><li>一星期后，观察哪些小白鼠死亡。如果第n只小白鼠死亡，那么毒药瓶子的二进制编号在第n位上是1。例如，如果第一只和第二只小白鼠死亡，那么毒药瓶子的编号在二进制表示中的最后两位是11。</li><li>通过这种方式，我们可以确定出哪个瓶子含有毒药。</li></ol><p>这种方法的关键在于利用了二进制编码的特性，使得10只小白鼠就能够测试出1000个瓶子中哪一个含有毒药。</p><h2 id="如何查询最热门的查询串">如何查询最热门的查询串？</h2><h3 id="题目描述-4">题目描述</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10个查询串，要求使用的内存不能超过1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h3 id="解答思路-4">解答思路</h3><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h4 id="方法一分治法-1">方法一：分治法</h4><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h4 id="方法二hashmap-法">方法二：HashMap 法</h4><p>虽然字符串总数比较多，但去重后不超过300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p><p>接着遍历 map，构建一个 10个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10个字符串就是出现次数最多的字符串。这一步时间复杂度<code>O(Nlog10)</code> 。</p><h4 id="方法三前缀树法">方法三：前缀树法</h4><p>方法二使用了 HashMap来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h2 id="如何统计不同电话号码的个数">如何统计不同电话号码的个数？</h2><h3 id="题目描述-5">题目描述</h3><p>已知某个文件内包含一些电话号码，每个号码为 8位数字，统计不同号码的个数</p><h3 id="解答思路-5">解答思路</h3><p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约12M。</p><p><strong>思路如下</strong>：</p><p>申请一个位图数组，长度为 1 亿，初始化为0。然后遍历所有电话号码，把号码对应的位图中的位置置为1。遍历完成后，如果 bit 为1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为不同电话号码的个数。</p><h3 id="方法总结">方法总结</h3><p>求解数据重复问题，记得考虑位图法。</p><h2 id="如何从-5-亿个数中找出中位数">如何从 5 亿个数中找出中位数？</h2><h3 id="题目描述-6">题目描述</h3><p>从 5亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第<code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。</p><h3 id="解答思路-6">解答思路</h3><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为<code>O(NlogN)</code> 。这里使用其他方法。</p><h4 id="方法一">方法一</h4><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过1。</p><p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; queMin;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; queMax;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">empty</span>() || num &lt;= queMin.<span class="hljs-built_in">top</span>()) &#123;<br>            queMin.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> &lt; queMin.<span class="hljs-built_in">size</span>()) &#123;<br>                queMax.<span class="hljs-built_in">push</span>(queMin.<span class="hljs-built_in">top</span>());<br>                queMin.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queMax.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() &gt; queMin.<span class="hljs-built_in">size</span>()) &#123;<br>                queMin.<span class="hljs-built_in">push</span>(queMax.<span class="hljs-built_in">top</span>());<br>                queMax.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">size</span>() &gt; queMax.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> queMin.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (queMin.<span class="hljs-built_in">top</span>() + queMax.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法二分治法">方法二：分治法</h4><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5亿个数与它后面的一个数的平均值。</p><div class="admonition note"><p class="admonition-title">note</p><p>5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1有一亿个数，那么中位数就是 f0 中从第 1.5亿个数开始的两个数求得的平均值。</p></div><p>对于 f0可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><div class="admonition info"><p class="admonition-title">info</p><p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p></div><h2 id="如何按照-query-的频度排序">如何按照 query 的频度排序？</h2><h3 id="题目描述-7">题目描述</h3><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h3 id="解答思路-7">解答思路</h3><p>如果 query 的重复度比较大，可以考虑一次性把所有 query读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的query，这时候就需要采用分治法或其他的方法来解决。</p><h4 id="方法一hashmap-法">方法一：HashMap 法</h4><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的query 都加载到内存中的 HashMap 中。接着就可以按照 query出现的次数进行排序。</p><h4 id="方法二分治法-1">方法二：分治法</h4><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query出现次数，根据次数排序并写入到另外一个单独文件中。</p><p>接着对所有文件按照 query的次数进行排序，这里可以使用归并排序（由于无法把所有 query都读入内存，因此需要使用外排序）。</p><h4 id="总结">总结</h4><ul><li>内存若够，直接读入进行排序；</li><li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统设计</title>
    <link href="/2024/01/06/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/01/06/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统一致性以及高并发">分布式、系统一致性以及高并发</h1><h2 id="分布式系统基本概念">分布式系统基本概念</h2><p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP定理是这方面的基本定理，也是理解分布式系统的起点。</p><p>1998年，加州大学的计算机科学家 Eric Brewer提出，分布式系统有三个指标：</p><ul><li>Consistency</li><li>Availability</li><li>Partition tolerance</li></ul><p>它们的第一个字母分别是<code>C</code>、<code>A</code>、<code>P</code>。Eric Brewer说，这三个指标不可能同时做到。这个结论就叫做 <code>CAP</code> 定理。</p><p>它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency）：等同于所有节点访问同一份最新的数据副本，或者说同一数据在不同节点上的副本在同一逻辑时钟应当是相同的内容。</li><li>可用性（Availability）：每次请求都能获取到非错的响应，以及尽量保证低延迟，但是不保证获取的数据为最新数据。</li><li>分区容错性（Partitiontolerance）：以实际效果而言，分区相当于对<strong>通信的时限要求</strong>。要求任意节点故障时，系统仍然可以对外服务。</li></ul><h3 id="数据一致性c侧">数据一致性（C侧）</h3><p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统<strong>采用弱一致性来提高性能</strong>，一些不同的一致性模型也相继被提出。</p><ul><li><strong>强一致性</strong>：要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</li><li><strong>弱一致性</strong>：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li><li><strong>最终一致性</strong>：是弱一致性的一种特例，保证用户<strong>最终（即窗口尽量长）</strong>能够读取到某操作对系统特定数据的更新。</li></ul><h4 id="一致性解决方案">一致性解决方案</h4><ol type="1"><li>分布式事务：两段提交</li><li>分布式锁</li><li>消息队列、消息持久化、重试、幂等操作</li><li>Raft / Paxos 等一致性算法</li></ol><h3 id="服务可用性a侧">服务可用性（A侧）</h3><p>可用性，意思是只要收到用户的请求，服务器就必须给出回应。</p><h4 id="高可用解决方案">高可用解决方案</h4><ul><li><strong>负载均衡</strong>：尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。</li><li><strong>服务降级</strong>：当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</li><li><strong>熔断</strong>：对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源。确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回的、不会阻塞的，等到目标服务好转后进行接口恢复。</li><li><strong>流量控制</strong>：流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行，类似于TCP拥塞控制方法。</li><li><strong>异地多活</strong>：在不同地区维护不同子系统，并保证子系统的可用性</li></ul><div class="admonition info"><p class="admonition-title">info</p><p>熔断是减少由于下游服务故障对自己的影响；而降级则是在整个系统的角度上，考虑业务整体流量，保护核心业务稳定。</p></div><h3 id="分区容错性p侧">分区容错性（P侧）</h3><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p><p>一般来说，分区容错无法避免，因此可以认为 CAP 的 <code>P</code>总是成立。CAP 定理告诉我们，剩下的 <code>C</code> 和 <code>A</code>无法同时做到。</p><h2 id="系统一致性">系统一致性</h2><h3 id="基本要求">基本要求</h3><p>规范的说，理想的分布式系统一致性应该满足：</p><ol type="1"><li>可终止性（Termination）：一致的结果在有限时间内能完成；</li><li>共识性（Consensus）：不同节点最终完成决策的结果应该相同；</li><li>合法性（Validity）：决策的结果必须是其它进程提出的提案。</li></ol><p>第一点很容易理解，这是计算机系统可以被使用的前提。需要注意，在现实生活中这点并不是总能得到保障的，例如取款机有时候会是<code>服务中断</code> 状态，电话有时候是 <code>无法连通</code> 的。</p><p>第二点看似容易，但是隐藏了一些潜在信息。算法考虑的是任意的情形，凡事一旦推广到任意情形，就往往有一些惊人的结果。例如现在就剩一张票了，中关村和西单的电影院也分别刚确认过这张票的存在，然后两个电影院同时来了一个顾客要买票，从各自观察看来，自己的顾客都是第一个到的……怎么能达成结果的共识呢？记住我们的唯一秘诀：<strong>核心在于需要把两件事情进行排序，而且这个顺序还得是合理的、大家都认可的</strong>。</p><p>第三点看似绕口，但是其实比较容易理解，即达成的结果必须是节点执行操作的结果。仍以卖票为例，如果两个影院各自卖出去一千张，那么达成的结果就是还剩八千张，决不能认为票售光了。</p><h3 id="强一致性">强一致性</h3><h4 id="线性一致性">线性一致性</h4><p>线性一致性或称 <strong>原子一致性</strong> 或<strong>严格一致性</strong>指的是程序在执行的历史中在存在可线性化点P的执行模型，这意味着一个操作将在程序的调用和返回之间的某个点P起作用。这里“起作用”的意思是被系统中并发运行的所有其他线程所感知。要求如下：</p><ol type="1"><li><strong>写后读</strong>这里写和读是两个操作，如果写操作在完成之后，读才开始，读要能读到最新的数据，而且保证以后也能读操作也都能读到这个最新的数据。</li><li><strong>所有操作的时序与真实物理时间一致</strong>，要求即使不相关的两个操作，如果执行有先后顺序，线性一致性要求最终执行的结果也需要满足这个先后顺序。比如，操作序列(写A，读A，写B，读B)，那么不仅，读A，读B能读到最新A值和B值；而且要保证，如果读B读到最新值时，读A一定也能读到最新值，也就是需要保证执行时序与真实时序相同。</li><li>如果两个操作是并发的（比如读A没有结束时，写B开始了），那么这个并发时序不确定，但从最终执行的结果来看，要确保所有线程(进程，节点)看到的执行序列是一致的。</li></ol><h4 id="顺序一致性">顺序一致性</h4><p>相比线性一致性，主要区别在于，<strong>对于物理上有先后顺序的操作，不保证这个时序</strong>。具体而言，对于单个线程，操作的顺序仍然要保留，对于多个线程(进程，节点)，执行的事件的先后顺序与物理时钟顺序不保证。<strong>但是要求，从执行结果来看，所有线程(进程，节点)看到的执行序列是一样的。</strong></p><h4 id="因果一致性">因果一致性</h4><p>因果一致性，被认为是比<code>顺序一致性</code>更弱的一致性，在因果一致性中，只对<strong>有因果关系的事件</strong>有顺序要求。</p><h3 id="带约束的一致性">带约束的一致性</h3><p>绝对理想的 <strong>强一致性（Strong Consistency）</strong>代价很大。除非不发生任何故障，所有节点之间的通信无需任何时间，这个时候其实就等价于一台机器了。实际上，越强的一致性要求往往意味着越弱的性能、越低的可用性。</p><p>强一致的系统往往比较难实现。很多时候，人们发现实际需求并没有那么强，可以适当放宽一致性要求，降低系统实现的难度。例如在一定约束下实现所谓<strong>最终一致性（EventualConsistency）</strong>，即总会存在一个时刻（而不是立刻），系统达到一致的状态，这对于大部分的Web 系统来说已经足够了。这一类弱化的一致性，被笼统称为<strong>弱一致性（Weak Consistency）</strong>。</p><h4 id="最终一致性乐观复制">最终一致性（乐观复制）</h4><p>最终一致性也被称为 <strong>乐观复制(optimisticreplication)</strong>，用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。这个达成一致所需要的时间，我们称为<strong>窗口时间</strong>。</p><p>我们常见的 <strong>异步复制的主从架构实现的是最终一致性</strong>。它的一个典型常见是用户读取异步从库时，可能读取到较旧的信息，因为该从库尚未完全与主库同步。注意，同步复制的主从架构会出现任一节点宕机导致的单点问题。</p><h3id="一致性consistency与共识consensus的关系">一致性（Consistency）与共识（Consensus）的关系</h3><p>我们常说的 <strong>一致性（Consistency）</strong>在分布式系统中指的是 <code>副本（Replication）</code>问题中对于同一个数据的多个副本，其对外表现的数据一致性，如<code>线性一致性</code>、<code>因果一致性</code>、<code>最终一致性</code>等，都是用来描述副本问题中的一致性的。</p><p>而 <strong>共识（Consensus）</strong>则不同，共识问题中所有的节点要最终达成共识，由于最终目标是所有节点都要达成一致，所以根本<strong>不存在一致性强弱</strong> 之分。</p><figure><img src="/img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222244561.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222244409.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="高并发系统的设计">高并发系统的设计</h2><h3 id="系统拆分">系统拆分</h3><p>将一个系统拆分为多个子系统，用 RPC来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存">缓存</h3><p>大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟Redis轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p><h3 id="消息队列">消息队列</h3><p>可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改。那高并发绝对搞挂你的系统，你要是用Redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU了，数据格式还无比简单，没有事务支持。所以该用 MySQL 还得用 MySQL啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ里，后边系统消费后慢慢写，控制在 MySQL承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ 来异步写，提升并发性。</p><h3 id="分库分表">分库分表</h3><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高SQL 跑的性能。</p><h3 id="读写分离">读写分离</h3><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p><h2 id="分布式缓存">分布式缓存</h2><h3 id="应用场景">应用场景</h3><ol type="1"><li><strong>页面缓存</strong>：用来缓存Web 页面的内容片段,包括HTML、CSS和图片等;</li><li><strong>应用对象缓存</strong>：缓存系统作为ORM框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问;解决分布式Web部署的session 同步问题，状态缓存.缓存包括Session会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群。</li><li><strong>并行处理</strong>：通常涉及大量中间计算结果需要共享;</li><li><strong>云计算领域提供分布式缓存服务</strong></li></ol><h3 id="缓存雪崩">缓存雪崩</h3><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效、新缓存未到之间(<strong>例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期</strong>)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><h3 id="缓存穿透">缓存穿透</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。<strong>这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空</strong>（<em>相当于进行了两次无用的查询</em>）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><h3 id="缓存预热">缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h3 id="缓存更新">缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外，我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol type="1"><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ol><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h3 id="缓存降级">缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>降级的最终目的是<strong>保证核心服务可用，即使是有损的</strong>。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ol type="1"><li><strong>一般</strong>：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li><strong>警告</strong>：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li><strong>错误</strong>：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li><strong>严重错误</strong>：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ol><h2 id="分布式锁">分布式锁</h2><h3 id="redis-的-redlock-锁">Redis 的 RedLock 锁</h3><p>为了解决 Redis 单点的问题。 Redis 的作者提出了 RedLock的解决方案。方案非常的巧妙和简洁。 RedLock的核心思想就是，<strong>同时使用多个 Redis Master来冗余，且这些节点都是完全的独立的，也不需要对这些节点之间的数据进行同步</strong>。</p><p>假设我们有N个Redis节点，N应该是一个大于2的奇数。RedLock的实现步骤:</p><ol type="1"><li>取得当前时间</li><li>使用单节点获取锁的方式，依次获取 N 个节点的 Redis 锁。</li><li>如果获取到的锁的数量大于 N/2+1<em>N</em>/2+1个，且获取的时间小于锁的有效时间(lock validitytime)就认为获取到了一个有效的锁，锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li><li>如果获取锁的数量小于 N/2+1<em>N</em>/2+1 ，或者在锁的有效时间(lockvaliditytime)内没有获取到足够的锁，就认为获取锁失败，这个时候需要向所有节点发送释放锁的消息。</li></ol><p>对于释放锁的实现就很简单了，向所有的 Redis节点发起释放的操作，无论之前是否获取锁成功。</p><h3 id="基于-zookeeper-的分布式锁">基于 ZooKeeper 的分布式锁</h3><p>基于 ZK 的特性，很容易得出使用 ZK 实现分布式锁的落地方案：</p><ol type="1"><li>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK创建一个临时有序的节点，比如在 <code>/lock/</code> 目录下。</li><li>创建节点成功后，获取 <code>/lock</code>目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点。</li><li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</li><li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的<strong>前一个节点</strong> 添加一个事件监听。</li></ol><h4 id="缺陷">缺陷</h4><ol type="1"><li><strong>羊群效应</strong>：当一个节点变化时，会触发大量的<code>watches</code> 事件，导致集群响应变慢。每个节点尽量少的<code>watches</code>，这里就只注册 <strong>前一个节点</strong>的监听</li><li>ZK 集群的读写吞吐量不高</li><li>网络抖动可能导致 Session 离线，锁被释放</li></ol><h2 id="分布式事务">分布式事务</h2><h3 id="pcxa方案">2PC/XA方案</h3><p><strong>XA方案</strong>，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不ok，那么就回滚事务。</p><p>这种分布式事务方案，比较<strong>适合单块应用里，跨多个库的分布式事务</strong>，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对<strong>不适合高并发的场景</strong>。</p><p>一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</p><h3 id="tcc强一致性方案">TCC强一致性方案</h3><p>TCC的全称是：<code>Try</code>、<code>Confirm</code>、<code>Cancel</code>。</p><ul><li><strong>Try阶段</strong>：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li><strong>Confirm阶段</strong>：这个阶段说的是在各个服务中执行实际的操作。</li><li><strong>Cancel阶段</strong>：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>这种方案说实话几乎<strong>很少人使用</strong>，但是也有使用的场景。因为这个<strong>事务回滚实际上是严重依赖于你自己写逻辑来实现回滚和补偿</strong>，会造成巨大的补偿代码量。</p><h3 id="可靠消息最终一致性方案">可靠消息最终一致性方案</h3><p>基于 MQ 来实现事务。比如阿里的 RocketMQ就支持消息事务。大概的意思就是：</p><ol type="1"><li>A 系统先发送一个 prepared 消息到 MQ，如果这个 prepared消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 MQ发送确认消息，如果失败就告诉 MQ 回滚消息；</li><li>如果发送了确认消息，那么此时 B系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动定时轮询所有 prepared消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B 系统本地回滚后，想办法通知系统 A也回滚；或者是发送报警由人工来手工回滚和补偿。</li></ol><h3 id="最大努力通知方案">最大努力通知方案</h3><ol type="1"><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N次，最后还是不行就放弃。</li></ol><h2 id="raft算法">Raft算法</h2><p>raft是<strong>工程</strong>上使用较为广泛的<strong>强一致性、去中心化、高可用</strong>的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的Paxos。但 Paxos是：少数真正理解的人觉得简单，尚未理解的人觉得很难，大多数人都是一知半解。本人也花了很多时间、看了很多材料也没有真正理解。直到看到raft 的论文，两位研究者也提到，他们也花了很长的时间来理解Paxos，他们也觉得很难理解，于是研究出了 raft 算法。</p><p>raft 是一个共识算法（consensusalgorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下。这些年最为火热的加密货币（比特币、区块链）就需要共识算法，而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在<ahref="https://www.cnblogs.com/xybaby/p/7153755.html">带着问题学习分布式系统之中心化复制集(opens new window)</a>一文中介绍了中心化复制集的相关知识。raft协议就是一种 leader-based 的共识算法，与之相应的是 leaderless的共识算法。</p><p>Raft算法的头号目标就是容易理解（UnderStandable），这从论文的标题就可以看出来。当然，Raft增强了可理解性，在性能、可靠性、可用性方面是不输于 Paxos 的。</p><p>为了达到易于理解的目标，raft 做了很多努力，其中最主要是两件事情：</p><ul><li>问题分解</li><li>状态简化</li></ul><p>问题分解是将 "复制集中节点一致性"这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，<em>leader election</em>， <em>logreplication</em>，<em>safety</em>，<em>membershipchanges</em>。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader 会包含所有 commited log entry）</p><p>上面的引文对 raft 协议的工作原理进行了高度的概括：raft 会先选举出leader，leader 完全负责 replicated log 的管理。leader负责接受所有客户端更新请求，然后复制到 follower 节点，并在 “安全”的时候执行这些请求。如果 leader 故障，followes 会重新选举出新的leader。</p><p>这就涉及到 raft 最新的两个子问题： leader election 和 logreplication</p><h3 id="leader-election">leader election</h3><p>raft 协议中，一个节点任一时刻处于以下三个状态之一：</p><ul><li>leader</li><li>follower</li><li>candidate</li></ul><p>给出状态转移图能很直观的直到这三个状态的区别</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245852.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看出所有节点启动时都是 follower状态；在一段时间内如果没有收到来自 leader 的心跳，从 follower 切换到candidate，发起选举；如果收到 majority 的造成票（含自己的一票）则切换到leader 状态；如果发现其他节点比自己更新，则主动切换到 follower。</p><p>总之，系统中最多只有一个 leader，如果在一段时间里发现没有leader，则大家通过选举 - 投票选出 leader。leader 会不停的给 follower发心跳消息，表明自己的存活状态。如果 leader 故障，那么 follower 会转换成candidate，重新选出 leader。</p><h4 id="term任期">term(任期)</h4><p>从上面可以看出，哪个节点做 leader 是大家投票选举出来的，每个 leader工作一段时间，然后选出新的 leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft 协议中，也是这样的，对应的术语叫<strong><em>term</em></strong>。</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245446.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normalOperation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term3 展示了一种情况，就是说没有选举出 leader就结束了，然后会发起新的选举，后面会解释这种 <em>split vote</em>的情况。</p><h4 id="选举过程详解">选举过程详解</h4><p>上面已经说过，如果 follower 在 <em>election timeout</em>内没有收到来自 leader 的心跳，（也许此时还没有选出leader，大家都在等；也许 leader 挂了；也许只是 leader 与该 follower之间网络故障），则会主动发起选举。步骤如下：</p><ul><li>增加节点本地的 <em>current term</em> ，切换到 candidate 状态</li><li>投自己一票</li><li>并行给其他节点发送 <em>RequestVote RPCs</em></li><li>等待其他节点的回复</li></ul><p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p><ol type="1"><li>收到 majority 的投票（含自己的一票），则赢得选举，成为 leader</li><li>被告知别人已当选，那么自行切换到 follower</li><li>一段时间内没有收到 majority 投票，则保持 candidate状态，重新发出选举</li></ol><p>第一种情况，赢得了选举之后，新的 leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p><ul><li>在任一任期内，单个节点最多只能投一票</li><li>候选人知道的信息不能比自己的少（这一部分，后面介绍 log replication和 safety 的时候会详细介绍）</li><li>first-come-first-served 先来先得</li></ul><p>第二种情况，比如有三个节点 A B C。A B 同时发起选举，而 A的选举消息先到达 C，C 给 A 投了一票，当 B 的消息到达 C时，已经不能满足上面提到的第一个约束，即 C 不会给 B 投票，而 A 和 B显然都不会给对方投票。A 胜出之后，会给 B,C 发心跳消息，节点 B 发现节点 A的 term 不低于自己的 term，知道有已经有 Leader 了，于是转换成follower。</p><p>第三种情况，没有任何节点获得 majority 投票，比如下图这种情况：</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245368.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>总共有四个节点，Node C、Node D 同时成为了 candidate，进入了 term4，但 Node A 投了 NodeD 一票，NodeB 投了 Node C 一票，这就出现了平票split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader 是不能处理客户端写请求的），因此 raft 引入了 randomized electiontimeouts 来尽量避免平票情况。同时，leader-based共识算法中，节点的数目都是奇数个，尽量保证 majority 的出现。</p><h3 id="log-replication">log replication</h3><p>当有了 leader，系统应该进入对外工作期了。客户端的一切请求来发送到leader，leader 来调度这些并发请求的顺序，并且保证 leader 与 followers状态的一致性。raft 中的做法是，将这些请求以及执行顺序告知followers。leader 和 followers以相同的顺序来执行这些请求，保证状态一致。</p><h4 id="replicated-state-machines复制状态机">Replicated statemachines（复制状态机）</h4><p>共识算法的实现一般是基于复制状态机（Replicated statemachines），何为复制状态机：</p><p>简单来说：<strong>相同的初识状态 + 相同的输入 =相同的结束状态</strong>。引文中有一个很重要的词<code>deterministic</code>，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一下不确定的值，比如本地时间等。如何保证所有节点<code>get the same inputs in the same order</code>，使用 replicated log是一个很不错的主意，log具有持久化、保序的特点，是大多数分布式系统的基石。</p><p>因此，可以这么说，在 raft 中，leader将客户端请求（command）封装到一个个 log entry，将这些 log entries复制（replicate）到所有 follower节点，然后大家按相同顺序应用（apply）log entry 中的command，则状态肯定是一致的。</p><p>下图形象展示了这种 log-based replicated state machine：</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245321.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="请求完整流程">请求完整流程</h4><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader 的视角来看会经历以下步骤：<strong>Leader把请求作为日志条目（Logentries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntriesRPC复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</strong></p><p>可以看到日志的提交过程有点类似两阶段提交 (2PC)，不过与 2PC的区别在于，leader只需要大多数（majority）节点的回复即可，这样只要超过一半节点处于工作状态则系统就是可用的。</p><p>那么日志在每个节点上是什么样子的呢</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245795.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>不难看到，logs 由顺序编号的 log entry 组成 ，每个 log entry 除了包含command，还包含产生该 log entry 时的 leaderterm。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader 会不断尝试给follower 发 log entries，直到所有节点的 log entries 都相同。</p><p>在上面的流程中，leader只需要日志被复制到大多数节点即可向客户端返回，一旦向客户端返回成功消息，那么系统就必须保证log（其实是 log 所包含的command）在任何异常的情况下都不会发生回滚。这里有两个词：commit（committed），apply(applied)，前者是指日志被复制到了大多数节点后日志的状态；而后者则是节点将日志应用到状态机，真正影响到节点状态。</p><h3 id="safety">safety</h3><p>在上面提到只要日志被复制到 majority节点，就能保证不会被回滚，即使在各种异常情况下，这根 leader election提到的选举约束有关。在这一部分，主要讨论 raft协议在各种各样的异常情况下如何工作的。</p><p>衡量一个分布式算法，有许多属性，如</p><ul><li>safety：nothing bad happens,</li><li>liveness： something good eventually happens.</li></ul><p>在任何系统模型下，都需要满足 safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是 safety 属性。而 raft最终会让所有节点状态一致，这属于 liveness 属性。</p><p>raft 协议会保证以下属性</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245235.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="election-safety">Election safety</h4><p>选举安全性，即任一任期内最多一个 leader被选出。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个 leader，被称之为脑裂（brainsplit），这是非常严重的问题，会导致数据的覆盖丢失。在 raft中，两点保证了这个属性：</p><ul><li>一个节点某一任期内最多只能投一票；</li><li>只有获得 majority 投票的节点才会成为 leader。</li></ul><p>因此，<strong>某一任期内一定只有一个 leader</strong>。</p><h4 id="log-matching">log matching</h4><p>很有意思，log 匹配特性， 就是说如果两个节点上的某个 log entry 的 logindex 相同且 term 相同，那么在该 index 之前的所有 log entry应该都是相同的。如何做到的？依赖于以下两点</p><ul><li>If two entries in different logs have the same index and term, thenthey store the same command.</li><li>If two entries in different logs have the same index and term, thenthe logs are identical in all preceding entries.</li></ul><p>首先，leader 在某一 term 的任一位置只会创建一个 log entry，且 logentry 是 append-only。其次，consistency check。leader 在 AppendEntries中包含最新 log entry 之前的一个 log 的 term 和 index，如果 follower在对应的 term index 找不到日志，那么就会告知 leader 不一致。</p><p>在没有异常的情况下，log matching 是很容易满足的，但如果出现了 nodecrash，情况就会变得负责。比如下图</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245788.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>注意</strong>：上图的 a-f 不是 6 个 follower，而是某个follower 可能存在的六个状态</p><p>leader、follower 都可能 crash，那么 follower 维护的日志与 leader相比可能出现以下情况</p><ul><li>比 leader 日志少，如上图中的 ab</li><li>比 leader 日志多，如上图中的 cd</li><li>某些位置比 leader 多，某些日志比 leader 少，如ef（多少是针对某一任期而言）</li></ul><p>当出现了 leader 与 follower 不一致的情况，leader 强制 follower复制自己的 log</p><p>leader 会维护一个 nextIndex[] 数组，记录了 leader 可以发送每一个follower 的 log index，初始化为 leader 最后一个 log index 加 1，前面也提到，leader 选举成功之后会立即给所有 follower 发送 AppendEntriesRPC（不包含任何 log entry， 也充当心跳消息）, 那么流程总结为：</p><ul><li>s1 leader 初始化 nextIndex[x] 为 leader 最后一个 log index + 1</li><li>s2 AppendEntries 里 prevLogTerm prevLogIndex 来自 logs[nextIndex[x]- 1]</li><li>s3 如果 follower 判断 prevLogIndex 位置的 log term 不等于prevLogTerm，那么返回 False，否则返回 True</li><li>s4 leader 收到 follower 的回复，如果返回值是 False，则 nextIndex[x]-= 1, 跳转到 s2. 否则</li><li>s5 同步 nextIndex[x] 后的所有 log entries</li></ul><h4 id="leader-completeness-vs-elcetion-restriction">leader completenessvs elcetion restriction</h4><p>leader 完整性：如果一个 log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高 term 的leader 的日志里面。这个跟 leader election、log replication 都有关。</p><ul><li>一个日志被复制到 majority 节点才算 committed</li><li>一个节点得到 majority 的投票才能成为 leader，而节点 A 给节点 B投票的其中一个前提是，B 的日志不能比 A的日志旧。下面的引文指处了如何判断日志的新旧</li></ul><blockquote><p>voter denies its vote if its own log is more up-to-date than that ofthe candidate.</p></blockquote><blockquote><p>If the logs have last entries with different terms, then the log withthe later term is more up-to-date. If the logs end with the same term,then whichever log is longer is more up-to-date.</p></blockquote><p>上面两点都提到了 majority：commit majority and vote majority，根据Quorum，这两个 majority 一定是有重合的，因此被选举出的 leader一定包含了最新的 committed 的日志。</p><p>raft 与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证 leade 包含最新的已提交的日志，因此 leader 不会从 followercatchup 日志，这也大大简化了系统的复杂度。</p><h3 id="corner-case">corner case</h3><h4 id="stale-leader">stale leader</h4><p>raft 保证 Election safety，即一个任期内最多只有一个leader，但在网络分割（networkpartition）的情况下，<strong>可能会出现两个 leader，但两个 leader所处的任期是不同的</strong>。</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245777.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>系统有 5 个节点 ABCDE 组成，在 term1，Node B 是 leader，但 Node A、B和 Node C、D、E 之间出现了网络分割，因此 Node C、D、E 无法收到来自leader（Node B）的消息，在 election time 之后，Node C、D、E会分期选举，由于满足 majority 条件，Node E 成为了 term 2 的leader。因此，在系统中貌似出现了两个 leader：term 1 的 Node B， term 2的 Node E, Node B 的 term 更旧，但由于无法与 Majority 节点通信，NodeB仍然会认为自己是 leader。</p><p>首先，如果客户端将请求发送到了 NodeB，NodeB 无法将 log entry 复制到majority 节点，因此不会告诉客户端写入成功，这就不会有问题。</p><p>对于读请求，stale leader 可能返回 stale data，比如在 read-after-write的一致性要求下，客户端写入到了 term2 任期的 leader NodeE，但读请求发送到了 Node B。如果要保证不返回 stale data，leader 需要check自己是否过时了，办法就是与大多数节点通信一次，这个可能会出现效率问题。另一种方式是使用lease，但这就会依赖物理时钟。</p><p>从 raft 的论文中可以看到，leader 转换成 follower 的条件是收到来自更高term 的消息，如果网络分割一直持续，那么 stale leader 就会一直存在。而在raft 的一些实现或者 raft-like 协议中，leader 如果收不到 majority节点的消息，那么可以自己 step down，自行转换到 follower 状态。</p><h4 id="state-machine-safety">State Machine Safety</h4><p>前面在介绍 safety 的时候有一条属性没有详细介绍，那就是 State MachineSafety：</p><blockquote><p>State Machine Safety: if a server has applied a log entry at a givenindex to its state machine, no other server will ever apply a differentlog entry for the same index.</p></blockquote><p>如果节点将某一位置的 log entry应用到了状态机，那么其他节点在同一位置不能应用不同的日志。简单点来说，所有节点在同一位置（indexin logentries）应该应用同样的日志。但是似乎有某些情况会违背这个原则：</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245596.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上图是一个较为复杂的情况。在时刻 (a), s1 是 leader，在 term2提交的日志只赋值到了 s1 s2 两个节点就 crash 了。在时刻（b), s5 成为了term 3 的 leader，日志只赋值到了 s5，然后 crash。然后在(c) 时刻，s1又成为了 term 4 的 leader，开始赋值日志，于是把 term2 的日志复制到了s3，此刻，可以看出 term2 对应的日志已经被复制到了 majority，因此是committed，可以被状态机应用。不幸的是，接下来（d）时刻，s1 又 crash了，s5 重新当选，然后将 term3的日志复制到所有节点，这就出现了一种奇怪的现象：被复制到大多数节点（或者说可能已经应用）的日志被回滚。</p><p>究其根本，是因为 term4 时的 leader s1 在（C）时刻提交了之前 term2任期的日志。为了杜绝这种情况的发生：</p><blockquote><p><strong>Raft never commits log entries from previous terms bycounting replicas</strong>. Only log entries from the leader’s currentterm are committed by counting replicas; once an entry from the currentterm has been committed in this way, then all prior entries arecommitted indirectly because of the Log Matching Property.</p></blockquote><p>也就是说，某个 leader 选举成功之后，不会直接提交前任 leader时期的日志，而是通过提交当前任期的日志的时候 “顺手”把之前的日志也提交了，具体怎么实现了，在 log matching部分有详细介绍。那么问题来了，如果 leader被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log</p><blockquote><p>Raft handles this by having each leader commit a blank no-op entryinto the log at the start of its term.</p></blockquote><p>因此，在上图中，不会出现（C）时刻的情况，即 term4 任期的 leader s1不会复制 term2 的日志到 s3。而是如同 (e) 描述的情况，通过复制 - 提交term4 的日志顺便提交 term2 的日志。如果 term4 的日志提交成功，那么 term2的日志也一定提交成功，此时即使 s1crash，s5 也不会重新当选。</p><h4 id="leader-crash">leader crash</h4><p>follower 的 crash 处理方式相对简单，leader 只要不停的给 follower发消息即可。当 leader crash 的时候，事情就会变得复杂。在<ahref="http://www.cnblogs.com/mindwind/p/5231986.html">这篇文章 (opensnew window)</a>中，作者就给出了一个更新请求的流程图。</p><figure><imgsrc="../img/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202206222245472.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>leader 在任意时刻 crash 的情况，有助于理解 raft 算法的容错性。</p><h2 id="总结">总结</h2><p>raft 将共识问题分解成两个相对独立的问题，leader election，logreplication。流程是先选举出 leader，然后 leader 负责复制、提交 log（log中包含 command）</p><p>为了在任何异常情况下系统不出错，即满足 safety 属性，对 leaderelection，log replication 两个子问题有诸多约束</p><p>leader election 约束：</p><ul><li>同一任期内最多只能投一票，先来先得</li><li>选举人必须比自己知道的更多（比较 term，log index）</li></ul><p>log replication 约束：</p><ul><li>一个 log 被复制到大多数节点，就是 committed，保证不会回滚</li><li>leader 一定包含最新的 committed log，因此 leader只会追加日志，不会删除覆盖日志</li><li>不同节点，某个位置上日志相同，那么这个位置之前的所有日志一定是相同的</li><li>Raft never commits log entries from previous terms by countingreplicas.</li></ul><p>个人觉得，如果只是相对 raft 协议有一个简单了解，看这个<ahref="http://thesecretlivesofdata.com/raft/">动画演示 (opens newwindow)</a>就足够了，如果想深入了解，还是要看论文，论文中 Figure 2 对raft 算法进行了概括。最后，还是找一个实现了 raft算法的系统来看看更好。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2023/12/25/Redis/"/>
    <url>/2023/12/25/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="redis面试知识点">Redis面试知识点</h1><h2 id="听说过redis吗它是什么">听说过Redis吗？它是什么？</h2><p>Redis是一个<strong>数据库</strong>，不过与传统数据库不同的是Redis的数据库是存在<strong>内存</strong>中，所以<strong>读写速度非常快</strong>，因此Redis被广泛应用于<strong>缓存</strong>方向。</p><p>除此之外，Redis也经常用来做分布式锁，Redis提供了多种数据类型来支持不同的业务场景。除此之外，Redis支持事务持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h2 id="redis的五种数据结构整理">Redis的五种数据结构整理</h2><h3id="简单动态字符串simple-dynamic-stringsds"><strong>简单动态字符串(SimpleDynamic String，SDS)</strong></h3><p>Redis没有直接使用C语言传统的字符串，而是自己构建了一种名为简单动态字符串（Simpledynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</p><p>其实SDS等同于C语言中的char*，但它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结束，因此它必然有个长度字段。</p><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sdshdr</span> &#123;<br>    <span class="hljs-comment">// 记录buf数组中已使用字节的数量</span><br>    <span class="hljs-comment">// 等于sds所保存字符串的长度</span><br>    <span class="hljs-type">int</span> len;<br>    <br>    <span class="hljs-comment">// 记录buf数组中未使用字节的数量</span><br>    <span class="hljs-type">int</span> free;<br>    <br>    <span class="hljs-comment">// 字节数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>获取字符串长度的复杂度为O(1)。</li><li>杜绝缓冲区溢出。</li><li>减少修改字符串长度时所需要的内存重分配次数。</li><li>二进制安全。</li><li>兼容部分C字符串函数。</li></ul><p>它具有很常规的 set/get 操作，value可以是String也可以是数字，一般做一些复杂的计数功能的缓存。</p><h3 id="链表">链表</h3><p>当有一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的额字符串时，Redis就会使用链表作为列表建的底层实现。</p><p><strong>节点底层结构</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listNode</span> &#123;<br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listNode</span> *prev;<br>    <span class="hljs-comment">// 后置节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listNode</span> *next;<br>    <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p><strong>list底层结构</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list</span> &#123;<br>    <span class="hljs-comment">// 表头节点</span><br>    listNode *head;<br>    <span class="hljs-comment">// 表尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">// 链表所包含的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>    <span class="hljs-comment">// 节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">// 节点值是放过函数</span><br>    <span class="hljs-built_in">void</span> (*free)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">// 节点值对比函数</span><br>    <span class="hljs-type">int</span>（*match）(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>&#125; list;<br></code></pre></td></tr></table></figure><p><strong>特性</strong></p><ul><li>链表被广泛用于实现Redis的各种功能，比如列表建、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul><h3 id="字典"><strong>字典</strong></h3><p>字典的底层是哈希表，类似 C++中的 map ，也就是键值对。</p><h3 id="哈希表"><strong>哈希表</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span> &#123;<br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">// 总是等于size-1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemark;<br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dichht;<br></code></pre></td></tr></table></figure><p><strong>哈希算法</strong></p><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash算法。这种算法的优点在于即使输入的键是规律的，算法仍能给出一个个很好的随机分布性，并且算法的计算速度非常快。</p><p><strong>哈希冲突的解决方式</strong></p><p>Redis的哈希表使用<strong>链地址法</strong>来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p><strong>特性</strong></p><ol type="1"><li>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</li><li>Redis中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li><li>Redis使用MurmurHash2算法来计算键的哈希值。</li><li>哈希表使用链地址法来解决键冲突。</li></ol><h3 id="跳跃表"><strong>跳跃表</strong></h3><p>先看这样一张图:</p><figure><img src="/img/Redis/202205220024713.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如上图，我们要查找一个元素，就需要从头节点开始遍历，直到找到对应的节点或者是第一个大于要查找的元素的节点（没找到）。时间复杂度为O(N)。</p><p>这个查找效率是比较低的，但如果我们把列表的某些节点拔高一层，如下图，例如把每两个节点中有一个节点变成两层。那么第二层的节点只有第一层的一半，查找效率也就会提高。</p><figure><img src="/img/Redis/202205220024190.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>查找的步骤是从头节点的顶层开始，查到第一个大于指定元素的节点时，退回上一节点，在下一层继续查找。</p><p>比如我们要查找16：</p><ol type="1"><li>从头节点的最顶层开始，先到节点7。</li><li>7的下一个节点是39，大于16，因此我们退回到7。</li><li>从7开始，在下一层继续查找，就可以找到16。</li></ol><p>这个例子中遍历的节点不比一维列表少，但是当节点更多，查找的数字更大时，这种做法的优势就体现出来了。还是上面的例子，如果我们要<strong>查找的是39</strong>，那么只需要访问两个节点（7、39）就可以找到了。这比一维列表要减少一半的数量。</p><p>为了避免插入操作的时间复杂度是O(N)，skiplist每层的数量不会严格按照2:1的比例，而是对每个要插入的元素随机一个层数。</p><p>随机层数的计算过程如下：</p><ol type="1"><li>每个节点都有第一层</li><li>那么它有第二层的概率是p，有第三层的概率是p*p</li><li>不能超过最大层数</li></ol><p><strong>zskiplistNode</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> &#123;<br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward;<br>    <span class="hljs-comment">// 分值 权重</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> &#123;<br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward;<br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br>    &#125; leval[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p>一般来说，层的数量越多，访问其他节点的速度越快。</p><p><strong>zskipList</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> leval;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p>特性</p><ul><li>跳跃表是有序集合的底层实现之一</li><li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点(redis5.0之后用listpack实现跳表)</li><li>每个跳跃表节点的层高都是1至32之间的随机数</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li><li>跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现。</li></ul><h3 id="ziplist">ziplist</h3><blockquote><p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p></blockquote><p><strong>特性</strong></p><p>看他的名字就能看出来，是为了节省内存造的列表结构</p><h2id="redis常见数据结构以及使用场景分别是什么">Redis常见数据结构以及使用场景分别是什么？</h2><h3 id="string">String</h3><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。常规key-value缓存</p><p><strong>应用</strong>； 常规计数：微博数，粉丝数等。</p><h3 id="list">List</h3><p>list 就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p><p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于list 实现分页查询，这个很棒的一个功能，基于 Redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h3 id="set"><strong>Set</strong></h3><p>set 对外提供的功能与list类似,是一个列表的功能，特殊之处在于 set是可以自动排重的。</p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：<code>sinterstore key1 key2 key3</code>将交集存在key1内。</p><h3 id="sorted-set">Sorted Set</h3><p>和set相比，sortedset增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p>举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p><h3id="有mysql不就够用了吗为什么要用redis这种新的数据库">有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</h3><p>主要是因为 Redis具备<strong>高性能</strong>和<strong>高并发</strong>两种特性。</p><ul><li><strong>高性能</strong>：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</li><li><strong>高并发</strong>：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li></ul><h2id="c中的map也是一种缓存型数据结构为什么不用map而选择redis做缓存">C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</h2><p>严格意义上来说缓存分为<strong>本地缓存</strong>和<strong>分布式缓存</strong>。</p><p>那以 C++ 语言为例，我们可以使用 STL 下自带的容器 map来实现缓存，但只能实现本地缓存，它最主要的特点是<strong>轻量</strong>以及<strong>快速</strong>，但是其生命周期随着程序的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存<strong>不具有一致性</strong>。</p><p>使用 Redis 或 Memcached之类的称为分布式缓存，在多实例的情况下，各实例共享一份缓存数据，缓存具有一致性。这是Redis或者Memcached的优点所在，但它也有缺点，那就是需要保持Redis 或 Memcached服务的高可用，整个程序架构上较为复杂。</p><h2 id="使用redis的好处有哪些">使用Redis的好处有哪些？</h2><ol type="1"><li><strong>访问速度快</strong>，因为数据存在内存中，类似于Java中的HashMap或者C++中的哈希表（如unordered_map/unordered_set），这两者的优势就是查找和操作的时间复杂度都是O(1)</li><li><strong>数据类型丰富</strong>，支持String，list，set，sortedset，hash这五种数据结构</li><li><strong>支持事务</strong>，Redis中的操作都是<strong>原子性</strong></li><li><strong>特性丰富</strong>：Redis可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h3id="memcached与redis的区别都有哪些">Memcached与Redis的区别都有哪些？</h3><ol type="1"><li>数据类型支持：Memcached仅支持简单的key-value结构的数据记录，而Redis支持更丰富的数据类型，包括字符串、哈希表、链表、集合和有序集合。</li><li>IO模型：Memcached是多线程，非阻塞IO复用的网络模型，而Redis使用单线程的IO复用模型。由于Redis还提供一些非KV存储之外的排序，聚合功能，在执行这些功能时，复杂的CPU计算，会阻塞整个IO调度。</li><li>底层模型不同：<ul><li>它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。</li><li>Redis直接自己构建了VM(virtual memory)机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ul></li><li>内存管理机制：Memcached使用SlabAllocation机制管理内存，而Redis采用的是包装的malloc/free。在<strong>Redis中，并不是所有的数据都一直存储在内存中的。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘</strong>，<strong>也就是说可以持久化数据</strong>。</li><li>复制和高可用性：Redis支持主从复制，可以将数据从一个主节点同步到多个从节点，提高读取性能和可用性。而Memcached没有内置的复制机制，只能通过客户端实现数据的复制。</li><li>扩展性：Redis支持分片（Sharding）和集群（Cluster）两种方式来扩展性能和容量。而Memcached只支持简单的多节点部署，需要通过客户端来实现数据的分片。</li><li>value值大小不同：Redis 最大可以达到 512MB；Memcached 只有 1MB</li></ol><div class="admonition info"><p class="admonition-title">Memcached</p><p>Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。</p></div><h2id="redis比memcached的优势在哪里">Redis比Memcached的优势在哪里？</h2><ol type="1"><li>Memcached所有的值均是简单字符串，Redis作为其替代者，支持<strong>更为丰富的数据类型</strong></li><li>Redis 的<strong>速度</strong>比 Memcached 快很多</li><li>Redis可以做到<strong>持久化数据</strong></li></ol><h2id="缓存中常说的热点数据和冷数据是什么">缓存中常说的热点数据和冷数据是什么？</h2><p>热数据就是访问次数较多的数据，冷数据就是访问很少或者从不访问的数据。</p><div class="admonition note"><p class="admonition-title">note</p><p>需要注意的是只有热点数据，缓存才有价值对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。<strong>数据更新前至少读取两次</strong>，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p></div><h2 id="redis-为什么是单线程的而不采用多线程方案">Redis为什么是单线程的而不采用多线程方案？</h2><p>从redis6.0开始支持多线程，但是多线程默认是禁用的，这主要是基于一种客观原因来考虑的。因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）</p><p>redis6.0以后支持多线程是因为随着硬件性能的提升，Redis的性能瓶颈可能出现在网络IO的读写上。这时候就可以使用多线程提高网络请求处理的并行度从而提高redis的性能。</p><h2 id="单线程的redis为什么这么快">单线程的Redis为什么这么快？</h2><p>主要是有三个原因：</p><ol type="1"><li>Redis的全部操作都是纯内存的操作；</li><li>Redis采用单线程，有效避免了频繁的上下文切换；</li><li>采用了非阻塞I/O多路复用机制。</li></ol><h2id="了解redis的线程模型吗可以大致说说吗">了解Redis的线程模型吗？可以大致说说吗？</h2><p>如果你打开看过 Redis 的源码就会发现Redis 内部使用文件事件处理器 fileevent handler，这个文件事件处理器是单线程的，所以 Redis才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据socket 上的事件来选择对应的事件处理器进行处理。</p><figure><img src="/img/Redis/202205220024968.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p>多个 socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO多路复用程序会监听多个 socket，会将 socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>一句话总结就是：“<strong>I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</strong>”</p><h2id="redis设置过期时间的两种方案是什么">Redis设置过期时间的两种方案是什么？</h2><p>我们 set key 的时候，都可以给一个 expiretime，就是过期时间，通过过期时间我们可以指定这个 key可以存活的时间，主要可采用<strong>定期删除和惰性删除</strong>两种方案。</p><ul><li><strong>定期删除</strong>：Redis默认是每隔 100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期这里是随机抽取的。为什么要随机呢？你想一想假如Redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key到了时间并没有被删除掉。所以就有了惰性删除。它是指某个键值过期后,此键值不会马上被删除,而是等到下次被使用的时候,才会被检查到过期,此时才能得到删除,惰性删除的<strong>缺点很明显是浪费内存</strong>。除非你的系统去查一下那个key，才会被Redis给删除掉。这就是所谓的惰性删除！</li></ul><h2id="定期和惰性一定能保证删除数据吗如果不能redis会有什么应对措施">定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？</h2><p>并不能保证一定删除，Redsi有一个<strong>Redis内存淘汰机制</strong>来确保数据一定会被删除。(定期删除和惰性删除见上一条)</p><p>采用定期删除+惰性删除的方式，如果定期删除没有删除掉，同时我们也没有即时去请求key，也就是说惰性删除也没生效，那么此时内存占用就会越来越高，这时候就要用到<strong>内存淘汰机制</strong>。</p><p>在Redis.conf中有一行配置:maxmemory-policyvolatile-lru，该配置就是配内存淘汰策略的，主要有以下六种方案：</p><ol type="1"><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-enviction</strong>（驱逐）：禁止驱逐数据，新写入操作会报错ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和noeviction(不删除) 基本上一致。</li></ol><h2id="redis对于大量的请求是怎样处理的">Redis对于大量的请求，是怎样处理的？</h2><p>Redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；2、Redis是通过IO多路复用（select，epoll，kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求。</p><h2id="缓存雪崩缓存穿透缓存预热缓存击穿服务降级">缓存雪崩、缓存穿透、缓存预热、缓存击穿、服务降级</h2><h3 id="缓存雪崩"><strong>缓存雪崩</strong></h3><p>缓存雪崩指的是<strong>缓存同一时间大面积的失效</strong>，所以，后面的请求都会落到数据库上，造成<strong>数据库短时间内承受大量请求而崩掉</strong>。</p><p><strong>解决办法</strong></p><ul><li><strong>设置不同的过期时间</strong>：为了避免大量的缓存数据同时失效，可以为不同的key设置不同的过期时间，使得缓存失效的时间点尽量均匀，一种做法是再设置的过期时间上加一个随机数，如加1~60s的随机数，这样即使再高并发的情况下。多个请求同时设置过期时间，由于有随机数的存在，也不会出现太多相同的过期key</li><li><strong>使用互斥锁</strong>：当缓存失效的时候，第一个访问数据的线程可以使用互斥锁或者分布式锁去加载数据。这样其他的线程就会等待，直到数据被加载到缓存。这样可以防止所有的线程都去查询数据库，给数据库带来巨大的压力。</li><li><strong>提高缓存的高可用性</strong>：通过使用一些高可用性的缓存解决方案，比如RedisCluster，可以在某个节点失效的时候，自动切换到其他的节点，提高系统的可用性。</li><li><strong>熔断机制</strong>：参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回“系统繁忙”，快速释放资源。如果目标服务情况好转则恢复调用。</li><li><strong>隔离机制</strong>：对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源，也不影响其他资源</li><li><strong>限流模式</strong>：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应</li><li><strong>预先更新缓存</strong>：在缓存失效之前，提前更新缓存。</li></ul><h3 id="缓存穿透"><strong>缓存穿透</strong></h3><p>一般是黑客故意去请求缓存中不存在的数据（比如数据库中不存在的数据，所以一定不会出现在缓存中），导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方法：</p><ol type="1"><li><p><strong>布隆过滤器</strong>：这是最常见的一种解决方法了，它是将所有可能存在的数据哈希到一个足够大的<strong>bitmap</strong>中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压 力。</p></li><li><p><strong>缓存空对象</strong>：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；如果一个<strong>查询返回的数据为空</strong>（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的<strong>过期时间会很短</strong>，最长不超过五分钟。</p><p>但是这种方法会存在两个问题：</p><ol type="1"><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><p>我们可以从适用场景和维护成本两方面对这两汇总方法进行一个<strong>简单比较</strong>：</p><ol type="1"><li><strong>适用场景</strong>：缓存空对象适用于<strong>数据命中不高</strong>且<strong>数据频繁变化且实时性较高</strong>的情况，而布隆过滤器适用<strong>数据命中不高</strong>且<strong>数据相对固定即实时性较低</strong>的情况</li><li><strong>维护成本</strong>：缓存空对象的方法适合<strong>代码维护简单</strong>、<strong>需要较多的缓存空间</strong>、<strong>可以容忍数据不一致</strong>的情况，布隆过滤器适合<strong>代码维护较复杂</strong>以及<strong>缓存空间少</strong>的情况</li></ol></li><li><p><strong>缓存预热</strong>：系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户会直接查询事先被预热的缓存数据！</p></li></ol><h3 id="缓存击穿"><strong>缓存击穿</strong></h3><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>解决方案：</p><ol type="1"><li><strong>加锁</strong>：在访问数据库时加锁，防止多个相同productId的请求同时访问数据库。</li><li><strong>自动续期</strong>：出现缓存击穿问题是由于key过期了导致的。那么，在热点key快要过期之前，就自动给它续期</li><li><strong>缓存不失效</strong>：很多热门key可以设置永久有效，比如双十一秒杀活动开始之前设置永久有效，等双十一过去之后再手动删除这些无用的缓存即可。</li></ol><h3 id="服务降级"><strong>服务降级</strong></h3><p>服务降级一般是指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而<strong>释放服务器资源的资源以保证核心业务的正常高效运行。</strong></p><h3 id="服务降级和熔断的区别">服务降级和熔断的区别</h3><p>服务降级和服务熔断都是在面对系统异常或压力过大的情况下，采取的一种保护措施，以保证系统的稳定性和可用性。然而，它们的触发原因、管理目标层次和实现方式都有所不同。</p><p>服务降级是从整体系统负荷出发，对某些负荷较高的情况，为了预防某些功能（业务场景）出现负荷过载或响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。</p><p>服务熔断则是应对系统服务雪崩的一种保险措施，给出的<strong>一种特殊降级措施</strong>。当某个服务（下游服务）出现故障引起，为了防止整个系统出现雪崩，暂时停止对该服务的调用。服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。</p><p><strong>熔断时可能会调用降级机制，而降级时通常不会调用熔断机制。</strong>因为熔断是从全局出发，为了保证系统稳定性而停用服务，而降级是退而求其次，提供一种保底的解决方案，所以它们的归属关系是不同（熔断&gt; 降级）。</p><h2id="假如mysql有1000万数据采用redis作为中间缓存取其中的10万如何保证redis中的数据都是热点数据">假如MySQL有1000万数据，采用Redis作为中间缓存，取其中的10万，如何保证Redis中的数据都是热点数据？</h2><p>可以使用Redis的<strong>数据淘汰策略</strong>，Redis内存数据集大小上升到一定大小的时候，就会施行这种策略。具体说来，主要有6种内存淘汰策略：</p><ul><li>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><h2 id="redis持久化机制可以说一说吗">Redis持久化机制可以说一说吗？</h2><p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。</p><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p><strong>实现</strong>：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p><p>持久化机制有两种：<strong>RDB持久化</strong>和<strong>AOF持久化</strong></p><h3id="快照snapshotting持久化rdb持久化"><strong>快照（snapshotting）持久化（RDB持久化）</strong></h3><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是Redis默认采用的持久化方式，在Redis.conf配置文件中默认有此下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs conf">save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br><br>save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br><br>save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br></code></pre></td></tr></table></figure><h3 id="aofappend-only-file持久化"><strong>AOF（append-onlyfile）持久化</strong></h3><p>与快照持久化相比，AOF<strong>持久化的实时性更好</strong>。默认情况下Redis没有开启AOF（append onlyﬁle）方式的持久化，可以通过appendonly参数开启：<code>appendonly yes</code></p><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度<br>appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘<br>appendfsync no  #让操作系统决定何时进行同步<br></code></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p>Redis 4.0 开始支持 RDB 和 AOF的<strong>混合持久化</strong>（默认关闭，可以通过配置项aof-use-rdb-preamble 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点,快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB部分是压缩格式不再是 AOF 格式，可读性较差。</p><h2 id="aof">AOF</h2><p>AOF重写是Redis的一种机制，用于压缩和优化AOF文件的内容，以提高Redis的性能和稳定性。</p><p>AOF重写的原理是根据Redis进程内的数据生成一个新的AOF文件，<strong>只包含当前有效和存在的数据的写入命令</strong>。这个过程是通过创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态是相同的，但是新的AOF文件<strong>不会包含任何浪费空间的冗余命令</strong>。</p><p>该功能是通过拷贝数据库中的<strong>键值对</strong>来实现的，程序无须对现有AOF文件进行任伺读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF<strong>重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。<strong>当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致</strong>。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p><h2id="是否使用过redis集群集群的原理是什么">是否使用过Redis集群？集群的原理是什么？</h2><p>RedisSentinel（哨兵）着眼于<strong>高可用</strong>，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从服务器中选举出新的主服务器。</p><p>RedisCluster（集群）着眼于<strong>扩展性</strong>，在单个Redis内存不足时，使用Cluster进行分片存储。</p><h2id="如何解决redis的并发竞争key问题">如何解决Redis的并发竞争Key问题</h2><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：<strong>分布式锁</strong>（zookeeper 和 Redis都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><h2id="如何保证缓存与数据库双写时的数据一致性五星高频">如何保证缓存与数据库双写时的数据一致性<spanclass="math inline">\(*****\)</span>(五星高频)</h2><ol type="1"><li>先写数据库，再写缓存：这种方案在<strong>低并发编程</strong>中有人在用。但在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。</li><li><strong>Cache-Aside</strong>：虽然不能100%避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。在<strong>读请求</strong>中，首先请求缓存，若缓存命中（cachehit），则直接返回缓存中的数据；若缓存未命中（cachemiss），则查询数据库并将查询结果更新至缓存，然后返回查询出的数据（demand-filledlook-aside）。在<strong>写请求</strong>中，先更新数据库，再删除缓存（write-invalidate）。</li><li><strong>延迟双删</strong>：<strong>先删除缓存，再写数据库，再次延迟删除缓存</strong>，这里延迟时间要稍微<strong>大于将数据库中旧数据写入缓存</strong>的耗时。</li></ol><h3 id="补偿机制">补偿机制</h3><p>在<strong>Cache-Aside</strong>和<strong>延迟双删</strong>中都可能会出现更新数据库成功，但删除缓存失败的场景，如果发生这种情况，那么便会导致缓存中的数据落后于数据库，产生数据的不一致的问题。针对可能出现的删除失败问题，目前业界主要有以下几种补偿机制。</p><h4 id="删除重试机制">删除重试机制</h4><p>由于同步重试删除在性能上会影响吞吐量，所以常通过引入消息队列，将删除失败的缓存对应的key放入消息队列中，在对应的消费者中获取删除失败的key，异步重试删除。这种方法在实现上相对简单，但由于删除失败后的逻辑需要基于业务代码的trigger来触发，对业务代码具有一定入侵性。</p><figure><img src="/img/Redis/v2-5f91dbeb4d37f876501a880984741d41_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4id="基于数据库日志mysql-binlog增量解析订阅和消费"><strong>基于数据库日志（MySQLbinlog）增量解析、订阅和消费</strong></h4><p>鉴于上述方案对业务代码具有一定入侵性，所以需要一种更加优雅的解决方案，让缓存删除失败的补偿机制运行在背后，尽量少的耦合于业务代码。一个简单的思路是通过后台任务使用更新时间戳或者版本作为对比获取数据库的增量数据更新至缓存中，这种方式在小规模数据的场景可以起到一定作用，但其扩展性、稳定性都有所欠缺。</p><p>一个相对成熟的方案是基于MySQL数据库增量日志进行解析和消费，这里较为流行的是阿里巴巴开源的作为MySQLbinlog增量获取和解析的组件canal（类似的开源组件还有Maxwell、Databus等）。canalsever模拟MySQL slave的交互协议，伪装为MySQL slave，向MySQLmaster发dump协议，MySQL master收到dump请求，开始推送binarylog给slave（即canal sever），canal sever解析binarylog对象（原始为byte流），可由canal client拉取进行消费，同时canalserver也默认支持将变更记录投递到MQ系统中，主动推送给其他系统进行消费。在ack机制的加持下，不管是推送还是拉取，都可以有效的保证数据按照预期被消费。当前版本的canal支持的MQ有kafka或者RocketMQ。另外，canal依赖zookeeper作为分布式协调组件来实现HA，canal的HA分为两个部分：</p><ul><li>为了减少对MySQL dump的请求压力，不同canalserver上的instance要求同一时间只能有一个处于运行状态，其他的instance处于standby状态；</li><li>为了保证有序性，对于一个instance在同一时间只能由一个canalclient进行get/ack等动作。</li></ul><figure><imgsrc="/img/Redis/v2-f1a35beef71e121126e7b0106702bee5_720w-17036799787423.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>那么，针对缓存的删除操作便可以在canalclient或consumer中编写相关业务代码来完成。这样，结合数据库日志增量解析消费的方案以及Cache-Aside模型，在读请求中未命中缓存时更新缓存（通常这里会涉及到复杂的业务逻辑），在写请求更新数据库后删除缓存，并基于日志增量解析来补偿数据库更新时可能的缓存删除失败问题，在绝大多数场景下，可以有效的保证缓存的最终一致性。</p><p>另外需要注意的是，还应该隔离事务与缓存，确保数据库入库后再进行缓存的删除操作。比如考虑到数据库的主从架构，主从同步及读从写主的场景下，可能会造成读取到从库的旧数据后便更新了缓存，导致缓存落后于数据库的问题，这就要求对缓存的删除应该确保在数据库操作完成之后。所以，基于binlog增量日志进行数据同步的方案，可以通过选择解析从节点的binlog，来避免主从同步下删除缓存过早的问题。</p><h3 id="数据传输服务dts"><strong>数据传输服务DTS</strong></h3><p>数据传输服务（Data TransmissionService，简称DTS）是云服务商提供的一种支持RDBMS（关系型数据库）、NoSQL、OLAP等多种数据源之间进行数据交互的数据流服务。DTS提供了包括数据迁移、数据订阅、数据同步等在内的多种数据传输能力，常用于不停服数据迁移、数据异地灾备、异地多活(单元化)、跨境数据同步、实时数据仓库、查询报表分流、缓存更新、异步消息通知等多种业务应用场景。</p><p>相对于上述基于canal等开源组件自建系统，DTS的优势体现在对多种数据源的支持、对多种数据传输方式的支持，避免了部署维护的人力成本。目前，各家云服务商的DTS服务已针对云数据库，云缓存等产品进行了适配，解决了Binlog日志回收，主备切换等场景下的订阅高可用问题。在大规模的缓存数据一致性场景下，优先推荐使用DTS服务。</p><h2id="数据为什么会出现不一致的情况">数据为什么会出现不一致的情况？</h2><p>这样的问题主要是在并发读写访问的时候，缓存和数据相互交叉执行。以<strong>先删缓存，再写数据库</strong>为例</p><h3 id="单库情况下"><strong>单库情况下</strong></h3><p>同一时刻发生了并发读写请求，<strong>例如为A(写) B(读)2个请求</strong></p><figure><img src="/img/Redis/202205220023694.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>A请求发送一个写操作到服务端，第一步会淘汰cache，然后因为各种原因卡主了，不在执行后面业务(例：大量的业务操作、调用其他服务处理消耗了1s）。</li><li>B请求发送一个读操作，读cache，因为cache淘汰，所以为空</li><li>B请求继续读DB，读出一个脏数据，并写入cache</li><li>A请求终于执行完全，在写入数据到DB</li></ol><p>总结：因最后才把写操作数据入DB，并没同步。cache里面一直保持脏数据</p><p>脏数据是指源系统中的数据不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑。</p><h3id="主从同步读写分离的情况下读从库而产生脏数据"><strong>主从同步，读写分离的情况下，读从库而产生脏数据</strong></h3><figure><img src="/img/Redis/202205220023284.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>A请求发送一个写操作到服务端，第一步会淘汰cache</li><li>A请求写主数据库，写了最新的数据。</li><li>B请求发送一个读操作，读cache，因为cache淘汰，所以为空</li><li>B请求继续读DB，读的是从库，此时主从同步还没同步成功。读出脏数据，然后脏数据入cache</li><li>最后数据库主从同步完成</li></ol><p>总结：这种情况下请求A和请求B操作时序没问题，是主从同步的时延问题(假设1s)，导致读请求读取从库读到脏数据导致的数据不一致</p><p><strong>根本原因:</strong></p><p>单库下，逻辑处理中消耗1s，可能读到旧数据入缓存</p><p>主从+读写分离，在1s的主从同步时延中，到从库的旧数据入缓存</p><h2 id="常见的数据优化方案你了解吗">常见的数据优化方案你了解吗？</h2><figure><img src="/img/Redis/202205220023822.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="延迟双删">延迟双删</h3><ol type="1"><li>先删除缓存</li><li>再写数据库</li><li>往消息总线esb发送一个删除消息，发送立即返回。写请求的处理时间几乎没有增加，这个方法删除了缓存两次。因此被称为“延迟双删“，而在消息总线下游，有一个异步淘汰删除的消费者，在拿到删除消息延迟一定时间后删除缓存，这样，即使在一秒内有脏数据入缓存，也能够被淘汰掉。注意这里的延迟时间要略大于数据库将旧数据写入缓存的时间.</li></ol><h3 id="异步淘汰缓存"><strong>异步淘汰缓存</strong></h3><p>上述的步骤，都是在业务线里面执行，新增一个线下的读取binlog异步淘汰缓存模块，读取binlog总的数据，然后进行异步淘汰。</p><figure><img src="/img/Redis/202205220023992.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里简单提供一个思路</p><p>1.思路：</p><p>MySQL binlog增量发布订阅消费+消息队列+增量数据更新到Redis</p><p>1）读请求走Redis：热数据基本都在Redis</p><p>2）写请求走MySQL: 增删改都操作MySQL</p><p>3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis</p><p>2.Redis更新</p><p>1）数据操作主要分为两块：</p><ul><li>一个是全量(将全部数据一次写入到Redis)</li><li>一个是增量（实时更新）</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新，就无需在从业务线去操作缓存内容。</p><h2 id="redis-的高并发和高可用是如何保证的">Redis的高并发和高可用是如何保证的？</h2><p>这样的问题主要是在并发读写访问的时候，缓存和数据相互交叉执行。</p><h3 id="redis的主从架构模式"><strong>Redis的主从架构模式</strong></h3><p>Redis的主从架构模式是实现高并发的主要依赖，一般很多项目只需要<strong>一主多从</strong>就可以实现其所需要的功能。通常使用单个master用来写入数据，单机几万QPS；多个slave一般是查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><p>一些项目需要在实现高并发的同时，尽可能多的容纳大量的数据，这时需要使用Redis集群，使用Redis 集群之后，可以提供每秒几十万的读写并发。</p><p>Redis高可用，如果是做主从架构部署，那么加上哨兵就可以实现，任何一个实例宕机，可以进行主备切换。</p><p>单机的 Redis，能够承载的 QPS大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的slave节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p><figure><img src="/img/Redis/202208092302036.png" alt="Redis-master-slave" /><figcaption aria-hidden="true">Redis-master-slave</figcaption></figure><p>Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt;水平扩容支撑读高并发</p><h3 id="redis-replication-的核心机制">Redis replication 的核心机制</h3><ul><li>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node可以提高读的吞吐量。</li></ul><p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> masternode 的持久化，不建议用 slave node 作为 master node的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master宕机重启的时候数据是空的，然后可能一经过复制， slave node的数据也丢了。</p><p>另外，master的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb去恢复master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的<strong>高可用机制</strong>，slavenode 可以自动接管 master node，但也可能 sentinel 还没检测到 masterfailure，master node 就自动重启了，还是可能导致上面所有的 slave node数据被清空。</p><h3 id="redis-主从复制的核心原理">Redis 主从复制的核心原理</h3><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次<code>full resynchronization</code> 全量复制。此时 master会启动一个后台线程，开始生成一份 <code>RDB</code>快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code>发送给 slave，slave会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slavenode 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后master node 仅会复制给 slave 部分缺少的数据。</p><figure><img src="/img/Redis/202208092302031.png"alt="Redis-master-slave-replication" /><figcaptionaria-hidden="true">Redis-master-slave-replication</figcaption></figure><h3 id="主从复制的断点续传">主从复制的断点续传</h3><p>从 Redis2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个replica offset 还有一个 master run id，offset 就是保存在 backlog中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次<code>resynchronization</code> 。</p><div class="admonition note"><p class="admonition-title">note</p><p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p></div><h3 id="无磁盘化复制">无磁盘化复制</h3><p>master 在内存中直接创建 <code>RDB</code> ，然后发送给slave，不会在自己本地落地磁盘了。只需要在配置文件中开启<code>repl-diskless-sync yes</code> 即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">repl-diskless-sync <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span><br>repl-diskless-sync-delay 5Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><h3 id="过期-key-处理">过期 key 处理</h3><p>slave 没有过期 key，只会等待 master 过期 key。如果 master 过期了一个key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给slave。</p><h3 id="复制的完整流程">复制的完整流程</h3><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 masternode 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了requirepass，那么 slave node 必须发送 masterauth的口令过去进行认证。master node<strong>第一次执行全量复制</strong>，将所有数据发给 slavenode。而在后续，master node 持续将写命令，异步复制给 slave node。</p><figure><img src="/img/Redis/202208092302833.png"alt="Redis-master-slave-replication-detail" /><figcaptionaria-hidden="true">Redis-master-slave-replication-detail</figcaption></figure><h3 id="全量复制">全量复制</h3><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过60 秒（repl-timeout），那么 slave node就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slavenode 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过256MB，那么停止复制，复制失败。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">client-output-buffer-limit slave 256MB 64MB 60Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb到自己的内存中，同时<strong>基于旧的数据版本</strong>对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写AOF。</li></ul><h3 id="增量复制">增量复制</h3><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slavenode，默认 backlog 就是 1MB。</li><li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog中获取数据的。</li></ul><h3 id="heartbeat">heartbeat</h3><p>主从节点互相都会发送 heartbeat 信息。</p><p>master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个heartbeat。</p><h3 id="异步复制">异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slavenode。</p><h2 id="redis-如何才能做到高可用">Redis 如何才能做到高可用？</h2><p>如果系统在 365 天内，有 99.99%的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。</p><p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave在提供相同数据下的相同的对外的查询服务。</p><p>但是，如果 master node死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。</p><p>Redis 的高可用架构，叫做 <code>failover</code><strong>故障转移</strong>，也可以叫做主备切换。</p><p>master node 在故障时，自动检测，并且将某个 slave node 自动切换为master node 的过程，叫做主备切换。这个过程，实现了 Redis的主从架构下的高可用。</p><h2 id="redis基于哨兵集群实现高可用">Redis基于哨兵集群实现高可用？</h2><h3 id="哨兵的定义">哨兵的定义</h3><p>sentinel，中文名是哨兵。哨兵是 Redis集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master地址。</li></ul><p>哨兵用于实现 Redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个 master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li></ul><h3 id="哨兵的核心知识">哨兵的核心知识</h3><ul><li>哨兵<strong>至少需要 3 个实例</strong>，来保证自己的健壮性。</li><li>哨兵 + Redis主从的部署架构，是<strong>不保证数据零丢失</strong>的，<strong>只能保证Redis 集群的高可用性</strong>。</li><li>对于哨兵 + Redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><p>哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2个哨兵实例，quorum = 1。</p><div class="admonition info"><p class="admonition-title">info</p><p>主从切换需要至少quorum数量的哨兵认为主机宕机，才会认为这个主机真正宕机了，然后需要选举出一个哨兵代表去执行主从切换。选举出这个哨兵的时候需要至少majority个哨兵的支持。</p></div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">+----+         +----+<br>| M1 |---------| R1 |<br>| S1 |         | S2 |<br>+----+         +----+<br></code></pre></td></tr></table></figure><p>配置 <code>quorum=1</code> ，如果 master 宕机， s1 和 s2 中只要有 1个哨兵认为 master 宕机了，就可以进行切换，同时 s1 和 s2会选举出一个哨兵来执行故障转移。但是同时这个时候，需要majority，也就是大多数哨兵都是运行的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">2 个哨兵，majority=2<br>3 个哨兵，majority=2<br>4 个哨兵，majority=2<br>5 个哨兵，majority=3<br></code></pre></td></tr></table></figure><p>如果此时仅仅是 M1 进程宕机了，哨兵 s1 正常运行，那么故障转移是 OK的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个R1，但是故障转移不会执行。</p><p>经典的 3 节点哨兵集群是这样的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">       +----+<br>       | M1 |<br>       | S1 |<br>       +----+<br>          |<br>+----+    |    +----+<br>| R2 |----+----| R3 |<br>| S2 |         | S3 |<br>+----+         +----+<br></code></pre></td></tr></table></figure><p>配置 <code>quorum=2</code> ，如果 M1所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移。</p><h2 id="redis-哨兵主备切换的数据丢失问题">Redis哨兵主备切换的数据丢失问题</h2><h3 id="导致数据丢失的两种情况">导致数据丢失的两种情况</h3><p>主备切换的过程，可能会导致数据丢失：</p><ol type="1"><li><p>异步复制导致的数据丢失</p><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到slave，master 就宕机了，此时这部分数据就丢失了。</p><figure><img src="/img/Redis/202208092301730.png"alt="async-replication-data-lose-case" /><figcaptionaria-hidden="true">async-replication-data-lose-case</figcaption></figure></li><li><p><strong>脑裂</strong>导致的数据丢失</p><p>脑裂指的是某个 master所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave机器不能连接，但是实际上 master还运行着。此时哨兵可能就会<strong>认为</strong> master宕机了，然后开启选举，将其他 slave 切换成了master。这个时候，集群里就会有两个 master。</p><p>此时虽然某个 slave 被切换成了 master，但是可能 client还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master再次恢复的时候，会被作为一个 slave 挂到新的 master上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><figure><img src="/img/Redis/202208092301262.png"alt="Redis-cluster-split-brain" /><figcaption aria-hidden="true">Redis-cluster-split-brain</figcaption></figure><p>### 数据丢失的解决方案</p><p>进行如下配置：</p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">min-slaves-to-write 1<br>min-slaves-max-lag 10<br></code></pre></td></tr></table></figure></p><p>min-slaves-to-write默认情况下是0，min-slaves-max-lag默认情况下是10。这两个参数表示至少有1个salve数据复制与同步的延迟不能超过10s，一旦所有的slave复制和同步的延迟达到了10s，那么此时master就不会接受任何写请求。</p><p>这样做的优点有：</p><ul><li>减少异步复制数据的丢失：有了 <code>min-slaves-max-lag</code>这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</li><li>减少脑裂的数据丢失：如果一个 master 出现了脑裂，跟其他 slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave发送数据，而且 slave 超过 10 秒没有给自己 ack消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10秒的数据。</li></ul></li></ol><h2 id="sdown-和-odown-转换机制">sdown 和 odown 转换机制</h2><p>S_DOWN:<strong>主观宕机</strong>，就一个哨兵如果自己觉得一个 master宕机了，那么就是主观宕机。</p><p>O_DOWN:客观宕机，如果 quorum 数量的哨兵都觉得一个 master宕机了，那么就是客观宕机。</p><p>S_DOWN达成的条件很简单，如果一个哨兵 ping 一个 master，超过了<code>is-master-down-after-milliseconds</code>指定的毫秒数之后，就主观认为 master宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个master 是 sdown 的，那么就认为是 odown 了。</p><h2 id="哨兵集群的自动发现机制">哨兵集群的自动发现机制</h2><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code>系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的<code>__sentinel__:hello</code> channel里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves对应的 <code>__sentinel__:hello</code>channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code>的监控配置，互相进行监控配置的同步。</p><h3 id="slave-配置的自动纠正">slave 配置的自动纠正</h3><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave连接到了一个错误的 master上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p><h3 id="slave-master-选举算法">slave-&gt;master 选举算法</h3><p>如果一个 master 被认为 O_DOWN了，而且 majority数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了<code>down-after-milliseconds</code> 的 10 倍，外加 master宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state<br></code></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个slave。</li></ul><h3 id="configuration-epoch">configuration epoch</h3><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch，作为新的 version 号。</p><h3 id="configuration-传播">configuration 传播</h3><p>哨兵完成切换之后，会在自己本地更新生成最新的 master配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code>消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的master 配置的。</p><h2id="redis集群模式的工作原理是什么">Redis集群模式的工作原理是什么？</h2><h3 id="基本通信原理">基本通信原理</h3><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的<code>storm</code>。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><figure><img src="/img/Redis/202208092301899.png"alt="zookeeper-centralized-storage" /><figcaptionaria-hidden="true">zookeeper-centralized-storage</figcaption></figure><p>Redis 维护集群元数据采用另一个方式， <code>gossip</code>协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><figure><img src="/img/Redis/202208092301027.png" alt="Redis-gossip" /><figcaption aria-hidden="true">Redis-gossip</figcaption></figure><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p>gossip<strong>好处</strong>在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；<strong>不好</strong>在于，元数据的更新有延时，可能导致集群中的一些操作会有一些<strong>滞后</strong>。</p><ul><li>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是 17001端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code>消息，同时其它几个节点接收到 <code>ping</code> 之后返回<code>pong</code> 。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot信息等等。</li></ul><h3 id="gossip-协议">gossip 协议</h3><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> ,<code>meet</code> , <code>fail</code> 等等。</p><ul><li>meet：某个节点发送 meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Redis-trib.rb add-node<br></code></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li>ping：每个节点都会频繁给其它节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping交换元数据。</li><li>pong：返回 ping 和meet，包含自己的状态和其它信息，也用于信息广播和更新。</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><h3 id="ping-消息深入">ping 消息深入</h3><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping，每次会选择 5个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了<code>cluster_node_timeout / 2</code> ，那么立即发送ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以<code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低ping 的频率。</p><p>每次 ping，会带上自己节点的信息，还有就是带上 1/10其它节点的信息，发送出去，进行交换。至少包含 <code>3</code>个其它节点的信息，最多包含 <code>总节点数减 2</code>个其它节点的信息。</p><h3 id="分布式寻址算法">分布式寻址算法</h3><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><h4 id="hash-算法">hash 算法</h4><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的master 节点上。一旦某一个 master节点宕机，所有请求过来，都会基于最新的剩余 master节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><h4 id="一致性-hash-算法">一致性 hash 算法</h4><p>一致性 hash 算法将整个 hash值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个master 节点（使用服务器的 ip 或主机名）进行hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性hash算法引入了<strong>虚拟节点机制</strong>，即对<strong>每一个master节点</strong>计算多个hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><figure><img src="/img/Redis/202208092301991.png"alt="consistent-hashing-algorithm" /><figcaption aria-hidden="true">consistent-hashing-algorithm</figcaption></figure><h4 id="redis-cluster-的-hash-slot-算法">Redis cluster 的 hash slot算法</h4><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个<code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code>取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master上去。移动 hash slot 的成本是非常低的。客户端的api，可以对指定的数据，让他们走同一个 hash slot，通过<code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hashslot，不是机器。</p><figure><img src="/img/Redis/202208092301481.png" alt="hash-slot" /><figcaption aria-hidden="true">hash-slot</figcaption></figure><h2 id="redis-cluster-的高可用与主备切换原理">Redis cluster的高可用与主备切换原理</h2><p>Redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p><h3 id="判断节点宕机">判断节点宕机</h3><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code>，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是<code>fail</code>，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown。</p><p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回<code>pong</code> ，那么就被认为 <code>pfail</code> 。</p><p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在<code>gossip ping</code> 消息中， <code>ping</code>给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code>了，那么就会变成 <code>fail</code> 。</p><h3 id="从节点过滤">从节点过滤</h3><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 masternode。</p><p>检查每个 slave node 与 master node 断开连接的时间，如果超过了<code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就<strong>没有资格</strong>切换成 <code>master</code> 。</p><h3 id="从节点选举">从节点选举</h3><p>每个从节点，都根据自己对 master 复制数据的offset，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave进行投票，如果大部分 master node <code>（N/2 + 1）</code>都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p><p>从节点执行主备切换，从节点切换为主节点。</p><h3 id="与哨兵比较">与哨兵比较</h3><p>整个流程跟哨兵相比，非常类似，所以说，Redis cluster功能强大，直接集成了 replication 和 sentinel 的功能。</p><h2id="redis-的并发竞争问题是什么如何解决这个问题了解-redis-事务的-cas-方案吗">Redis的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS方案吗？</h2><p>这个也是线上非常常见的一个问题，就是<strong>多客户端同时并发写</strong>一个key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个key，修改值之后再写回去，只要顺序错了，数据就错了。</p><p>而且 Redis 自己就有天然解决这个问题的 CAS 类的乐观锁方案。</p><p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper实现分布式锁。每个系统通过 zookeeper获取分布式锁，确保同一时间，只能有一个系统实例在操作某个key，别人都不允许读和写。</p><figure><img src="/img/Redis/202208092301751.png"alt="zookeeper-distributed-lock" /><figcaption aria-hidden="true">zookeeper-distributed-lock</figcaption></figure><p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入mysql 中的时候必须保存一个时间戳，从 mysql查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 value的时间戳是否比缓存里的 value的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p><h2 id="生产环境中的-redis-是怎么部署的">生产环境中的 Redis是怎么部署的？</h2><p>看看你了解不了解你们公司的 Redis生产集群的部署架构，如果你不了解，那么确实你就很失职了，你的 Redis是主从架构？集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上Redis 给几个 G 的内存？设置了哪些参数？压测后你们 Redis 集群承载多少QPS？</p><p>Redis cluster，10 台机器，5 台机器部署了 Redis 主实例，另外 5台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5个节点对外提供读写服务，每个节点的读写高峰 QPS 可能可以达到每秒 5 万，5台机器最多是 25 万读写请求每秒。</p><p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 Redis进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过10g 可能会有问题。</p><p>5 台机器对外提供读写，一共有 50g 内存。</p><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis从实例会自动变成主实例继续提供读写服务。</p><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是3500 左右的请求量。</p><p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p><h2 id="redis三个缓冲区">redis三个缓冲区</h2><h3 id="客户端缓冲区">客户端缓冲区</h3><p>客户端缓冲区又有两个，输入缓冲区和输出缓冲区，都是为了解决客户端和服务器端的请求发送和处理速度不匹配所设置的。</p><p>输入缓冲区会先暂存客户端发送过来的命令，Redis主线程从输入缓冲区中读取命令，进行处理。当 Redis主线程处理完数据后，会把结果写入到输出缓冲区，再从输出缓冲区返回给客户端。</p><p>输出缓冲区暂存的是 Redis主线程要返回给客户端的数据。这个数据，既有简单且大小固定的 OK响应（例如，执行 SET命令）或报错信息，也有大小不固定的、包含具体数据的执行结果（例如，执行HGET 命令）</p><figure><imgsrc="/img/Redis/modb_20210621_ded936aa-d26a-11eb-b77e-00163e068ecd.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="复制缓冲区"><strong>复制缓冲区</strong></h3><p>复制缓冲区是用于Redis主从节点之间复制时使用的。由于主从节点间的数据复制包括全量复制和增量复制两种。因此复制缓冲区也分为复制缓冲区和复制积压缓冲区两种。</p><h4 id="复制缓冲区-1">复制缓冲区</h4><p>在全量复制过程中，主节点在向从节点传输 RDB文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等RDB文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p><figure><imgsrc="/img/Redis/modb_20210621_df20dfdc-d26a-11eb-b77e-00163e068ecd.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="复制积压缓冲区">复制积压缓冲区</h4><p>增量复制时，主节点和从节点进行常规同步时，会把写命令也暂存在复制积压缓冲区中。如果从节点和主节点间发生了网络断连，等从节点再次连接后，可以从复制积压缓冲区中同步尚未复制的命令操作。</p><figure><imgsrc="/img/Redis/modb_20210621_df5ea5f6-d26a-11eb-b77e-00163e068ecd-17099709329317.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="aof缓冲区"><strong>AOF缓冲区</strong></h3><p>AOF缓冲区是Redis在AOF持久化的所设置的缓冲区，AOF缓冲区也有两种AOF缓冲区和AOF重写缓冲区。</p><h4 id="aof缓冲区-1">AOF缓冲区</h4><p>我们都知道，即使是固态硬盘，它的读写速度也是与内存的读写速度相差很多的。AOF缓冲区就主要是Redis用来解决主进程执行命令速度与磁盘写入速度不同步所设置的，通过AOF缓冲区可以有效地避免频繁对硬盘进行读写，进而提升性能。Redis在AOF持久化的时候，会先把命令写入到AOF缓冲区，然后通过回写策略来写入硬盘AOF文件。</p><figure><imgsrc="/img/Redis/modb_20210621_df965dca-d26a-11eb-b77e-00163e068ecd.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>AOF缓冲区的溢出可能与磁盘写入速度有关系，也可能与AOF回写策略有关系，当大量命令积压在AOF缓冲区，超过其设置阈值之后，就会导致缓冲区溢出，想要避免这个问题，我们可以通过调整回写策略，或者调整AOF缓冲区大小的方式来解决。</p><h4 id="aof重写缓冲区">AOF重写缓冲区</h4><p>AOF重写缓冲区是Redis在子进程进行AOF重写的时候，父进程接受了新的命令，此时会把命令写入AOF重写缓冲区，等到子进程重写完成后，把AOF重写缓冲区命令追加到新的AOF文件中。</p><figure><imgsrc="/img/Redis/modb_20210621_dfdcb036-d26a-11eb-b77e-00163e068ecd.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>AOF重写缓冲区的溢出与AOF重写期间主进程所处理的命令数有关系，当AOF重写期间Redis主进程处理了大量的命令，这些命令都会写入AOF重写缓冲区，当超过设定阈值之后，就会导致溢出。避免AOF重写缓冲区的溢出我们也可以通过调整AOF重写缓冲区的大小来解决。</p><h2 id="redis内存管理机制">redis内存管理机制</h2><h3 id="内存最大限制">内存最大限制</h3><p>Redis使用 maxmemory参数限制最大可用内存，默认值为0，表示无限制。限制内存的目的主要有：</p><ul><li>用于缓存场景，当超出内存上限 maxmemory 时使用 LRU等删除策略释放空间。</li><li>防止所用内存超过服务器物理内存。因为 Redis默认情况下是会尽可能多使用服务器的内存，可能会出现服务器内存不足，导致Redis 进程被杀死。</li></ul><p>maxmemory 限制的是Redis实际使用的内存量，也就是used_memory统计项对应的内存。由于内存碎片率的存在，实际消耗的内存可能会比maxmemory设置的更大，实际使用时要小心这部分内存溢出。</p><h3 id="内存回收策略">内存回收策略</h3><p>Redis回收内存大致有两个机制：<strong>一是删除到达过期时间的键值对象</strong>；<strong>二是当内存达到maxmemory时触发内存移除控制策略，强制删除选择出来的键值对象。</strong></p><h4 id="删除过期键对象">删除过期键对象</h4><p>当Redis保存大量的键，对每个键都进行精准的过期删除可能会导致消耗大量的CPU，会阻塞 Redis 的主线程，拖累 Redis 的性能，因此 Redis采用惰性删除和定时任务删除机制实现过期键的内存回收。</p><h5 id="惰性删除">惰性删除</h5><p>惰性删除是指当客户端操作带有超时属性的键时，会检查是否超过键的过期时间，然后会同步或者异步执行删除操作并返回键已经过期。这样可以节省CPU成本考虑，不需要单独维护过期时间链表来处理过期键的删除。</p><p>过期键的<strong>惰性删除策略</strong>由 db.c/expireifNeeded函数实现，所有对数据库的读写命令执行之前都会调用 expireifNeeded来检查命令执行的键是否过期。如果键过期，expireifNeeded会将过期键从键值表和过期表中删除，然后同步或者异步释放对应对象的空间。</p><p>expireIfNeeded先从过期表中获取键对应的过期时间，如果当前时间已经超过了过期时间(lua脚本执行则有特殊逻辑，详看代码注释)，则进入删除键流程。删除键流程主要进行了三件事：</p><ul><li>一是删除操作命令传播，通知 slave 实例并存储到 AOF 缓冲区中</li><li>二是记录键空间事件，</li><li>三是根据 lazyfree_lazy_expire是否开启进行异步删除或者异步删除操作。</li></ul><h5 id="定期删除">定期删除</h5><p>定期删除策略由 expire.c/activeExpireCycle函数实现。在redis事件驱动的循环中的eventLoop-&gt;beforesleep和</p><p>周期性操作 databasesCron 都会调用 activeExpireCycle来处理过期键。但是二者传入的 type 值不同，一个是ACTIVE_EXPIRE_CYCLE_SLOW另外一个是ACTIVE_EXPIRE_CYCLE_FAST。activeExpireCycle在规定的时间，分多次遍历各个数据库，从 expires字典中随机检查一部分过期键的过期时间，删除其中的过期键。</p><h3 id="内存溢出控制策略">内存溢出控制策略</h3><p>当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持6种策略：</p><ul><li>noeviction：默认策略，<strong>不会删除任何数据，拒绝所有写入操作并返回客户端错误信息</strong>（error）OOMcommand not allowed when used memory，此 时Redis只响应读操作。</li><li>volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</li><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li></ul><h3 id="redis怎么实现限流">redis怎么实现限流</h3><p>主流的限流算法为以下四种：</p><ol type="1"><li>计数器（固定窗口）</li><li>滑动窗口（分割计数器）</li><li>漏桶算法</li><li>令牌桶算法</li></ol><h4 id="计数器法">计数器法</h4><p>计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。</p><p>此算法在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性和线程安全即可轻松实现。</p><figure><imgsrc="/img/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这个算法通常用于QPS限流和统计总访问量，对于秒级以上的时间周期来说，会存在一个非常严重的问题，那就是临界问题，如下图：</p><figure><imgsrc="/img/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70-17117992229352.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端。</p><h4 id="滑动窗口算法">滑动窗口算法</h4><p>滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。</p><p>如下图，假设时间周期为1min，将1min再分为2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，超过100的访问则被限流掉了</p><figure><imgsrc="/img/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70-17117993515904.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p>此算法可以很好的解决固定窗口算法的临界问题。</p><h4 id="漏桶算法">漏桶算法</h4><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</p><figure><imgsrc="/img/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70-17117994148506.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="令牌桶算法">令牌桶算法</h4><p>令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p><figure><imgsrc="/img/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg0NjMyMA==,size_16,color_FFFFFF,t_70-17117994326788.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/12/23/MySQL/"/>
    <url>/2023/12/23/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql知识点">MySQL知识点</h1><h2 id="关系型和非关系型数据库">关系型和非关系型数据库？</h2><h3 id="概念">概念</h3><p><strong>关系型数据库</strong>：。关系数据库（或 SQL数据库）以包含行和列的表格格式存储数据。列包含数据属性，行包含数据值。您可以链接关系数据库中的表，以更深入地了解不同数据点之间的相互关系。主要代表有SQLServer，Oracle,Mysql,PostgreSQL。</p><p><strong>非关系型数据库</strong>：非关系数据库（或 NoSQL数据库）使用各种数据模型来访问和管理数据。这些数据库专门针对需要大数据量、低延迟和灵活数据模型的应用程序进行了优化，这是通过放宽其他数据库的某些数据一致性限制来实现的。主要代表MongoDB，Redis、CouchDB。</p><h3 id="数据存储">数据存储</h3><h4 id="关系型数据库">关系型数据库</h4><p>关系数据库将数据存储在包含列和行的表中。每列代表一个特定的数据属性，每行代表该数据的一个实例。您为每个表指定一个主键，即唯一标识表的标识符列。您可以使用主键在表之间建立关系。您可以使用它作为领个表中的外键，在两个表的行之间建立关联。</p><p>例如，假设一家零售商创建了一张包含所有产品的表。在此表中，您可以为产品名称、描述和价格设置列。另一张表包含有关客户、客户姓名以及客户所购商品的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Product_id（主键）  Product_name  Product_cost<br>P1   Product_A 100 USD<br>P2   Product_B 50 USD<br>P3   Product_C 80 USD<br><br>Customer_id Customer_name Item_purchased（外键）<br>C1Customer_A  P2<br>C2Customer_B  P1<br>C3Customer_C  P3<br></code></pre></td></tr></table></figure><h3 id="非关系型数据库">非关系型数据库</h3><p>由于管理和存储无架构数据的方式不同，因此存在几种不同的非关系数据库系统。无架构数据是指在不受关系数据库要求的限制的情况下存储的数据。</p><h4 id="键值数据库">键值数据库</h4><p>键值数据库将数据存储为<strong>键值对的集合</strong>。在一个键值对中，键用作唯一标识符。键和值都可以是从简单对象到复杂复合对象的任何内容。</p><figure><imgsrc="/img/MySQL/PartitionKey.8dd0530a7f6d66d101f31de30db515564f4cf28a.png"alt="键值数据库" /><figcaption aria-hidden="true">键值数据库</figcaption></figure><h4 id="文档数据库">文档数据库</h4><p>面向文档的数据库的文档模型格式与开发人员在其应用程序代码中使用的格式相同。它们将数据存储为JSON 对象，这些对象具有灵活、半结构化和分层的性质。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><br>  company_name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AnyCompany&quot;</span><span class="hljs-punctuation">,</span><br><br>  address<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>street<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1212 Main Street&quot;</span><span class="hljs-punctuation">,</span> city<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Anytown&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  phone_number<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1-800-555-0101&quot;</span><span class="hljs-punctuation">,</span><br><br>  industry<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;food processing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;appliances&quot;</span><span class="hljs-punctuation">]</span><br><br>  type<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;private&quot;</span><span class="hljs-punctuation">,</span><br><br>  number_of_employees<span class="hljs-punctuation">:</span> <span class="hljs-number">987</span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="图形数据库">图形数据库</h4><p>图形数据库专门用于存储和导航关系。它们使用节点来存储数据实体，并使用边缘来存储实体之间的关系。</p><p>边缘总是有起始节点、终止节点、类型和方向。例如，它可以描述父子关系、操作和所有权。</p><figure><imgsrc="/img/MySQL/foaf-graph.e5e42865e0ee97a2972f9014d28f525ef68a981b.png"alt="图形数据库" /><figcaption aria-hidden="true">图形数据库</figcaption></figure><h3 id="区别">区别</h3><h4 id="结构">结构</h4><p>关系数据库以表格形式存储数据，并遵循有关数据变体和表关系的严格规则。</p><p>非关系数据库则更加灵活，适用于需求不断变化的数据。</p><h4 id="存储">存储</h4><p>Sql通常以数据库表的形式存储，例如存储用户信息，SQL中增加外部关系的话，需要在原表中增加一个外键，来关联外部数据表。</p><p>NoSql采用key-value的形式存储</p><h4 id="事务"><strong>事务</strong></h4><p>关系数据库模型遵循严格的 <strong>ACID</strong>属性。这意味着一组后续操作将始终一起完成。如果单个操作失败，则整组操作都会失败。这样可以始终保证数据的准确性。</p><div class="admonition info"><p class="admonition-title">ACID属性</p><p>ACID属性指的是<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>和<strong>持久性</strong>是指数据库在数据处理中出现错误或中断的情况下保持数据完整性的能力。</p></div><p>非关系数据库提供了一种更灵活的模型，即<strong>基本可用</strong>、<strong>软状态</strong>和<strong>最终一致性</strong>（BASE）。非关系数据库可以保证可用性，但不能保证即时一致性。数据库状态可能会随着时间的推移而发生变化，并最终保持一致。一些非关系数据库可能会在性能或其他方面做出妥协，以实现ACID 合规性。</p><h4 id="数据表-vs-数据集"><strong>数据表 VS 数据集</strong></h4><p>关系型是表格型的，存储在数据表的行和列中。彼此关联，容易提取。而非关系型是大块存储在一起。</p><h4 id="预定义结构-vs-动态结构"><strong>预定义结构 VS动态结构</strong></h4><p>在sql中，必须定义好地段和表结构之后，才能够添加数据，例如定义表的主键、索引、外键等。表结构可以在定义之后更新，但是如果有比较大的结构变更，就会变的比较复杂。</p><p>在Nosql数据库中，数据可以在任何时候任何地方添加。不需要预先定义。</p><h2 id="为什么使用索引">为什么使用索引？</h2><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的<strong>唯一性</strong>。</li><li>可以大大<strong>加快数据的检索速度</strong>，这也是创建索引的最主要的原因。</li><li>帮助服务器<strong>避免排序和临时表</strong></li><li>将随机IO变为顺序IO。</li><li>可以<strong>加速表和表之间的连接</strong>，特别是在实现数据的参考完整性方面特别有意义。</li></ul><h2 id="建立索引的原则">建立索引的原则</h2><ul><li><strong>尽量在经常被用于查询的列上建立索引</strong>，包括WHERE子句、JOIN 条件和排序的列。</li><li><strong>为经常需要排序、分组和联合操作的字段建立索引</strong></li><li><strong>避免在小表建立索引</strong>：小表遍历全表可能就很快，甚至可能比索引要快。</li><li><strong>避免在频繁更新的列上建立索引：</strong>索引的维护需要额外的开销，频繁更新的列可能导致索引失效，影响性能。</li><li><strong>限制索引的数目</strong>：索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。</li></ul><h2id="innodb为什么要用自增id作为主键">Innodb为什么要用自增id作为主键？</h2><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果使用<strong>非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZETABLE（optimize table）来重建表并优化填充页面</strong>。</p><h2id="myisam和innodb实现b树索引方式的区别是什么">MyISAM和InnoDB实现B树索引方式的区别是什么？</h2><ul><li><p>MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“<strong>非聚簇索引</strong>”</p></li><li><p>InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“<strong>聚簇索引</strong>”或者“<strong>聚集索引</strong>”，而其余的索引都作为辅助索引，<strong>辅助索引的data域存储相应记录主键的值而不是地址</strong>，这也是和MyISAM不同的地方。</p><p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></li></ul><div class="admonition info"><p class="admonition-title">info</p><p>InnoDB和MyISAM是MySQL的两个存储引擎</p></div><h2id="你了解mysql的内部构造吗一般可以分为哪两个部分">你了解MySQL的内部构造吗？一般可以分为哪两个部分？</h2><p>可以分为服务层和存储引擎层两部分，其中：</p><p><strong>服务层包括连接器、查询缓存、分析器、优化器、执行器等</strong>，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p><strong>存储引擎层负责数据的存储和提取</strong>。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认的存储引擎。</p><figure><img src="/img/MySQL/202205220024265.png" alt="SQL执行的全部过程" /><figcaption aria-hidden="true">SQL执行的全部过程</figcaption></figure><h2id="说一下mysql是如何执行一条sql的具体步骤有哪些">说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</h2><figure><img src="/img/MySQL/202205220024265.png" alt="SQL执行的全部过程" /><figcaption aria-hidden="true">SQL执行的全部过程</figcaption></figure><p>Server层按顺序执行sql的步骤为：</p><ol type="1"><li>连接器（验证用户身份，给予权限）</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）</li><li>分析器（对SQL进行词法分析和语法分析操作）</li><li>优化器（主要对执行的sql优化选择最优的执行方案方法）</li><li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</li><li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li></ol><h2id="说一说dropdelete与truncate的共同点和区别">说一说Drop、Delete与Truncate的共同点和区别</h2><ul><li>Drop直接删掉表;</li><li>Truncate删除表中数据，再插入时自增长id又从1开始 ;</li><li>Delete删除表中数据，可以加where字句。</li></ul><h3 id="具体解析"><strong>具体解析</strong></h3><ol type="1"><li><p><strong>DELETE语句</strong>执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。<strong>TRUNCATETABLE</strong>则<strong>一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存</strong>，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器，且使用的系统和事务日志资源少。</p></li><li><p>表被TRUNCATE后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p></li><li><p>一般而言，drop &gt; truncate &gt; delete</p></li><li><p>TRUNCATE 只能对TABLE；DELETE可以是table和view</p></li><li><p>TRUNCATE和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p></li><li><p>truncate与不带where的delete只删除数据，而不删除表的结构（定义）；drop语句将删除表的结构，包括被依赖的约束（constrain),触发器（trigger)索引（index)，依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p></li><li><p>TRUNCATE TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变，新<strong>行标识所用的计数值重置为该列的种子</strong>。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p></li><li><p>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATETABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE不记录在日志中，所以它不能激活触发器。</p></li></ol><p>​</p><h2id="mysql优化了解吗说一下从哪些方面可以做到性能优化">MySQL优化了解吗？说一下从哪些方面可以做到性能优化？</h2><ul><li>为搜索字段创建索引</li><li>避免使用 Select *，列出需要查询的字段</li><li>垂直分割分表</li><li>选择正确的存储引擎</li></ul><div class="admonition info"><p class="admonition-title">MySQL的两个存储引擎</p><p>MySQL的两个存储引擎为InnoDB和MyISAM,它们各有特点和使用场景。</p><ol><li>InnoDB</li></ol><ul><li>支持事务，通过MVCC（并发版本控制）来实现</li><li>默认的锁粒度为行级锁，可以支持更高的并发</li><li>支持外键约束</li><li>可以通过自动增长列</li><li>配合一些热备工具可以支持在线热备份</li><li>在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度</li><li>对于InnoDB类型的表，其数据的物理组织形式是聚簇表</li></ul><ol start="2"><li>MyISAM</li></ol><ul><li>不支持事务</li><li>MyISAM的索引和数据是分开的，并且索引是有压缩的</li><li>每张MyISAM表在磁盘上会对应三个文件：.frm文件（存储表的定义数据）、.MYD文件（存放表具体记录的数据）、.MYI文件（存储索引）</li><li>MyISAM表的select count (*) 是非常快的</li></ul></div><h2 id="数据库隔离级别">数据库隔离级别</h2><ul><li><strong>未提交读</strong>，事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>提交读</strong>，对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>重复读</strong>，就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></li><li><strong>可串行化读</strong>，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；<strong>该级别可以防止脏读、不可重复读以及幻读</strong></li></ul><table><thead><tr class="header"><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr class="odd"><td>READ-UNCOMMITTED 未提交读</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>READ-COMMITTED 提交读</td><td>×</td><td>√</td><td>√</td></tr><tr class="odd"><td>REPEATABLE-READ 重复读</td><td>×</td><td>×</td><td>√</td></tr><tr class="even"><td>SERIALIZABLE 可串行化读</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><div class="admonition info"><p class="admonition-title">info</p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是<strong>REPEATABLE-READ（可重读）</strong>,与 SQL标准不同的地方在于InnoDB 存储引擎在REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock锁算法，因此可以<strong>避免幻读</strong>的产生，这与其他数据库系统(如SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即<strong>达到了SQL标准的SERIALIZABLE(可串行化)隔离级别</strong>。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。</p></div><h2id="都知道数据库索引采用b树而不是b树原因也有很多主要原因是什么">都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？</h2><p>B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。</p><h2id="文件索引和数据库索引为什么使用b树而不是b树上个问题的详细回答">文件索引和数据库索引为什么使用B+树而不是B树?（上个问题的详细回答）</h2><ul><li><strong>遍历更方便</strong>：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。</li><li><strong>IO次数更少</strong>：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率</li><li><strong>磁盘寻址加载次数更少</strong>：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了</li><li><strong>查找效率稳定</strong>：B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。</li></ul><h2 id="听说过视图吗那游标呢">听说过视图吗？那游标呢？</h2><p>视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p><h2id="mysql中为什么要有事务回滚机制">MySQL中为什么要有事务回滚机制？</h2><p>MySQL 中，恢复机制是通过回滚日志（undolog）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。<strong>当事务已经被提交之后，就无法再次回滚了。</strong></p><p>回滚日志作用：</p><ol type="1"><li>能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息<br /></li><li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</li></ol><h2id="数据库引擎innodb与myisam的区别">数据库引擎InnoDB与MyISAM的区别</h2><h3 id="innodb"><strong>InnoDB</strong></h3><ul><li>是 MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li><li>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLEREAD)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-KeyLocking)防止幻影读。</li><li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li><li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li><li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li></ul><p>### <strong>MyISAM</strong></p><ul><li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li><li>提供了大量的特性，包括压缩表、空间数据索引等。</li><li>不支持事务。</li><li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENTINSERT)。</li></ul><h3 id="总结">总结</h3><ul><li>事务: InnoDB 是事务型的，可以使用 <code>Commit</code> 和<code>Rollback</code> 语句。</li><li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键: InnoDB 支持外键。</li><li>备份: InnoDB 支持在线热备份。</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB高很多，而且恢复的速度也更慢。</li><li>其它特性: MyISAM 支持压缩表和空间数据索引。</li></ul><h2id="数据库并发事务会带来哪些问题">数据库并发事务会带来哪些问题？</h2><p>数据库并发会带来<strong>脏读</strong>、<strong>幻读</strong>、<strong>丢弃更改</strong>、<strong>不可重复读</strong>这四个常见问题，其中：</p><ul><li><strong>脏读</strong>：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。</li><li><strong>幻读</strong>：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之前的了，强调范围。</li><li><strong>丢弃修改</strong>：两个写事务T1T2同时对A=0进行递增操作，结果T2覆盖T1，导致最终结果是1而不是2，事务被覆盖</li><li><strong>不可重复读</strong>：T2 读取一个数据，然后T1对该数据做了修改。如果 T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li></ul><h3 id="脏读"><strong>脏读</strong></h3><figure><img src="/img/MySQL/202205220024781.png" alt="脏读" /><figcaption aria-hidden="true">脏读</figcaption></figure><p>第一个事务首先读取var变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取var为100，此时第一个事务做了回滚。最终第二个事务读取的var和数据库的var不一样。</p><h3 id="幻读幻影读"><strong>幻读（幻影读）</strong></h3><figure><img src="/img/MySQL/202205220024132.png" alt="幻读" /><figcaption aria-hidden="true">幻读</figcaption></figure><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><h3 id="丢弃修改"><strong>丢弃修改</strong></h3><figure><img src="/img/MySQL/202205220024561.png" alt="丢弃修改" /><figcaption aria-hidden="true">丢弃修改</figcaption></figure><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2的修改覆盖了 T1的修改。例如：事务1读取某表中的数据A=50，事务2也读取A=50，事务1修改A=A+50，事务2也修改A=A+50，最终结果A=100，事务1的修改被丢失。</p><h3 id="不可重复读"><strong>不可重复读</strong></h3><figure><img src="/img/MySQL/202205220024930.png" alt="不可重复读" /><figcaption aria-hidden="true">不可重复读</figcaption></figure><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2id="数据库悲观锁和乐观锁的原理和应用场景分别有什么">数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h2><p><strong>悲观锁，先获取锁，再进行业务操作</strong>，一般就是利用类似SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，selectforupdate获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过</strong>。Java并发包中的 AtomicFieldUpdater 类似，也是利用 CAS机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p><h2id="mysql索引主要使用的两种数据结构是什么">MySQL索引主要使用的两种数据结构是什么？</h2><ul><li><p><strong>哈希索引</strong>，对于哈希索引来说，底层的数据结构肯定是哈希表，因此<strong>在绝大多数需求为单条记录查询</strong>的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引</p></li><li><p><strong>BTree索引</strong>，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。</p><p>但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</p></li></ul><h2id="数据库为什么要进行分库和分表呢都放在一个库或者一张表中不可以吗">数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</h2><p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p><p><strong>通过分表</strong>，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。</p><p>分表策略可以归纳为垂直拆分和水平拆分：</p><ul><li><strong>水平拆分</strong>：将同一个表的数据按一定规则拆到不同的数据库中。当表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放</li><li><strong>垂直拆分</strong>：将一个表按照字段分成多表，每个表存储其中一部分字段</li></ul><p><strong>库内分表</strong>，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括CPU、内存、磁盘 IO、网络带宽等。</p><p><strong>分库与分表带来的分布式困境与应对之策</strong>：</p><ul><li>数据迁移与扩容问题：一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。</li><li>分页与排序问题：需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</li></ul><h2id="不可重复读和幻读区别是什么可以举个例子吗">不可重复读和幻读区别是什么？可以举个例子吗？</h2><p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</strong></p><ul><li>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了）：事务1中的A先生读取自己的工资为1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为2000；这就是不可重复读。</li><li>例2（同样的条件, 第1次和第2次读出来的记录数不一样）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</li></ul><h2id="mysql中有四种索引类型可以简单说说吗">MySQL中有四种索引类型，可以简单说说吗？</h2><ul><li><strong>FULLTEXT</strong>：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTERTABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT列上可以创建全文索引，需要注意的是MySQL5.6以后支持全文索引了，5.6之前是不支持的。</li><li><strong>HASH</strong>：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</li><li><strong>BTREE</strong>：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</li><li><strong>RTREE</strong>：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</li></ul><h2 id="mysql的索引种类有哪些">MySQL的索引种类有哪些？</h2><ul><li><p><strong>普通索引</strong>：最基本的索引，没有任何限制。</p></li><li><p><strong>唯一索引</strong>：索引列的值必须唯一，但允许有空值。</p></li><li><p><strong>主键索引</strong>：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。</p></li><li><p><strong>全文索引</strong>：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。</p></li></ul><div class="admonition info"><p class="admonition-title">info</p><p>索引类型主要指的是索引的数据结构，如B-Tree、Hash、R-Tree等。不同类型的索引有不同的适用场景和性能特性。例如，B-Tree索引适用于全键值、键值范围或键前缀查找，而Hash索引主要适用于等值查询。</p></div><p>​索引种类则是根据索引的特性和约束来分类的，包括普通索引、唯一索引、主键索引和全文索引。</p><h2 id="视图的作用是什么可以更改吗">视图的作用是什么？可以更改吗？</h2><p><strong>视图</strong>是一种虚拟表，其内容由查询定义。与真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</p><p>视图的<strong>主要作用</strong>包括：</p><ul><li>简化用户对数据的理解和操作：视图可以简化复杂的SQL查询，使得用户不必为以后的操作每次指定全部的条件。</li><li>增加数据的安全性：通过视图，用户只能查询和修改指定的数据，防止敏感信息被未授权的用户查看，增强机密信息的安全性。</li><li>提高表的逻辑独立性：视图可以屏蔽原有表结构变化带来的影响。</li></ul><p>视图<strong>可以被修改</strong>，MySQL中，你可以使用ALTERVIEW语句来修改已存在的视图。此外，视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据，也就是说，<strong>更新视图会作用在原表上</strong>。</p><h2id="场景题假如你所在的公司选择mysql数据库作数据存储一天五万条以上的增量预计运维三年你有哪些优化手段">场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</h2><ul><li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li><li>MySQL库主从读写分离。</li><li>找规律分表，减少单表中的数据量提高查询速度。</li><li>添加缓存机制，比如Memcached，Apc等。</li><li>不经常改动的页面，生成静态页面。</li><li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1,field_2, field_3 FROM TABLE。</li></ul><div class="admonition info"><p class="admonition-title">info</p><p>Memcached是一个高性能的分布式内存对象缓存系统。它通过在内存中维护一个统一的巨大的hash表，能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度345。</p><p>APC，全称是Alternative PHPCache，是PHP的一个扩展。它除了可以将PHP代码解释成OPCode保存在内存中之外，还能在PHP的进程之间使用共享内存（系统内核的数据结构）来保存数据，而且完全透明。</p></div><h2id="什么时候需要建立数据库索引呢">什么时候需要建立数据库索引呢？</h2><p>在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。</p><p>不宜建索引的情况：</p><ol type="1"><li>对于查询中很少涉及的列或者重复值比较多的列</li><li>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）</li></ol><h2id="数据库中的主键超键候选键外键是什么">数据库中的主键、超键、候选键、外键是什么？</h2><ul><li><strong>超键</strong>：在关系中能唯一标识<strong>元组的属性集</strong>称为关系模式的超键</li><li><strong>候选键</strong>：不含有<strong>多余属性的超键</strong>称为候选键。也就是在候选键中，若再删除属性，就不是键了！</li><li><strong>主键</strong>：<strong>用户选作元组标识的一个候选键程序主键</strong></li><li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li></ul><p>举例：</p><table><thead><tr class="header"><th>学号</th><th>姓名</th><th>性别</th><th>年龄</th><th>系别</th><th>专业</th></tr></thead><tbody><tr class="odd"><td>20020612</td><td>李辉</td><td>男</td><td>20</td><td>计算机</td><td>软件开发</td></tr><tr class="even"><td>20060613</td><td>张明</td><td>男</td><td>18</td><td>计算机</td><td>软件开发</td></tr><tr class="odd"><td>20060614</td><td>王小玉</td><td>女</td><td>19</td><td>物理</td><td>力学</td></tr><tr class="even"><td>20060615</td><td>李淑华</td><td>女</td><td>17</td><td>生物</td><td>动物学</td></tr><tr class="odd"><td>20060616</td><td>赵静</td><td>男</td><td>21</td><td>化学</td><td>食品化学</td></tr><tr class="even"><td>20060617</td><td>赵静</td><td>女</td><td>20</td><td>生物</td><td>植物学</td></tr></tbody></table><ol type="1"><li>超键：于是我们从例子中可以发现学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(<code>学号</code>，<code>性别</code>)，(<code>学号</code>，<code>年龄</code>)</li><li>候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如（学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。</li><li>主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。</li><li>外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。</li></ol><p><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</strong></p><h3 id="主键和候选键的区别">主键和候选键的区别</h3><table><thead><tr class="header"><th style="text-align: center;">比较基础</th><th style="text-align: center;">主键</th><th style="text-align: center;">候选键</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>定义</strong></td><tdstyle="text-align: center;">它是一个唯一且非空的键，用于唯一地标识模式中每个表的记录。</td><tdstyle="text-align: center;">它也是一个唯一键，用于唯一地标识关系或表中的记录。</td></tr><tr class="even"><td style="text-align: center;"><strong>基本</strong></td><td style="text-align: center;">一个表或关系只能包含一个主键。</td><td style="text-align: center;">一个表或关系可以有多个候选键。</td></tr><tr class="odd"><td style="text-align: center;"><strong>NULL</strong></td><tdstyle="text-align: center;">主键的任何<strong>列都不能为NULL</strong>。</td><tdstyle="text-align: center;">候选键的列<strong>可以包含NULL值</strong>。</td></tr><tr class="even"><td style="text-align: center;"><strong>目标</strong></td><td style="text-align: center;">它是表或关系的基本组成部分。</td><td style="text-align: center;">它表示哪个键可以用作主键。</td></tr><tr class="odd"><td style="text-align: center;"><strong>用途</strong></td><td style="text-align: center;">它可以用作候选键。</td><td style="text-align: center;">它可能或可能不用作主键。</td></tr><tr class="even"><td style="text-align: center;"><strong>指定</strong></td><td style="text-align: center;">不需要为任何关系指定主键。</td><tdstyle="text-align: center;">在不指定候选键的情况下无法建立关系。</td></tr><tr class="odd"><td style="text-align: center;"><strong>示例</strong></td><tdstyle="text-align: center;">考虑一个名为“student”的表，具有列（roll_no.,name, class, DOB, email, mobile）。这里，roll_no**列可以作为关系的主键，因为它可以唯一标识学生的记录。</td><td style="text-align: center;">给定表中的roll_no,mobile<strong>和email</strong>列可以作为候选键，因为它们可以唯一标识学生的记录。</td></tr></tbody></table><h2 id="数据库三大范式">数据库三大范式</h2><h3 id="第一范式"><strong>第一范式</strong></h3><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</p><p>如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p><p>简而言之，<strong>第一范式就是无重复的列</strong>。</p><h3 id="第二范式">第二范式</h3><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。</p><p>为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。</p><p>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。</p><p>简而言之，<strong>第二范式就是非主属性非部分依赖于主关键字</strong>。</p><h3 id="第三范式">第三范式</h3><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p><p>例如，<strong>存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</strong></p><p>简而言之，第三范式就是属性不依赖于其它非主属性。</p><h3 id="总结-1">总结</h3><ul><li>第一范式（1NF）：字段不可分； 　　</li><li>第二范式（2NF）：有主键，非主键字段依赖主键； 　</li><li>第三范式（3NF）：非主键字段不能相互依赖。</li></ul><p>解释：1NF：原子性。 字段不可再分,否则就不是关系数据库;；　　2NF：唯一性 。一个表只说明一个事物；　　3NF：每列都与主键有直接关系，不存在传递依赖。</p><h2id="mysql常见的存储引擎innodbmyisam的区别适用场景分别是">MySQL常见的存储引擎InnoDB、MyISAM的区别？适用场景分别是？</h2><ol type="1"><li>事务：MyISAM不支持，InnoDB支持</li><li>锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束</li><li>MyISAM存储表的总行数；InnoDB不存储总行数；</li><li>MyISAM采用<strong>非聚集索引，B+树叶子存储指向数据文件的指针</strong>。InnoDB主键索引采用<strong>聚集索引，B+树叶子存储数据</strong></li></ol><p><strong>适用场景</strong>： MyISAM适合：插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择，没有事务。 InnoDB适合：可靠性要求比较高，或者要求事务；表更新和查询都相当的频繁，大量的INSERT或UPDATE。</p><h2 id="聚集索引和非聚集索引">聚集索引和非聚集索引</h2><p>以字典为例，聚集索引就是按照拼音查询，非聚集索引就是按照偏旁等来进行查询。</p><h3 id="聚集索引">聚集索引</h3><p>我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查"安"字，就会很自然地翻开字典的前几页，因为"安"的拼音是"an"，而按照拼音排序汉字的字典是以英文字母"a"开头并以"z"结尾的，那么"安"字就自然地排在字典的前部。如果你翻完了所有以"a"开头的部分仍然找不到这个字，那么就说明你的字典中没有这个字；也就是说，<strong>字典的正文部分本身就是一个目录，你不需要再去查其他目录来找到你需要找的内容</strong>。</p><p>我们把这种<strong>正文内容本身就是一种按照一定规则排列的目录称为"聚集索引"</strong>。</p><h3 id="非聚集索引">非聚集索引</h3><p>仍然以字典为例，如果你遇到不认识的字，不知道它的发音，这时候，你就不能按照聚集索引的方法找到你要查的字，而需要去根据"偏旁部首"查到你要找的字，然后根据这个字后的页码直接翻到某页来找到你要找的字。</p><p>但是结合"部首目录"和"检字表"而查到的字的排序并不是真正的正文的排序方法，比如你查"张"字，我们可以看到在查部首之后的检字表中"张"的页码是672页，检字表中"张"的上面是"驰"字，但页码却是63页，"张"的下面是"弩"字，页面是390页。</p><p>我们把<strong>这种目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"。</strong></p><h3 id="区别-1">区别</h3><p>聚集索引和非聚集索引的区别在于，通过<strong>聚集索引可以直接查到需要查找的数据</strong>，而通过<strong>非聚集索引只能查到记录对应的主键值 ，再使用主键的值通过聚集索引查找到需要的数据</strong>。聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p><h2id="事务四大特性acid原子性一致性隔离性持久性">事务四大特性（ACID）原子性、一致性、隔离性、持久性</h2><p><strong>原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p><strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p><strong>隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Readuncommitted）、读提交（read committed）、可重复读（repeatableread）和串行化（Serializable）。</p><p><strong>持久性</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h2id="sql中的now和current_date两个函数有什么区别">SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？</h2><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。</p><h2 id="创建索引时需要注意什么">创建索引时需要注意什么？</h2><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在 MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：变量各个取值之间的差异程度大的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。唯一、不为空、经常被查询的字段的字段适合建索引</li></ul><h2id="mysql中char和varchar的区别有哪些">MySQL中CHAR和VARCHAR的区别有哪些？</h2><ul><li>char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。</li><li>char的存取速度还是要比varchar要快得多</li><li>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</li></ul><h2 id="mysql-索引使用的注意事项">MySQL 索引使用的注意事项</h2><p>MySQL 索引通常是被用于提高 WHERE条件的数据行匹配时的搜索速度，在索引的使用过程中，存在一些使用细节和注意事项。</p><h3id="不要在列上使用函数这将导致索引失效而进行全表扫描"><strong>不要在列上使用函数，这将导致索引失效而进行全表扫描</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span>(publish_time) <span class="hljs-operator">&lt;</span> <span class="hljs-number">2017</span><br></code></pre></td></tr></table></figure><p>为了使用索引，防止执行全表扫描，可以进行改造:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> publish_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2017-01-01&#x27;</span><br></code></pre></td></tr></table></figure><p>还有一个建议，不要在列上进行运算，这也将导致索引失效而进行全表扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">/</span> <span class="hljs-number">100</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>为了使用索引，防止执行全表扫描，可以进行改造</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="尽量避免使用-或-not-in或-等否定操作符"><strong>尽量避免使用 !=或 not in或 &lt;&gt; 等否定操作符</strong></h3><p>应该尽量避免在 where 子句中使用 != 或 not in 或 &lt;&gt;操作符，因为这几个操作符都会导致索引失效而进行全表扫描。尽量避免使用 or来连接条件 应该尽量避免在 where 子句中使用 or来连接条件，因为这会导致索引失效而进行全表扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3id="多个单列索引并不是最佳选择"><strong>多个单列索引并不是最佳选择</strong></h3><p>MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高MySQL 的查询性能。 假设，有两个单列索引，分别为 news_year_idx(news_year)和news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL语句可以写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> news_year <span class="hljs-operator">=</span> <span class="hljs-number">2017</span> <span class="hljs-keyword">and</span> news_month <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month两个列都被索引覆盖。</p><h3id="复合索引的最左前缀原则"><strong>复合索引的最左前缀原则</strong></h3><p>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL语句可以写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> news_month <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>此时，无法使用 news_year_month_idx(news_year, news_month)索引，因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引是不会被使用的。</p><h3 id="覆盖索引的好处"><strong>覆盖索引的好处</strong></h3><p>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</p><h3id="范围查询对多列查询的影响"><strong>范围查询对多列查询的影响</strong></h3><p>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL语句可以写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> publish_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2017-01-02&#x27;</span> <span class="hljs-keyword">and</span> publish_time <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;2017-01-08&#x27;</span> <span class="hljs-keyword">and</span> enable <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这种情况下，因为范围查询对多列查询的影响，将导致news_publish_idx(publish_time, enable) 索引中 publish_time右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time,enable) 索引等价于 news_publish_idx(publish_time) 。对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL可以改写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> news_weekth <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> enable <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的SortedSet有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。</p><h3id="索引不会包含有null值的列"><strong>索引不会包含有NULL值的列</strong></h3><p>只要列中包含有 NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。因此，在数据库设计时，除非有一个很特别的原因使用 NULL值，不然尽量不要让字段的默认值为 NULL。<br /></p><h3 id="隐式转换的影响"><strong>隐式转换的影响</strong></h3><p>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。下面的案例中，date_str是字符串，然而匹配的是整数类型，从而发生隐式转换。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> date_str <span class="hljs-operator">=</span> <span class="hljs-number">201701</span><br></code></pre></td></tr></table></figure><p>因此，要谨记隐式转换的危害，时刻注意通过同类型进行比较。</p><h3 id="like-语句的索引失效问题"><strong>like语句的索引失效问题</strong></h3><p>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like“%value%”这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用ElasticSearch 或 Solr 是个不错的方案。</p><h2id="mysql中有哪些索引有什么特点">MySQL中有哪些索引？有什么特点？</h2><ul><li><strong>普通索引</strong>：仅加速查询</li><li><strong>唯一索引</strong>：加速查询 + 列值唯一（可以有null）</li><li><strong>主键索引</strong>：加速查询 + 列值唯一（不可以有null）+表中只有一个</li><li><strong>组合索引</strong>：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li><strong>全文索引</strong>：对文本的内容进行分词，进行搜索</li><li><strong>索引合并</strong>：使用多个单列索引组合搜索</li><li><strong>覆盖索引</strong>：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</li><li><strong>聚簇索引</strong>：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</li></ul><h2id="既然索引有那么多优点为什么不对表总的每一列创建一个索引呢">既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？</h2><ul><li>当对表中的数据进行增加、删除和修改的时候，<strong>索引也要动态的维护</strong>，这样就降低了数据的维护速度。</li><li><strong>索引需要占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。</li><li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加</li></ul><h2 id="索引如何提高查询速度的">索引如何提高查询速度的</h2><p>将无序的数据变成相对有序的数据（就像查有目的一样）</p><h2 id="使用索引的注意事项">使用索引的注意事项</h2><ul><li>在经常需要搜索的列上，可以加快搜索的速度；</li><li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li><li><strong>将打算加索引的列设置为NOTNULL，否则将导致引擎放弃使用索引而进行全表扫描</strong></li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li>避免where子句中对字段施加函数，这会造成无法命中索引</li><li>在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建议用逻辑索引</li><li>在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度</li><li>与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗</li><li>在使用limit offset查询缓存时，可以借助索引来提高性能。</li></ul><h2id="增加b树的路数可以降低树的高度那么无限增加树的路数是不是可以有最优的查找效率">增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？</h2><p>不可以，无限增加路数B+树会退化为一个有序数组，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存。</p><h2 id="数据库表锁和行锁">数据库表锁和行锁</h2><h3 id="表锁"><strong>表锁</strong></h3><p>不会出现死锁，发生锁冲突几率高，并发低。</p><p>MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p><p>MySQL的表级锁有两种模式：<strong>表共享读锁</strong>和<strong>表独占写锁</strong>。读锁会阻塞写，写锁会阻塞读和写。</p><ul><li>对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li><li>对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li></ul><p>MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h3 id="行锁"><strong>行锁</strong></h3><p>会出现死锁，发生锁冲突几率低，并发高。</p><p>在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的行锁是通过索引加载的，也就是说，行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。</p><div class="admonition info"><p class="admonition-title">行锁的实现需要注意</p><ul><li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</li><li>如果是共享锁，两个事务可以锁同一个索引，排它锁则不能。</li><li>insert，delete，update在事务中都会自动默认加上排它锁。</li></ul></div><p><strong>行锁的适用场景：</strong></p><p>A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。</p><p>否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。</p><p>为了避免此情况，需要在A用户操作该记录的时候进行for update加锁。</p><h2id="sql语法中内连接自连接外连接左右全交叉连接的区别分别是什么">SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？</h2><p><strong>内连接</strong>：只有两个元素表相匹配的才能在结果集中显示。</p><p><strong>外连接</strong>： 左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。</p><p><strong>右外连接</strong>:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。</p><p><strong>全外连接</strong>：连接的表中不匹配的数据全部会显示出来。</p><p><strong>交叉连接</strong>：笛卡尔效应，显示的结果是链接表数的乘积。</p><h2id="你知道哪些数据库结构优化的手段">你知道哪些数据库结构优化的手段？</h2><ul><li><strong>范式优化</strong>： 比如消除冗余（节省空间。。）</li><li><strong>反范式优化</strong>：比如适当加冗余等（减少join）</li><li><strong>限定数据的范围</strong>：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</li><li><strong>读/写分离</strong>：经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>拆分表</strong>：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。</li></ul><p>!!! info 反范式优化优缺点 - 优点 -提高查询性能：反范式设计可以避免复杂的联接操作，从而提高查询性能。当数据量很大的时候，反范式只需在同一张表中查询，显然反范式的效率会更好。- 简化查询：反范式设计使得某些查询变得更加简单和高效。 -提升性能：反范式是通过增加冗余、聚合的手段来提升性能。反范式优化也是一种改善慢查询的优化思路。- 缺点 -反范式有很多重复的数据，会占用更多的内存，查询时可能会较多地使用GROUPBY或DISTINCT等耗时耗性能的关键字。 -当要修改更新数据时，范式更灵活，而反范式要修改全部的数据，且易出错。</p><h2id="数据库优化中有一个比较常用的手段就是把数据表进行拆分关于拆分数据表你了解哪些">数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于拆分数据表你了解哪些？</h2><p>分表策略可以归纳为垂直拆分和水平拆分：</p><ul><li><strong>水平拆分</strong>：将同一个表的数据按一定规则拆到不同的数据库中。当表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放</li><li><strong>垂直拆分</strong>：将一个表按照字段分成多表，每个表存储其中一部分字段</li></ul><h2id="为什么mysql索引适用用b树而不用hash表和b树">为什么MySQL索引适用用B+树而不用hash表和B树？</h2><ul><li>利用Hash需要把数据全部<strong>加载到内存中</strong>，如果数据量大，是一件很<strong>消耗内存</strong>的事，而采用B+树，是基于<strong>按照节点分段加载，由此减少内存消耗</strong>。</li><li>和业务场景有段，<strong>对于唯一查找</strong>（查找一个值），Hash确实更快，<strong>但数据库中经常查询多条数据</strong>，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。</li><li>b+树的<strong>非叶子节点不保存数据</strong>，<strong>只保存子树的临界值</strong>（最大或者最小），所以同样大小的节点，<strong>b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少</strong>。</li></ul><h2id="关系型数据库的四大特性在得不到保障的情况下会怎样">关系型数据库的四大特性在得不到保障的情况下会怎样？</h2><p>ACID，原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。</p><p>我们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。</p><h3 id="原子性"><strong>原子性</strong></h3><p>原子性是指一个事务是一个不可分割的工作单位，<strong>其中的操作要么都做，要么都不做</strong>。即要么转账成功，要么转账失败，是不存在中间的状态！</p><p><strong>如果无法保证原子性会怎么样？</strong></p><p>OK，就会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元。</p><h3 id="一致性"><strong>一致性</strong></h3><p>一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。<strong>满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！</strong></p><p><strong>如果无法保证一致性会怎么样？</strong></p><ul><li>例一:A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须大于0。</li><li>例二:A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的余额必须不变。</li></ul><h3 id="隔离性"><strong>隔离性</strong></h3><p>隔离性是指<strong>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的</strong>，并发执行的各个事务之间不能互相干扰。</p><p><strong>如果无法保证隔离性会怎么样</strong>？</p><p>假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！</p><h3 id="持久性"><strong>持久性</strong></h3><p>根据定义，<strong>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</strong>。接下来的其他操作或故障不应该对其有任何影响。</p><p>如果无法保证持久性会怎么样？</p><p>在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。</p><p>设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是<strong>数据不一致</strong>的情形。</p><h2 id="数据库如何保证一致性">数据库如何保证一致性？</h2><p>分为两个层面来说。</p><ul><li><strong>从数据库层面</strong>，数据库通过<strong>原子性、隔离性、持久性</strong>来保证一致性。也就是说ACID四大特性之中，<strong>C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段</strong>，是为了保证一致性，数据库提供的手段。<strong>数据库必须要实现AID三大特性，才有可能实现一致性</strong>。例如，原子性无法保证，显然一致性也无法保证。</li><li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！</li></ul><h2 id="数据库如何保证持久性">数据库如何保证持久性？</h2><p>主要是利用Innodb的<strong>redo log</strong>。重写日志，正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。怎么解决这个问题？简单啊，事务提交前直接把数据写入磁盘就行，但是这样做会带来一些问题：</p><ul><li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li><li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li></ul><p>于是，决定采用<strong>redolog</strong>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<strong>redolog</strong>中记录这次操作。当事务提交的时候，会将<strong>redolog</strong>日志进行刷盘(<strong>redolog</strong>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redolog中的内容恢复到数据库中，再根据<strong>undolog</strong>和<strong>binlog</strong>内容决定回滚数据还是提交数据。</p><p><strong>采用redo log的好处？</strong></p><p>其实好处就是将<strong>redolog</strong>进行刷盘比对数据页刷盘效率高，具体表现如下：</p><ul><li><strong>redolog</strong>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li><li><strong>redolog</strong>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li></ul><h2id="数据库高并发是我们经常会遇到的你有什么好的解决方案吗">数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？</h2><ul><li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li>主从读写分离，让主服务器负责写，从服务器负责读。</li><li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li><li>使用分布式架构，分散计算压力。</li></ul><h3 id="面试问题mvcc是怎么实现的">面试问题：MVCC是怎么实现的？</h3><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的<strong>4个隐式字段</strong>，<strong>undo日志</strong> ，<strong>ReadView</strong> 来实现的。</p><p>具体实现见<ahref="https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#mvcc%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">MVCC的实现原理</a></p><h2 id="b树和b树以及区别">B树和B+树以及区别</h2><h4 id="b树">B树</h4><p>首先介绍一下一棵 m 阶的 B 树的特性。<imgsrc="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"alt="m" /> 表示这个树的每一个节点最多可以拥有的子节点个数。一棵 m 阶的 B树满足的性质如下：</p><ol type="1"><li>每个节点最多有 m 个子节点。</li><li>每一个非叶子节点（除根节点）最少有 <spanclass="math inline">\(\lceil m/2 \rceil\)</span> 个子节点。</li><li>如果根节点不是叶子节点，那么它至少有两个子节点。</li><li>有 k 个子节点的非叶子节点拥有 k - 1个键，且升序排列，满足 k[i] &lt;k[i+1]。</li><li>所有的叶子节点都在同一层</li></ol><h4 id="b树-1">B+树</h4><p>m阶B+树</p><ol type="1"><li>每个分支结点最多有m棵子树。</li><li>非叶根结点至少有两棵子树,其他每个分支结点至少有⌈m/2⌉棵子树。</li><li>结点的子树个数与关键字个数相等。</li><li>所有叶结点包含全部关键字及指向相应记录的指针，而且叶结点中将关键字按大小顺序排列,并且相邻叶结点按大小顺序相互链接起来。</li><li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。</li></ol><h4 id="区别-2">区别</h4><ol type="1"><li>在B树中，具有n个关键字的结点含有（n+1）棵子树；而在B+树中，具有n个关键字的结点只含有n棵子树,即每个关键字对应一棵子树。</li><li>在B树中，根结点的关键字个数n的范围是1 &lt;= n &lt;=m-1,非根结点的范围是⌈m/2⌉-1&lt;=n &lt;=m-1；而在B+树中，根结点的关键字个数n的范围是1 &lt;= n &lt;=m,非根结点的范围是⌈m/2⌉&lt;=n &lt;= m。</li><li>在B+树中，所有非叶结点仅起到索引作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li><li>在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的；而在B+树中，叶结点包含了全部关键字，即其他非叶结点中的关键字包含在叶结点中。</li></ol><h2 id="覆盖索引">覆盖索引</h2><p>每一个索引在 InnoDB里面对应一棵B+树，先讲一下主键索引和非主键索引的区别：</p><p>对于表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from student;<br>+----+------+-----+<br>| id | name | age |<br>+----+------+-----+<br>|  1 | 小赵 |  10 |<br>|  2 | 小王 |  11 |<br>|  3 | 小李 |  12 |<br>|  4 | 小陈 |  13 |<br>+----+------+-----+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure><img src="/img/MySQL/2002319-20201221103607402-1375547408.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>叶子节点中，主键索引存储了整行数据，而非主键索引中存储的值为主键id</strong>。</p><p>当我们执行以下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select age from student where name = &#x27;小李&#x27;;<br></code></pre></td></tr></table></figure><p>执行顺序:</p><ol type="1"><li>在name索引树上找到名称为小李的节点 id为03</li><li>从id索引树上找到id为03的节点 获取所有数据</li><li>从数据中获取字段命为age的值12,返回.</li></ol><p>这样<strong>从非主键索引树搜索再回到主键索引树搜索的过程称为：回表</strong></p><p>回表一定程度上消耗性能,那么如何降低这种性能损耗呢?于是提出了一种方法:<strong>覆盖索引</strong>.</p><h3 id="覆盖索引-1">覆盖索引</h3><p>覆盖索引（covering index，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，<strong>避免回表的产生</strong>减少了树的搜索次数，显著提升性能。</p><h3 id="覆盖索引的使用">覆盖索引的使用</h3><p>如果一个业务中,很多类似于根据姓名查找年龄的业务,那么可以将这些热点业务重新根据(name, age)建立联合索引,先删除之前以name构建的索引:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> I_name;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> I_name_age(<span class="hljs-type">name</span>, age);<br></code></pre></td></tr></table></figure><p>联合索引:</p><p>[<img src="/img/MySQL/2002319-20201221103615438-278818902.png"alt="img" /></p><p>再次执行如下sql:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> age <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;小李&#x27;</span>;<br></code></pre></td></tr></table></figure><p>执行流程:</p><ol type="1"><li>在name,age联合索引树上找到名称为小李的节点。</li><li>此时节点索引里包含信息age直接返回 12,从而避免回表。</li></ol><h2 id="select-...-for-update-where-xxx...-加锁情况">select ... forupdate where xxx... 加锁情况</h2><p>更详细见<ahref="https://www.cnblogs.com/rjzheng/p/9950951.html">【原创】惊！史上最全的select加锁分析(Mysql)</a></p><h3 id="主键">主键</h3><p>当where条件用的数据库主键时。</p><p>例如开启一个事务1，在事务中更新id=1的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>where条件中的id是数据库的主键，并且使用forupdate关键字，加了一个<strong>行锁</strong>，这个事务没有commit。</p><p>此时，开启了另外一个事务2，也更新id=1的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>在执行事务2的sql语句的过程中，会一直等待事务1释放锁。</p><h3 id="唯一索引">唯一索引</h3><p>当where条件用的数据库唯一索引时。</p><p>开启一个事务1，在事务中更新code=101的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;101&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;101&#x27;</span>;<br></code></pre></td></tr></table></figure><p>where条件中的code是数据库的<strong>唯一索引</strong>，并且使用forupdate关键字，加了一个<strong>行锁</strong>，这个事务没有commit。</p><p>此时，开启了另外一个事务2，也更新code=101的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;101&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><h3 id="普通索引">普通索引</h3><p>当where条件用的数据库普通索引时。</p><p>开启一个事务1，在事务中更新name=周星驰的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;周星驰&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;周星驰&#x27;</span>;<br></code></pre></td></tr></table></figure><p>where条件中的name是数据库的普通索引，并且使用forupdate关键字，加了一个<strong>行锁</strong>，这个事务没有commit。</p><p>此时，开启了另外一个事务2，也更新name=周星驰的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;周星驰&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>执行结果跟主键的情况也是一样的。 <imgsrc="/img/MySQL/f0dac846-3c8b-4c30-b1c6-9eed869d65cd-17111930681232.png"alt="img" /></p><h3 id="主键范围">主键范围</h3><p>当where条件用的数据库主键范围时。</p><p>开启一个事务1，在事务中更新id in (1,2)的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>where条件中的id是数据库的主键范围，并且使用forupdate关键字，加了多个行锁，这个事务没有commit。</p><p>此时，开启了另外一个事务2，也更新id=1的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>执行结果跟主键的情况也是一样的。 <imgsrc="/img/MySQL/f0dac846-3c8b-4c30-b1c6-9eed869d65cd-17111931086044.png"alt="img" /></p><p>此时，开启了另外一个事务2，也更新id=2的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>执行结果跟主键的情况也是一样的。 <imgsrc="/img/MySQL/f0dac846-3c8b-4c30-b1c6-9eed869d65cd-17111931086044.png"alt="img" /></p><h3 id="普通字段">普通字段</h3><p>当where条件用的数据库普通字段时。该字段<strong>既不是主键，也不是索引</strong>。</p><p>开启一个事务1，在事务中更新age=22的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> ;<br></code></pre></td></tr></table></figure><p>where条件中的age是数据库的普通字段，并且使用forupdate关键字，加的是<code>表锁</code>，这个事务没有commit。</p><p>此时，开启了另外一个事务2，也更新age=22的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> ;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时，执行事务2时，会一直阻塞等待事务1释放锁。</p><p>调整一下sql条件，查询条件改成age=23：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> ;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时，行事务3时，也会一直阻塞等待事务1释放锁。</p><p>也就是说，在forupdate语句中，使用普通字段作为查询条件时，加的是<strong>表锁</strong>，而并非行锁。</p><h3 id="空数据">空数据</h3><p>当where条件查询的数据不存在时，会发生什么呢？</p><p>开启一个事务1，在事务中更新id=66的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">66</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">66</span> ;<br></code></pre></td></tr></table></figure><p>这条数据是不存在的。</p><p>此时，开启了另外一个事务2，也更新id=66的用户的年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">23</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">66</span> ;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>执行结果： <imgsrc="/img/MySQL/495c7155-c901-47bd-a0ce-cd4b5f3a86f9.png" alt="img" />执行成功了，说明这种情况<strong>没有加锁</strong>。</p><h3 id="总结-2">总结</h3><p>最后给大家总结一下select...for update加锁的情况：</p><ol type="1"><li>主键字段：加行锁。</li><li>唯一索引字段：加行锁。</li><li>普通索引字段：加行锁。</li><li>主键范围：加多个行锁。</li><li>普通字段：加表锁。</li><li>查询空数据：不加锁。</li></ol><p>如果事务1加了行锁，一直没有释放锁，事务2操作相同行的数据时，会一直等待直到超时。</p><p>如果事务1加了表锁，一直没有释放锁，事务2不管操作的是哪一行数据，都会一直等待直到超时。</p><h3 id="索引下推">索引下推</h3><p>索引下推(Index ConditionPushdown，简称ICP)，是MySQL5.6版本的新特性，它能<strong>减少回表查询次数</strong>，提高查询效率。</p><h4 id="索引下推优化的原理">索引下推优化的原理</h4><p>我们先简单了解一下MySQL大概的架构：</p><figure><img src="/img/MySQL/20210908213037.png" alt="MySQL大概架构" /><figcaption aria-hidden="true">MySQL大概架构</figcaption></figure><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录（回表一次）；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件（回表第二次）。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（回表一次）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。、</li></ul><h4 id="什么时候会触发索引下推">什么时候会触发索引下推</h4><ol type="1"><li><p><strong>查询类型</strong>：只有使用了<strong>非聚簇索引</strong>的查询才可能触发ICP。这是因为在聚簇索引中，索引与数据行是紧密耦合的，所以没有额外的检索步骤。</p></li><li><p><strong>WHERE子句的结构</strong>：当查询的WHERE子句中的一部分可以使用索引进行过滤，而另一部分则不能时，ICP最有可能被触发。在这种情况下，可以使用索引的部分首先进行过滤，然后应用余下的条件。</p></li></ol><p>例如，考虑一个包含<code>first_name</code>和<code>last_name</code>的复合索引。以下查询可能会触发ICP：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> first_name = <span class="hljs-string">&#x27;John&#x27;</span> <span class="hljs-keyword">AND</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Smi%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>first_name</code>的等值比较可以直接用索引进行过滤，而<code>last_name</code>的LIKE操作可能会触发ICP，这样只有满足<code>first_name</code>条件的索引条目才会进一步检查<code>last_name</code>。</p><ol start="3" type="1"><li><p><strong>存储引擎</strong>：不是所有的存储引擎都支持ICP。例如，InnoDB和MEMORY存储引擎支持ICP，而MyISAM则不支持。</p></li><li><p><strong>EXPLAIN输出</strong>：当怀疑ICP可能对查询有益时，可以使用EXPLAIN命令来查看查询的执行计划。如果ICP被使用，你会在<code>Extra</code>列看到“Usingindex condition”。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统">操作系统</h1><h2 id="进程线程和协程的区别和联系">进程、线程和协程的区别和联系</h2><table><thead><tr class="header"><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr class="odd"><td>定义</td><td>进程是资源分配和拥有的基本单位</td><td>线程是程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr class="even"><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr class="odd"><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr class="even"><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态（没有陷入内核）</td></tr><tr class="odd"><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr class="even"><td>资源拥有</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr class="odd"><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr class="even"><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr class="odd"><td>通信方式</td><td>进程间通信方式多，如管道、消息队列、共享内存、信号量等</td><td>线程间通信方式少，可以通过直接读写进程数据段(如全局变量)来进行通信</td><td>协程间可以通过共享内存、消息队列等方式进行通信</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">note</p><ol><li>进程是资源分配的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</li><li>线程是资源调度的基本单位，也是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</li><li>协程是用户态的轻量级线程，线程内部调度的基本单位</li></ol></div><h2id="进程和线程比较进程和线程的区别">进程和线程比较？/进程和线程的区别？</h2><ol type="1"><li>线程的启动速度快，轻量级，系统开销小，但使用有一定难度，需要处理数据一致性问题。同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈。</li><li><strong>调度</strong>：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li><li><strong>并发性</strong>：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li><li><strong>拥有资源</strong>：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li><li><strong>系统开销</strong>：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</li></ol><h3 id="协程切换需要保存哪些东西">协程切换需要保存哪些东西</h3><p>协程切换只涉及基本的CPU上下文切换，所谓的 CPU上下文，就是一堆寄存器，里面保存了CPU运行任务所需要的信息：从哪里开始运行（<strong>%rip：指令指针寄存器</strong>，标识CPU 运行的下一条指令），栈顶的位置（<strong>%rsp：是堆栈指针寄存器</strong>，通常会指向栈顶位置），当前栈帧在哪（<strong>%rbp是栈帧指针，用于标识当前栈帧的起始位置</strong>）以及<strong>其它的CPU的中间状态或者结果（%rbx，%r12，%r13，%14，%15等等</strong>）。协程切换非常简单，就是把当前协程的 CPU寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU寄存器上就 ok了。而且完全在用户态进行，一般来说一次协程上下文切换最多就是几十ns这个量级。</p><h2id="一个进程可以创建多少线程和什么有关">一个进程可以创建多少线程，和什么有关？</h2><ul><li>如果是32 位系统，<strong>用户态的虚拟空间只有3G</strong>，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建300 个左右的线程。</li><li>如果是64 位系统，<strong>用户态的虚拟空间大到有128T</strong>，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li></ul><p>顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁。</p><h2 id="外中断和异常有什么区别">外中断和异常有什么区别？</h2><p><strong>外中断是指由 CPU 执行指令以外的事件引起</strong>，如 I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。而<strong>异常是由CPU执行指令的内部事件引起</strong>，如非法操作码、地址越界、算术溢出等</p><h2 id="进程线程模型你知道多少">进程线程模型你知道多少？</h2><h3 id="多线程">多线程</h3><p>这里讨论的是<strong>用户态</strong>的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量inti =10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p><p>我们必须知道，<strong>做一次简单的i = i +1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节</strong>，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p><p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p><p>而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><h3 id="多进程">多进程</h3><p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：<strong>代码段、堆栈段、数据段</strong>。代码段是静态的二进制代码，多个程序可以共享。</p><p>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p><p>如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p><p>我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><div class="admonition note"><p class="admonition-title">进程创建方式</p><p>进程有两种创建方式，一种是操作系统创建的，一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程-&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt;shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></div><h2 id="进程调度算法你了解多少">进程调度算法你了解多少？</h2><h3 id="先来先服务-first-come-first-serverdfcfs">1. 先来先服务first-come first-serverd（FCFS）</h3><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h3 id="短作业优先-shortest-job-firstsjf">2. 短作业优先 shortest jobfirst（SJF）</h3><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h3 id="最短剩余时间优先-shortest-remaining-time-nextsrtn">3.最短剩余时间优先 shortest remaining time next（SRTN）</h3><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p><p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="时间片轮转">4. 时间片轮转</h3><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU时间分配给队首进程，该进程可以执行一个时间片。</p><p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证，时间片过长的时候也会退化为先来先服务。</li></ul><h3 id="优先级调度">5. 优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h3 id="多级反馈队列">6. 多级反馈队列</h3><p>一个进程需要执行 100个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p><p>这种方式下，之前的进程只需要交换 7次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是<strong>时间片轮转调度算法和优先级调度算法的结合</strong>。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220000527.png"alt="多级反馈队列" /><figcaption aria-hidden="true">多级反馈队列</figcaption></figure><h2 id="linux下进程间通信方式">Linux下进程间通信方式？</h2><ul><li>管道：<ul><li>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</li></ul></li><li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<strong>共享内存是最快的IPC方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</li><li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li><li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl +C就是信号。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</li></ul><h2 id="linux下同步机制">Linux下同步机制？</h2><ul><li>POSIX信号量：可用于进程同步，也可用于线程同步。</li><li>POSIX互斥锁 + 条件变量：只能用于线程同步。</li></ul><h2id="如果系统中具有快表后那么地址的转换过程变成什么样了">如果系统中具有快表后，那么地址的转换过程变成什么样了？</h2><ol type="1"><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</li></ol><h2 id="内存交换和覆盖有什么区别">内存交换和覆盖有什么区别？</h2><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。</p><h2 id="动态分区分配算法有哪几种">动态分区分配算法有哪几种？</h2><h3 id="首次适应算法">1. 首次适应算法</h3><p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p><figure><img src="/img/C++八股文/操作系统/首次适应算法.png"alt="首次适应算法" /><figcaption aria-hidden="true">首次适应算法</figcaption></figure><ul><li><strong>优点</strong>：保留了高地址部分的大空闲区，为以后到达的大作业分配大的内存空间创造了条件。</li><li><strong>缺点</strong>：低地址不断被划分，容易产生小的内存碎片，每次查找都从低址开始增加了系统开销。</li></ul><h3 id="最佳适应算法">2. 最佳适应算法</h3><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p><p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。</p><figure><img src="/img/C++八股文/操作系统/最佳适应算法.png"alt="最佳适应算法" /><figcaption aria-hidden="true">最佳适应算法</figcaption></figure><ul><li><strong>优点</strong>：保留了大的空闲区，为以后到达的大作业分配大的内存空间创造了条件。</li><li><strong>缺点</strong>：容易产生很多无法利用的外部碎片。</li></ul><h3 id="最坏适应算法">3. 最坏适应算法</h3><p>又称最大适应算法(Largest Fit)</p><p>算法思想:为了解决最佳适应算法的问题————即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。</p><figure><img src="/img/C++八股文/操作系统/最坏适应算法.png"alt="最坏适应算法" /><figcaption aria-hidden="true">最坏适应算法</figcaption></figure><ul><li><strong>优点</strong>：<ul><li>可使剩下的空闲分区不至于太小，产生外部碎片的可能性更小，对中小作业有利</li><li>查找效率高，先找最大的，若最大不满足，就直接失败</li></ul></li><li><strong>缺点</strong>：可能会导致空白存储链中缺少大容量的空白内存块，当大容量作业进入时无法满足。</li></ul><h3 id="循环首次适应算法">4. 循环首次适应算法</h3><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><figure><img src="/img/C++八股文/操作系统/循环首次适应.png"alt="循环首次适应" /><figcaption aria-hidden="true">循环首次适应</figcaption></figure><div class="admonition info"><p class="admonition-title">info</p><p><strong>首次适应不仅最简单，通常也是最好最快</strong>，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。<strong>循环首次算法</strong>试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p><p>最佳导致大量碎片，最坏导致没有大的空间。</p><p>经过实验，首次适应比最佳适应要好，他们都比最坏好。</p></div><table><thead><tr class="header"><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序</td><td></td></tr><tr class="even"><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr class="odd"><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少内存碎片的产生</td><td>大分区容易被用完，不利于大进程;算法开销大(原因同上)</td></tr><tr class="even"><td>循环首次适应</td><td>每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)</td><td>不用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h2 id="虚拟技术你了解吗">虚拟技术你了解吗？</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：<strong>时（时间）分复用技术</strong>和<strong>空（空间）分复用技术</strong>。</p><p><strong>多进程与多线程是时分复用技术</strong>，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。<strong>虚拟内存是空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h2 id="进程状态的切换你知道多少">进程状态的切换你知道多少？</h2><figure><img src="/img/C++八股文/操作系统/进程状态切换.png"alt="进程状态切换" /><figcaption aria-hidden="true">进程状态切换</figcaption></figure><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><div class="admonition attention"><p class="admonition-title">attention</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul></div><h2id="一个cc程序从开始编译到生成可执行文件的完整过程你能说出来多少">一个C/C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h2><ol type="1"><li><strong>预编译</strong>:主要处理源代码文件中的以<code>#</code>开头的预编译指令。处理规则见下<ol type="1"><li>删除所有的<code>#define</code>，展开所有的宏定义。</li><li>处理所有的条件预编译指令，如<code>#if</code>、<code>#endif</code>、<code>#ifdef</code>、<code>#elif</code>和<code>#else</code>。</li><li>处理<code>#include</code>预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li><li>删除所有的注释，<code>//</code>和<code>/**/</code>。</li><li>保留所有的<code>#pragma</code>编译器指令，编译器需要用到他们，如：<code>#pragma once</code>是为了防止有文件被重复引用。</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</li></ol></li><li><strong>编译</strong>:把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。<ol type="1"><li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li><li>优化：源代码级别的一个优化过程。</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li></ol></li><li><strong>汇编</strong>:将汇编代码转变成机器可以执行的指令(机器码文件)。汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</li><li>链接:将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为<strong>静态链接</strong>和<strong>动态链接</strong>：<ol type="1"><li>静态链接：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。但是其相对动态链接有以下几个缺点：<ol type="1"><li><strong>空间浪费</strong>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li><li><strong>更新困难</strong>：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li></ol></li><li><strong>动态链接</strong>：动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。有以下特点：<ol type="1"><li><strong>共享库</strong>：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</li><li><strong>更新方便</strong>：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li><li><strong>性能损耗（缺点）</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li></ol></li></ol></li></ol><h2id="通过例子讲解逻辑地址转换为物理地址的基本过程">通过例子讲解逻辑地址转换为物理地址的基本过程</h2><p>可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意:页面大小是2的整数幂设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p><figure><img src="/img/C++八股文/操作系统/逻辑地址转物理地址过程.png"alt="逻辑地址转物理地址过程" /><figcaption aria-hidden="true">逻辑地址转物理地址过程</figcaption></figure><h2 id="进程同步的四种方法">进程同步的四种方法？</h2><h3 id="临界区">1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">// entry section<br>// critical section;<br>// exit section<br></code></pre></td></tr></table></figure><h3 id="同步与互斥">2. 同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区</li></ul><h3 id="信号量">3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up操作，也就是常见的 P 和 V 操作。</p><ul><li>P : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于0，进程睡眠，等待信号量大于 0；</li><li>V ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>PV操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0表示临界区已经加锁，1 表示临界区解锁。</p><h3 id="管程">4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal语言来描述管程。示例代码的管程提供了 insert() 和 remove()方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Pascal">monitor ProducerConsumer<br>    integer i;<br>    condition c;<br><br>    <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span>;</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">end</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span>;</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">end</span>;<br><span class="hljs-keyword">end</span> monitor;<br></code></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：wait() 和signal() 来实现同步操作。对条件变量执行 wait()操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal()操作用于唤醒被阻塞的进程。</p><p><strong>使用管程实现生产者-消费者问题</strong></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Pascal"><span class="hljs-comment">// 管程</span><br>monitor ProducerConsumer<br>    condition full, empty;<br>    integer count := <span class="hljs-number">0</span>;<br>    condition c;<br><br>    <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">insert</span><span class="hljs-params">(item: integer)</span>;</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> count = N <span class="hljs-keyword">then</span> wait(full);<br>        insert_item(item);<br>        count := count + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> count = <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> signal(empty);<br>    <span class="hljs-keyword">end</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>:</span> integer;<br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> count = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> wait(empty);<br>        remove = remove_item;<br>        count := count - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> count = N -<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> signal(full);<br>    <span class="hljs-keyword">end</span>;<br><span class="hljs-keyword">end</span> monitor;<br><br><span class="hljs-comment">// 生产者客户端</span><br><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">producer</span></span><br><span class="hljs-function"><span class="hljs-title">begin</span></span><br><span class="hljs-function">    <span class="hljs-title">while</span> <span class="hljs-title">true</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">    <span class="hljs-title">begin</span></span><br><span class="hljs-function">        <span class="hljs-title">item</span> = <span class="hljs-title">produce_item</span>;</span><br>        ProducerConsumer.insert(item);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">// 消费者客户端</span><br><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">consumer</span></span><br><span class="hljs-function"><span class="hljs-title">begin</span></span><br><span class="hljs-function">    <span class="hljs-title">while</span> <span class="hljs-title">true</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">    <span class="hljs-title">begin</span></span><br><span class="hljs-function">        <span class="hljs-title">item</span> = <span class="hljs-title">ProducerConsumer</span>.<span class="hljs-title">remove</span>;</span><br>        consume_item(item);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h2id="操作系统在对内存进行管理的时候需要做些什么">操作系统在对内存进行管理的时候需要做些什么?</h2><ul><li>操作系统负责<strong>内存空间的分配与回收</strong>。</li><li>操作系统需要提供某种技术从逻辑上对<strong>内存空间进行扩充</strong>。</li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换。</li><li>操作系统需要提供<strong>内存保护功能</strong>。保证各进程在各自存储空间内运行，互不干扰</li></ul><h2 id="进程间通信有哪几种方式">进程间通信有哪几种方式？</h2><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p><h3 id="管道">管道</h3><ul><li>无名管道<ul><li>特点：<ul><li>无名管道是一种特殊的文件，这种文件只存在于内存中。</li><li>无名管道只能用于父子进程或兄弟进程之间，<strong>必须用于具有亲缘关系的进程间的通信</strong>。</li><li>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</li></ul></li><li>相关接口：<ul><li>int pipe(int fd[2]);<ul><li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li></ul></li></ul></li></ul></li><li>有名管道<ul><li>有名管道特点：<ul><li>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</li><li>有名管道<strong>可以在不具有亲缘关系的进程间进行通信</strong>。</li></ul></li><li>相关接口：<ul><li>int mkfifo(const char *pathname, mode_t mode);<ul><li>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</li><li>mode：和open()中的参数相同。</li></ul></li></ul></li></ul></li></ul><h3 id="消息队列">消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO那样只能默认地接收。</li></ul><h3 id="共享内存">共享内存</h3><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p><div class="admonition note"><p class="admonition-title">note</p><p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p><p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p></div><h3 id="信号量-1">信号量</h3><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEMV信号量。</p><h3 id="辅助命令">辅助命令</h3><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p><ul><li>ipcs -a：列出共享内存、信号量和消息队列信息。</li><li>ipcs -l：列出系统限额。</li><li>ipcs -u：列出当前使用情况。</li></ul><h3 id="套接字">套接字</h3><p>与其它通信机制不同的是，它<strong>可用于不同机器间的进程通信</strong>。</p><h2 id="虚拟内存的目的是什么">虚拟内存的目的是什么？</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p><p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p><p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个64K 大小的程序。</p><p><img src="/img/C++八股文/操作系统/虚拟内存.png" /></p><h2id="说一下你理解中的内存他有什么作用呢">说一下你理解中的内存？他有什么作用呢？</h2><figure><img src="/img/C++八股文/操作系统/内存的理解.png" alt="内存的理解" /><figcaption aria-hidden="true">内存的理解</figcaption></figure><h2 id="哲学家进餐问题">哲学家进餐问题</h2><p>防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h2 id="介绍一下几种典型的锁">介绍一下几种典型的锁？</h2><h3 id="读写锁">读写锁</h3><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><h3 id="自旋锁">自旋锁</h3><p>线程<strong>抢锁失败不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止</strong>。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是因为<strong>自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁</strong>。</p><h3 id="互斥锁">互斥锁</h3><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在<strong>抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒</strong>，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p><h3 id="条件变量">条件变量</h3><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制</strong>。</p><h2 id="逻辑地址vs物理地址">逻辑地址VS物理地址</h2><ul><li>逻辑地址：由 CPU生成的虚拟地址。它是在程序执行期间由进程使用的地址。当程序员编写代码时，他们引用的是逻辑地址，而不用关心实际物理内存中数据的位置。逻辑地址空间通常比实际物理内存大，因为它可以包含虚拟内存和其他映射区域。操作系统使用内存管理单元（MMU）将逻辑地址映射到物理地址。</li><li>物理地址：这是在计算机的实际物理内存中的地址。它是 RAM中存储数据的确切位置。CPU通过内存管理单元（MMU）将逻辑地址转换为对应的物理地址，以便正确访问内存中的数据。</li></ul><p>简而言之，<strong>逻辑地址是程序员和进程所看到的抽象地址，而物理地址是实际存储器硬件中的地址。内存管理单元负责将逻辑地址转换为物理地址，以实现正确的内存访问</strong>。</p><h2 id="怎么回收线程有哪几种方法">怎么回收线程？有哪几种方法？</h2><ol type="1"><li><p>等待线程结束： int pthread_join(pthread_t tid, void**retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li>tid：创建线程时通过指针得到tid值。</li><li>retval：指向返回值的指针。</li></ul></li><li><p>结束线程： void pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程： int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ol><h2 id="内存的覆盖是什么有什么特点">内存的覆盖是什么？有什么特点？</h2><p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把<strong>用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区</strong>，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p><p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p><h2 id="内存交换是什么有什么特点">内存交换是什么？有什么特点？</h2><p>交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p><p>换入：把准备好竞争CPU运行的程序从辅存移到内存。换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p><h2 id="什么时候会进行内存的交换">什么时候会进行内存的交换？</h2><p>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p><h2id="终端退出终端运行的进程会怎样">终端退出，终端运行的进程会怎样</h2><p>终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p><h2 id="如何让进程后台运行">如何让进程后台运行</h2><ol type="1"><li>命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</li><li>ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</li><li>nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out文件中，忽略所有挂断（SIGHUP）信号</li><li>运行指令前面 +setsid，使其父进程编程init进程，不受HUP信号的影响</li><li>将 命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</li></ol><h2id="什么是快表你知道多少关于快表的知识">什么是快表，你知道多少关于快表的知识？</h2><p>快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212343703.png"alt="快表" /><figcaption aria-hidden="true">快表</figcaption></figure><h2id="地址变换中有快表和没快表有什么区别">地址变换中，有快表和没快表，有什么区别？</h2><table><thead><tr class="header"><th></th><th>地址变换过程</th><th>访问一个逻辑地址的访存次数</th></tr></thead><tbody><tr class="odd"><td>不具有快表的地址变换机构</td><td>①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元</td><td>两次访存</td></tr><tr class="even"><td>具有快表的地址变换机构</td><td>①算页号、页内偏移量 ②检查页号合法性③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④④查页表，找到页面存放的内存块号，并且将页表项复制到快表中⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元</td><td>快表命中，只需一次访存 快表未命中，需要两次访存</td></tr></tbody></table><h2id="在执行malloc申请内存的时候操作系统是怎么做的">在执行malloc申请内存的时候，操作系统是怎么做的？</h2><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p><ul><li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小.这些内存释放后并不会立刻归还系统，而是被缓存起来，重复使用。<ul><li>优缺点：<strong>mmap()</strong> 方式可以将内存及时返回给系统，避免OOM。但是工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是malloc 只对大块内存使用 mmap 的原因。</li></ul></li><li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。<strong>mmap()</strong>方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。<ul><li>优缺点：<strong>mmap()</strong> 方式可以将内存及时返回给系统，避免OOM。但是工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是malloc 只对大块内存使用 mmap 的原因。</li></ul></li></ul><p>通常，<strong>分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存</strong>。</p><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p><h2 id="守护进程僵尸进程和孤儿进程">守护进程、僵尸进程和孤儿进程</h2><h3 id="守护进程">守护进程</h3><p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等。</p><p>创建守护进程的要点：</p><ol type="1"><li>让程序在后台执行。方法是调用fork()产生一个子进程，然后使父进程退出。</li><li>调用setsid()创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid()使进程成为一个会话组长。setsid()调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</li><li>禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork()创建新的子进程，使调用fork的进程退出。</li><li>关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</li><li>将当前目录更改为根目录。</li><li>子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask(0)将屏蔽字清零。</li><li>处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。</li></ol><h3 id="孤儿进程">孤儿进程</h3><p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><h3 id="僵尸进程">僵尸进程</h3><p><strong>僵尸进程</strong>是指一个已经终止执行的进程，但其父进程尚未调用<code>wait()</code> 或 <code>waitpid()</code>等系统调用来获取该进程的终止状态。在这种状态下，进程虽然已经结束，但系统仍然保留其进程描述符和部分信息。</p><p>设置<strong>僵尸进程的目的</strong>是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p><h2id="局部性原理你知道吗主要有哪两大局部性原理各自是什么">局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h2><p>主要分为<strong>时间局部性和空间局部性</strong>。</p><p><strong>时间局部性</strong>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p><p><strong>空间局部性</strong>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344455.png"alt="局部性原理" /><figcaption aria-hidden="true">局部性原理</figcaption></figure><h2id="父进程子进程进程组作业和会话">父进程、子进程、进程组、作业和会话</h2><h3 id="父进程">父进程</h3><p>已创建一个或多个子进程的进程</p><h3 id="子进程">子进程</h3><p>由fork创建的新进程被称为子进程（childprocess）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。</p><p>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p><div class="admonition info"><p class="admonition-title">info</p><p>子进程从父进程继承的有：</p><p>1.进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))2.环境(environment) 3.堆栈 4.内存 5.进程组号</p><p>子进程独有：</p><p>1.进程号；2.不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同，父进程号可由getppid函数得到)； 3.资源使用(resource utilizations)设定为0</p></div><h3 id="进程组">进程组</h3><p>进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。</p><h3 id="作业">作业</h3><p>shell分前后台来控制的不是进程而是作业（job）或者进程组（ProcessGroup）。</p><p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。</p><h3 id="为什么只能运行一个前台作业">为什么只能运行一个前台作业？</h3><p>当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</p><p>作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组。</p><h3 id="会话">会话</h3><p>会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p><h2 id="进程终止的几种方式">进程终止的几种方式</h2><ol type="1"><li>main函数的自然返回，<code>return</code></li><li>调用<code>exit</code>函数，属于c的函数库</li><li>调用<code>_exit</code>函数，属于系统调用</li><li>调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程。</li></ol><p><strong>exit和_exit的区别</strong>:</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344845.png"alt="exit和_exit的区别" /><figcaption aria-hidden="true">exit和_exit的区别</figcaption></figure><h2 id="linux中异常和中断的区别">Linux中异常和中断的区别</h2><h3 id="中断"><strong>中断</strong></h3><p>当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断大多数是由硬件设备产生的，而它们<strong>从物理上说就是电信号</strong>，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344538-17031598211726.png"alt="中断处理的流程" /><figcaption aria-hidden="true">中断处理的流程</figcaption></figure><p><strong>软件中断与软中断</strong>除了硬件中断，还存在部分由软件产生的中断，称之为软件中断（SoftwareInterrupt），最常见的有引发系统调用的Int0x80。同时，软件中断又区别于软中断（SoftIRQ），软中断主要用于中断处理的下半程（BottomHalves），非关键逻辑的部分，来提高中断处理的效率与实时性，最常用于I/O相关的中断处理。处理中断下半程的方法除了软中断，还有tasklet，二者存在一定的区别与联系：</p><ul><li>二者都可以被注册用于中断处理下半程的延时任务；</li><li>同一种类型的tasklet只能串行执行，而同类型的软中断可以多个CPU并发执行，不同类型的软中断和tasklet均可并发执行；</li><li>tasklet底层是基于两种软中断来实现的，分别是HI_SOFTIRQ和TASKLET_SOFTIRQ；</li></ul><h3 id="异常">异常</h3><p>我们在学习《计算机组成原理》的时候会知道两个概念，CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以需要记住的是，<strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong>，下面这张图显示了异常处理的流程：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344494.png"alt="异常" /><figcaption aria-hidden="true">异常</figcaption></figure><h3 id="异同"><strong>异同</strong></h3><ul><li>相同点：<ul><li>处理程序的流程设计上是相似的</li><li>最后都是由CPU发送给内核，由内核去处理</li></ul></li><li>不同点：<ul><li>产生源不相同，异常是由CPU产生的，而中断主要是由硬件设备产生的</li><li>内核需要根据是异常还是中断调用不同的处理程序</li><li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li><li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li></ul></li></ul><h2id="windows和linux环境下内存分布情况">Windows和Linux环境下内存分布情况</h2><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344868.png"alt="内存分布情况" /><figcaption aria-hidden="true">内存分布情况</figcaption></figure><p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 7种不同的内存段：</p><ul><li>程序文件段，包括二进制可执行代码；</li><li>已初始化数据段，包括静态常量；</li><li>未初始化数据段，包括未初始化的静态变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是<code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li></ul><h2id="一个由cc编译的程序占用的内存分为哪几个部分">一个由C/C++编译的程序占用的内存分为哪几个部分？</h2><ol type="1"><li>栈区（stack）—地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的数据结构中的栈，先进后出。</li><li>堆区（heap）—地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li><li>全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束后有系统释放</li><li>文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放</li><li>程序代码区(text)—存放函数体的二进制代码。</li></ol><h2id="一般情况下在linuxwindows平台下栈空间的大小">一般情况下在Linux/windows平台下栈空间的大小</h2><p>Linux环境下由操作系统决定，一般是8MB，8192KB，通过<code>ulimit</code>命令查看以及修改</p><p>Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，VC++6.0一般是1M</p><p>在Linux下通过如下命令可查看和设置栈的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ulimit -a            # 显示当前栈的大小 （ulimit为系统命令，非编译器命令）<br>ulimit -s 32768      # 设置当前栈的大小为32M<br></code></pre></td></tr></table></figure><p><strong>VC6.0中修改堆栈大小的方法</strong>：</p><ul><li>选择 "Project-&gt;Setting"</li><li>选择 "Link"</li><li>选择 "Category"中的 "Output"</li><li>在 "Stack allocations"中的"Reserve:"中输栈的大小</li></ul><h2 id="常见的几种磁盘调度算法">常见的几种磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间占比最大，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h3 id="先来先服务">先来先服务</h3><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="最短寻道时间优先">最短寻道时间优先</h3><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现<strong>饥饿现象</strong>。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344899.png"alt="最短寻道时间" /><figcaption aria-hidden="true">最短寻道时间</figcaption></figure><h3 id="scan">SCAN</h3><p>磁头在当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF的饥饿问题。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212344070.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="cscan">CSCAN</h3><p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。</p><h2 id="交换空间与虚拟内存的关系">交换空间与虚拟内存的关系</h2><h3 id="交换空间"><strong>交换空间</strong></h3><p>Linux 中的交换空间（Swapspace）在<strong>物理内存</strong>（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。交换空间的总大小应该相当于你的计算机内存的两倍和 32MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。</p><h3 id="虚拟内存"><strong>虚拟内存</strong></h3><p>虚拟内存是文件数据交叉链接的活动文件。是WINDOWS目录下的一个"WIN386.SWP"文件，这个文件会不断地扩大和自动缩小。就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是<strong>虚拟内存使用的是硬盘的空间</strong>，为什么我们要使用速度最慢的硬盘来做为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M/512M内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。</p><h2id="抖动你知道是什么吗它也叫颠簸现象">抖动你知道是什么吗？它也叫颠簸现象</h2><p><strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动</strong>，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集”的概念</p><h2id="从堆和栈上建立对象哪个快考察堆和栈的分配效率比较">从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</h2><p><strong>建立对象</strong>：堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。</p><div class="admonition info"><p class="admonition-title">堆和栈对象的访问时间</p><p>建立对象后访问时间来说，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</p></div><h2 id="常见内存分配方式有哪些">常见内存分配方式有哪些？</h2><h3 id="程序内存分配方式"><strong>程序内存分配方式</strong></h3><ol type="1"><li>从<strong>静态存储区域分配</strong>。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</li><li>在<strong>栈</strong>上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</li></ol><h3id="操作系统的内存分配方式"><strong>操作系统的内存分配方式</strong></h3><h4 id="连续分配">连续分配</h4><p>连续分配方式出现的时间比较早，曾广泛应用于20世纪60~70年代的OS中，但是它至今仍然在内存管理方式中占有一席之地，原因在于它实现起来比较方便，所需的硬件支持最少。连续分配方式又可细分为四种：<strong>单一连续分配、固定分区分配、动态分区分配和动态重定位分区分配</strong>。</p><p>其中<strong>固定分区分配方式</strong>，因为分区固定，所以缺乏灵活性，即当程序太小时，会造成内存空间的浪费（内部碎片）；程序太大时，一个分区又不足以容纳，致使程序无法运行。但尽管如此，当一台计算机去控制多个相同对象的时候，由于这些对象内存大小相同，所以完全可以采用这种内存管理方式，而且是最高效的。这里我们可以看出存储器管理机制的多面性：即没有那种存储器管理机制是完全没有用的，在适合的场合下，一种被认为最不合理的分配方案却可能称为最高效的分配方案。一切都要从实际问题出发，进行设计。</p><p>为了解决固定分区分配方式的缺乏灵活性，出现了<strong>动态分配方式</strong>。动态分配方式采用一些寻表的方式，查找能符合程序需要的空闲内存分区。但代价是增加了系统运行的开销，而且内存空闲表本身是一个文件，必然会占用一部分宝贵的内存资源，而且有些算法还会增加<strong>内存碎片</strong>。</p><p><strong>可重定位分区分配</strong>通过对程序实现成定位，从而可以将内存块进行搬移，将小块拼成大块，将小空闲“紧凑”成大空闲，腾出较大的内存以容纳新的程序进程。但是拼凑过程的开销较大。</p><h4 id="基本分页存储管理方式">基本分页存储管理方式</h4><p>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)，也同样为它们加以编号，如0#块、1#块等等。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。<strong>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</strong></p><p>在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块。为此，系统又为每个进程建立了一张<strong>页面映射表</strong>，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的<strong>作用是实现从页号到物理块号的地址映射（逻辑地址向物理地址的映射）</strong>。</p><p>页表的功能可由一组专门的寄存器来实现。由于寄存器成本较高，且大多数现代计算机的页表又很大，使页表项总数可达几千甚至几十万个，显然这些页表项不可能都用寄存器来实现，因此，页表大多驻留在内存中。因为一个进程可以通过它的PCB来时时保存自己的状态，等到CPU要处理它的时候才将PCB交给寄存器，所以，系统中虽然可以运行多个进程，但也只需要一个页表寄存器就可以了。</p><p>由于页表是存放在内存中的，这使得CPU在每存取一个数据时，都要两次访问内存。为了提高地址变换速度，在地址变化机构中增设了一个具有并行查询能力的缓冲寄存器，又称为“<strong>联想寄存器</strong>”（TLB）或<strong>快表</strong>。</p><p>在单级页表的基础上，为了适应非常大的逻辑地址空间，出现了两级和多级页表，但是，他们的原理和单级页表是一样的，只不过为了适应地址变换层次的增加，需要在地址变换机构中增设外层的页表寄存器。</p><h4 id="基本分段存储管理方式">基本分段存储管理方式</h4><p>分段存储管理方式的目的，主要是为了满足用户（程序员）在编程和使用上多方面的要求，其中有些要求是其他几种存储管理方式所难以满足的。</p><ol type="1"><li>方便编程：通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。</li><li>信息共享：分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储器管理能与用户程序分段的组织方式相适应。</li><li>信息保护：信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便的实现信息保护功能。</li><li>动态增长：在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前面的几种存储管理方式都难以应付这种动态增长的情况，分段存储管理方式能较好的解决这一问题。</li><li>动态链接：动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</li></ol><h4 id="段页式存储管理方式">段页式存储管理方式</h4><p>前面所介绍的分页和分段存储管理方式都各有优缺点。分页系统能有效地提高内存利用率，而分段系统则能很好地满足用户需求。我们希望能够把两者的优点结合，于是出现了段页式存储管理方式。</p><p>段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，地址结构由段号、段内页号和页内地址三部分所组成。和前两种存储管理方式相同，段页式存储管理方式同样需要增设联想寄存器（TLB）。</p><h2 id="分页和分段的主要区别">分页和分段的主要区别</h2><p>分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换。但在概念上两者完全不同，主要表现在3个方面：</p><ol type="1"><li>页是信息的物理单位，分页是为实现离散分配方式，<strong>消减外部碎片</strong>，提高内存的利用率（没有外部碎片）。分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好的满足用户的需要。</li><li>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而<strong>段的长度不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li></ol><h2 id="常见内存分配内存错误">常见内存分配内存错误</h2><ol type="1"><li><strong>内存分配未成功，却使用了它</strong>:编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL)或if(p!=NULL)进行防错处理。</li><li><strong>内存分配虽然成功，但是尚未初始化就引用它</strong>:犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li><li><strong>内存分配成功并且已经初始化，但操作越过了内存的边界</strong>:内存分配成功并且已经初始化，但操作越过了内存的边界。</li><li><strong>忘记了释放内存，造成内存泄露</strong>:含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li><li><strong>释放了内存却继续使用它。常见于以下有三种情况：</strong><ol type="1"><li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li><li>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li><li>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”</li></ol></li></ol><h2id="内存交换中被换出的进程保存在哪里">内存交换中，被换出的进程保存在哪里？</h2><p><strong>保存在磁盘中，也就是外存中</strong>。具有<strong>对换功能</strong>的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</p><h2id="在发生内存交换时有些进程是被优先考虑的你可以说一说吗">在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</h2><p><strong>可优先换出阻塞进程</strong>;<strong>可换出优先级低的进程</strong>;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的<strong>驻留时间</strong>…(注意: PCB 会常驻内存，不会被换出外存)</p><h2id="asciiunicode和utf-8编码的区别">ASCII、Unicode和UTF-8编码的区别？</h2><p><strong>ASCII</strong>：ASCII只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</p><p><strong>Unicode</strong>：由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常<strong>两个字节表示一个字符</strong>，而<strong>ASCII是一个字节表示一个字符</strong>，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p><strong>UTF-8</strong>：为了解决上述问题，又出现了把Unicode编码转化为“<strong>可变长编码</strong>”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6个字节</strong>，<strong>英文字母被编码成一个字节，常用汉字被编码成三个字节</strong>，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</p><h3 id="三者之间的联系">三者之间的联系</h3><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><ol type="1"><li><p>在计算机<strong>内存中，统一使用Unicode编码</strong>，当需要保存到<strong>硬盘</strong>或者需要传输的时候，就转换为<strong>UTF-8编码</strong></p></li><li><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图（截取他人图片）</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345239.png"alt="各个编码之间关系" /><figcaption aria-hidden="true">各个编码之间关系</figcaption></figure></li></ol><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345501-17032452356814.png"alt="网页编码" /><figcaption aria-hidden="true">网页编码</figcaption></figure><h2 id="原子操作的是如何实现的">原子操作的是如何实现的</h2><p>处理器使用基于<strong>对缓存加锁</strong>或<strong>总线加锁</strong>的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><ol type="1"><li><p><strong>总线锁</strong></p><p>如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如下所示。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">CPU1 CPU2<br>i=1  i=1<br>i++  i++<br>i=2  i=2<br></code></pre></td></tr></table></figure></p><p>多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中,就会出现上面所示现象。</p><p>那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。处理器使用<strong>总线锁</strong>就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p></li><li><p><strong>缓存锁</strong></p><p>在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p><p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行。</strong></p><p>但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cacheline）时，则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Intel486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p></li></ol><h2id="内存交换你知道有哪些需要注意的关键点吗">内存交换你知道有哪些需要注意的关键点吗？</h2><ol type="1"><li>交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。</li><li>为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。</li><li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。</li><li>普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。</li></ol><h2 id="系统并发和并行">系统并发和并行</h2><p><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而<strong>并行</strong>则指同一时刻能运行多个指令。</p><p><strong>并行需要硬件支持</strong>，如多流水线、多核处理器或者分布式计算系统。<strong>操作系统通过引入进程和线程，使得程序能够并发运行</strong>。</p><h2 id="页面置换算法">页面置换算法</h2><h3 id="最佳置换法opt">最佳置换法(OPT)</h3><p>最佳置换算法(OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345108.png"alt="最佳置换算法" /><figcaption aria-hidden="true">最佳置换算法</figcaption></figure><div class="admonition info"><p class="admonition-title">info</p><p>OPT算法可以通过看未来使用的页面来决定当前置换出的页面，实际中是不可能做到的，因为我们不可能知道未来会用到哪些页面。</p></div><h3 id="先进先出置换算法fifo">先进先出置换算法(FIFO)</h3><p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong></p><p>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头。页面队列的最大长度取决于系统为进程分配了多少个内存块。</p><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345413.png"alt="FIFO-三个内存块" /><figcaption aria-hidden="true">FIFO-三个内存块</figcaption></figure><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345552.png"alt="FIFO-四个内存块" /><figcaption aria-hidden="true">FIFO-四个内存块</figcaption></figure><div class="admonition info"><p class="admonition-title">Belady异常</p><p>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p></div><p>​只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，FIFO算法性能差</p><h3 id="最近最久未使用置换算法lru">最近最久未使用置换算法(LRU)</h3><p>最近最久未使用置换算法(LRU，least recently used):每次淘汰的页面是<strong>最近最久未使用的页面</strong></p><p>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间<code>t</code>(该算法的实现需要专门的硬件支持，虽然<strong>算法性能好</strong>，但是<strong>实现困难</strong>，<strong>开销大</strong>)。当需要淘汰一个页面时，选择现有页面中<code>t</code>值最大的，即最近最久未使用的页面。</p><p>LRU性能较好，但<strong>需要寄存器和栈的硬件支持</strong>。<strong>LRU是堆栈类算法</strong>，理论上可以证明，堆栈类算法不可能出现Belady异常。</p><div class="admonition info"><p class="admonition-title">info</p><p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</p></div><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345619.png"alt="LRU算法" /><figcaption aria-hidden="true">LRU算法</figcaption></figure><h3 id="时钟置换算法clock">时钟置换算法(CLOCK)</h3><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。所以操作系统的设计者尝试了很多算法，试图<strong>用比较小的开销接近LRU的性能</strong>，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p><p>时钟置换算法是一种<strong>性能和开销较均衡</strong>的算法，又称CLOCK算法，或<strong>最近未用算法(NRU，NotRecently Used)</strong>.</p><p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，直到找到第一个访问位是0的页面然后换出。</p><div class="admonition info"><p class="admonition-title">info</p><p>因为是循环队列，如果队列当前全部页面访问位都是1，那么访问一轮之后全部都为0，继续向后访问，其实就是第一个访问的页面被换出。</p></div><figure><imgsrc="/img/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212345526.png"alt="CLOCK算法" /><figcaption aria-hidden="true">CLOCK算法</figcaption></figure><h3 id="改进型的时钟置换算法">改进型的时钟置换算法</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，<strong>如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</strong></p><h3 id="总结">总结</h3><table><thead><tr class="header"><th></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr class="odd"><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好;但无法实现</td></tr><tr class="even"><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单;但性能很差，可能出现Belady异常</td></tr><tr class="odd"><td>LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好;但需要硬件支持，算法开销大</td></tr><tr class="even"><td>CLOCK (NRU)</td><td>循环扫描各页面第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小;但未考虑页面是否被修改过。</td></tr><tr class="odd"><td>改进型CLOCK (改进型NRU)</td><td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0)第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0)第四轮:淘汰(0, 1)</td><td>算法开销较小，性能也不错</td></tr></tbody></table><h2 id="共享是什么">共享是什么？</h2><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h2 id="死锁相关问题">死锁相关问题</h2><p><strong>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。</strong></p><h3 id="产生原因">产生原因</h3><p>举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。</p><p>理论上认为死锁产生有以下<strong>四个必要条件</strong>，缺一不可：</p><ol type="1"><li><strong>互斥条件</strong>：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li><li><strong>不剥夺条件</strong>：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</li><li><strong>请求和保持条件</strong>：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li><li><strong>循环等待条件</strong>：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ol><h3 id="死锁演示">死锁演示</h3><p>通过代码的形式进行演示，需要两个线程和两个互斥量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>  <span class="hljs-comment">//引入互斥量头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//插入消息，模拟消息不断产生</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertMsg</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;插入一条消息:&quot;</span> &lt;&lt; i &lt;&lt; endl;<br>my_mutex1.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//语句1</span><br>my_mutex2.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//语句2</span><br>Msg.<span class="hljs-built_in">push_back</span>(i);<br>my_mutex2.<span class="hljs-built_in">unlock</span>();<br>my_mutex1.<span class="hljs-built_in">unlock</span>();<br>&#125;<br>&#125;<br><span class="hljs-comment">//读取消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readMsg</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> MsgCom;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>MsgCom = <span class="hljs-built_in">MsgLULProc</span>(i);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">MsgLULProc</span>(MsgCom)) &#123;<br><span class="hljs-comment">//读出消息了</span><br>cout &lt;&lt; <span class="hljs-string">&quot;消息已读出&quot;</span> &lt;&lt; MsgCom &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//消息暂时为空</span><br>cout &lt;&lt; <span class="hljs-string">&quot;消息为空&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//加解锁代码</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MsgLULProc</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;command)</span> </span>&#123;<br><span class="hljs-type">int</span> curMsg;<br>my_mutex2.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">//语句3</span><br>my_mutex1.<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">//语句4</span><br><span class="hljs-keyword">if</span> (!Msg.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-comment">//读取消息，读完删除</span><br>command = Msg.<span class="hljs-built_in">front</span>();<br>Msg.<span class="hljs-built_in">pop_front</span>();<br><br>my_mutex1.<span class="hljs-built_in">unlock</span>();<br>my_mutex2.<span class="hljs-built_in">unlock</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>my_mutex1.<span class="hljs-built_in">unlock</span>();<br>my_mutex2.<span class="hljs-built_in">unlock</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>std::list&lt;<span class="hljs-type">int</span>&gt; Msg;  <span class="hljs-comment">//消息变量</span><br>std::mutex my_mutex1; <span class="hljs-comment">//互斥量对象1</span><br>std::mutex my_mutex2; <span class="hljs-comment">//互斥量对象2</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>A a;<br><span class="hljs-comment">//创建一个插入消息线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">insertTd</span><span class="hljs-params">(&amp;A::insertMsg, &amp;a)</span></span>; <span class="hljs-comment">//这里要传入引用保证是同一个对象</span><br><span class="hljs-comment">//创建一个读取消息线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">readTd</span><span class="hljs-params">(&amp;A::readMsg, &amp;a)</span></span>; <span class="hljs-comment">//这里要传入引用保证是同一个对象</span><br>insertTd.<span class="hljs-built_in">join</span>();<br>readTd.<span class="hljs-built_in">join</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>语句1和语句2表示线程A先锁资源1，再锁资源2，语句3和语句4表示线程B先锁资源2再锁资源1，具备死锁产生的条件。</p><h3 id="死锁的解决方案">死锁的解决方案</h3><p>保证上锁的顺序一致。</p><h3 id="死锁必要条件">死锁必要条件</h3><ul><li>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li><li>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放</li><li>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li><li>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ul><h3 id="处理方法">处理方法</h3><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h4 id="鸵鸟策略"><strong>鸵鸟策略</strong></h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 <strong>Unix，Linux 和Windows</strong>，处理死锁问题的办法仅仅是忽略它。</p><h4 id="死锁检测与死锁恢复"><strong>死锁检测与死锁恢复</strong></h4><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><ol type="1"><li><p>每种类型一个资源的死锁检测</p><figure><imgsrc="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/202205212345141-170331929874913.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上图为资源分配图，其中<strong>方框表示资源</strong>，<strong>圆圈表示进程</strong>。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过<strong>检测有向图是否存在环来实现</strong>，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p></li><li><p>每种类型多个资源的死锁检测</p><figure><imgsrc="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/202205212345141-170332063527515.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1也可以执行。所有进程都可以顺利执行，没有死锁。</p><p><strong>算法总结如下</strong>：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol type="1"><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol></li></ol><h3 id="死锁恢复">死锁恢复</h3><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="死锁预防">死锁预防</h3><p>在程序运行之前预防发生死锁。</p><ol type="1"><li><p>破坏互斥条件</p><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p></li><li><p>破坏请求和保持条件</p><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p></li><li><p>破坏不剥夺条件</p><p>允许抢占资源</p></li><li><p>破环循环等待条件</p><p>给资源统一编号，进程只能按编号顺序来请求资源。</p></li></ol><h3 id="死锁避免">死锁避免</h3><p>在程序运行时避免发生死锁</p><ol type="1"><li><p>安全状态</p><figure><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/202205212345923.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free变为 5（图 c）；接着以同样的方式运行 C 和A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：<strong>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</strong></p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p></li><li><p>单个资源的银行家算法</p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><figure><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/202205212345716.png"alt="单个资源的银行家算法" /><figcaption aria-hidden="true">单个资源的银行家算法</figcaption></figure><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c中的状态。</p></li><li><p>多个资源的银行家算法</p><figure><imgsrc="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/202205212345258-170332226699720.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的E、P 以及 A分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p></li><li><p><strong>检查一个状态是否安全的算法如下</strong>：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p></li></ol><h2id="为什么分段式存储管理有外部碎片而无内部碎片为什么固定分区分配有内部碎片而不会有外部碎片">为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</h2><p>分段式分配是按需分配，而固定式分配是固定分配的方式。</p><h2 id="内部碎片与外部碎片">内部碎片与外部碎片</h2><p>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式</p><p>内存总量相同，100M</p><p>固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；</p><p>分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。</p><p>外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中</p><p>分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片</p><h2 id="如何消除外部碎片">如何消除外部碎片</h2><p>对于<strong>外部碎片，通过紧凑技术消除</strong>，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑。</p><h2id="冯诺依曼结构有哪几个模块分别对应现代计算机的哪几个部分百度安全一面">冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h2><ul><li><strong>存储器</strong>：内存</li><li><strong>控制器</strong>，<strong>运算器</strong>：共同组成CPU</li><li><strong>输入设备</strong>：键盘</li><li><strong>输出设备</strong>：显示器、网卡</li></ul><div class="admonition info"><p class="admonition-title">现代计算机结构和传统冯诺依曼结构的区别</p><p>现代计算机结构和传统冯诺依曼结构还是有一定区别的，传统冯诺依曼结构是把控制器和运算器分开，而现代计算机将运算器和控股之气放到一起，形成了<strong>中央处理器(CPU)</strong>。</p></div><h2id="多进程和多线程的区别是什么换句话说什么时候该用多线程什么时候该用多进程">多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</h2><ul><li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li><li>计算量：需要大量计算的优先使用<strong>多线程</strong>因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li><li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li><li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布用<strong>多线程</strong>。</li></ul><p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p><h2id="服务器高并发的解决方案你知道多少">服务器高并发的解决方案你知道多少？</h2><ul><li><strong>应用数据与静态资源分离</strong>：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</li><li><strong>客户端缓存</strong>：因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</li><li><strong>集群和分布式</strong>：<strong>集群</strong>是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用，<strong>分布式</strong>是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</li><li><strong>反向代理</strong>：在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li></ul><h3id="虚拟内存中分页算法是为了解决什么样的问题">虚拟内存中分页算法是为了解决什么样的问题</h3><p>解决连续长内存的分配问题</p><h3 id="cpu中断后进程的处理流程">cpu中断后进程的处理流程</h3><figure><imgsrc="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD-171120309605511.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式">设计模式</h1><h2 id="uml类图">UML类图</h2><p>类之间的关系通常是我们需要关心的，而我们可以通过UML类图来描述类之间的关系。UML类图中的关系有以下几种：</p><h3 id="泛化关系generalization">泛化关系(generalization)</h3><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a来表示，就是继承关系：(..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><figure><img src="/img/设计模式/泛化关系表示.jpg" alt="泛化关系表示" /><figcaption aria-hidden="true">泛化关系表示</figcaption></figure><p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p><figure><img src="/img/设计模式/泛化关系例子.jpg" alt="泛化关系例子" /><figcaption aria-hidden="true">泛化关系例子</figcaption></figure><h3 id="实现关系realization">实现关系(realization)</h3><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p><figure><img src="/img/设计模式/uml_realize.jpg" alt="实现关系" /><figcaption aria-hidden="true">实现关系</figcaption></figure><p>注：最终代码中，实现关系表现为继承抽象类；</p><h3 id="聚合关系aggregation">聚合关系(aggregation)</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><figure><img src="/img/设计模式/uml_aggregation.jpg" alt="聚合关系" /><figcaption aria-hidden="true">聚合关系</figcaption></figure><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；</p><h3 id="组合关系composition">组合关系(composition)</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><figure><img src="/img/设计模式/uml_composition.jpg" alt="组合关系" /><figcaption aria-hidden="true">组合关系</figcaption></figure><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如，公司不存在了，部门也将不存在了；</p><h3 id="关联关系association">关联关系(association)</h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构；所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但B不知道A；</p><figure><img src="/img/设计模式/uml_association.jpg" alt="关联关系" /><figcaption aria-hidden="true">关联关系</figcaption></figure><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h3 id="依赖关系dependency">依赖关系(dependency)</h3><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><figure><img src="/img/设计模式/uml_dependency.jpg" alt="依赖关系" /><figcaption aria-hidden="true">依赖关系</figcaption></figure><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化；依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><h2 id="设计模式-1">设计模式</h2><p>设计模式知识见<ahref="https://refactoringguru.cn/design-patterns/catalog">设计模式</a></p><h3 id="面向对象设计原则">面向对象设计原则</h3><ol type="1"><li>单一职责原则（Single Responsibility Principle）<ul><li>一个类应该仅有一个引起它变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul></li><li>里氏替换原则（Liskov Substitution Principle）<ul><li>子类必须能够替换它们的基类(IS-A)。</li><li>继承表达类型抽象。</li></ul></li><li>依赖倒置原则（Dependence Inversion Principle）<ul><li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)。</li><li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。</li></ul></li><li>接口隔离原则（Interface Segregation Principle）<ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul></li><li>迪米特法则（Law Of Demeter）<ul><li>一个对象应该对其他对象有最少的了解,低耦合，高内聚。</li></ul></li><li>开闭原则（Open Close Principle）<ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul></li></ol><h3 id="设计模式分类">设计模式分类</h3><ul><li>创建型模式: 这类模式提供创建对象的机制，能够提升已有代码的灵活性和可复用性。创建型模式包括单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式</li><li>结构型模式: 这类模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。结构型模式包括适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li><li>行为型模式:这类模式负责对象间的高效沟通和职责委派。行为型模式包括策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li></ul><h3 id="单例模式">单例模式</h3><h4 id="面试手写两种单例">面试手写两种单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 线程安全懒汉式</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx;<span class="hljs-comment">//全局的锁</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//C++ 11新特性，所管理工具</span><br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">//双重判断</span><br>            &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* <span class="hljs-keyword">volatile</span> instance; <span class="hljs-comment">//2.定义一个唯一的类的实例对象  //加上volatile</span><br>    <span class="hljs-built_in">Singleton</span>()    <span class="hljs-comment">//1.构造函数私有化</span><br>    &#123;<br>        <span class="hljs-comment">//省略构造函数的具体实现，实际业务中会有很多功能</span><br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//C++11中，定义成员函数，可在后面使用 = delete修饰，表示该函数被删除，禁用；</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br><br>Singleton*<span class="hljs-keyword">volatile</span> Singleton::instance = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//加上volatile</span><br><br><span class="hljs-comment">// 饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function">Singleton&amp; <span class="hljs-title">Singleton</span><span class="hljs-params">(<span class="hljs-type">const</span> Singleton&amp;)</span> </span>= <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function">Singleton&amp; <span class="hljs-title">Singleton</span><span class="hljs-params">(Singleton&amp;&amp;)</span> </span>= <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton instance;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">Singleton</span>()<br>    &#123;<br><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 饿汉式默认初始化</span><br>Singleton Singleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br></code></pre></td></tr></table></figure><h4id="单例模式中懒汉和饿汉的本质区别">单例模式中懒汉和饿汉的本质区别</h4><ul><li>饿汉式在进程刚开始的时候就创建了对象，若这个其构造函数需要做的事有很多，那么会导致系统在启动的时候卡顿.而懒汉式的实例对象是在第一次使用的时候才创建的,这样就避免了启动卡顿的问题。在<strong>C++中由于饿汉式的这个缺点,所以一般不使用饿汉式,而是使用懒汉式。</strong></li><li>饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。而懒汉模式需要在实现的时候保证线程安全。</li></ul><h4 id="懒汉式的实现方式">懒汉式的实现方式</h4><p>首先将static类型的对象<strong>改成指针</strong>，调用函数获取该指针时，首先判断指针是否为空，为空就new一个，不为空直接返回指针.我们初始化其为空，这样就需要new一个了，然后第二次调用该函数getInstance()就不为空了，然后直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">//不为空则直接返回</span><br>    &#125;<br>    <br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance; <br>    <span class="hljs-built_in">Singleton</span>()    <br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//初始为空</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Singleton* p1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但这个并不是线程安全的！</strong></p><p>上面的实现在单线程环境下没问题,因为单线程情况下<code>getInstance()</code>不会被同时调用，只能调用完，再调用.但是在多线程条件下，该函数不是可重入函数。<strong>多线程条件下，某个线程调用该函数，没有执行完即对象instance还没被创建，另一个线程也执行该函数，发现instance为空，那也执行创建语句instance= new Singleton();</strong>，所以该函数不是可重入函数.</p><div class="admonition info"><p class="admonition-title">info</p><p>可重入函数是指能够被多个线程“同时”调用的函数,并且能保证函数结果正确不必担心数据错误的函数</p></div><p>创建instance对象其实做了三件事:</p><ul><li>分配内存空间</li><li>构造对象</li><li>给instance赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>    <span class="hljs-comment">/*  </span><br><span class="hljs-comment">    开辟内存</span><br><span class="hljs-comment">    构造对象</span><br><span class="hljs-comment">    给instance赋值</span><br><span class="hljs-comment">    */</span><br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>如前面所说,线程A把new的对象赋值给instance之前,线程B也进入了<code>getInstance()</code>函数,发现instance为空,也执行了new语句,这样就会导致两个线程创建了两个对象,这样就违背了单例.</li><li>编译器为了加快代码执行速度,可能<strong>先赋值,然后再构造对象</strong>,比如对象的属性很多,构造比较久,就先给变量赋值,然后再对该变量进行初始化.这样就会导致<strong>线程A执行到第一步,给instance赋值,此时instance不为空,但是对象还没有构造出来,线程B执行到第一步,发现instance不为空,就直接返回了instance,但是此时对象还没有构造出来,这样就会导致线程B使用了一个没有构造出来的对象</strong>,这样就会导致程序崩溃.</li></ol><p>从上面两个角度来看,我们都需要给<code>instance = new Singleton();</code>加锁,不能让多个线程同时执行这一句.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//C++11新特性，锁管理工具</span><br><br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)&#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition info"><p class="admonition-title">info</p><p>std::lock_guard属于C++11特性，锁管理遵循RAII习语管理资源。RAII详见<a href="https://gstarmin.github.io/2023/06/22/RAII%E5%8E%9F%E7%90%86/">RAII原理</a></p></div><p>但是这里又有新的问题:<strong>锁的粒度太大了</strong>,单线程环境下每次调用该函数也会执行加锁操作.所以还得修改,改成下面之后,单线程下只有第一次会加锁,第二次以后调用就不会加锁了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//放到if里面</span><br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下,出自这个if的括号就会释放锁了，（returninstance前面的括号）。这个也有问题，第二个线程阻塞后还是会执行new，所以需要加一个if判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 锁+双重判断</span><br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//还要判断下是否为空</span><br>        &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个instance是static的，存储在全局/静态变量区——操作系统的数据段。是同一个进程，多个线程共享的数据。</p><p>CPU在执行线程指令的时候，为了加快多线程的执行速度（或者说是先由编译器做的优化，然后落实到CPU上），会将这些线程共享的数据都拷贝一份到自己的线程寄存器上——我们这里就是instance对象.</p><p>所以我们要加一个关键字<strong>volatile</strong>,加了之后，当instance这个共享变量改变之后，就是告诉线程该去内存上去找该变量而不是取自己的寄存器上的。因为线程A先取了该变量到自己寄存器上，然后线程B把该变量修改了（修改后它也会同步到内存里），那么线程A要是还在自己的寄存器上取该变量，那读取到的就是未更新的。</p><p><strong>所以volatile适合用来修饰随时都可能被修改的变量，告诉将要读取该变量的线程不要从自己的寄存器或者cache上取该变量，而是去内存上取。</strong></p><h4 id="线程安全的懒汉式单例模式">线程安全的懒汉式单例模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx;<span class="hljs-comment">//全局的锁</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//C++ 11新特性，所管理工具</span><br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">//双重判断</span><br>            &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* <span class="hljs-keyword">volatile</span> instance; <span class="hljs-comment">//2.定义一个唯一的类的实例对象  //加上volatile</span><br>    <span class="hljs-built_in">Singleton</span>()    <span class="hljs-comment">//1.构造函数私有化</span><br>    &#123;<br>        <span class="hljs-comment">//省略构造函数的具体实现，实际业务中会有很多功能</span><br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//C++11中，定义成员函数，可在后面使用 = delete修饰，表示该函数被删除，禁用；</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br><br>Singleton*<span class="hljs-keyword">volatile</span> Singleton::instance = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//加上volatile</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Singleton* p1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4id="不使用互斥锁的线程安全的懒汉式单例模式">不使用互斥锁的线程安全的懒汉式单例模式</h4><p>将该对象放在函数里，成为<strong>静态局部变量</strong>。注意，静态局部变量也是在全局区（C++内存模型的叫法），和静态全局变量，全局变量一样，是在编译器就被分配了内存。</p><p>但是静态局部变量的初始化是<strong>运行</strong>到该语句时，进行初始化</p><div class="admonition info"><p class="admonition-title">info</p><p>C和C++的处理还不一样,C语言是编译时分配内存和初始化的;C++，<strong>编译时</strong>分配内存,（<strong>运行时</strong>）首次使用时初始化。这主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不适用互斥锁的单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSingleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> CSingleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> CSingleton single; <span class="hljs-comment">// 懒汉式单例模式，定义唯一的对象实例</span><br><span class="hljs-keyword">return</span> &amp;single;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> CSingleton *single;<br><span class="hljs-built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-built_in">CSingleton</span>(<span class="hljs-type">const</span> CSingleton&amp;);<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CSingleton *p1 = CSingleton::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也因为是调用该函数才会初始化该对象，没调用的话该对象不会调用构造函数，所以也是一个懒汉式单例模式。</p><div class="admonition info"><p class="admonition-title">info</p><p>在多线程情况下,<strong>函数静态局部变量的初始化，在汇编指令上已经自动添加线程互斥指令了</strong>.如果线程A调用该函数，在初始化未完成之前，线程B不会执行该初始化操作。线程A完成初始化后，已经初始化过的变量，其它线程不会再重复进行初始化操作，从而只有一个实例对象产生。</p></div><p>C++ static初始化见<ahref="https://gstarmin.github.io/2023/11/23/Cpp-static%E5%88%9D%E5%A7%8B%E5%8C%96/">Cpp-static初始化</a></p><p>以上单例内容参考自<ahref="https://blog.csdn.net/mrqiuwen/article/details/127624028">C++单例模式</a></p><h3 id="建造者模式和工厂模式的区别">建造者模式和工厂模式的区别</h3><p>建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</p><p>与工厂模式相比，建造者模式一般用来创建<strong>更为复杂的对象</strong>，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类————导演类。也就是说，<strong>工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类</strong>。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p><h3 id="为什么需要创建型模式">为什么需要创建型模式</h3><p>首先，在编程中，对象的创建通常是一件比较复杂的事，因为，为了达到降低耦合的目的，我们通常采用面向抽象编程的方式，对象间的关系不会硬编码到类中，而是等到调用的时候再进行组装，这样虽然降低了对象间的耦合，提高了对象复用的可能，但在一定程度上将组装类的任务都交给了最终调用的客户端程序，大大增加了客户端程序的复杂度。采用创建类模式的优点之一就是将组装对象的过程封装到一个单独的类中，这样，既不会增加对象间的耦合，又可以最大限度的减小客户端的负担。</p><p>其次，使用普通的方式创建对象，一般都是返回一个具体的对象，即所谓的面向实现编程，这与设计模式原则是相违背的。采用创建类模式则可以实现面向抽象编程。客户端要求的只是一个抽象的类型，具体返回什么样的对象，由创建者来决定。</p><p>再次，可以对创建对象的过程进行优化，客户端关注的只是得到对象，对对象的创建过程则不关心，因此，创建者可以对创建的过程进行优化，例如在特定条件下，如果使用单例模式或者是使用原型模式，都可以优化系统的性能。</p><!-- ### 模板方法模式**定义**：定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。**类型**：行为类模式**类图**：![](/img/设计模式/模板方法模式类图.jpg)#### 模版方法的优点及适用场景**优点**：- 容易扩展：一般来说，抽象类中的模版方法是不易发生改变的部分，而抽象方法是容易发生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。- 便于维护。对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。**适用场景**：在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。 -->]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络">计算机网络</h1><h3 id="一些术语的缩写">一些术语的缩写</h3><ul><li><p><code>MSL(Maximum Segment Lifetime)</code>:传输层的概念，表示TCP报文最大存活时间</p></li><li><p><code>TTL(Time to Live)</code>:网络层的概念，每次IP数据包在网络中被路由器传递时，TTL值减一。当TTL减为零时，数据包会被丢弃，并向源发送一个ICMP 时间超过消息。TTL用来防止数据包在网络中无限循环</p></li><li><p><code>RTT(Round-Trip Time)</code>: 往返时延</p></li><li><p><code>RTO(Retransmission Time Out)</code>：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</p></li></ul><h2 id="osi-七层协议模型">OSI 七层协议模型</h2><p>OSI 模型（Open System Interconnection Model）是⼀个由 ISO提出得到概念模型，试图提供⼀个使各种不同的的计算机和⽹络在世界范围内实现互联的标准框架。</p><p>虽然OSI参考模型在实际中的应⽤意义并不是很⼤，但是它对于理解⽹络协议内部的运作很有帮助，为我们学习⽹络协议提供了⼀个很好的参考。它将计算机⽹络体系结构划分为7层，每层都为上⼀层提供了良好的接⼝。以下将具体介绍各层结构及功能。</p><figure><img src="/img/C++八股文/计网/osi七层协议图.gif" alt="OSI模型" /><figcaption aria-hidden="true">OSI模型</figcaption></figure><p>主要分为以下七层（从下⾄上）：物理层、数据链路层、⽹络层、传输层、会话层、表示层、应⽤层。</p><p><strong>物理层</strong>：规定了一些<strong>机械特性，电⽓特性，功能特性</strong>，如网线、网卡标准，这⼀层传输的是<strong>bit 流</strong>。</p><p><strong>数据链路层</strong>：定义数据的基本格式，如何传输，如何标识，在<strong>不可靠</strong>的物理介质上<strong>提供可靠的传输</strong>。该层的作⽤包括：<strong>物理地址寻址、封装成帧、流量控制、数据的检错、重发</strong>等。这⼀层中将bit 流封装成 <strong>frame 帧</strong>。</p><p><strong>⽹络层</strong>：定义ip编址，对数据包进⾏<strong>路由选择</strong>。此外，⽹络层还可以实现<strong>拥塞控制</strong>、<strong>⽹际互连</strong>等功能。在这⼀层，数据的单位称为<strong>数据包（packet）</strong>。</p><p><strong>传输层</strong>：提供<strong>端到端的、可靠的或不可靠的传输</strong>。此外，传输层还要处理端到端的<strong>差错控制</strong>和<strong>流量控制</strong>问题。在这⼀层，数据的单位称为<strong>数据段（segment）</strong>。</p><p><strong>会话层</strong>：<strong>控制应用程序之间会话能力</strong>。如不同软件负责不同软件分发给不同软件。</p><p><strong>表示层</strong>：数据格式标识，基本压缩加密功能</p><p><strong>应⽤层</strong>：各种应用软件，包括 Web 应用。</p><p>网络七层模型是一个标准，而非实现。网络四层模型由七层模型简化而来，是一个实现的应用模型。</p><!-- ## 各层传输协议、传输单元、主要功能性设备⽐较|名称|传输协议|传输单元|主要功能设备/接口||-----|-----|-----|-----||物理层|IEEE 802.1A、IEEE 802.2| bit-flow 比特流|光纤，双绞线，中继器，集线器，网线接口||数据链路层|ARP、MAC、FDDI、Ethernet、Arpanet、PPP、PDN|frame帧|网桥、二层交换机||网络层|IP、ICMP、ARP、PPP、RARP|数据包packet|路由器、三层交换机||传输层|TCP、UDP|segment/datagram|四层交换机||会话层|SMTP、DNS|报文|QoS||表示层|Telnet、FTP、HTTP、SNMP|报文|-||应用层|FTP、HTTP、TFTP、Telnet、DNS|报文|-|--><h2 id="tcp-三次握手和四次挥手的流程">TCP 三次握手和四次挥手的流程</h2><h3 id="三次握手">三次握手</h3><ul><li>第⼀次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt;SYN_SEND）</li><li>第⼆次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM =P的包到客户机。（服 -&gt; SYN_RECV）</li><li>第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt;ESTABLISH，服 -&gt; ESTABLISH）</li></ul><h3 id="四次挥手">四次挥手</h3><ul><li>第⼀次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt;FIN_WAIT_1）</li><li>第⼆次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt;CLOSE_WAIT，客 -&gt; FIN_WAIT_2）</li><li>此处有等待</li><li>第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt;LAST_ACK，客 -&gt; TIME_WAIT）</li><li>此处有等待</li><li>第四次：客户机发送最后⼀个含有ACK位且ACK_NUM = R +1的包到客户机。（服 -&gt; CLOSED</li></ul><h2id="为什么建立连接时候要三次握手不是两次也不是四次">为什么建立连接时候要三次握手？不是两次也不是四次？</h2><p>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。</p><p>例子：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p><p>所以说两次握手不能满足需求，而三次握手已经可以满足需求，那么四次握手就是浪费了。</p><p>从另一个角度看“TCP建立连接为什么是三次握手？”，这个问题的本质是,信道不可靠,但是通信双发需要就某个问题达成一致. 而要解决这个问题,无论你在消息中包含什么信息, 三次通信是理论上的最小值.所以<strong>三次握手不是TCP本身的要求,而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的</strong>.请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了,那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了.因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到,或者你不关心是否要保证对方收到你的消息,那就能像UDP那样直接发送消息就可以了.”。</p><p>参考自<ahref="https://www.zhihu.com/question/24853633/answer/63668444">TCP为什么是三次握手，而不是两次或四次？</a></p><h2id="说一下一次完整的http请求过程包括哪些内容">说一下一次完整的HTTP请求过程包括哪些内容？</h2><p>域名解析 --&gt; 发起TCP的3次握手 --&gt; 建立TCP连接后发起http请求--&gt; 服务器响应http请求，浏览器得到html代码 --&gt;浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --&gt;浏览器对页面进行渲染呈现给用户。</p><h2 id="你知道dns是什么">你知道DNS是什么？</h2><p><strong>官方解释</strong>：DNS（Domain NameSystem，域名系统），因特网上作为<strong>域名和IP地址相互映射的一个分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><p>通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。</p><h2id="https是如何保证数据传输的安全整体的流程是什么ssl是怎么工作保证安全的">HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h2><ol type="1"><li>客户端向服务器端发起SSL连接请求；</li><li>服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥</li><li>客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端</li><li>服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密</li><li>进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。</li></ol><p>以上是属于TLS 1.0版本的答案，使用RSA密钥交换算法。而TLS1.2版本使用的是ECDHE_RSA密钥交换算法，其过程如下：</p><ol type="1"><li>客户端和服务器各自选择一个<strong>椭圆曲线私钥（随机数）</strong>，并使用椭圆曲线算法生成对应的<strong>椭圆曲线公钥</strong>。</li><li>在握手阶段，客户端和服务器互相交换<strong>椭圆曲线公钥</strong>。</li><li>客户端和服务器各自使用 <strong>对方的椭圆曲线公钥</strong> 和<strong>自己的椭圆曲线私钥</strong>，通过椭圆曲线的点运算生成一个<strong>共享密钥</strong>。由于椭圆曲线的数学性质，这个共享密钥在双方都知道，但是不能被第三方计算出来。(共享密钥并非通过传输手段获得，避免中间人截取。)</li><li>客户端和服务器使用这个共享密钥进行<strong>对称加密通信</strong>。</li></ol><h2id="在浏览器地址栏输入一个url后回车背后都发生了什么">在浏览器地址栏输入一个URL后回车，背后都发生了什么？</h2><p>查浏览器缓存，检查域名是否在缓存中，如果没有则调用 gethostbyname(不同操作系统函数名也不同)进行查询。</p><p>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts里找到，它将会向 DNS 服务器发送一条 DNS查询请求。查询本地DNS服务器，如果DNS服务器和我们的主机在一个子网内采用ARP地址解析协议进行ARP查询;如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）</p><p>拿到服务器的ip以及端口号后，浏览器会建立一个TCP连接，连接建立成功之后如果使用的是http协议的话直接返回网页需要的数据；如果是https协议的话，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了（http默认端口是80，https默认端口是443）.然后四次挥手断开连接，再进行一边上述操作，但是端口从80变为443，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，然后浏览器会对页面进行需求渲染。</p><h2 id="谈谈dns解析过程具体一点">谈谈DNS解析过程，具体一点</h2><p>先在浏览器找之前有没有缓存过的域名所对应的ip地址，有的话，直接跳过dns解析了，若是没有，就会找硬盘的hosts文件，看看有没有，有的话，直接找到hosts文件里面的ip。</p><p>如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个dns请求到本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。</p><p>查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归查询</strong>。</p><p>如果没有，本地DNS服务器继续向域服务器发出请求，比如查询google.com，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p><p>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p><h2 id="dns负载均衡是什么策略">DNS负载均衡是什么策略？</h2><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是<strong>在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的</strong>｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p><h2 id="https和http的区别">HTTPS和HTTP的区别</h2><ul><li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li></ul><h2 id="什么是ssltls">什么是SSL/TLS ？</h2><p>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。身份验证 ，加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p><p>SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；</p><p>对称加密：优点在于加密、解密效率通常比较高 ，HTTPS是基于非对称加密的， 公钥是公开的.</p><h2 id="cookie是什么">Cookie是什么？</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie来保存状态信息。</p><p>Cookie是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用Web storage API（本地存储和会话存储）或 IndexedDB。</p><h2 id="cookie有什么用途">Cookie有什么用途？</h2><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h2 id="session-的工作原理是什么">Session 的工作原理是什么？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的session，session 创建完之后，会把 session 的 id发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session这样就可以正常工作了。</p><h2 id="cookie与session的对比">Cookie与Session的对比</h2><h3 id="cookie">Cookie</h3><p>Cookie是<strong>客户端</strong>保持状态的方法。</p><p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p><p>除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p><h3 id="session">Session</h3><p>Session是<strong>服务器</strong>保持状态的方法。</p><p>首先需要明确的是，<strong>Session保存在服务器上</strong>，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为<strong>每个用户有一个独一无二的SessionID作为Session文件的Hash键</strong>，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p><p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p><h2 id="cookies和session区别是什么">Cookies和Session区别是什么？</h2><ol type="1"><li>cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全</li><li>存储的数据类型不同两者都是key-value的结构，但针对value的类型是有差异的cookie：value只能是字符串类型，session：value是Object类型</li><li>存储的数据大小限制不同cookie：大小受浏览器的限制，很多是是4K的大小，session：理论上受当前内存的限制</li><li>生命周期的控制:cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束;session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁</li></ol><h2 id="sql注入攻击了解吗">SQL注入攻击了解吗？</h2><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1，如果此时使用参数构造的方式，就会出现 select * from user where name =‘lianggzone’ and password = ‘’ or ‘1’=‘1’不管用户名和密码是什么内容，使查询出来的用户列表不为空。</p><p>如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。</p><p><strong>Web端</strong></p><ol type="1"><li>有效性检验。</li><li>限制字符串输入的长度。</li></ol><p><strong>服务端</strong></p><ol type="1"><li>不用拼接SQL字符串。</li><li>使用预编译的PrepareStatement。</li><li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</li><li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li></ol><h2 id="什么是rarp工作原理">什么是RARP？工作原理</h2><p>概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p><p><strong>工作原理</strong>：</p><ol type="1"><li>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的<strong>广播数据包</strong>，请求RARP服务器回复该主机的IP地址。</li><li>RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。</li><li>PC1收到RARP回应后，就使用得到的IP地址进行通讯。</li></ol><h2 id="端口有效范围是多少到多少">端口有效范围是多少到多少？</h2><p>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）</p><p>UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</p><h2 id="为何需要把-tcpip-协议栈分成-5-层或7层开放式回答">为何需要把TCP/IP 协议栈分成 5 层（或7层）？开放式回答。</h2><p>为了更好的管理和维护，将协议分层，每一层都有自己的功能，每一层都可以独立的进行修改，而不会影响到其他层。</p><h2 id="dns查询方式有哪些">DNS查询方式有哪些</h2><h3 id="递归解析">递归解析</h3><p>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p><h3 id="迭代解析">迭代解析</h3><p>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p><h2 id="使用-session-的过程是怎样的">使用 Session 的过程是怎样的？</h2><p>过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 SessionID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie值，服务器收到之后提取出 Session ID，从 Redis中取出用户信息，继续之前的业务操作。</li></ul><p><strong>注意</strong>：Session ID的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的Session ID 值。此外，还需要经常重新生成 SessionID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h2id="session和cookie应该如何去选择适用场景">Session和cookie应该如何去选择（适用场景）？</h2><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session中。</li></ul><h2 id="ddos-攻击了解吗">DDos 攻击了解吗？</h2><p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认.没有彻底根治的办法，除非不使用TCP</p><p><strong>DDos 预防</strong>:</p><ol type="1"><li>限制同时打开SYN半链接的数目</li><li>缩短SYN半链接的Time out 时间</li><li>关闭不必要的服务</li></ol><h2 id="mtu和mss分别是什么">MTU和MSS分别是什么？</h2><p><strong>MTU</strong>：maximum transmissionunit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。</p><p><strong>MSS</strong>：maximum segmentsize，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4Header（20 Byte）和TCP header（20 Byte）得到。</p><h2id="http中有个缓存机制但如何保证缓存是最新的呢缓存过期机制">HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）</h2><p>max-age指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Expires</span>: Wed, <span class="hljs-number">04</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05</span> GMT<br></code></pre></td></tr></table></figure><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h2 id="tcp头部中有哪些信息">TCP头部中有哪些信息？</h2><ul><li>源端口 目标端口</li><li>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值= ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN =1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 +512。用于解决网络包乱序问题。</li><li>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 +1。</li><li>首部长（4bit）：标识首部有多少个4字节 *首部长，最大为15，即60字节。</li><li>标志位（6bit）：<ul><li>URG：标志紧急指针是否有效。</li><li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li><li>PSH：提示接收端立即从缓冲读走数据。</li><li>RST：表示要求对方重新建立连接（复位报文段）。</li><li>SYN：表示请求建立一个连接（连接报文段）。</li><li>FIN：表示关闭连接（断开报文段）。</li></ul></li><li>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</li><li>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</li></ul><h2 id="常见tcp的连接状态有哪些">常见TCP的连接状态有哪些？</h2><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li><li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li><li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li><li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li><li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li><li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li></ul><h2id="网络的七层五层模型主要的协议有哪些">网络的七层/五层模型主要的协议有哪些？</h2><p><img src="/img/C++八股文/计网/网络协议.png" /></p><h2 id="tcp是什么">TCP是什么？</h2><p>TCP（Transmission Control Protocol传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><h2id="应用层常见协议知道多少了解几个">应用层常见协议知道多少？了解几个？</h2><table><thead><tr class="header"><th>协议</th><th>名称</th><th>默认端口</th><th>底层协议</th></tr></thead><tbody><tr class="odd"><td>HTTP</td><td>超文本传输协议</td><td>80</td><td>TCP</td></tr><tr class="even"><td>HTTPS</td><td>安全超文本传输协议</td><td>443</td><td>TCP</td></tr><tr class="odd"><td>Telnet</td><td>远程登录服务</td><td>23</td><td>TCP</td></tr><tr class="even"><td>FTP</td><td>文件传输协议</td><td>20传输/21连接</td><td>TCP</td></tr><tr class="odd"><td>TFTP</td><td>简单文件传输协议</td><td>69</td><td>UDP</td></tr><tr class="even"><td>SMTP</td><td>简单邮件传输协议</td><td>25</td><td>TCP</td></tr><tr class="odd"><td>POP3</td><td>邮局协议</td><td>110</td><td>TCP</td></tr><tr class="even"><td>DNS</td><td>域名系统</td><td>53</td><td>服务器间进行域传输的时候用TCP，客户端查询DNS服务器时用 UDP</td></tr></tbody></table><h2id="浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开">浏览器在与服务器建立了一个TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2><p>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP链接。但是这样每次请求都会重新建立和断开 TCP连接，代价过大。所以虽然<strong>标准中没有设定，某些服务器对 Connection:keep-alive 的 Header 进行了支持</strong>。意思是说，完成这个 HTTP请求之后，不要断开 HTTP 请求使用的 TCP连接。这样的好处是连接可以被重新使用，之后发送 HTTP请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL的开销也可以避免。</p><p>HTTP/1.1 就把 Connection头写进标准，并且默认开启持久连接，除非请求中写明 Connection:close，那么浏览器和服务器之间是会维持一段时间的 TCP连接，不会一个请求结束就断掉。</p><p>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection:close 才会在请求完成后关闭连接。</p><h2 id="三次握手相关内容">三次握手相关内容</h2><p><img src="/img/C++八股文/计网/三次握手.png" /></p><ul><li><strong>初始状态</strong>：客户端处于 closed(关闭)状态，服务器处于listen(监听) 状态。</li><li><strong>第一次握手</strong>：客户端发送请求报文将 SYN =1同步序列号和初始化序列号seq =x发送给服务端，发送完之后客户端处于SYN_Send状态。（验证了客户端的发送能力和服务端的接收能力）</li><li><strong>第二次握手</strong>：服务端受到 SYN请求报文之后，如果同意连接，会以自己的同步序列号SYN(服务端) =1、初始化序列号 seq = y和确认序列号（期望下次收到的数据包）ack = x+ 1以及确认号ACK =1报文作为应答，服务器为SYN_Receive状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li><li><strong>第三次握手</strong>： 客户端接收到服务端的 SYN +ACK之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号ack = y + 1和数据包的序列号 seq = x + 1以及确认号ACK =1确认包作为应答，客户端转为established状态。（分别站在双方的角度上思考，各自ok）</li></ul><h2 id="什么是半连接队列">什么是半连接队列？</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为1s，2s，4s，8s......</p><h2 id="isninitial-sequence-number是固定的吗">ISN(Initial SequenceNumber)是固定的吗？</h2><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN是一个有可以看作是一个32比特的计数器，但并不是简单的计数器，大概每4ms加1。</p><div class="admonition info"><p class="admonition-title">info</p><p>ISN = M + F(localhost, localport, remotehost,remoteport)(M为计数器)，ISN应该由这个公式确定，F为哈希算法，不是一个简单计数器。</p></div><p>这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p><p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(InitialSequenceNumber)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN是动态生成的。</strong></p><h2id="三次握手过程中可以携带数据吗">三次握手过程中可以携带数据吗？</h2><p>第三次握手的时候，可以携带数据。但是，第一次、第二次握手不可以携带数据。</p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的SYN报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，<strong>第一二次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p><h2 id="syn攻击是什么">SYN攻击是什么？</h2><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<strong>SYN攻击是一种典型的 DoS/DDoS 攻击。</strong></p><p>检测 SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -n -p TCP | grep SYN_RECV<br></code></pre></td></tr></table></figure><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h2 id="四次挥手相关内容">四次挥手相关内容</h2><p><img src="/img/C++八股文/计网/四次挥手.png" /></p><p>刚开始双方都处于 ESTABLISHED状态，<strong>假如是客户端先发起关闭请求</strong>。四次挥手的过程如下：</p><ul><li><strong>第一次挥手</strong>：客户端发送一个 FIN报文，报文中会指定一个序列号。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，<strong>进入FIN_WAIT1</strong>（终止等待1）状态，等待服务端的确认。</li><li><strong>第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK报文，且把客户端的序列号值 +1 作为 ACK报文的序列号值，表明已经收到客户端的报文了。即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），<strong>服务端进入CLOSE_WAIT</strong>（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。<strong>客户端</strong>收到服务端的确认后，<strong>进入FIN_WAIT2</strong>（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li><strong>第三次挥手</strong>：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给FIN 报文，且指定一个序列号。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），<strong>服务端进入LAST_ACK（最后确认）状态</strong>，等待客户端的确认。</li><li><strong>第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK报文作为应答，且把服务端的序列号值 +1 作为自己 ACK报文的确认号值。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED状态。即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），<strong>客户端进入TIME_WAIT</strong>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><h2 id="挥手为什么需要四次">挥手为什么需要四次？</h2><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，<strong>当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。之后服务器端可能还有想要传输的数据，只有等到服务端所有的报文都发送完了，服务器端才发送FIN报文</strong>，因此不能一起发送。故需要四次挥手。</p><h2 id="msl等待状态">2MSL等待状态？</h2><p>TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（MaximumSegmentLifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p><p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><h2id="四次挥手释放连接时等待2msl的意义">四次挥手释放连接时，等待2MSL的意义?</h2><ol type="1"><li>保证客户端发送的最后一个ACK报文段能够到达服务端。这个ACK报文段有可能丢失，使得处于LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li><li>防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h2id="tcp粘包问题是什么你会如何去解决它">TCP粘包问题是什么？你会如何去解决它？</h2><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p>造成TCP粘包的原因：</p><ul><li>TCP连接复用</li><li>TCP默认会使用Nagle算法，此算法会导致粘包问题</li><li>数据包过大</li><li>流量控制，拥塞控制也可能导致粘包</li><li>接收方不及时接收缓冲区的包，造成多个包接收</li></ul><p>解决方案：</p><ul><li>Nagle算法问题导致的，需要结合应用场景适当关闭该算法</li><li>尾部标记序列。通过特殊标识符表示数据包的边界，例如或者一些隐藏字符</li><li>头部标记分步接收。在TCP报文的头部加上表示数据长度</li><li>应用层发送数据时定长发送</li></ul><h2 id="对称密钥加密的优点缺点">对称密钥加密的优点缺点？</h2><p>对称密钥加密（Symmetric-KeyEncryption），加密和解密使用同一密钥。</p><p><strong>优点</strong>：运算速度快</p><p><strong>缺点</strong>：无法安全地将密钥传输给通信方</p><h2id="非对称密钥加密你了解吗优缺点">非对称密钥加密你了解吗？优缺点？</h2><p>非对称密钥加密，又称公开密钥加密（Public-KeyEncryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><p><strong>优点</strong>：可以更安全地将公开密钥传输给通信发送方；</p><p><strong>缺点</strong>：运算速度慢。</p><h2 id="https是什么">HTTPS是什么？</h2><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure SocketsLayer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS使用了隧道进行通信。通过使用 SSL，HTTPS具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><h2 id="http的缺点有哪些">HTTP的缺点有哪些？</h2><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><h2id="https采用的加密方式有哪些是对称还是非对称">HTTPS采用的加密方式有哪些？是对称还是非对称？</h2><p>PS采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p><h2id="为什么有的时候刷新页面不需要重新建立-ssl-连接">为什么有的时候刷新页面不需要重新建立SSL 连接？</h2><p>TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP不需要重新建立，SSL 自然也会用之前的。</p><h2id="ssl中的认证中的证书是什么了解过吗">SSL中的认证中的证书是什么？了解过吗？</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，CertificateAuthority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><h2id="http如何禁用缓存如何确认缓存">HTTP如何禁用缓存？如何确认缓存？</h2><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p><strong>禁止进行缓存</strong></p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cache-Control: no-store<br></code></pre></td></tr></table></figure><p><strong>强制确认缓存</strong></p><p>no-cache指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cache-Control: no-cache<br></code></pre></td></tr></table></figure><h2id="get与post传递数据的最大长度能够达到多少呢">GET与POST传递数据的最大长度能够达到多少呢？</h2><p>get是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。</p><p>很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。</p><p>这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。</p><p>post理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</p><p>因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。</p><p>以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。这就很明白的说明了这个问题了。</p><h2 id="网络层常见协议可以说一下吗">网络层常见协议？可以说一下吗？</h2><table style="width:100%;"><thead><tr class="header"><th>协议</th><th>名称</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>IP</td><td>网际协议</td><td>IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</td></tr><tr class="even"><td>ICMP</td><td>Internet控制报文协议</td><td>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</td></tr><tr class="odd"><td>RIP</td><td>路由信息协议</td><td>使用“跳数”(即metric)来衡量到达目标地址的路由距离</td></tr><tr class="even"><td>IGMP</td><td>Internet组管理协议</td><td>用于实现组播、广播等通信</td></tr></tbody></table><h2 id="tcp四大拥塞控制算法总结">TCP四大拥塞控制算法总结?*</h2><h3 id="四大算法">四大算法</h3><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p><p><img src="/img/C++八股文/计网/TCP四大拥塞控制算法.png" /></p><h3 id="慢启动算法-slow-start">慢启动算法 – Slow Start</h3><p>所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p><p>慢启动算法：</p><ol type="1"><li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li><li>每当收到一个ACK，cwnd大小加一，呈线性上升。</li><li>每当过了一个往返延迟时间RTT(Round-TripTime)，cwnd大小直接翻倍，乘以2，呈指数让升。</li><li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;=ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li></ol><h3 id="拥塞避免算法-congestion-avoidance">拥塞避免算法 – CongestionAvoidance</h3><p>如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p><ol type="1"><li>收到一个ACK，则cwnd = cwnd + 1 / cwnd</li><li>每当过了一个往返延迟时间RTT，cwnd大小加一。</li></ol><p>过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p><h3 id="拥塞发生状态时的算法">拥塞发生状态时的算法</h3><p>一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[RetransmissionTimeout]超时，另一个是收到三个重复确认ACK。</p><p>超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p><p>但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做<strong>快速重传</strong>，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p><p>超时重传RTO[RetransmissionTimeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：</p><ul><li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh =cwnd / 2.</li><li>cwnd重置为1</li><li>进入慢启动过程</li></ul><p>最为早期的TCPTahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。</p><p>所以，TCPReno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传FastRetransmit算法，而不用等到RTO超时再进行重传：</p><ul><li>cwnd大小缩小为当前的一半</li><li>ssthresh设置为缩小后的cwnd大小</li><li>然后进入快速恢复算法Fast Recovery</li></ul><p><img src="/img/C++八股文/计网/拥塞控制图.png" /></p><h3 id="快速恢复算法-fast-recovery">快速恢复算法 – Fast Recovery</h3><p>TCPTahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在<strong>进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半</strong>。快速恢复算法的逻辑如下：</p><ul><li>cwnd = cwnd + 3 MSS，加3 MSS的原因是因为收到3个重复的ACK。</li><li>重传DACKs指定的数据包。</li><li>如果再收到DACKs，那么cwnd大小增加一。</li><li>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</li></ul><p><img src="/img/C++八股文/计网/快速恢复算法.png" /></p><h2id="为何快速重传是选择3次重复ack">为何快速重传是选择3次重复ACK？</h2><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p><p>两次duplicated ACK时很可能是乱序造成的！三次duplicatedACK时很可能是丢包造成的！四次duplicatedACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicatedACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p><p>在没有fast retransmit / recovery 算法之前，重传依靠发送方的retransmittimeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因</p><ol type="1"><li>包checksum 出错</li><li>网络拥塞</li><li>网络断，包括路由重收敛，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND减为1/2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</li></ol><p>于是有了fast retransmit算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout时间内没有接收到&gt; 2 的duplicatedACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；</p><p>而如果接收到三个或三个以上的duplicatedACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。</p><p>而如果依然接收到duplicatedACK，则认为是网络拥塞造成的，此时降速则比较合理。</p><h2id="对于fin_wait_2close_wait状态和time_wait状态你知道多少">对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h2><p>FIN_WAIT_2：</p><ul><li>半关闭状态。</li><li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li></ul><p>CLOSE_WAIT状态：</p><ul><li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li><li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</li></ul><p>TIME_WAIT状态：</p><ul><li>又叫2MSL等待状态。</li><li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li><li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li></ul><h2 id="你了解流量控制原理吗">你了解流量控制原理吗？</h2><ul><li><strong>目的</strong>:接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li><li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<ul><li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li><li>接收窗：用来标记可以接收的数据大小。</li></ul></li><li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分| 已发送未被确认部分 | 未发送但可发送部分 |不可发送部分，其中<strong>发送窗 = 已发送未确认部分 +未发但可发送部分</strong>。接收到的数据流可分为：已接收 |未接收但准备接收 | 未接收不准备接收。<strong>接收窗 =未接收但准备接收部分</strong>。</li><li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li></ul><h2id="建立tcp服务器的各个系统调用过程是怎样的">建立TCP服务器的各个系统调用过程是怎样的？</h2><figure><img src="/img/C++八股文/计网/TCP系统调用流程.png"alt="TCP的系统调用过程" /><figcaption aria-hidden="true">TCP的系统调用过程</figcaption></figure><figure><img src="/img/C++八股文/计网/TCP系统调用流程-1.png"alt="TCP的系统调用过程" /><figcaption aria-hidden="true">TCP的系统调用过程</figcaption></figure><h2 id="tcp-协议如何保证可靠传输">TCP 协议如何保证可靠传输？</h2><p>首部校验 这个校验机制能够确保数据传输不会出错吗？ 答案是不能。</p><p><strong>解决方案</strong>:</p><p>传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题</p><h2 id="udp是什么">UDP是什么？</h2><p>提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><ol type="1"><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li><strong>TCP提供可靠的服务</strong>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;<strong>UDP尽最大努力交付，即不保证可靠交付</strong></li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li><li><strong>UDP是面向报文的</strong>，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小;<strong>TCP是面向字节流的</strong>，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</li></ol><h2id="封包和拆包你听说过吗它是基于tcp还是udp的">封包和拆包你听说过吗？它是基于TCP还是UDP的？</h2><p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p><ul><li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li><li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li></ul><h2 id="tcp和upd的特点">TCP和UPD的特点</h2><h3 id="udp特点">UDP特点</h3><ul><li>UDP是无连接的；</li><li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP是面向报文的；</li><li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信；</li><li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ul><h3 id="tcp特点">TCP特点</h3><ul><li>TCP是面向连接的。</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ul><h2 id="tcp对应的应用层协议有哪些">TCP对应的应用层协议有哪些？</h2><ul><li>FTP：定义了文件传输协议，使用21端口.</li><li>Telnet：它是一种用于远程登陆的端口,23端口</li><li>SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于接收邮件。</li></ul><h2 id="udp对应的应用层协议">UDP对应的应用层协议</h2><ul><li>DNS：用于域名解析服务，用的是53号端口</li><li>SNMP：简单网络管理协议，使用161号端口</li><li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，69</li></ul><h2id="数据链路层常见协议可以说一下吗">数据链路层常见协议？可以说一下吗？</h2><table><thead><tr class="header"><th>协议</th><th>名称</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>ARP</td><td>地址解析协议</td><td>根据IP地址获取物理地址</td></tr><tr class="even"><td>RARP</td><td>逆地址解析协议</td><td>根据物理地址获取IP地址</td></tr><tr class="odd"><td>PPP</td><td>点对点协议</td><td>在两点之间建立可靠的通信链路</td></tr></tbody></table><h2id="ping命令基于什么协议原理是什么">Ping命令基于什么协议？原理是什么？</h2><p>ping是基于网络层的ICMP协议实现的。通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。</p><div class="admonition note"><p class="admonition-title">ICMP协议类型</p><p>ICMP报文分为两个种类:</p><ul><li>ICMP差错报告报文，常见的有</li></ul><ol><li>终点不可达</li><li>时间超过</li><li>参数问题</li><li>改变路由</li></ol><ul><li>ICMP询问报文</li></ul><ol><li>回送请求和回答：向特定主机发出回送请求报文，收到回送请求报文的主机响应<strong>回送回答报文</strong>。</li><li>时间戳请求和回答：询问对方当前的时间，返回的是一个32位的时间戳。</li></ol></div><h2id="在进行udp编程的时候一次发送多少bytes好">在进行UDP编程的时候，一次发送多少bytes好?</h2><p>当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的。</p><p>我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:首先,我们知道,TCP/IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.UDP属于运输层,</p><p>下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.</p><p>所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。</p><p>当我们发送的UDP数据大于1472的时候会怎样呢？这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报。</p><p>因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.</p><p>进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.</p><p>鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.最好将UDP的数据长度控件在576-8-20=548字节以内</p><h2 id="tcp实现流量控制的机制">TCP实现流量控制的机制？</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。<strong>TCP利用滑动窗口实现流量控制</strong>。</p><p>TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，<strong>一种情况</strong>是可以发送紧急数据。例如，允许用户终止在远端机上的运行进程。<strong>另一种情况</strong>是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h2id="可以解释一下rtortt和超时重传分别是什么吗">可以解释一下RTO，RTT和超时重传分别是什么吗？</h2><ul><li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。<ul><li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......</li><li>重传次数到达上限之后停止重传。</li></ul></li><li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li><li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul><li>发送的数据没能到达接收端，所以对方没有响应。</li><li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li><li>接收端拒绝或丢弃数据。</li></ul></li></ul><h2 id="xss攻击是什么低频">XSS攻击是什么？（低频）</h2><p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。</p><p>如何防范XSS攻击？</p><ol type="1"><li>前端，服务端，同时需要字符串输入的长度限制。</li><li>前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。防 XSS 的核心是必须对输入的数据做过滤处理。</li></ol><h2 id="csrf攻击">CSRF攻击？</h2><p>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。</p><p><strong>如何防范CSRF攻击？</strong></p><ul><li>安全框架，例如Spring Security。</li><li>token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。</li><li>验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。</li><li>referer识别。在HTTPHeader中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。<ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul></li></ul><h2id="文件上传漏洞是如何发生的如何防范文件上传漏洞">文件上传漏洞是如何发生的？如何防范文件上传漏洞？</h2><p><strong>文件上传漏洞</strong>，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。</p><p><strong>如何防范文件上传漏洞?</strong></p><ol type="1"><li>判断文件类型。在判断文件类型的时候，可以结合使用MIMEType，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。</li><li>对上传的文件类型进行白名单校验，只允许上传可靠类型。</li><li>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。</li><li>限制上传文件的大小。</li><li>单独设置文件服务器的域名。</li></ol><!-- ## 拥塞控制原理？- 拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。- TCP拥塞控制算法：  - **慢启动 & 拥塞避免**：先试探网络拥塞程度再逐渐增大拥塞窗口。假设窗口长度为d，收到一个确认就加1，正好收到了d个确认，所以一共加d，正好是翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行增加，这个过程为拥塞避免。  - 快速重传 & 快速恢复：见[TCP四大拥塞控制算法总结](https://gstarmin.github.io/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/#tcp%E5%9B%9B%E5%A4%A7%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93)  - 最终拥塞窗口会收敛于稳定值。 --><h2 id="如何区分流量控制和拥塞控制">如何区分流量控制和拥塞控制？</h2><p>流量控制和拥塞控制是网络通信中两个重要的概念，它们的主要区别在于目标和作用对象。</p><p><strong>流量控制</strong>：</p><ul><li>作用对象：主要针对发送者和接收者之间的数据流量进行控制。</li><li>目标：控制发送者的发送速度，使得接收者来得及接收，防止分组丢失。</li><li>实现原理：通过滑动窗口协议实现，接收方告知发送方自己的窗口大小，发送方立刻更改即可实现流量控制。</li></ul><p><strong>拥塞控制</strong>：</p><ul><li>作用对象：主要针对<strong>网络中的节点和链路进行控制</strong>。</li><li>目标：防止过多的数据注入到网络中，避免出现网络负载过大的情况。</li><li>实现原理：常用的方法有<strong>慢开始、拥塞避免、快重传、快速恢复</strong>。发送方会维持一个拥塞窗口（动态变化），拥塞窗口的大小代表着网络的拥塞程度。</li></ul><p>总的来说，<strong>流量控制是为了防止接收方被淹没，而拥塞控制是为了防止网络被淹没</strong>。这两种控制机制共同保证了网络通信的稳定和高效。</p><h2 id="常见的http状态码有哪些">常见的HTTP状态码有哪些？</h2><table><thead><tr class="header"><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>1xx</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr class="even"><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr class="odd"><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr class="even"><td>4xx</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr class="odd"><td>5xx</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h3 id="xx-信息">1xx 信息</h3><p>100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p><h3 id="xx-成功">2xx 成功</h3><ul><li>200 OK</li><li>204 No Content：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由Content-Range 指定范围的实体内容。</li></ul><h3 id="xx-重定向">3xx 重定向</h3><ul><li>301 Moved Permanently ：永久性重定向</li><li>302 Found ：临时性重定向</li><li>303 See Other ：和 302 有着相同的功能，但是 303明确要求客户端应该采用 GET 方法获取资源。</li><li>304 Not Modified：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回304 状态码。</li><li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h3 id="xx-客户端错误">4xx 客户端错误</h3><ul><li>400 Bad Request ：请求报文中存在语法错误。</li><li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li>403 Forbidden ：请求被拒绝。</li><li>404 Not Found</li></ul><h3 id="xx-服务器错误">5xx 服务器错误</h3><ul><li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li><li>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2id="三次握手过程中bindlistenaccept哪个环节">三次握手过程中bind()、listen()、accept()哪个环节？</h2><ol type="1"><li><code>bind()</code>:该函数用于将一个本地地址绑定到套接字，指定套接字使用的IP地址和端口号。这对应于<strong>第一次握手中客户端发送</strong>SYN请求的时候，客户端选择一个本地端口并将其绑定到目标IP地址上。</li><li><code>listen()</code>:该函数使套接字进入监听状态，等待客户端的连接请求。这对应于第一次握手中服务端收到客户端的SYN请求，服务端准备接受连接。</li><li><code>accept()</code>:该函数用于接受客户端的连接请求，创建一个新的套接字用于与客户端通信。这对应于第二次握手中服务端发送SYN-ACK，表示接受连接。</li><li><code>connect()</code>:该函数用于发起到远程套接字的连接请求。这对应于第三次握手中客户端接收到服务端的SYN-ACK后，发送ACK表示连接建立成功。</li></ol><h2 id="socket端口复用">socket端口复用</h2><p>C++可以使用<code>setsockopt</code>函数，并将<code>SO_REUSEADDR</code>选项设置为<code>1</code>。这样可以允许多个socket绑定到同一端口上。</p><h2id="http对文件的分段是怎么设计的">HTTP对文件的分段是怎么设计的？</h2><ol type="1"><li><strong>分块传输标识：</strong>在HTTP响应的头部，通过设置<code>Transfer-Encoding: chunked</code>来表示服务器将采用分块传输的方式。这告诉客户端，响应实体主体将以块的形式进行传输。</li><li><strong>数据块格式：</strong>每个数据块由两部分组成，分别是十六进制的块大小和块数据。块大小指示了当前块包含的数据的字节数，然后是一个CRLF（回车换行）标志，接着是实际的数据，再以CRLF标志结束。</li><li><strong>最后的块：</strong>为了表示数据传输的结束，使用一个零大小的块（"0"）。这表明没有更多的块要传输，标志着实体主体的结束。</li></ol><p>下面是一个简单的示例，展示了一个包含两个分块的HTTP响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-moonscript"><span class="hljs-number">7</span>\r\n</span><br><span class="language-moonscript">Hello, \r\n</span><br><span class="language-moonscript"><span class="hljs-number">6</span>\r\n</span><br><span class="language-moonscript">world!\r\n</span><br><span class="language-moonscript"><span class="hljs-number">0</span>\r\n\r\n</span><br></code></pre></td></tr></table></figure><p>在这个例子中，第一个块大小为7（十进制），包含字符串"Hello,"；第二个块大小为6，包含字符串"world!"；最后的块为0，表示传输结束。</p><h2 id="rpc协议">RPC协议</h2><p>RPC（Remote ProcedureCall）远程过程调用协议是一个用于建立适当框架的协议。从本质上讲，它使一台机器上的程序能够调用另一台机器上的子程序，而不会意识到它是远程的。</p><h3 id="为什么会有rpc">为什么会有RPC</h3><p>大多数独立的应用程序并没有那么多地使用消息传递技术。一般来说，首选的机制是函数（或方法或过程）的调用。RPC就是将这种编程方式引入网络世界的一种尝试。</p><h3 id="rpc如何工作">RPC如何工作</h3><figure><imgsrc="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17dffc912301f96a0d2c7b6f55255365.png"alt="See the source image" /><figcaption aria-hidden="true">See the source image</figcaption></figure><h2 id="常见的网络攻击方式有哪些">常见的网络攻击方式有哪些</h2><ol type="1"><li>SQL注入攻击</li><li>DDoS攻击</li><li>中间人攻击</li><li>暴力破解</li><li>网络钓鱼</li><li>零日攻击</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-static初始化</title>
    <link href="/2023/11/23/Cpp-static%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2023/11/23/Cpp-static%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="c-static初始化">C++ static初始化</h1><h2 id="non-local-static对象初始化函数外">non-localstatic对象初始化(函数外)</h2><p>C++规定,non-local static对象的初始化发生在main函数执行之前，也即main函数之前的单线程启动阶段，所以不存在线程安全问题。但<strong>C++没有规定多个non-localstatic 对象的初始化顺序，尤其是来自多个编译单元的non-localstatic对象，他们的初始化顺序是随机的</strong>。</p><h2 id="local-static对象初始化函数内">localstatic对象初始化(函数内)</h2><p>对于local static对象，其初始化发生在控制流第一次执行到该对象的初始化语句时。多个线程的控制流可能同时到达其初始化语句。</p><p>在C++11之前，在多线程环境下localstatic对象的初始化并<strong>不是线程安全的</strong>。具体表现就是：如果一个线程正在执行localstatic对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该localstatic对象的构造函数中。这会造成这个localstatic对象的重复构造，进而产生内存泄露问题。所以，localstatic对象在多线程环境下的重复构造问题是需要解决的。</p><p>而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始localstatic 对象的初始化后到完成初始化前，其他线程执行到这个localstatic对象的初始化语句就会等待，直到该local static 对象初始化完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++知识点</title>
    <link href="/2023/11/23/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/11/23/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="c知识点">C++知识点</h1><h2 id="c-知识点">C++ 知识点</h2><h3 id="说一下你理解的-c-中的四种智能指针">说一下你理解的 C++中的四种智能指针</h3><p>面试官你好，⾸先，说一下为什么要使用智能指针：智能指针其作用是管理一个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。</p><p>然后使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要⼿动释放内存空间。</p><p><strong>常用接口</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>T&amp; <span class="hljs-keyword">operator</span>*(); T* <span class="hljs-keyword">operator</span>-&gt;();<br>T&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> T&amp; val); <br><span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span> <span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>T 是模板参数, 也就是传入的类型；</li><li>get() 用来获取 auto_ptr 封装在内部的指针, 也就是获取原生指针；</li><li>operator() 重载 , operator-&gt;() 重载了-&gt;,operator=()重载了=；</li><li>realease() 将 auto_ptr 封装在内部的指针置为 nullptr,但并不会破坏指针所指向的内容, 函数返回的是内部指针置空之前的值；</li><li>直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值,则将内部指针初始化为该值 (否则将其设置为 nullptr；</li></ul><p>下面分别说一下哪四种：</p><h4 id="auto_ptrc98-的方案c11-已抛弃采用所有权模式">1.<strong>auto_ptr</strong>（C++98 的方案，C11 已抛弃）采用所有权模式</h4><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;std::string&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;hello&quot;</span>))</span></span>;<br>auto_ptr&lt;std::string&gt; p2;<br>p2 = p1; <span class="hljs-comment">//auto_ptr 不会报错.</span><br></code></pre></td></tr></table></figure></p><p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p><h4 id="unique_ptr替换-auto_ptr">2. <strong>unique_ptr</strong>（替换auto_ptr ）</h4><p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露特别有用。</p><p>采用所有权模式，还是上面那个例子</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-keyword">auto</span>))</span></span>;<span class="hljs-comment">//#4 </span><br>unique_ptr&lt;string&gt; p4；<span class="hljs-comment">//#5</span><br>p4 = p3;<span class="hljs-comment">//此时会报错</span><br></code></pre></td></tr></table></figure></p><p>编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。</p><p>因此，unique_ptr ⽐ auto_ptr 更安全。</p><h4 id="shared_ptr共享型强引用">3.<strong>shared_ptr</strong>（共享型，强引用）</h4><p>shared_ptr实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。</p><p>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用release() 时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针。</p><h4 id="weak_ptr弱引用">4. <strong>weak_ptr</strong>（弱引用）</h4><p>weak_ptr是一种<strong>不控制对象生命周期的智能指针</strong>，它指向一个shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr。</p><p>weak_ptr 只是提供了对管理对象的一个访问⼿段。weak_ptr设计的目的是为配合 shared_ptr 而引入的一种智能指针，来协助 shared_ptr工作，它只可以从一个 shared_ptr 或另一个 weak_ptr对象构造,它的构造和析构不会引起引用记数的增加或减少。</p><p>weak_ptr 是用来<strong>解决 shared_ptr相互引用时的死锁问题</strong>，如果说两个 shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用lock 函数来获得 shared_ptr。</p><p>当两个智能指针都是 shared_ptr类型的时候，析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（的析构函数没有被调用），解决办法：把其中一个改为weak_ptr就可以。</p><p>详细介绍智能指针见<ahref="https://gstarmin.github.io/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">C++智能指针</a></p><h3id="make_shared与直接创建shared_ptr的区别">make_shared与直接创建shared_ptr的区别</h3><h4 id="shared_ptr结构">shared_ptr结构</h4><p>shared_ptr源码如下（截取片段）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> : <span class="hljs-keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="hljs-comment">// class for reference counted resource management</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ptr_base</span> &#123; <span class="hljs-comment">// base class for shared_ptr and weak_ptr</span><br><span class="hljs-keyword">private</span>:<br>    element_type* _Ptr&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    _Ref_count_base* _Rep&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/v2-0f63ac10a770358bae0ec65a954fe457_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/v2-4dccfe27f585d77a81e74ca427731616_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4id="直接创建shared_ptr是异常不安全的可能会发生内存泄漏而make_shared是异常安全的">（1）直接创建shared_ptr是异常不安全的，可能会发生内存泄漏；而make_shared是异常安全的。</h4><p>参考下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不好：可能会泄漏</span><br><span class="hljs-comment">//异常不安全的，编译器可能会把两个用以创建函数的两个参数的表达式重新排序。</span><br><span class="hljs-comment">//可能会首先为两个对象先进行内存分配，然后再试图调用二者的Widget构造函数。</span><br><span class="hljs-comment">//一旦其中一个构造函数调用抛出了异常，那么另一个对象的内存可能永远不会被释放了！</span><br><br><span class="hljs-comment">//异常不安全</span><br><span class="hljs-built_in">fun</span>(<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(a,b)),<br>    <span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(c,d)));<br><br><span class="hljs-comment">//异常不安全</span><br><span class="hljs-keyword">auto</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(a,b);<br><span class="hljs-keyword">auto</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(c,d);<br><span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(p1);<br><span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(p2);<br><br><span class="hljs-comment">//异常安全，但写法不干净</span><br><span class="hljs-function">shared_ptr&lt;Widget&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget(a,b))</span></span>;<br><span class="hljs-function">shared_ptr&lt;Widget&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget(c,d))</span></span>;<br><span class="hljs-built_in">fun</span>(sp1,sp2);<br><br><span class="hljs-comment">//异常安全，性能最好，也很干净</span><br><span class="hljs-built_in">fun</span>(<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(a,b), <span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(c,d));<br></code></pre></td></tr></table></figure><h4id="make_shared-只需要分配一次内存而直接创建-shared_ptr-需要分配两次内存">2）make_shared只需要分配一次内存，而直接创建 shared_ptr 需要分配两次内存。</h4><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/v2-a26c103854275fabd9f854a186ff7c18_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>采用直接创建shared_ptr的方式，那么首先需要在堆上为原始对象分配内存，其次根据上面shared_ptr 的构造函数可知，<code>new _Ref_count&lt;_Ux&gt;(_Px)</code>时还需要为控制块分配一次内存。</p><p>然后我们再来看看 make_shared 源码，它采用placementnew的方式，动态分配了一个<code>_Ref_count_obj2</code>，这也是<code>_Ref_count_base</code>的一个派生类，<code>union &#123;_Wrap&lt;_Ty&gt; _Storage;&#125;</code>为<code>_Ty</code>类型的对象分配了内存空间，所以对象和控制块都被放在了一块。</p><h4id="make_shared也存在缺陷只有当-_weaks-为-0-时控制块才会调用-_delete_this-释放自己weak_ptr会拖延整块内存释放时间">（3）make_shared也存在缺陷，只有当_Weaks 为 0 时，控制块才会调用 _Delete_this()释放自己，weak_ptr会拖延整块内存释放时间。</h4><p>上面我们提到，在_Ref_count_base的实现中，只有当 _Weaks 为 0时，控制块才会调用 _Delete_this()释放自己，然而**由于现在对象也被放在了控制块中，所以即使 _Uses 为 0时，对象空间也没有算被释放，只有当 _Weaks 为 0 时，才算是真的被释放了**。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;MyClass()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~MyClass()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x, y, z;<br>&#125;;<br><br><span class="hljs-type">int</span> alloc_times = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dealloc_times = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> allocated = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-type">void</span>* p = std::<span class="hljs-built_in">malloc</span>(size);<br>    cout &lt;&lt; <span class="hljs-string">&quot;new &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot; byte(s)&quot;</span> &lt;&lt; endl;<br><br>    allocated += size;<br>    alloc_times++;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;deleted memory&quot;</span> &lt;&lt; endl;<br><br>    dealloc_times++;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;MyClass&gt; w;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配尺寸:&quot;</span> &lt;&lt; allocated &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配次数&quot;</span> &lt;&lt; alloc_times &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;释放次数&quot;</span> &lt;&lt; dealloc_times &lt;&lt; endl;<br>    &#123;<br>        <span class="hljs-comment">//shared_ptr&lt;MyClass&gt; s&#123;new MyClass()&#125;;</span><br>        shared_ptr s = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>        w = s;<br><br>    &#125;   <span class="hljs-comment">//1. s析构、释放原始对象、但不释放控制块</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;block end--------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配尺寸:&quot;</span> &lt;&lt; allocated &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配次数&quot;</span> &lt;&lt; alloc_times &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;释放次数&quot;</span> &lt;&lt; dealloc_times &lt;&lt; endl;<br><br>    w.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//2. w析构、释放控制块</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;分配尺寸:&quot;</span> &lt;&lt; allocated &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配次数&quot;</span> &lt;&lt; alloc_times &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;释放次数&quot;</span> &lt;&lt; dealloc_times &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>当采用直接创建shared_ptr的方式时，输入如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">分配尺寸:0<br>分配次数0<br>释放次数0<br>new 24 byte(s)<br>MyClass()<br>new 24 byte(s)<br>~MyClass()<br>deleted memory<br>block end--------<br>分配尺寸:48<br>分配次数2<br>释放次数1<br>deleted memory<br>分配尺寸:48<br>分配次数2<br>释放次数2<br></code></pre></td></tr></table></figure><p>当采用make_shared的方式时，输入如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">分配尺寸:0<br>分配次数0<br>释放次数0<br>new 40 byte(s)<br>MyClass()<br>~MyClass()<br>block end--------<br>分配尺寸:40<br>分配次数1<br>释放次数0<br>deleted memory<br>分配尺寸:40<br>分配次数1<br>释放次数1<br></code></pre></td></tr></table></figure><h3id="智能指针的引用计数是普通成员变量还是指针变量使用static可不可以">智能指针的引用计数是普通成员变量还是指针变量？使用static可不可以？</h3><p>指针变量；</p><p>不可以用static变量，在只有一个对象的时候，该方法是合适的。但是static变量是属于类的，如下图所示，当出现第二个对象，此时新增一个shared_ptr指针，此时内部的count就变成了4，既不满足指向对象1的指针数量，也不满足指向对象2的指针数量。</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/650eab4b416c41089f3219a7b6dea02f.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="c-中内存分配情况">C++ 中内存分配情况</h3><p>栈：由编译器管理分配和回收，存放局部变量和函数参数。</p><p>堆：由程序员管理，需要⼿动 new malloc delete free进行分配和回收，空间较大，但可能会出现内存泄漏和空闲碎⽚的情况。</p><p>全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</p><p>常量存储区：存储常量，一般不允许修改。</p><p>代码区：存放程序的⼆进制代码。</p><h3id="c中指针参数传递和引用参数传递">C++中指针参数传递和引用参数传递</h3><p><strong>指针参数传递本质上是值传递</strong>，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p><p>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的<strong>实参变量的地址</strong>。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p><p><strong>引用传递和指针传递是不同的</strong>，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p><p><strong>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）</strong>。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><h3 id="c-中-const-和-static-关键字定义用途">C++ 中 const 和 static关键字（定义，用途）</h3><h4 id="static-作用控制变量的存储方式和可性">static作用：控制变量的存储方式和可⻅性</h4><p><strong>作用一,修饰局部变量</strong>：一般情况下，对于局部变量在程序中是存放在栈区的，并且局部的生命周期在包含语句块执行结束时便结束了。但是如果用static关键字修饰的话，该变量便会存放在静态数据区，其生命周期会一直延续到整个程序执行结束。但是要注意的是，虽然用static对局部变量进行修饰之后，其生命周期以及存储空间发生了变化，但其作用域并没有改变，作用域还是限制在其语句块。</p><p><strong>作用二,修饰全局变量</strong>：C++中全局变量是对整个项目都可见的，只要你在另一个文件中使用的时候加上<strong>extern关键字</strong>，如果你想让这个全局变量作用域改为仅当前文件可见，那么可以在定义的时候在前面加上static关键字。也就是说，C++中static关键字和extern关键字是冲突的。<strong>如果你在一个文件中声明了一个static全局变量，它将无法在其他文件中通过extern关键字访问。static全局变量的生命周期是整个程序的执行期间，但它的链接属性是内部的，意味着它只能在定义它的翻译单元（通常是一个源文件）中被访问</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// header.h</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVarGlobal = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// source1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header.h&quot;</span></span><br><span class="hljs-comment">// staticVarGlobal 可以在这里访问,因为有include</span><br><br><span class="hljs-comment">// source2.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> staticVarGlobal; <span class="hljs-comment">// 错误：staticVarGlobal 在这个文件中不可见</span><br></code></pre></td></tr></table></figure><p><strong>作用三,修饰函数</strong>：用 static修饰函数，情况和修饰全局变量类似，也是改变了函数的作用域。</p><p><strong>作用四,修饰类的成员变量/成员函数</strong>：如果 C++中对类中的某个函数用 static修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，则表示该变量以及所有的对象共有，存储空间中只存在一个副本，可以通过；类和对象去调用。</p><p>（补充：静态非常量数据成员，其只能在类外定义和初始化，在类内仅是声明而已。）</p><p><strong>作用五,函数体/类成员函数内声明 static</strong>:</p><ul><li>函数体内 static 变量的作用范围为该函数体，不同于 auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</li><li>在模块内的 static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</li><li>在模块内的 static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；<br /></li><li>在类中的 static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li><li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this指针，因而只能访问类的 static 成员变量。</li><li>static 类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化；</li><li>由于 static 修饰的类成员函数属于类，不属于对象，因此 <strong>static类成员函数是没有 this 指针</strong>，this指针是指向本对象的指针，正因为没有 this 指针，<strong>所以 static类成员函数不能访问⾮ static 的类成员，只能访问static修饰的类成员；</strong></li><li>static 成员函数不能被 virtual 修饰，static成员不属于任何对象或实例，所以加上 virtual没有任何实际意义；静态成员函数没有 this指针，虚函数的实现是为每一个对象分配一个 vptr 指针，而 vptr 是通过 this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtualfunction。</li></ul><h4 id="const-关键字含义及实现机制">const 关键字：含义及实现机制</h4><p><strong>const 修饰基本类型数据类型</strong>：基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值即可。</p><p><strong>const 修饰指针变量和引用变量</strong>：如果 const位于小星星的左侧,也叫<strong>顶层const</strong>，则 const就是用来<strong>修饰指针所指向的变量，即指针指向为常量</strong>；如果const 位于小星星的右侧，也叫<strong>底层const</strong>，则 <strong>const就是修饰指针本身，即指针本身是常量</strong>。</p><p><strong>const 应用到函数中</strong>：作为参数的 const修饰符：调用函数的时候，用相应的变量初始化 const常量，则在函数体中，按照 const所修饰的部分进行常量化，保护了原对象的属性。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>参数 const 通常用于参数为指针或引用的情况; 作为函数返回值的 const修饰符：声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。</p></div><p><strong>const 在类中的用法</strong>：const成员变量，只在某个对象生命周期内是常量，而对于整个类而⾔是可以改变的。因为类可以创建多个对象，不同的对象其const 数据成员值可以不同。所以不能在类的声明中初始化 const数据成员，因为类的对象在没有创建时候，编译器不知道 const数据成员的值是什么。<strong>const数据成员的初始化只能在类的构造函数的初始化列表中进行</strong>。const成员函数：const成员函数的主要目的是防⽌成员函数修改对象的内容。要注意，<strong>const关键字和 static 关键字对于成员函数来说是不能同时使用的，因为 static关键字修饰静态成员函数不含有 this 指针，即不能实例化，const成员函数⼜必须具体到某一个函数</strong>。</p><p><strong>const修饰类对象，定义常量对象</strong>：常量对象只能调用常量函数，别的成员函数都不能调用。</p><div class="admonition note"><p class="admonition-title">note</p><p>const 成员函数中如果实在想修改某个变量，可以使用 mutable进行修饰。成员变量中如果想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现或者static const。</p></div><p><strong>C ++ 中的const类成员函数（用法和意义）</strong>:常量对象可以调用类中的 const成员函数，但不能调用非 const 成员函数； （原因：const成员函数承诺不修改对象的状态。因此，即使在常量对象上调用，它们也不会违反对象的不可变性。因此，对于常量对象来说，只有const 成员函数是安全的，并且可以被调用。而非 const成员函数没有保证不修改对象的状态。因此，在常量对象上调用非 const成员函数会导致潜在的对象状态修改，这与常量对象的本质相违背，因此编译器不允许这样的调用。）</p><div class="admonition info"><p class="admonition-title">info</p><p>const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。</p></div><h3 id="c-和-c-区别-函数类structclass">C 和 C++ 区别（函数/类/struct/class）</h3><p>C 和 C++ 在基本语句上没有过大的区别，但在语法和关键字上，C++有许多新增的内容。以下是一些主要的区别：</p><p>首先，C++与C在<strong>语法和关键字</strong>上有显著区别。C++允许<strong>命名空间</strong>的概念，这使得我们能够定义自己的作用域，而在C中是不允许的。此外，在<strong>关键字</strong>方面，C++采用不同的内存管理方式，引入了<code>new</code>和<code>delete</code>来动态管理内存，同时也在指针的基础上增加了引用的概念。C++还引入了一些新的关键字，例如<code>auto</code>、<code>explicit</code>，以及<code>dynamic_cast</code>用于增强类型安全性。</p><p><strong>在函数方面</strong>，C++引入了<strong>函数重载</strong>和<strong>虚函数</strong>的概念。函数重载允许同名函数拥有不同的参数列表，以提供更多灵活性，而C不支持函数重载。另外，C++的虚函数概念用于实现多态性。</p><p><strong>在类方面</strong>，C语言的struct和C++中的class有着显著区别。在C++中，struct不仅可以包含成员变量，还可以包含成员函数，并且引入了成员访问权限的概念。在<strong>C++中，struct的默认成员访问权限和默认继承权限都是public，而class的默认成员访问权限和默认继承权限都是private</strong>。</p><p>C++还引入了模板的概念，允许代码的重用，并且提供了更强大的<strong>STL标准库</strong>。</p><p>总体来说，C语言更加侧重于算法和数据结构，强调通过代码和过程对输入进行运算处理并输出。而C++更加注重对象模型的构建，利用对象的状态信息来得到输出。因此，C的struct更适合看作是数据结构的实现体，而C++的class更适合看作是对象的实现体。</p><h3 id="c-和-java的区别">C++ 和 Java的区别</h3><ul><li><strong>指针</strong>：Java语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的自动管理功能，从而有效的防⽌了C++ 语⾔中的指针操作失误的影响。但并⾮ Java 中没有指针，Java虚拟机内部中还是用了指针，保证了 Java 程序的安全。</li><li><strong>多重继承</strong>：C++ ⽀持多重继承但 Java不⽀持，但⽀持一个类继承多个接口，实现了 C++ 中多重继承的功能，⼜避免了C++ 的多重继承带来的不便。</li><li><strong>数据类型和类</strong>：Java是完全面向对象的语⾔，所有的函数和变量必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可以实现自⼰的特点和行为。Java 中取消了 C++ 中的 struct 和 union 。</li><li><strong>自动内存管理</strong>：Java 程序中所有对象都是用 new操作符建立在内存堆栈上，<strong>Java自动进行无用内存回收操作</strong>，不需要程序员进行⼿动删除。而 C++中必须由程序员释放内存资源，增加了程序设计者的负担。Java中当一个对象不再被用到时， 无用内存回收器将给他们加上标签。Java⾥无用内存回收程序是以线程方式在后台运行的，利用空闲时间工作来删除。</li><li>Java 不⽀持操作符重载。<strong>操作符重载被认为是 C++的突出特性。</strong></li><li>Java 不⽀持预处理功能。C++ 在编译过程中都有一个预编译阶段，Java没有预处理器，但它提供了 import 与 C++预处理器具有类似功能。</li><li><strong>类型转换</strong>：C++ 中有数据类型隐含转换的机制，Java中需要限时强制类型转换。</li><li><strong>字符串</strong>：C++中字符串是以 Null终⽌符代表字符串的结束，而 Java 的字符串 是用类对象（string 和stringBuffer）来实现的。</li><li>Java 中不提供 goto 语句，虽然指定 goto作为关键字，但不⽀持它的使用，使程序简洁易读。</li><li>Java 的异常机制用于捕获例外事件，增强系统容错能⼒。</li></ul><h3 id="说一下-c-里是怎么定义常量的常量存放在内存的哪个位置">说一下 C++里是怎么定义常量的？常量存放在内存的哪个位置？</h3><ul><li>对于局部常量，存放在栈区；</li><li>对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</li><li>字面值常量，⽐如字符串，放在常量区。</li></ul><h3 id="c-中重载重写重定义的区别">C++ 中重载、重写、重定义的区别</h3><p><strong>重载</strong>：翻译自overload，是指同一可访问区内被声明的几个具有不同参数列表的同名函数，依赖于C++函数名字的修饰会将参数加在后面，<strong>可以是参数类型，个数，顺序的不同</strong>。根据参数列表决定调用哪个函数，重载不关⼼函数的返回类型。</p><p><strong>重写</strong>：翻译自override，派生类中重新定义父类中除了函数体外完全相同的<strong>虚函数</strong>，注意被重写的函数不能是static的，一定要是虚函数，且其他一定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管virtual 中是 private 的，派生类中重写可以改为 public。</p><p><strong>重定义（隐藏）</strong>：派生类重新定义父类中相同名字的<strong>非虚函数</strong>，参数列表和返回类型都可以不同，即父类中除了定义成 virtual且完全相同的同名函数才不会被派生类中的同名函数所隐藏（重定义）。</p><p><strong>重写和隐藏的区别在于基类函数是否是虚函数</strong>。</p><h3 id="介绍-c-所有的构造函数">介绍 C++ 所有的构造函数</h3><p>类的对象被创建时，编译系统为对象分配内存空间，并自动调用构造函数，由构造函数完成成员的初始化工作。即<strong>构造函数的作用：初始化对象的数据成员</strong>。</p><p><strong>无参数构造函数</strong>：即默认构造函数，如果没有明确写出无参数构造函数，编译器会自动生成默认的无参数构造函数，函数为空，什么也不做，如果不想使用自动生成的无参构造函数，必需要自⼰显示写出一个无参构造函数。</p><p><strong>一般构造函数</strong>：也称<strong>重载构造函数</strong>，一般构造函数可以有各种参数形式，一个类可以有多个一般构造函数，前提是参数的个数或者类型不同，创建对象时根据传入参数不同调用不同的构造函数。</p><p><strong>拷贝构造函数</strong>：拷贝构造函数的函数参数为对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在的对象的数据成员的值一一复制到新创建的对象中。如果没有显示的写拷贝构造函数，则系统会默认创建一个拷贝构造函数，但当类中有指针成员时，最好不要使用编译器提供的默认的拷贝构造函数，最好自⼰定义并且在函数中执行深拷贝。</p><p><strong>类型转换构造函数</strong>：根据一个指定类型的对象创建一个本类的对象，也可以算是一般构造函数的一种，这⾥提出来，是想说有的时候不允许默认转换的话，要记得将其声明为explict 的，来阻⽌一些隐式转换的发生。</p><p><strong>赋值运算符的重载</strong>：注意，这个类似拷贝构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会生成默认的赋值运算符，做一些基本的拷贝工作。</p><p>这里区分赋值构造函数和拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a1, A a2; a1 = a2;    <span class="hljs-comment">// 调用赋值运算符</span><br>A a3 = a1;              <span class="hljs-comment">// 调用拷贝构造函数</span><br></code></pre></td></tr></table></figure><h3 id="c-的四种强制转换">C++ 的四种强制转换</h3><p><strong>static_cast</strong>：明确指出类型转换，一般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上行转换（派生类-&gt;基类）安全，下行转换（基类-&gt;派生类）不安全，所以<strong>主要执行⾮多态的转换操作</strong>；</p><p><strong>dynamic_cast</strong>：专门用于派生类之间的转换，type-id必须是类指针，类引用或void*，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而static_cast，当类型不一致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。</p><p><strong>const_cast</strong>：专门用于 const 属性的转换，去除 const性质，或增加 const 性质，是四个转换符中唯一一个可以操作常量的转换符。</p><p><strong>reinterpret_cast</strong>：<strong>不到万不得已，不要使用这个转换符，高危操作</strong>。使用特点：从底层对数据进行重新解释，依赖具体的平台，可移植性差； 可以将整形转换为指针，也可以把指针转换为数组；可以在指针和引用之间进行肆无忌惮的转换。</p><h3 id="指针和引用的区别">指针和引用的区别</h3><p>指针和引用都是一种内存地址的概念，区别呢，指针是一个实体，引用只是一个别名。在程序编译的时候，将指针和引用添加到符号表中。</p><p>指针它指向一块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有const 和⾮ const 区别，甚⾄可以为空，sizeof指针得到的是指针类型的大小。</p><p>而对于引用来说，它只是一块内存的别名，在添加到符号表的时候，是将"引用变量名-引用对象的地址"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑定到一块内存上，后续不能更改，也不能为空，也没有const 和⾮ const 区别。</p><p>sizeof 引用得到代表对象的大小。而 sizeof指针得到的是指针本身的大小。另外在参数传递中，指针需要被解引用后才可以对对象进行操作，而直接对引用进行的修改会直接作用到引用对象上。</p><p>作为参数时也不同，传指针的实质是传值，传递的值是指针指向内存的地址；传引用的实质是传地址，传递的是变量的地址。</p><h3id="野wild指针与悬空dangling指针有什么区别如何避免">野(wild)指针与悬空(dangling)指针有什么区别？如何避免？</h3><p><strong>野指针(wild pointer)</strong>：就是没有被初始化过的指针。用<code>gcc -Wall</code>编译, 会出现 used uninitialized 警告。</p><p><strong>悬空指针</strong>：是指针最初指向的内存已经被释放了的一种指针。</p><p>无论是野指针还是悬空指针，都是指向无效内存区域(这⾥的无效指的是"不安全不可控")的指针。访问"不安全可控"(invalid)的内存区域将导致"Undefined Behavior"。</p><p><strong>如何避免使用野指针</strong>?在平时的编码中，养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。</p><h3 id="说一下-const-修饰指针如何区分">说一下 const修饰指针如何区分？</h3><p>下面都是合法的声明，但是含义大不同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p1;  <span class="hljs-comment">//指向整形常量 的指针，它指向的值不能修改</span><br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p2;  <span class="hljs-comment">//指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3; <span class="hljs-comment">//指向整形常量 的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。</span><br></code></pre></td></tr></table></figure><p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。</p><p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。</p><h3 id="简单说一下函数指针">简单说一下函数指针</h3><p>从定义和用途两方面来说一下自⼰的理解：</p><p>⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这⾥是指向函数。</p><p>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p><p>其次是用途：调用函数和做函数的参数，⽐如回调函数。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> * p)</span> </span>&#123;…&#125; <span class="hljs-comment">// 函数fun</span><br><span class="hljs-type">char</span> * (*pf)(<span class="hljs-type">char</span> * p); <span class="hljs-comment">// 函数指针pf</span><br>pf = fun;               <span class="hljs-comment">// 函数指针pf指向函数fun</span><br><span class="hljs-built_in">pf</span>(p);                  <span class="hljs-comment">// 通过函数指针pf调用函数fun</span><br></code></pre></td></tr></table></figure><h3 id="堆和栈区别">堆和栈区别</h3><p><strong>栈</strong>：由编译器进行管理，在需要时由编译器自动分配空间，在不需要时候自动回收空间，一般保存的是局部变量和函数参数等。</p><p>连续的内存空间，在函数调用的时候，⾸先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。</p><p>大多数编译器中，参数是从右向左入栈（原因在于采用这种顺序，是为了让程序员在使用C/C++的“函数参数⻓度可变”这个特性时更方便。如果是从左向右压栈，第一个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第一步就需要解析可变参数表的各参数类型，即第一步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产生碎⽚。</p><p>栈是<strong>高地址向低地址扩展</strong>，栈底高地址，空间较小。</p><p><strong>堆</strong>：由程序员管理，需要⼿动 new malloc delete free进行分配和回收，如果不进行回收的话，会造成内存泄漏的问题。</p><p>不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个大于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写入内存大小，方便delete回收空间大小。当然如果有剩余的，也会将剩余的插入到空闲链表中，这也是产生内存碎⽚的原因。</p><p>堆是<strong>低地址向高地址扩展</strong>，空间较大，较为灵活。</p><h3 id="函数传递参数的几种方式">函数传递参数的几种方式</h3><p><strong>值传递</strong>：形参是实参的拷贝，函数内部对形参的操作并不会影响到外部的实参。</p><p><strong>指针传递</strong>：也是值传递的一种方式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。</p><p><strong>引用传递</strong>：实际上就是把引用对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上面。</p><h3 id="new-delete-malloc-free-区别">new / delete ，malloc / free区别</h3><p>都可以用来在堆上分配和回收空间。new / delete是<strong>操作符</strong>，malloc/free 是<strong>库函数</strong>。</p><p><strong>执行 new实际上执行两个过程</strong>：1.分配未初始化的内存空间（malloc）；2.使用对象的构造函数对空间进行初始化；返回空间的⾸地址。如果在第一步分配空间中出现问题，则抛出std::bad_alloc异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则自动调用delete 释放内存。</p><p><strong>执行 delete 实际上也有两个过程</strong>：1.使用析构函数对对象进行析构；2.回收内存空间（free）。以上也可以看出 new和 malloc 的区别，new 得到的是经过初始化的空间，而 malloc得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc一个字节⻓度的空间。delete 和 free 同理，delete不仅释放空间还析构对象，delete 一个类型，而 free是释放一个字节⻓度的空间。</p><p><strong>为什么有了 malloc／free 还需要new／delete</strong>？因为对于⾮内部数据类型而⾔，光用 malloc／free无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于mallo／ free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于malloc／free，所以有了 new／delete 操作符。</p><h3 id="volatile-和-extern-关键字">volatile 和 extern 关键字</h3><p><strong>volatile 三个特性</strong>:</p><ul><li>易变性：在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile 变量的寄存器内容，而是重新从内存中读取。</li><li>不可优化性：volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚⾄将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</li><li>顺序性：能够保证 volatile变量之间的顺序性，编译器不会进行乱序优化。</li></ul><p><strong>extern</strong>:</p><p>在 C 语⾔中，修饰符 extern 用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。</p><p>注意 extern 声明的位置对其作用域也有关系，如果是在 main函数中进行声明的，则只能在 main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include 包含进来即可，为啥要用 extern？因为用 extern会加速程序的编译过程，这样能节省时间。</p><p>在 C++ 中 extern 还有另外一种作用，用于指示 C 或者C＋＋函数的调用规范。⽐如在 C＋＋ 中调用 C 库函数，就需要在 C＋＋程序中用 extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是 C＋＋ 和 C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。不单单是C++可以调用C，在C中也可以用extern关键字调用C++函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++调用C函数</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//xx.c</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//xx.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xx.h&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C调用C++函数</span><br><br><span class="hljs-comment">//xx.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//xx.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;    <br>&#125;<br><span class="hljs-comment">//xx.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="define-和-const-的区别编译阶段安全性内存占用等">define 和 const的区别（编译阶段、安全性、内存占用等）</h3><p>对于 define来说，<strong>宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查</strong>，仅仅做的是遇到宏定义进行字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为define 宏定义仅仅是展开，因此运行时系统并不为宏定义分配内存，但是从汇编的⻆度来讲， define 却以立即数的方式保留了多份数据的拷贝。</p><p>对于 const 来说，<strong>const 是在编译期间进行处理的，const有类型，也有类型检查</strong>，程序运行时系统会为 const常量分配内存，而且从汇编的⻆度讲，const常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的const 常量分配内存，而是直接将 const常量添加到符号表中，省去了读取和写入内存的操作，效率更高。</p><p>此外C++ 11 中还引入了 constexpr 的关键字（并在C++14中进行改进），它也用于定义常量，但它更强调在编译时期求值的常量。const变量可以在编译时期或运行时期进行赋值，而 constexpr只能在编译时期赋值。</p><p><strong>const 和 constexpr 的区别</strong>？见下条</p><h3 id="const-和-constexpr-的区别">const 和 constexpr 的区别</h3><p>在 C++ 中，const 和 constexpr都用于创建常量，但它们在使用和编译时期的特性上有一些区别：</p><ul><li>const 可以修饰变量或者指针，表示其值不可以被修改，而 constexpr更强调在编译时期求值的变量</li><li>const 变量可以在编译时期或运行时期进行赋值，而 constexpr只能在编译时期赋值。</li><li>const变量的值在编译时期不需要确定，可以是运行时期确定的值，只要在使用前初始化即可；而constexpr变量的值必须在编译时期确定，其初始化必须是一个常量表达式。</li><li>在修饰函数时，const只能用于非静态成员函数，它保证成员函数不修改任何非静态数据；而constexpr函数是在使用需要它的代码时，可在编译时计算其返回值的函数，当其自变量为constexpr 值时， constexpr 函数将生成编译时 constant（常数）。 使用非constexpr自变量调用时，或者编译时不需要其值时，它将与正则函数一样，在运行时生成一个值。（此双重行为使你无需编写同一函数的 constexpr 和非 constexpr版本。）</li></ul><h3id="面向对象的三大特性并举例说明">面向对象的三大特性，并举例说明</h3><p>C++ 面向对象的三大特征是：封装、继承、多态。</p><p><strong>所谓封装</strong></p><p>就是把客观事物封装成抽象的类，并且类可以把自⼰的数据和方法只让信任的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防⽌程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><p><strong>所谓继承</strong></p><p>是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它⽀持按级分类的概念。继承是指这样一种能⼒：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或者“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。</p><p>继承概念的实现方式有两类：</p><p>实现继承：实现继承是指直接使用基类的属性和方法而无需额外编码的能⼒。</p><p>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必需提供实现的能⼒。</p><p><strong>所谓多态</strong></p><p>指的是通过一个基类指针或引用调用一个虚函数时，会根据具体对象的类型来调用该虚函数的不同实现1。在多态中，相同的操作可以作用于不同的对象，而具体执行的操作则取决于对象的类型和特性1。</p><p>多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并产生代码，则是静态的，即地址早绑定。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定</p><h3 id="多态的实现">多态的实现</h3><p>多态其实一般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数生成符号表时的不同规则，重载只是一种语⾔特性，与多态无关，与面向对象也无关，但这⼜是C++中增加的新规则，所以也算属于C++，所以如果⾮要说重载算是多态的一种，那就可以说：多态可以分为<strong>静态多态</strong>和<strong>动态多态</strong>。</p><p><strong>静态多态其实就是重载</strong>，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定；</p><p><strong>动态多态是指通过子类重写父类的虚函数来实现的</strong>，因为是在运行期间决定调用的函数，所以称为动态多态，一般情况下我们不区分这两个时所说的多态就是指动态多态。动态多态的实现与虚函数表，虚函数指针相关。</p><p><strong>扩展</strong>：子类是否要重写父类的虚函数？子类继承父类时，父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p><h3id="虚函数相关虚函数表虚函数指针虚函数的实现原理">虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</h3><p>⾸先我们来说一下，C++中多态的表象，在基类的函数前加上 virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数，如果是基类，就调用基类的函数。</p><p>实际上，当一个类中包含虚函数时，编译器会为该类生成一个虚函数表，保存该类中虚函数的地址，同样，派生类继承基类，派生类中自然一定有虚函数，所以编译器也会为派生类生成自⼰的虚函数表。当我们定义一个派生类对象时，编译器检测该类型有虚函数，所以为这个派生类对象生成一个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。</p><p>后续如果有一个基类类型的指针，指向派生类，那么当调用虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调用派生类的虚函数表中的虚函数以此实现多态。</p><p><strong>补充</strong>：如果基类中没有定义成 virtual，那么进行 Base B;Derived D; Base *p = D; p-&gt;function(); 这种情况下调用的则是 Base 中的function()。因为基类和派生类中都没有虚函数的定义，那么编译器就会认为不用留给动态多态的机会，就事先进行函数地址的绑定（早绑定），详述过程就是，定义了一个派生类对象，⾸先要构造基类的空间，然后构造派生类的自身内容，形成一个派生类对象，那么在进行类型转换时，直接截取基类的部分的内存，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另一个表］中）绑定的函数地址也就是基类中函数的地址，所以执行的是基类的函数。</p><h3id="编译器处理虚函数表应该如何处理">编译器处理虚函数表应该如何处理</h3><p>对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤：</p><ol type="1"><li>拷贝基类的虚函数表，如果是多继承，就拷贝每个有虚函数基类的虚函数表</li><li>当然还有一个基类的虚函数表和派生类自身的虚函数表共用了一个虚函数表，也称为某个基类为派生类的主基类</li><li>查看派生类中是否有重写基类中的虚函数，如果有，就替换成已经重写的虚函数地址；查看派生类是否有自身的虚函数，如果有，就追加自身的虚函数到自身的虚函数表中。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Derived *pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">D</span>(); B *pb = pd; C *pc = pd;<br></code></pre></td></tr></table></figure><p>其中 pb，pd，pc的指针位置是不同的，要注意的是派生类的自身的内容要追加在主基类的内存块后。</p><figure><img src="/img/C++八股文/虚函数.jpg" alt="虚函数" /><figcaption aria-hidden="true">虚函数</figcaption></figure><h3 id="析构函数一般写成虚函数的原因">析构函数一般写成虚函数的原因</h3><p>直观的讲：是为了<strong>降低内存泄漏的可能性</strong>。举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数,该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。</p><p>如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。</p><h3id="构造函数为什么一般不定义为虚函数">构造函数为什么一般不定义为虚函数</h3><ul><li>虚函数调用只需要知道“部分的”信息，即只需要知道函数接口，而不需要知道对象的具体类型。但是，我们要创建一个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；</li><li>而且从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过实例化之后对象的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违反了先实例化后调用的准则。</li></ul><h3id="构造函数或析构函数中调用虚函数会怎样">构造函数或析构函数中调用虚函数会怎样</h3><p>实际上是不应该在构造函数或析构函数中调用虚函数的，因为这样的调用其实并不会带来所想要的效果。</p><p>举例来说就是，有一个动物的基类，基类中定义了一个动物本身行为的虚函数action_type()，在基类的构造函数中调用了这个虚函数。</p><p>派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自实现的虚函数，但实际上当我们创建一个派生类对象时，⾸先会创建派生类的基类部分，执行基类的构造函数，此时，派生类的自身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为一种安全的方法。</p><p>也就是说构造派生类的基类部分是，编译器会认为这就是一个基类类型的对象，然后调用基类类型中的虚函数实现，并没有按照我们想要的方式进行。即对象在派生类构造函数执行前并不会成为一个派生类对象。</p><p>在析构函数中也是同理，派生类执行了析构函数后，派生类的自身成员呈现未定义的状态，那么在执行基类的析构函数中是不可能调用到派生类重写的方法的。所以说，我们不应该在构在函数或析构函数中调用虚函数，就算调用一般也不会达到我们想要的结果。</p><h3 id="析构函数的作用如何起作用">析构函数的作用，如何起作用？</h3><p>构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数⾥面，这样就使其他的函数⾥面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就是你不写，编译器也自动调用一次。</p><p>析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</p><p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。</p><p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p><h3id="构造函数的执行顺序析构函数的执行顺序">构造函数的执行顺序？析构函数的执行顺序？</h3><p><strong>构造函数顺序</strong></p><ul><li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li><li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</li><li>派生类构造函数。</li></ul><p><strong>析构函数顺序</strong></p><ul><li>调用派生类的析构函数；</li><li>调用成员类对象的析构函数；</li><li>调用基类的析构函数。</li></ul><h3 id="纯虚函数-应用于接口继承和实现继承">纯虚函数（应用于接口继承和实现继承）</h3><p>实际上，纯虚函数的出现就是为了让继承可以出现多种情况：</p><ul><li>有时我们希望派生类只继承成员函数的接口</li><li>有时我们⼜希望派生类既继承成员函数的接口，⼜继承成员函数的实现，而且可以在派生类中可以重写成员函数以实现多态</li><li>有的时候我们⼜希望派生类在继承成员函数接口和实现的情况下，不能重写缺省的实现。</li></ul><p>其实，声明一个纯虚函数的目的就是为了让派生类只继承函数的接口，而且派生类中必需提供一个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进行实例化。</p><p>对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调用这个实现的唯一方式是在派生类对象中指出其class 名称来调用。</p><h3 id="静态绑定和动态绑定的介绍">静态绑定和动态绑定的介绍</h3><p>说起静态绑定和动态绑定，我们⾸先要知道<strong>静态类型和动态类型</strong>，静态类型就是它在程序中被声明时所采用的类型，在编译期间确定。动态类型则是指“目前所指对象的实际类型”，在运行期间确定。</p><p><strong>静态绑定</strong>，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期间。</p><p><strong>动态绑定</strong>，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发生在运行期间。</p><p>⽐如说，virtual函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意，我们<strong>不应该重新定义继承而来的缺省参数，因为即使我们重定义了，也不会起到效果</strong>。因为一个基类的指针指向一个派生类对象，在派生类的对象中针对虚函数的参数缺省值进行了重定义，但是<strong>缺省参数值是静态绑定的</strong>，静态绑定绑定的是静态类型相关的内容，所以会出现一种派生类的虚函数实现方式结合了基类的缺省参数值的调用效果，这个与所期望的效果不同。</p><h3id="深拷贝和浅拷贝的区别举例说明深拷贝的安全性">深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h3><p><strong>浅拷贝</strong>只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。<strong>深拷贝</strong>不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p><p>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数－即浅拷贝，它能够完成成员的一一复制。<strong>当数据成员中没有指针时，浅拷贝是可行的。</strong></p><p>但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致指野指针的问题。</p><p>所以，这时必需采用深拷贝。深拷贝与浅拷贝之间的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决来野指针的问题。简而⾔之，当数据成员中有指针时，必需要用深拷贝更加安全。</p><h3id="引用是否能实现动态绑定为什么可以实现">引用是否能实现动态绑定，为什么可以实现？</h3><p>可以。</p><p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>  <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>  <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br>Base&amp; b = s; <span class="hljs-comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span><br>s.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">//son::fun()</span><br>b.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">//son :: fun()</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>需要说明的是虚函数才具有动态绑定</strong>，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p><h3id="什么情况下会调用拷贝构造函数三种情况">什么情况下会调用拷贝构造函数(三种情况)</h3><ul><li>一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间中。</li><li>一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值。<br /></li><li>一个对象需要通过另外一个对象进行初始化。</li></ul><h3id="为什么拷贝构造函数必需时引用传递不能是值传递">为什么拷贝构造函数必需时引用传递，不能是值传递？</h3><p>为了防⽌递归调用。当一个对象需要以值方式进行传递时，编译器会生成代码调用它的拷贝构造函数生成一个副本，如果类A的拷贝构造函数的参数不是引用传递，而是采用值传递，那么就⼜需要为了创建传递给拷贝构造函数的参数的临时对象，而⼜一次调用类A 的拷贝构造函数，这就是一个无限递归。</p><h3id="结构体内存对齐方式和为什么要进行内存对齐">结构体内存对齐方式和为什么要进行内存对齐？</h3><p>⾸先我们来说一下结构体中内存对齐的规则：</p><ul><li>对于结构体中的各个成员，第一个成员位于偏移为 0的位置，以后的每个数据成员的偏移量必须是<code>min(#pragma pack()制定的数，数据成员本身⻓度)</code>的倍数。</li><li>在所有的数据成员完成各自对齐之后，结构体或联合体本身也要进行对齐，整体⻓度是<code>min(#pragma pack()制定的数，⻓度最⻓的数据成员的⻓度)</code>的倍数。</li></ul><p>那么内存对齐的作用是什么呢？</p><ul><li>经过内存对齐之后，CPU 的内存访问速度大大提升。因为 CPU把内存当成是一块一块的，块的大小可以是 2，4，8，16 个字节，因此 CPU在读取内存的时候是一块一块进行读取的，块的大小称为内存读取粒度。⽐如说CPU 要读取一个 4 个字节的数据到寄存器中（假设内存读取粒度是4），如果数据是从 0 字节开始的，那么直接将 0-3四个字节完全读取到寄存器中进行处理即可。</li><li>如果数据是从 1 字节开始的，就⾸先要将前 4个字节读取到寄存器，并再次读取 4-7 个字节数据进入寄存 器，接着把 0字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4字节的数据进入寄存器，所以说，当内存没有对齐时，寄存器进行了很多额外的操作，大大降低了CPU 的性能。</li><li>另外，还有一个就是，有的 CPU遇到未进行内存对齐的处理直接拒绝处理，不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存对齐还有利于平台移植。</li></ul><h3id="内存泄漏的定义如何检测与避免">内存泄漏的定义，如何检测与避免？</h3><p><strong>定义</strong>：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。</p><p><strong>如何检测内存泄漏</strong></p><ul><li>⾸先可以通过观察猜测是否可能发生内存泄漏，Linux 中使用 swap命令观察还有多少可用的交换空间，在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。</li><li>还可以使用 其他一些 /usr/bin/stat 工具如 netstat、vmstat等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。</li><li>当然也有用于内存调试，内存泄漏检测以及性能分析的软件开发工具如linux的valgrind 、windows下CRT库这样的工具来进行内存泄漏的检测。</li></ul><h3id="说一下平衡二叉树高度平衡二叉树avl">说一下平衡二叉树、高度平衡二叉树（AVL）</h3><p>⼆叉树：任何节点最多只允许有两个子节点，称为左子节点和右子节点，以递归的方式定义⼆叉树为，一个⼆叉树如果不为空，便是由一个根节点和左右两个子树构成，左右子树都可能为空。</p><p>⼆叉搜索树：⼆叉搜索树可以提供对数时间的元素插入和访问。节点的放置规则是：任何节点的键值一定大于其左子树的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此一直向左⾛可以取得最小值，一直向右⾛可以得到最大值。插入：从根节点开始，遇键值较大则向左，遇键值较小则向右，直到尾端，即插入点。删除：如果删除点只有一个子节点，则直接将其子节点连⾄父节点。如果删除点有两个子节点，以右子树中的最小值代替要删除的位置。</p><p>平衡⼆叉树：其实对于树的平衡与否没有一个绝对的标准，“平衡”的大致意思是：没有任何一个节点过深，不同的平衡条件会造就出不同的效率表现。以及不同的实现复杂度。有数种特殊结构例如AVL-tree, RB-tree, AA-tree，均可以实现平衡⼆叉树。</p><p>AVL-tree ：高度平衡的平衡⼆叉树（严格的平衡⼆叉树）AVL-tree是要求任何节点的左右子树高度相差最多为 1 的平衡⼆叉树。当插入新的节点破坏平衡性的时候，从下往上找到第一个不平衡点，需要进行单旋转，或者双旋转进行调整。</p><h3 id="说一下红黑树rb-tree">说一下红黑树（RB-tree）</h3><p>红黑树的定义：</p><p>性质1：每个节点要么是黑色，要么是红色。</p><p>性质2：根节点是黑色。</p><p>性质3：每个叶子节点（NIL）是黑色。</p><p>性质4：每个红色结点的两个子结点一定都是黑色</p><p><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点</strong></p><h3 id="说一下-defineconsttypedefinline-使用方法">说一下define、const、typedef、inline 使用方法？</h3><ol type="1"><li>const 与 #define 的区别</li></ol><p><strong>类型检查</strong>：const 定义的常量是带类型的变量，而 #define定义的只是一个不带类型的常数。这意味着 const在编译时会进行类型检查，可以避免一些低级错误，而 #define只是简单的字符串替换，没有类型检查。</p><p><strong>预处理和编译</strong>：#define只在预处理阶段起作用，进行简单的文本替换，而 const在编译、链接过程中起作用。</p><p><strong>内存占用</strong>：#define 预处理后，占用代码段空间，而 const占用数据段空间。</p><p><strong>重定义</strong>：const 不能重定义，而 #define 可以通过 #undef取消某个符号的定义，进行重定义。</p><p><strong>文件重复引用</strong>：#define有独特的功能，比如可以用来防止文件重复引用。</p><p>总的来说，const 和 #define都可以用来定义常量，但它们的工作方式和用途有所不同。</p><ol start="2" type="1"><li>#define 和别名 typedef 的区别</li></ol><p><strong>执行时间不同</strong>，typedef 在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p><p><strong>功能差异</strong>：typedef用来定义类型的别名，定义与平台无关的数据类型，与 struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p><p><strong>作用域不同</strong>：#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef 有自⼰的作用域。</p><ol start="3" type="1"><li>define 与 inline 的区别</li></ol><p><strong>#define是关键字，inline是函数</strong>;</p><p>宏定义在预处理阶段进行文本替换，inline 函数在编译阶段进行替换；inline函数有类型检查，相⽐宏定义⽐较安全；</p><h3id="预处理编译汇编链接程序的区别">预处理，编译，汇编，链接程序的区别</h3><p>一段高级语⾔代码经过四个阶段的处理形成可执行的目标⼆进制代码:预处理器→编译器→汇编器→链接器</p><p>这⾥采用《深入理解计算机系统》的说法。</p><p><strong>预处理阶段</strong>：写好的高级语⾔的程序文本⽐如hello.c，预处理器根据#开头的命令，修改原始的程序，如#include&lt;stdio.h&gt;将把系统中的头文件插入到程序文本中，通常是以 .i 结尾的文件。</p><p><strong>编译阶段</strong>：编译器将 hello.i 文件翻译成文本文件hello.s，这个是汇编语⾔程序。高级语⾔是源程序。所以注意概念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的文本格式确切描述一条低级机器语⾔指令。不同的高级语⾔翻译的汇编语⾔相同。</p><p><strong>汇编阶段</strong>：汇编器将 hello.s翻译成机器语⾔指令。把这些指令打包成可重定位目标程序，即.o文件。hello.o是一个⼆进制文件，它的字节码是机器语⾔指令，不再是字符。前面两个阶段都还有字符。</p><p><strong>链接阶段</strong>：⽐如 hello 程序调用 printf 程序，它是每个C 编译器都会提供的标准库 C 的函数。这个函数存在于一个名叫 printf.o的单独编译好的目标文件中，这个文件将以某种方式合并到 hello.o中。链接器就负责这种合并。得到的是可执行目标文件</p><p>fork</p><h3 id="说一下-forkwaitexec-函数">说一下 fork，wait，exec 函数</h3><p>父进程产生子进程使用 fork拷贝出来一个父进程的副本，此时只拷贝了父进程的⻚表，两个进程都读同一块内存。</p><p>当有进程写的时候使用写实拷贝机制分配内存，exec 函数可以加载一个 elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</p><p>fork 从父进程返回子进程的 pid，从子进程返回 0，调用了 wait的父进程将会发生阻塞，直到有子进程状态改变，执行成功返回 0，错误返回-1。exec 执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。</p><h3 id="动态编译与静态编译">动态编译与静态编译</h3><p><strong>静态编译</strong>，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p><p><strong>动态编译</strong>，可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；⼆是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行</p><h3 id="动态链接和静态链接区别">动态链接和静态链接区别</h3><p>静态连接库就是把 (lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL 中寻找相应函数代码，因此需要相应 DLL 文件的⽀持。</p><p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该DLL 不必被包含在最终 EXE 文件中，EXE文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。</p><p>静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p><p>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但如果有多处对lib文件中同一个函数的调用，那么执行时该函数将在当前程序的执行空间⾥留下多份拷贝，而且是一处调用就产生一份拷贝。</p><h3 id="动态联编与静态联编">动态联编与静态联编</h3><p>在 C++中，联编是指一个计算机程序的不同部分彼此关联的过程。按照联编所进行的阶段不同，可以分为<strong>静态联编</strong>和<strong>动态联编</strong>；</p><p><strong>静态联编</strong>是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。</p><p><strong>动态联编</strong>是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。</p><p>C++中一般情况下的联编是<strong>静态联编</strong>，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p><p><strong>实现动态联编三个条件</strong>：</p><ol type="1"><li>必须把动态联编的行为定义为类的虚函数；</li><li>类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来</li><li>必须先使用基类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数</li></ol><h3id="怎么用c代码判断16位32位还是64位系统">怎么用C++代码判断16位、32位还是64位系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) == <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is a 16-bit system.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) == <span class="hljs-number">4</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is a 32-bit system.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) == <span class="hljs-number">8</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is a 64-bit system.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown architecture.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition info"><p class="admonition-title">info</p><p>16位是2字节是因为16位下地址空间有2^16,一个地址要用16位表示，所以就是2字节。32位和64位同理。</p></div><h2 id="类和数据抽象">类和数据抽象</h2><h3 id="类之间的关系">类之间的关系</h3><p>has-A 包含关系:⽤以描述⼀个类由多个部件类构成，实现 has-A关系⽤类的成员属性表示，即⼀个类的成员属性是另⼀个已经定义好的类;</p><p>use-A，⼀个类使⽤另⼀个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p><p>is-A，继承关系，关系具有传递性.</p><h3 id="什么是类的继承">什么是类的继承？</h3><p>所谓的继承就是⼀个类继承了另⼀个类的属性和方法，这个新的类包含了上⼀个类的属性和方法，被称为子类或者派⽣类，被继承的类称为父类或者基类。</p><p><strong>继承的特点</strong>：子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使⽤；</p><p><strong>继承的兼容性原则</strong>：继承的兼容性原则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来代替。具体来说，继承的兼容性原则包括以下几点：</p><ul><li>子类对象可以当做父类对象使用。</li><li>子类对象可以直接赋值给父类对象。</li><li>子类对象可以直接初始化父类对象。</li><li>父类指针可以直接指向子类对象。</li><li>父类引用可以直接引用子类对象。</li></ul><h3 id="什么是组合">什么是组合</h3><p>⼀个类⾥面的数据成员是另⼀个类的对象，即内嵌其他类的对象作为⾃⼰的成员；创建组合类的对象：⾸先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进⾏初始化，⼜要对内嵌对象进⾏初始化。</p><p>创建组合类对象，构造函数的执⾏顺序：先调⽤内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表顺序⽆关。然后执⾏组合类构造函数的函数体，析构函数调⽤顺序相反</p><h3 id="c中的虚函数表存储在哪里">C++中的虚函数表存储在哪里？</h3><p>存储在常量区，参考<a href="https://qr.ae/pKx6bW"><strong>Where arevirtual tables stored in C++?</strong></a></p><h3id="在main执行之前和之后执行的代码可能是什么">在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li><code>__attribute__((constructor))</code></li></ul><p><strong>main函数执行之后</strong>：</p><ul><li>全局对象的析构函数会在main函数之后执行；</li><li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main之后执行;</li><li><code>__attribute__((destructor))</code></li></ul><h3 id="结构体内存对齐问题">结构体内存对齐问题？</h3><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul><p>c++11以后引入两个关键字 <ahref="https://zh.cppreference.com/w/cpp/language/alignas">alignas (opensnew window)</a>与 <ahref="https://zh.cppreference.com/w/cpp/language/alignof">alignof (opensnewwindow)</a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// alignas 生效的情况</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint16_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 6  2 + 2 + 2</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) Info2 &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint16_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 8  4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">为什么<code>sizeof(info2)</code>是8？</p><p><code>alignas(4)</code> 指定了整个结构体的对齐方式为 4字节。这意味着结构体的起始地址和大小都必须是 4的倍数。由于结构体中的成员也需要按照特定的对齐方式排列，因此编译器会在成员之间添加填充字节。</p></div><ul><li><code>uint8_t a;</code> 占用 1 字节。</li><li>在 <code>a</code> 和 <code>b</code> 之间添加 1 字节的填充，以确保<code>b</code> 在 2 字节边界上对齐。</li><li><code>uint16_t b;</code> 占用 2 字节。</li><li><code>uint8_t c;</code> 占用 1 字节。</li><li>在 <code>c</code> 之后添加 3 字节的填充，以确保整个结构体的大小是 4字节的倍数。</li></ul><pre><code class="hljs">这里声明了`alignas`之后每个成员变量之间仍然要考虑自然对齐，`uint16_t` 类型的变量自然对齐是 2 字节，这意味着它应该从一个 2 字节边界开始。所以`a`声明之后要有1字节的对齐而不是3字节的对齐。</code></pre><p>但是<code>alignas</code>在某些情况下是不能使用的，具体见下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// alignas 失效的情况</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 12  4 + 4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">2</span>) Info2 &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 12  4 + 4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</p><div class="admonition info"><p class="admonition-title">info</p><p>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragmapack(push,1)</code>或者使用<code><strong>attribute</strong>((packed))</code>。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125; ONEBYTE_ALIGN;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 6 1 + 4 + 1</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>确定结构体中每个元素大小可以通过下面这种方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 0 1   3     6   8 9            15</span><br><span class="hljs-comment">* +-+---+-----+---+-+-------------+</span><br><span class="hljs-comment">* | |   |     |   | |             |</span><br><span class="hljs-comment">* |a| b |  c  | d |e|     pad     |</span><br><span class="hljs-comment">* | |   |     |   | |             |</span><br><span class="hljs-comment">* +-+---+-----+---+-+-------------+</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint16_t</span> a : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">uint16_t</span> b : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint16_t</span> c : <span class="hljs-number">3</span>;<br>  <span class="hljs-type">uint16_t</span> d : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint16_t</span> e : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">uint16_t</span> pad : <span class="hljs-number">7</span>;<br>&#125; ONEBYTE_ALIGN;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 2</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>这种处理方式是<code>alignas</code>处理不了的。</p><h3id="在传递函数参数时什么时候该使用指针什么时候该使用引用呢">在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h3><ul><li>需要返回函数内局部变量的内存的时候用指针(注意该<strong>局部变量一定要是动态分配内存</strong>的，否则函数结束后该局部变量就会被销毁)。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li></ul><h3 id="宏定义和typedef区别">宏定义和typedef区别？</h3><ul><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li><li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li><li>宏不检查类型；typedef会检查数据类型。</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li><li>注意对<strong>指针的操作</strong>，typedef char * p_char和#definep_char char *区别巨大。</li></ul><div class="admonition info"><p class="admonition-title">info</p><p>在使用 <code>typedef</code>时，如果你声明了多个变量，它们都会被视为指针类型。例如：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* p_char;<br>p_char a, b, c; <span class="hljs-comment">// a, b, c 都是 char 类型的指针</span><br></code></pre></td></tr></table></figure></p><p>而使用 <code>#define</code>时，只有第一个变量会被视为指针类型，其余的将被视为普通变量。例如：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">define</span> p_char char*</span><br>p_char x, y, z; <span class="hljs-comment">// x 是 char 类型的指针，y 和 z 是 char 类型的变量</span><br></code></pre></td></tr></table></figure></p><p>因此，typedef 更适合用于定义新类型，而 #define可以用于定义值的别名，但在定义指针类型时可能会导致混淆。<strong>在现代C++中，建议尽可能避免使用宏（#define），而是使用typedef 或 using 语句来定义类型别名。</strong></p></div><h3 id="strlen和sizeof区别">strlen和sizeof区别</h3><ul><li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。</li><li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;name&quot;</span>;<br><br>    <span class="hljs-built_in">sizeof</span>(str); <span class="hljs-comment">// 取的是指针str的长度，是8</span><br>    <span class="hljs-built_in">strlen</span>(str); <span class="hljs-comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个指针占多少字节">一个指针占多少字节？</h3><p>上面有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；</p><p>而在32位环境下，指针占用大小为4字节。</p><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p><h3 id="a和a有什么区别">a和&amp;a有什么区别？</h3><p>假设数组<code>int a[10]; int (*p)[10] = &amp;a</code>;其中：</p><ul><li><code>a</code>是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果<code>a</code>的值是0x00000001，加1操作后变为0x00000005。<code>*(a + 1) = a[1]</code>。</li><li>&amp;a是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若<code>(int *)p</code> ，此时输出<code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照<code>int</code>类型大小来读取。</li></ul><div class="admonition note"><p class="admonition-title">note</p><p>注意&amp;a的类型为<code>int (<em>)[10]</code>,<code>int(</em>)[10]</code>和<code>int <em>[10]</code>是不一样的，<code>int(</em>)[10]</code>表示一个指向<code>int</code>数组的指针，这个数组的长度为10，而<code>int<em>[10]</code>表示一个<code>int </em></code>类型的数组，数组的长度是10.</p></div><h3 id="c和python的区别">C++和Python的区别</h3><p>包括但不限于：</p><ul><li>Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li><li>Python使用缩进来区分不同的代码块，C++使用花括号来区分</li><li>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li><li>Python的库函数比C++的多，调用起来很方便</li></ul><h3id="数组名和指针这里为指向数组首元素的指针区别">数组名和指针（这里为指向数组首元素的指针）区别？</h3><ul><li>二者均可通过增减偏移量来访问数组中的元素。</li><li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li><li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了</strong></li></ul><h3 id="拷贝初始化和直接初始化">拷贝初始化和直接初始化</h3><ul><li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;I am a string&quot;</span>)</span></span>;<span class="hljs-comment">//语句1 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(str1)</span></span>;<span class="hljs-comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br>string str3 = <span class="hljs-string">&quot;I am a string&quot;</span>;<span class="hljs-comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span><br>string str4 = str1;<span class="hljs-comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span><br></code></pre></td></tr></table></figure><ul><li><p>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了</p><p>（语句1和语句3等价），但是需要辨别两种情况。</p><ul><li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li><li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li></ul></li></ul><h3 id="初始化和赋值的区别">初始化和赋值的区别</h3><ul><li>对于简单类型来说，初始化和赋值没什么区别</li><li>对于类和复杂数据类型来说，这两者的区别就大了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">num1</span>(a),<span class="hljs-built_in">num2</span>(b)&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;;<br>    <span class="hljs-comment">//重载 = 号操作符函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        num1 = a.num1 + <span class="hljs-number">1</span>;<br>        num2 = a.num2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    A a1 = a; <span class="hljs-comment">//拷贝初始化操作，调用拷贝构造函数</span><br>    A b;<br>    b = a;<span class="hljs-comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内联函数和宏定义的区别">内联函数和宏定义的区别</h3><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行<strong>参数类型检查</strong>（编译时），且具有返回值。</li><li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数有<strong>类型检测、语法判断</strong>等功能，而宏没有</li></ul><p><strong>内联函数适用场景:</strong></p><ul><li>使用宏定义的地方都可以使用 inline 函数。</li><li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。</li></ul><h3id="publicprotected和private访问和继承权限publicprotectedprivate的区别">public，protected和private访问和继承权限/public/protected/private的区别？</h3><h4 id="访问权限">访问权限</h4><ul><li>public的变量和函数在类的内部外部都可以访问。</li><li>protected的变量和函数只能在类的内部和其派生类中访问。</li><li>private修饰的元素只能在类内访问。</li></ul><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212341241.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="继承权限">继承权限</h4><p>派生类继承自基类的成员权限有四种状态：public、protected、private、不可见，排序为public &gt; protected &gt; private。</p><p>派生类对基类成员的访问权限取决于两点：</p><ul><li>继承方式；</li><li>基类成员在基类中的访问权限</li></ul><p>基类成员在派生类中的访问权限不得高于继承方式中指定的权限，高于继承方式中指定的权限则下降为继承权限，低于继承权限则不调整，<strong>基类private 成员在任何继承方式下都是不可见的</strong>。例如：</p><ul><li>public 继承 + private 成员 =&gt; 不可见</li><li>public 继承 + protected 成员 =&gt; protected</li><li>protected 继承 + public 成员 =&gt; protected</li><li>private 继承 + protected 成员 =&gt; private</li><li>private 继承 + public 成员 =&gt; private</li></ul><h3 id="如何用代码判断大小端存储">如何用代码判断大小端存储？</h3><p><strong>大端存储</strong>：字数据的高字节存储在低地址中</p><p><strong>小端存储</strong>：字数据的低字节存储在低地址中</p><p>例如：32bit的数字0x12345678</p><p>小端模式中的存储方式为：</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071832785.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>大端模式中的存储方式为：</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071832707.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</p><h4id="方法一使用强制类型转换">方法一：<strong>使用强制类型转换</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)(a);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;big endian&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;little endian&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4id="方法二巧用union联合体">方法二：巧用<strong>union联合体</strong></h4><p><strong>什么是联合体</strong>？</p><p>C++中的联合体（<code>union</code>）是一种特殊的数据结构，允许在同一内存位置存储不同的数据类型。在联合体中，<strong>所有成员共享同一块内存空间，占用的大小取决于联合体中最大的成员。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义联合体</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> &#123;<br>    <span class="hljs-type">int</span> intValue;<br>    <span class="hljs-type">double</span> doubleValue;<br>    <span class="hljs-type">char</span> charValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>MyUnion</code>联合体有三个成员：<code>intValue</code>（整数）、<code>doubleValue</code>（双精度浮点数）和<code>charValue</code>（字符）。这三个成员共享相同的内存空间，因此对一个成员的修改会影响到其他成员。</p><p>需要注意的是，联合体在某一时刻只能存储其中的一个成员的值。在上面的示例中，赋值给<code>intValue</code>后，<code>doubleValue</code>和<code>charValue</code>的值将变得不确定，因为它们共享相同的内存位置。</p><p>联合体常用于需要在不同数据类型之间进行快速切换的情况，但在使用时需要格外小心，确保正确地理解和处理数据的类型。</p><p><strong>使用union联合体判断大小端</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">endian</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> ch;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    endian value;<br>    value.a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//a和ch共用4字节的内存空间</span><br>    <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;big endian&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;little endian&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="volatilemutable和explicit关键字的用法">volatile、mutable和explicit关键字的用法</h3><h4 id="volatile">volatile</h4><p>volatile关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>volatile 指针和 const 修饰词类似，const有常量指针和指针常量的说法，volatile也有相应的概念,修饰由指针指向的对象、数据是 const 或 volatile 的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpch;<span class="hljs-keyword">volatile</span> <span class="hljs-type">char</span>* vpch;<br></code></pre></td></tr></table></figure><p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* <span class="hljs-type">const</span> pchc;<span class="hljs-type">char</span>* <span class="hljs-keyword">volatile</span> pchv;<br></code></pre></td></tr></table></figure><p>!!! attention - 可以把一个非volatile int赋给volatileint，但是不能把非volatile对象赋给一个volatile对象。 -除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。 -C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集,只能调用那些被类的实现者明确允许在<code>volatile</code>对象上调用的成员函数。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</p><p><strong>多线程下的volatile</strong>：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</strong></p><h4 id="mutable">mutable</h4><p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// example1.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量 在常函数里值也可以被修改</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-comment">//在函数里不可修改this指针指向的值 常量指针</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误  不可修改值，this已经被修饰为常量指针</span><br>        m_B = <span class="hljs-number">20</span>;<span class="hljs-comment">//正确</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// example2.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量 在常函数里值也可以被修改</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> person p = <span class="hljs-built_in">person</span>();<span class="hljs-comment">//修饰常对象 不可修改类成员的值</span><br>    p.m_A = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误，被修饰了指针常量</span><br>    p.m_B = <span class="hljs-number">200</span>;<span class="hljs-comment">//正确，特殊变量，修饰了mutable</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="explicit"><strong>explicit</strong></h4><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显式的方式进行类型转换</strong>，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul><h3 id="什么情况下会调用拷贝构造函数">什么情况下会调用拷贝构造函数</h3><ul><li>用类的一个实例化对象去初始化另一个对象的时候（注意初始化和赋值的区别）</li><li>函数的参数是类的对象时（非引用传递）</li><li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（NamedreturnValue优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li></ul><p><strong>第三种情况在Linux g++下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p><p><strong>总结就是：即使发生NRV优化的情况下，Linux+g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows+VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123;&#125;;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;copy constructor is called&quot;</span> &lt;&lt; endl;<br>&#125;;<br>~<span class="hljs-built_in">A</span>() &#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useClassA</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function">A <span class="hljs-title">getClassA</span><span class="hljs-params">()</span><span class="hljs-comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><br><span class="hljs-comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//A a;</span><br><span class="hljs-comment">//return a;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a1,a3,a4;<br>A a2 = a1;  <span class="hljs-comment">//调用拷贝构造函数,对应情况1</span><br><span class="hljs-built_in">useClassA</span>(a1);<span class="hljs-comment">//调用拷贝构造函数，对应情况2</span><br>a3 = <span class="hljs-built_in">getClassA</span>();<span class="hljs-comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span><br>a4 = <span class="hljs-built_in">getClassA2</span>(a1);<span class="hljs-comment">//发生NRV优化，且引用返回自身，不会调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c中有几种类型的new">C++中有几种类型的new</h3><p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placementnew.</p><h4 id="plain-new"><strong>plain new</strong></h4><p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>因此<strong>plainnew</strong>在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-type">char</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10e11</span>];<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc &amp;ex)<br>&#123;<br>cout &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//执行结果：bad allocation</span><br></code></pre></td></tr></table></figure><h4 id="nothrow-new"><strong>nothrow new</strong></h4><p>nothrownew在<strong>空间分配失败的情况下是不抛出异常，而是返回NULL</strong>，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">char</span>[<span class="hljs-number">10e11</span>];<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;alloc failed&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：alloc failed</span><br></code></pre></td></tr></table></figure><h4 id="placement-new"><strong>placement new</strong></h4><p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placementnew不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">void</span>*)</span></span>;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ADT</span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ADT</span>()&#123;<br>i = <span class="hljs-number">10</span>;<br>j = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j &lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">ADT</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ADT destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">char</span>[<span class="hljs-keyword">sizeof</span> ADT + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;alloc failed&quot;</span> &lt;&lt; endl;<br>&#125;<br>ADT *q = <span class="hljs-built_in">new</span>(p) ADT;  <span class="hljs-comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span><br><span class="hljs-comment">//delete q;//错误!不能在此处调用delete q;</span><br>q-&gt;ADT::~<span class="hljs-built_in">ADT</span>();<span class="hljs-comment">//显示调用析构函数</span><br><span class="hljs-keyword">delete</span>[] p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//ADT construct i=10j=100</span><br><span class="hljs-comment">//ADT destruct</span><br></code></pre></td></tr></table></figure><h3 id="c的异常处理的方法">C++的异常处理的方法</h3><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li><li>···</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><h4id="trythrow和catch关键字"><strong>try、throw和catch关键字</strong></h4><p>C++中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，其在程序中的用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> m = <span class="hljs-number">1</span>, n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;before dividing.&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">//抛出int型异常</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> - <span class="hljs-number">1.0</span>;  <span class="hljs-comment">//拋出 double 型异常</span><br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; m / n &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;after dividing.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">double</span> d) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;catch (...)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;finished&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-comment">//before dividing.</span><br><span class="hljs-comment">//catch (...)</span><br><span class="hljs-comment">//finished</span><br></code></pre></td></tr></table></figure><p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。</strong>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p><h4 id="函数的异常声明列表"><strong>函数的异常声明列表</strong></h4><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,A,B,C)</span></span>&#123;...&#125;;<br></code></pre></td></tr></table></figure><p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p><h4 id="c标准异常类-exception"><strong>C++标准异常类exception</strong></h4><p>C++ 标准库中有一些类代表异常，这些类都是从 exception类派生而来的，如下图所示</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212342667.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为NULL，则会拋出此异常，</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>();<br>&#125;;<br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>A* a = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">try</span> &#123;<br>  cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*a).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">// Error condition</span><br>  &#125;<br><span class="hljs-built_in">catch</span> (bad_typeid)&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;Object is NULL&quot;</span> &lt;&lt; endl;<br>  &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：bject is NULL</span><br></code></pre></td></tr></table></figure></p></li><li><p>bad_cast：在用 dynamic_cast进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</p></li><li><p>bad_alloc：在用 new运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</p></li><li><p>out_of_range:用 vector 或 string的at成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</p></li></ul><h3 id="delete-pdelete-pallocator都有什么作用">delete p、delete []p、allocator都有什么作用？</h3><ol type="1"><li><p>动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p></li><li><p>new动态数组返回的并不是数组类型，而是一个元素类型的指针；</p></li><li><p>delete[]时，数组中的元素按逆序的顺序进行销毁；</p></li><li><p>new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p></li></ol><h3id="new和delete的实现原理-delete是如何知道释放内存的大小的">new和delete的实现原理，delete是如何知道释放内存的大小的？</h3><p>在分配内存的时候，编译器已经在内存块的前面存储了这些信息。</p><h3id="malloc申请的存储空间能用delete释放吗">malloc申请的存储空间能用delete释放吗?</h3><p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc/free的。</p><p>malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。</p><p>new和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。</p><p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p><h3 id="malloc与free的实现原理">malloc与free的实现原理？</h3><ol type="1"><li><p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由<strong>brk、mmap、，munmap</strong>这些<strong>系统调用</strong>实现的;</p></li><li><p>brk是将「堆顶」指针向高地址移动，获得新的内存空间,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p></li><li><p>malloc<strong>小于128k的内存，使用brk分配内存</strong>，将「堆顶」指针往高地址推；malloc<strong>大于128k的内存，使用mmap分配内存</strong>，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p></li><li><p>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p></li></ol><h3 id="mallocrealloccalloc的区别">malloc、realloc、calloc的区别</h3><ol type="1"><li><p>malloc函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_size)</span></span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));申请<span class="hljs-number">20</span>个<span class="hljs-type">int</span>类型的空间；<br></code></pre></td></tr></table></figure></p></li><li><p>calloc函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n,<span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure></p><p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p></li><li><p>realloc函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">size_t</span> new_size)</span></span>;<br></code></pre></td></tr></table></figure></p><p>给动态分配的空间分配额外的空间，用于扩充容量。</p></li></ol><h3id="类成员初始化方式构造函数的执行顺序-为什么用成员初始化列表会快一些">类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？</h3><ol type="1"><li>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。</li></ol><p>这两种方式的主要区别在于：</p><p>函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p><ol start="2" type="1"><li>一个派生类构造函数的执行顺序如下：</li></ol><p>①虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p><p>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p><p>③ 类类型的成员对象的构造函数（按照成员对象在类中的定义顺序）</p><p>④ 派生类自己的构造函数。</p><ol start="3" type="1"><li>方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</li></ol><h3id="有哪些情况必须用到成员列表初始化作用是什么">有哪些情况必须用到成员列表初始化？作用是什么？</h3><p>必须使用成员初始化的四种情况:</p><ol type="1"><li><p>当初始化一个引用成员时；</p></li><li><p>当初始化一个常量成员时；</p></li><li><p>当调用一个基类的构造函数，而它拥有一组参数时；</p></li><li><p>当调用一个成员类的构造函数，而它拥有一组参数时；</p></li></ol><div class="admonition note"><p class="admonition-title">note</p><p>成员初始化列表做了什么?编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；<strong>初始化列表中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的</strong>；</p></div><h3id="c中新增了string它与c语言中的-char-有什么区别吗它是如何实现的">C++中新增了string，它与C语言中的char *有什么区别吗？它是如何实现的？</h3><p>string继承自basic_string,其实是对char<em>进行了封装，封装的string包含了char</em>数组，容量，长度等等属性。</p><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</p><h3 id="对象复用的了解零拷贝的了解">对象复用的了解，零拷贝的了解</h3><h4 id="对象复用"><strong>对象复用</strong></h4><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p><p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p><h4 id="零拷贝"><strong>零拷贝</strong></h4><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p><p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p><p>在C++中，vector的一个成员函数<strong>emplace_back()</strong>很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：<strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造（原地构造指的是直接在容器的末尾添加一个元素，不用创建临时元素），不需要触发拷贝构造和转移构造</strong>，效率更高。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//初始构造函数</span><br>    <span class="hljs-built_in">Person</span>(string p_name, <span class="hljs-type">int</span> p_age): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(p_name)), <span class="hljs-built_in">age</span>(p_age)<br>    &#123;<br>         cout &lt;&lt; <span class="hljs-string">&quot;I have been constructed&quot;</span> &lt;&lt;endl;<br>    &#125;<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    &#123;<br>         cout &lt;&lt; <span class="hljs-string">&quot;I have been copy constructed&quot;</span> &lt;&lt;endl;<br>    &#125;<br>     <span class="hljs-comment">//转移构造函数</span><br>     <span class="hljs-built_in">Person</span>(Person&amp;&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    &#123;<br>         cout &lt;&lt; <span class="hljs-string">&quot;I have been moved&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Person&gt; e;<br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:&quot;</span> &lt;&lt;endl;<br>    e.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">//不用构造类对象</span><br><br>    vector&lt;Person&gt; p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;push_back:&quot;</span>&lt;&lt;endl;<br>    p.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Mike&quot;</span>,<span class="hljs-number">36</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//emplace_back:</span><br><span class="hljs-comment">//I have been constructed</span><br><span class="hljs-comment">//push_back:</span><br><span class="hljs-comment">//I have been constructed</span><br><span class="hljs-comment">//I am being moved.</span><br></code></pre></td></tr></table></figure><h3id="成员初始化列表的概念为什么用它会快一些">成员初始化列表的概念，为什么用它会快一些？</h3><h4 id="成员初始化列表的概念">成员初始化列表的概念</h4><p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值</p><h4 id="效率">效率</h4><p>用初始化列表会快一些的原因是，<strong>对于自定义类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。</strong>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造函数A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)<br>    &#123;<br>        value = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span>&lt;&lt;value&lt;&lt;<span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>    &#123;<br>        value = a.value;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数A(A&amp; a):  &quot;</span>&lt;&lt;value &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        b = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    A a;<br>    A b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>&#125;<br><br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//默认构造函数A()</span><br><span class="hljs-comment">//A(int 2)</span><br><span class="hljs-comment">//拷贝构造函数A(A&amp; a): 2</span><br><br><br><span class="hljs-comment">// 注：</span><br><span class="hljs-comment">// 在B的构造函数中，先初始化了B类的成员变量a（使用A类的默认构造函数），然后初始化了成员变量b，通过调用A类的带有int参数的构造函数（A(2)）。</span><br><span class="hljs-comment">// A类的带有int参数的构造函数被调用，输出&quot;A(int 2)&quot;。</span><br><span class="hljs-comment">// 接着，A类的拷贝构造函数被调用，因为在B类的构造函数中，要将A类对象b初始化为A类对象（A(2)），这会触发拷贝构造函数。拷贝构造函数输出&quot;拷贝构造函数A(A&amp; a): 2&quot;。</span><br></code></pre></td></tr></table></figure><p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p><h3 id="c函数调用的压栈过程">C++函数调用的压栈过程</h3><ol type="1"><li>当前函数运行状态压栈</li><li>被调用函数的返回地址压栈</li><li>被调用函数的参数（从右到左压栈）</li><li>被调用函数的变量压栈</li></ol><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; n &lt;&lt; endl;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> param1, <span class="hljs-type">int</span> param2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> var1 = param1;<br><span class="hljs-type">int</span> var2 = param2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var1=%d,var2=%d&quot;</span>, <span class="hljs-built_in">f</span>(var1), <span class="hljs-built_in">f</span>(var2));<span class="hljs-comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//var1=1,var2=2</span><br></code></pre></td></tr></table></figure><p>当函数从入口函数main函数开始执行时，编译器会将我们<strong>操作系统的运行状态</strong>，<strong>main函数的返回地址</strong>、<strong>main的参数</strong>、<strong>mian函数中的变量、进行依次压栈</strong>；</p><p>当main函数开始调用func()函数时，编译器此时会将<strong>main函数的运行状态进行压栈</strong>，<strong>再将func()函数的返回地址</strong>、<strong>func()函数的参数从右到左</strong>、<strong>func()定义变量依次压栈</strong>；</p><p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p><p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p><h3id="写c代码时有一类错误是-coredump-很常见你遇到过吗怎么调试这个错误">写C++代码时有一类错误是coredump ，很常见，你遇到过吗？怎么调试这个错误？</h3><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><h4 id="调试">调试</h4><p><strong>使用gdb命令对core文件进行调试</strong>：</p><p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir coredumpTest<br>vim coredumpTest.cpp<br></code></pre></td></tr></table></figure><p>在编辑器内键入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<span class="hljs-comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ coredumpTest.cpp -g -o coredumpTest<br></code></pre></td></tr></table></figure><p>运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./coredumpTest<br></code></pre></td></tr></table></figure><p>使用gdb调试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gdb [可执行文件名] [core文件名]<br></code></pre></td></tr></table></figure><h3 id="gdb怎么调试怎么打断点">gdb怎么调试怎么打断点</h3><p>gdb调试见上一条</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ Test.cpp -g -o Test # 注意编译的时候要加上-g选项<br><br>gdb ./Test<br><br>break main:10 # 在main的第10行添加断点，也可以用缩写b<br><br>run<br></code></pre></td></tr></table></figure><h3id="gdb怎么查看一个很多元素数组的后部分内容">gdb怎么查看一个很多元素数组的后部分内容？</h3><p>假设有一个数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure><p>编译并调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ Test.cpp -g -o Test # 注意编译的时候要加上-g选项<br><br>gdb ./Test<br><br>break main:10 # 在合适的地方打上断点<br><br>run # 运行到合适的位置之后可以开始查看数组的元素了<br><br>x/5dw &amp;arr[5] # <br></code></pre></td></tr></table></figure><p><code>x/5dw</code> 命令的含义是查看从<code>&amp;arr[5]</code>（数组的第6个元素）开始的5个整数（<code>d</code>表示以十进制显示，<code>w</code>表示以4字节为单位显示，可以根据实际情况调整）。</p><p>注意：<code>&amp;arr[5]</code>是数组的第6个元素的地址，可以根据实际情况选择数组中的任何一个元素。</p><h3 id="说说移动构造函数">说说移动构造函数</h3><ol type="1"><li><p>如果我们用对象a初始化对象b，构造出对象b之后对象a我们就不再使用了，但是对象a的空间在析构之前还在，既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p></li><li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p><p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p></li><li><p>移动构造函数的参数和拷贝构造函数不同，<strong>拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</strong>意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p></li></ol><h3id="c中将临时变量局部变量作为返回值时的处理过程">C++中将临时变量（局部变量）作为返回值时的处理过程</h3><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：<strong>16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</strong></p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了。</p><h3id="如何获得结构成员相对于结构开头的字节偏移量">如何获得结构成员相对于结构开头的字节偏移量</h3><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">S</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">int</span> z;<br><span class="hljs-type">double</span> a;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Visual Studio 2019 + Win10 下的输出情况如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span><br></code></pre></td></tr></table></figure><p>当然了，如果加上 #pragma pack(4) 指定4字节对齐方式就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">S</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">int</span> z;<br><span class="hljs-type">double</span> a;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>S结构体中各个数据成员的内存空间划分如下所示，需要注意内存对齐</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035079.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3id="全局变量和局部变量有什么区别">全局变量和局部变量有什么区别？</h3><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p><p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。</p><h3 id="指针加减计算要注意什么">指针加减计算要注意什么？</h3><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *a, *b, c;<br>a = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x500</span>;<br>b = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x520</span>;<br>c = b - a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c); <span class="hljs-comment">// 8</span><br>a += <span class="hljs-number">0x020</span>;<br>c = b - a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c); <span class="hljs-comment">// -24</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16^2=1280）和1312（5</em>16^2+2*16=1312)，那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p><p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 =1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280= -96，所以c的值就变成了-96/4 = -24</p><p>遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</strong></p><h3 id="怎样判断两个浮点数是否相等">怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><h3id="类如何实现只能静态分配和只能动态分配">类如何实现只能静态分配和只能动态分配</h3><p><strong>只能静态分配</strong>：把<code>new</code>、<code>delete</code>运算符重载为private属性</p><p><strong>只能动态分配</strong>：把构造函数、析构函数设为protect属性，再用子类动态创建</p><div class="admonition note"><p class="admonition-title">note</p><p>建立类的对象有两种方式：<strong>静态建立</strong>，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；<strong>动态建立</strong>，<code>A*p = newA()</code>;动态建立一个类对象，就是使用<code>new</code>运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行<code>operatornew()</code>函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象。只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</p></div><p>### 如果想将某个类用作基类，为什么该类必须定义而非声明？</p><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。所以必须定义而非声明。</p><h3id="继承机制中对象之间如何转换指针和引用之间如何转换">继承机制中对象之间如何转换？指针和引用之间如何转换？</h3><p><strong>向上类型转换</strong>：将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是<strong>安全</strong>的。</p><p><strong>向下类型转换</strong>：将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用<strong>dynamic_cast</strong>进行向下类型转换。</p><h3id="知道c中的组合吗它与继承相比有什么优缺点吗">知道C++中的组合吗？它与继承相比有什么优缺点吗？</h3><h4 id="继承">继承</h4><p>继承是Is a 的关系，比如说Student继承Person,则说明Student is aPerson。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p><p>继承的缺点有以下几点：</p><p>①：父类的内部细节对子类是可见的。</p><p>②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p><p>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</p><h4 id="组合">组合</h4><p>组合是一种对象关系，它表示<strong>一个对象包含另一个对象作为其部分</strong>。</p><p>组合的<strong>优点</strong>：</p><ol type="1"><li><p>当前对象只能通过所包含的那个对象去调用其方法，所以被包含的对象的内部细节对当前对象时不可见的。</p></li><li><p>当前对象与包含的对象是一个低耦合关系，如果修改被包含对象的类中代码不需要修改当前对象类的代码。</p></li><li><p>当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</p></li></ol><p>组合的<strong>缺点</strong>：</p><ol type="1"><li>容易产生过多的对象.</li><li>为了能组合多个对象，必须仔细对接口进行定义。</li></ol><h3 id="函数指针">函数指针</h3><h4 id="什么是函数指针"><strong>什么是函数指针?</strong></h4><p>函数指针指向的是特殊类型的指针，用于存储函数的地址，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p><h4 id="函数指针的声明方法"><strong>函数指针的声明方法</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*pf)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;);<br></code></pre></td></tr></table></figure><p>上面的pf就是一个函数指针，指向函数的返回类型为int，并带有两个constint&amp;参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>声明了一个函数，函数的返回值是<code>int *</code>,参数是<code>const int&amp;</code>和<code>const int&amp;</code>。</p><h4 id="为什么有函数指针"><strong>为什么有函数指针</strong></h4><ol type="1"><li><strong>抽象和封装</strong>：函数指针可以使得函数的具体实现被抽象和封装，使得代码更加模块化。通过函数指针，我们可以将函数作为参数传递给其他函数，或者将函数作为结构体或类的成员。</li><li><strong>回调函数</strong>：函数指针是实现回调函数的一种常见方式。回调函数是在某个特定事件或条件发生时被调用的函数。通过函数指针，我们可以动态地指定需要在特定事件发生时执行的函数，增加了程序的灵活性和可扩展性。</li><li><strong>动态函数调用</strong>：<strong>函数指针的值可以在运行时进行更改，从而实现动态函数调用。</strong>这可以用于实现多态和类似接口的概念，使得程序可以根据运行时的上下文，选择合适的函数进行调用。</li><li><strong>运行时多态</strong>：函数指针可以实现运行时多态。这种数据成为专门的数据类型时就是函数指针。</li></ol><h4id="一个函数名就是一个指针它指向函数的代码"><strong>一个函数名就是一个指针，它指向函数的代码</strong></h4><p>一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p><h4 id="两种方法赋值"><strong>两种方法赋值</strong></h4><p>指针名 = 函数名； 指针名 = &amp;函数名</p><h3id="说一说你理解的内存对齐以及原因">说一说你理解的内存对齐以及原因</h3><p>在C++中，内存对齐是<strong>将变量的起始地址调整为其自身大小或者某个值的倍数</strong>，这个值称为“对齐系数”。</p><p>内存对齐的原因主要有以下几点：</p><ol type="1"><li><strong>提高程序性能</strong>：大部分处理器并不是按字节块来存取内存的，而是以双字节、四字节、8字节、16字节甚至32字节为单位来存取内存。如果没有内存对齐机制，数据可以任意存放，处理器在取数据时可能需要做很多额外的操作，而有了内存对齐的机制后，处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，从而提高了效率。</li><li><strong>平台移植</strong>：不同的硬件平台对内存对齐的要求可能不同，内存对齐可以帮助代码在不同的平台上运行。</li><li><strong>SIMD优化</strong>：SIMD（Single Instruction MultipleData）技术要求数据在内存中是对齐的，内存对齐可以帮助实现这种优化。</li></ol><h3id="你知道printf函数的实现原理是什么吗">你知道printf函数的实现原理是什么吗？</h3><p>在C/C++中，对函数参数的扫描是<strong>从右向左</strong>的。</p><p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p><p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码</p><h3id="为什么模板类一般都是放在一个h文件中">为什么模板类一般都是放在一个h文件中</h3><p>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于链接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</p><p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待链接器能够将符号的地址决议出来。</p><p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是链接器也黔驴技穷了。</p><h3 id="cout和printf有什么区别">cout和printf有什么区别？</h3><p>很多人认为cout&lt;&lt;是一个函数，其实不是的，它是类<code>std::ostream</code>的<strong>全局对象</strong>。</p><p>cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p><p>输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p><p>cout是<strong>有缓冲输出</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt; &lt; <span class="hljs-string">&quot;abc &quot;</span> &lt; &lt;endl;  <span class="hljs-comment">// 这行代码会输出字符串 &quot;abc &quot;，然后输出一个换行符，并且立即刷新输出缓冲区。这意味着，一旦执行这行代码，字符串 &quot;abc &quot; 就会立即显示在屏幕上。</span><br><br><span class="hljs-comment">// 等价于</span><br>cout &lt; &lt; <span class="hljs-string">&quot;abc\n &quot;</span>; <span class="hljs-comment">// 也会输出字符串 &quot;abc &quot;，然后输出一个换行符，但是它不会立即刷新输出缓冲区。这意味着，如果输出缓冲区没有满，字符串 &quot;abc &quot; 可能不会立即显示在屏幕上,所以加上fulsh才和上面等价</span><br>cout &lt; &lt;flush; <br><br></code></pre></td></tr></table></figure><p>flush立即强迫缓冲输出。</p><p>printf是行缓冲输出，不是无缓冲输出</p><h3 id="你知道重载运算符吗">你知道重载运算符吗？</h3><ol type="1"><li>只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li><li>两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数，因为成员成员运算符有一个隐藏的参数就是对象本身；</li><li>引入运算符重载，是为了实现类的多态性；</li><li>当重载的运算符是成员函数时，this绑定到左侧运算符对象；</li><li>当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）时，从参数的个数推断到底定义的是哪种运算符；</li><li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li><li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li></ol><h3id="当程序中有函数重载时函数的匹配原则和顺序是什么">当程序中有函数重载时，函数的匹配原则和顺序是什么？</h3><ol type="1"><li>名字查找</li><li>确定候选函数</li><li>寻找最佳匹配</li></ol><h3 id="如何消除隐式转换">如何消除隐式转换？</h3><p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p><h3 id="c如何处理多个异常">C++如何处理多个异常</h3><p>在C++中，你可以使用try-catch语句块来处理多个异常。当你的代码可能会抛出多种类型的异常时，你可以在try-catch语句块中列出多个catch语句，每个catch语句用于捕获一种特定类型的异常。</p><h3 id="定义和声明的区别">定义和声明的区别</h3><p>从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p><h3id="如何在不使用额外空间的情况下交换两个数你有几种方法">如何在不使用额外空间的情况下，交换两个数？你有几种方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span>)  算术<br><br>x = x + y;<br>y = x - y;<br>x = x - y; <br><br><span class="hljs-number">2</span>)  异或<br>x = x^y;<span class="hljs-comment">// 只能对int,char..</span><br>y = x^y;<br>x = x^y;<br></code></pre></td></tr></table></figure><h3 id="strcpy和memcpy的区别">strcpy和memcpy的区别</h3><ol type="1"><li>strcpy只能复制字符串，而memcpy可以复制任意内容</li><li>strcpy不需要指定长度，它复制到‘\0’自动结束，而memcpy需要指定第三个参数来确定复制的长度</li></ol><h3id="程序在执行int-mainint-argc-char-argv时的内存结构你了解吗">程序在执行intmain(int argc, char *argv[])时的内存结构，你了解吗？</h3><p>参数的含义是程序在命令行下运行的时候，需要<strong>输入argc个参数</strong>，<strong>每个参数是以char类型输入的，依次存在数组里面，数组是argv[]</strong>，所有的参数在指针</p><p>char * 指向的内存中，数组的中元素的个数为 argc个，<strong>第一个参数为程序的名称</strong>。</p><h3id="strcpy函数和strncpy函数的区别哪个函数更安全">strcpy函数和strncpy函数的区别？哪个函数更安全？</h3><p>他们都是C语言中的字符串复制函数，但是他们之间存在一些重要的区别。</p><ol type="1"><li>strcpy函数：<ul><li><strong>作用：</strong> 用于将一个字符串复制到另一个字符串。</li><li><strong>参数：</strong><code>strcpy(destination, source)</code>，其中<code>destination</code>是目标字符串，<code>source</code>是要复制的源字符串。</li><li><strong>特点：</strong>复制源字符串的所有字符直到遇到空字符('\0')。</li><li><strong>安全性：</strong>如果源字符串比目标字符串长，可能会导致缓冲区溢出，因此需要确保目标字符串足够大。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> destination[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> source[] = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">strcpy</span>(destination, source);<br></code></pre></td></tr></table></figure><ol type="1"><li>strncpy函数：<ul><li><strong>作用：</strong>用于将一个字符串的指定数量的字符复制到另一个字符串。</li><li><strong>参数：</strong><code>strncpy(destination, source, n)</code>，其中<code>destination</code>是目标字符串，<code>source</code>是要复制的源字符串，<code>n</code>是要复制的字符数。</li><li><strong>特点：</strong>复制源字符串的前<code>n</code>个字符，如果源字符串长度小于<code>n</code>，则用空字符填充剩余的空间。</li><li><strong>安全性：</strong>相对于<code>strcpy</code>更安全，因为可以限制复制的字符数，防止缓冲区溢出。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> destination[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> source[] = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">strncpy</span>(destination, source, <span class="hljs-built_in">sizeof</span>(destination) - <span class="hljs-number">1</span>);<br>destination[<span class="hljs-built_in">sizeof</span>(destination) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 确保目标字符串以空字符结尾</span><br></code></pre></td></tr></table></figure><p><strong>安全性比较：</strong></p><ul><li>在处理已知长度的字符串时，<code>strncpy</code>更安全，因为它允许明确指定要复制的字符数，避免了缓冲区溢出。</li><li>但需要注意，<code>strncpy</code>有一个缺点，即当源字符串长度大于或等于<code>n</code>时，目标字符串可能不以空字符结尾，因此需要手动添加空字符。</li></ul><h3id="static_cast比c语言中的转换强在哪里">static_cast比C语言中的转换强在哪里？</h3><ol type="1"><li>更加安全；</li><li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图</li></ol><h3id="成员函数里memsetthis0sizeofthis会发生什么">成员函数里memset(this,0,sizeof(*this))会发生什么</h3><ol type="1"><li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this,0, sizeof*this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</li><li>类含有虚函数表：这么做会<strong>破坏虚函数表</strong>，后续对虚函数的调用都将出现异常；</li><li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存</li></ol><h3 id="你知道回调函数吗它的作用">你知道回调函数吗？它的作用？</h3><ol type="1"><li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li><li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li><li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1<strong>，声明；2，定义；3，设置触发条件</strong>，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li><li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li></ol><h3id="为什么友元函数必须在类内部声明">为什么友元函数必须在类内部声明？</h3><p>友元函数必须要在类内部声明，表明这是在类内的的授权，但是在正式使用友元函数之前，还需要在类外部或者其他头文件中进行一次正式的函数定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">double</span> x, y; <span class="hljs-comment">//点的坐标</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y) &#123; <span class="hljs-comment">//构造函数</span><br>            <span class="hljs-keyword">this</span>-&gt;x = x;<br>            <span class="hljs-keyword">this</span>-&gt;y = y;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(Point &amp;p1, Point &amp;p2)</span></span>; <span class="hljs-comment">//友元函数声明</span><br>&#125;;<br><br><span class="hljs-comment">//友元函数类外声明，可以省略</span><br><span class="hljs-comment">//double distance(Point &amp;p1, Point &amp;p2);</span><br><br><span class="hljs-comment">//友元函数定义</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(Point &amp;p1, Point &amp;p2)</span> </span>&#123;<br>    <span class="hljs-type">double</span> dx = p1.x - p2.x; <span class="hljs-comment">//可以直接访问Point类的私有成员</span><br>    <span class="hljs-type">double</span> dy = p1.y - p2.y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(dx * dx + dy * dy);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//创建两个点对象</span><br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The distance between p1 and p2 is &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(p1, p2) &lt;&lt; endl; <span class="hljs-comment">//调用友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用c语言实现c的继承">用C语言实现C++的继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//C++中的继承与多态</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>  <span class="hljs-comment">//C++中的多态:通过虚函数实现</span></span><br><span class="hljs-function">  </span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;A:fun()&quot;</span>&lt;&lt;endl;<br>  &#125;<br><br>  <span class="hljs-type">int</span> a;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A     <span class="hljs-comment">//C++中的继承:B类公有继承A类</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>  <span class="hljs-comment">//C++中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span></span><br><span class="hljs-function">  </span>&#123;<br>   cout&lt;&lt;<span class="hljs-string">&quot;B:fun()&quot;</span>&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-type">int</span> b;<br><br>&#125;;<br><br><span class="hljs-comment">//C语言模拟C++的继承与多态</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*FUN)</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//定义一个函数指针来实现对成员函数的继承</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_A</span>    <span class="hljs-comment">//父类</span><br>&#123;<br>  FUN _fun;  <span class="hljs-comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span><br>  <span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_B</span>     <span class="hljs-comment">//子类</span><br>&#123;<br>  _A _a_;   <span class="hljs-comment">//在子类中定义一个基类的对象即可实现对父类的继承</span><br>  <span class="hljs-type">int</span> _b;<br>&#125;;<br><br><span class="hljs-type">void</span> _fA()    <span class="hljs-comment">//父类的同名函数</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;_A:_fun()\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> _fB()    <span class="hljs-comment">//子类的同名函数</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;_B:_fun()\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//测试C++中的继承与多态</span><br>  A a;  <span class="hljs-comment">//定义一个父类对象a</span><br>  B b;  <span class="hljs-comment">//定义一个子类对象b</span><br>    <br>  A* p1 = &amp;a;  <span class="hljs-comment">//定义一个父类指针指向父类的对象</span><br>  p1-&gt;<span class="hljs-built_in">fun</span>();  <span class="hljs-comment">//调用父类的同名函数</span><br>  p1 = &amp;b;   <span class="hljs-comment">//让父类指针指向子类的对象</span><br>  p1-&gt;<span class="hljs-built_in">fun</span>();  <span class="hljs-comment">//调用子类的同名函数</span><br><br>  <span class="hljs-comment">//C语言模拟继承与多态的测试</span><br><br>  _A _a;  <span class="hljs-comment">//定义一个父类对象_a</span><br>  _B _b;  <span class="hljs-comment">//定义一个子类对象_b</span><br>  _a._fun = _fA;    <span class="hljs-comment">//父类的对象调用父类的同名函数</span><br>  _b._a_._fun = _fB;  <span class="hljs-comment">//子类的对象调用子类的同名函数</span><br><br>  _A* p2 = &amp;_a;  <span class="hljs-comment">//定义一个父类指针指向父类的对象</span><br>  p2-&gt;_fun();   <span class="hljs-comment">//调用父类的同名函数</span><br>  p2 = (_A*)&amp;_b; <span class="hljs-comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br>  p2-&gt;_fun();   <span class="hljs-comment">//调用子类的同名函数</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3id="为什么不能把所有的函数写成内联函数">为什么不能把所有的函数写成内联函数?</h3><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p><ul><li>函数体内的代码比较长，将导致内存消耗代价</li><li>函数体内有递归调用的话，函数执行时间要比函数调用开销大</li></ul><h3id="为什么c没有垃圾回收机制这点跟java不太一样">为什么C++没有垃圾回收机制？这点跟Java不太一样</h3><ul><li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul><h3 id="c的多态是如何实现的">C++的多态是如何实现的</h3><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022619.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022551.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</strong></p><ol type="1"><li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li><li>*<strong>*编译器会在每个对象的前四个字节中保存一个虚表指针，即<code>*vptr</code></strong>，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li><li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li><li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li></ol><h3 id="为什么析构函数一般写成虚函数">为什么析构函数一般写成虚函数</h3><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p><p>所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test1.cpp 不将析构函数声明为虚函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Parent</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;<br>&#125;;<br>~<span class="hljs-built_in">Parent</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Parent&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;<br>&#125;;<br>~<span class="hljs-built_in">Son</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//Parent construct function</span><br><span class="hljs-comment">//Son construct function</span><br><span class="hljs-comment">//Parent destructor function</span><br><br><br><br><span class="hljs-comment">// test2.cpp 将析构函数声明为虚函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Parent</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;<br>&#125;;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Parent</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Parent&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;<br>&#125;;<br>~<span class="hljs-built_in">Son</span>()&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//Parent construct function</span><br><span class="hljs-comment">//Son construct function</span><br><span class="hljs-comment">//Son destructor function</span><br><span class="hljs-comment">//Parent destructor function</span><br></code></pre></td></tr></table></figure><p>但存在一种特例，在<code>CRTP</code>模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应该声明为虚函数，因为这种继承方式，不需要虚函数表。</p><h3id="构造函数能否声明为虚函数或者纯虚函数析构函数呢">构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h3><p>析构函数：</p><ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li><li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li><strong>析构函数可以是纯虚函数</strong>，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul><p>构造函数：</p><ul><li>根据《effectiveC++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li><li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li></ul><h3id="基类的虚函数表存放在内存的什么区虚表指针vptr的初始化时间">基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><p>虚函数表的特征：</p><ul><li>一个类的虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li><li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li><li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。测试结果显示：</p><p>虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别。</p><p>C++中<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong></p><h3 id="模板函数和模板类的特例化">模板函数和模板类的特例化</h3><p><strong>引入原因</strong>：编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p><p><strong>定义</strong>：对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p><h4 id="模板函数特例化"><strong>模板函数特例化</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;v1,<span class="hljs-type">const</span> T &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(v1 &gt; v2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(v2 &gt; v1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;v1,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1,p2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>本质</strong>:特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用<strong>特例化版本</strong>（因为这个cosntchar*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p><p><strong>注意</strong>:模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p><h4 id="类模板特例化"><strong>类模板特例化</strong></h4><p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hash</span>&lt;sales_data&gt;<br>&#123;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(sales_data&amp; s)</span></span>;<br><span class="hljs-comment">//里面所有T都换成特例化类型版本sales_data</span><br><span class="hljs-comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>类模板的部分特例化</strong>:不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p><h5 id="特例化类中的部分成员"><strong>特例化类中的部分成员</strong></h5><p><strong>可以特例化类中的部分成员函数而不是整个类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bar</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barst</span><span class="hljs-params">(T a)</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">void</span> Foo&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">Bar</span>()<br>&#123;<br>    <span class="hljs-comment">//进行int类型的特例化处理</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;我是int型特例化&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Foo&lt;string&gt; fs;<br>Foo&lt;<span class="hljs-type">int</span>&gt; fi;<span class="hljs-comment">//使用特例化</span><br>fs.<span class="hljs-built_in">Bar</span>();<span class="hljs-comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span><br>fi.<span class="hljs-built_in">Bar</span>();<span class="hljs-comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span><br><span class="hljs-comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span><br></code></pre></td></tr></table></figure><h3id="c模板是什么你知道底层怎么实现的">C++模板是什么，你知道底层怎么实现的？</h3><ol type="1"><li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行<strong>两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</strong>。</li><li>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</li></ol><h3id="构造函数和析构函数可以调用虚函数吗为什么">构造函数和析构函数可以调用虚函数吗，为什么</h3><ol type="1"><li>在C++中，提倡不在构造函数和析构函数中调用虚函数；</li><li><strong>构造函数和析构函数调用虚函数时都不使用动态联编</strong>，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</li><li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义</li></ol><h3id="构造函数析构函数的执行顺序构造函数和拷贝构造的内部都干了啥">构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h3><p><strong>1) 构造函数顺序</strong></p><ol type="1"><li><p>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</p></li><li><p>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</p></li><li><p>派生类构造函数。</p></li></ol><p><strong>2) 析构函数顺序</strong></p><ol type="1"><li><p>调用派生类的析构函数；</p></li><li><p>调用成员类对象的析构函数；</p></li><li><p>调用基类的析构函数。</p></li></ol><h3 id="构造函数析构函数可否抛出异常">构造函数析构函数可否抛出异常</h3><ol type="1"><li>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。因此在构造函数中抛出异常要考虑释放已经申请的资源。比如<strong>用auto_ptr对象来取代指针类成员</strong>，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</li><li>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</li><li>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情.</li></ol><div class="admonition note"><p class="admonition-title">总结</p><p>在构造函数和析构函数中抛出异常时都要注意释放已经申请的资源.</p></div><h3 id="类什么时候会析构">类什么时候会析构？</h3><ol type="1"><li>对象生命周期结束，被销毁时；</li><li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</li><li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</li></ol><h3 id="构造函数的几种关键字">构造函数的几种关键字</h3><h4 id="default"><strong>default</strong></h4><p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CString</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">//语句1</span><br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">CString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr) : _str(pstr)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//这样不允许使用new关键字</span><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">CString</span>()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>     string _str;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">auto</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CString</span>(); <span class="hljs-comment">//语句2</span><br>   cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-comment">//Hello World</span><br></code></pre></td></tr></table></figure><h4 id="delete"><strong>delete</strong></h4><p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//这样不允许使用new关键字</span><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">CString</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">auto</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CString</span>(); <span class="hljs-comment">//语句1</span><br>   cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p><h4 id="section">0</h4><p>将虚函数定义为纯虚函数（纯虚函数无需定义，=0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。</p><h3id="构造函数拷贝构造函数和赋值操作符的区别">构造函数、拷贝构造函数和赋值操作符的区别</h3><p><strong>构造函数</strong></p><p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p><p><strong>拷贝构造函数</strong></p><p>对象不存在，但是使用别的已经存在的对象来进行初始化</p><p><strong>赋值运算符</strong></p><p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p><h3id="拷贝构造函数和赋值运算符重载的区别">拷贝构造函数和赋值运算符重载的区别？</h3><ul><li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p></li><li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p></li><li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p></li><li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Student s;<br>Student s1 = s;    <span class="hljs-comment">// 调用拷贝构造函数</span><br>Student s2;<br>s2 = s;    <span class="hljs-comment">// 赋值运算符操作</span><br></code></pre></td></tr></table></figure></p></li></ul><div class="admonition note"><p class="admonition-title">note</p><p>注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。</p></div><h3 id="什么是虚拟继承">什么是虚拟继承</h3><p>虚拟继承是面向对象编程中的一个概念，主要出现在支持多重继承的语言中，如C++。虚拟继承解决了由多重继承引入的菱形继承问题（Diamond Problem）。</p><p>菱形继承问题是指一个类同时继承了两个不同路径上的同一个基类，而这两个路径最终汇聚到一个共同的派生类。这样在继承体系中，<strong>基类的成员在派生类中出现了多次，可能导致二义性和冗余</strong>。</p><p>虚拟继承通过在派生类对共同基类的继承前添加 <code>virtual</code>关键字，告诉编译器在继承体系中使用虚拟继承。这样，只会有一个共同基类的实例被派生类继承，从而解决了菱形继承问题。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal is eating&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">breathe</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Mammal is breathing&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bird is flying&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span> : <span class="hljs-keyword">public</span> Mammal, <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">navigate</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bat is navigating&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Bat bat;<br>    bat.<span class="hljs-built_in">eat</span>();      <span class="hljs-comment">// Accessing eat from Animal</span><br>    bat.<span class="hljs-built_in">breathe</span>();  <span class="hljs-comment">// Accessing breathe from Mammal</span><br>    bat.<span class="hljs-built_in">fly</span>();      <span class="hljs-comment">// Accessing fly from Bird</span><br>    bat.<span class="hljs-built_in">navigate</span>(); <span class="hljs-comment">// Accessing navigate from Bat</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么情况会合成默认构造函数">什么情况会合成默认构造函数？</h3><ol type="1"><li><p>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正被需要的时候才会发生；</p><p>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</p></li><li><p>带有默认构造函数的基类，如果一个没有任何构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</p></li><li><p>带有一个虚函数的类</p></li><li><p>带有一个虚基类的类</p></li><li><p>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</p></li></ol><h3id="什么时候需要合成拷贝构造函数呢">什么时候需要合成拷贝构造函数呢？</h3><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p><ol type="1"><li>对一个对象做显示的初始化操作，X xx = x;</li><li>当对象被当做参数交给某个函数时；</li><li>当函数传回一个类对象时；</li><li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</li><li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li><li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li><li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li></ol><h3 id="抽象基类为什么不能创建对象">抽象基类为什么不能创建对象？</h3><p>抽象基类（Abstract Base Class，简称ABC）是一种在面向对象编程中用于定义接口和规范的机制。抽象基类本身不能被实例化，主要有以下原因：</p><ol type="1"><li><strong>纯虚函数：</strong> 抽象基类通常包含至少一个纯虚函数（PureVirtualFunction），这是一种在基类中声明但没有提供实现的函数。这样的函数使得基类成为抽象，因为它没有完整的实现，必须由派生类提供具体实现。由于抽象基类中存在纯虚函数，无法实例化该类。</li><li><strong>接口规范：</strong>抽象基类用于定义一组接口规范，它为派生类提供了一种契约，告诉派生类应该实现哪些方法。这些规范用于确保派生类的一致性，但抽象基类本身并不提供完整的实现，因此不能创建对象。</li><li><strong>设计目的：</strong>抽象基类的设计目的是为了促使子类提供特定的功能，而不是为了直接创建实例。通过强制派生类实现抽象基类中的虚函数，可以确保派生类符合特定的接口规范。</li></ol><h3id="模板类和模板函数的区别是什么">模板类和模板函数的区别是什么？</h3><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必.</p><h3id="多继承的优缺点作为一个开发者怎么看待多继承">多继承的优缺点，作为一个开发者怎么看待多继承</h3><h4 id="优点">优点</h4><ol type="1"><li><strong>灵活性：</strong>多继承允许一个类从多个基类派生，从而获得不同类的功能。这提供了更灵活的设计选择。</li><li><strong>代码重用：</strong>可以通过继承多个类来重用现有代码，避免重复实现相似的功能。</li><li><strong>分层设计：</strong>多继承使得可以通过多个层次结构来建模复杂的关系，更容易表达真实世界的问题。</li></ol><h4 id="缺点">缺点</h4><p>多继承是C++中一项强大而灵活的特性，但也容易引入复杂性和潜在的问题。以下是多继承的一些优缺点，以及开发者在使用多继承时应该注意的一些方面：</p><h3 id="优点-1">优点：</h3><ol type="1"><li><strong>灵活性：</strong>多继承允许一个类从多个基类派生，从而获得不同类的功能。这提供了更灵活的设计选择。</li><li><strong>代码重用：</strong>可以通过继承多个类来重用现有代码，避免重复实现相似的功能。</li><li><strong>分层设计：</strong>多继承使得可以通过多个层次结构来建模复杂的关系，更容易表达真实世界的问题。</li></ol><h3 id="缺点-1">缺点：</h3><ol type="1"><li><strong>菱形继承问题（Diamond Problem）：</strong>当一个类从两个不同的类继承，而这两个类又共同继承自同一个类时，可能导致二义性和代码冗余。</li><li><strong>复杂性：</strong>多继承引入了更多的复杂性，增加了理解和维护代码的难度。代码结构可能会变得混乱，难以追踪。</li><li><strong>潜在的命名冲突：</strong>如果多个基类中有相同的成员名，可能会引发命名冲突，需要显式解决。</li><li><strong>维护困难：</strong>随着继承层次的增加，维护和修改代码可能变得更加困难。</li></ol><h4 id="开发者应该注意的方面">开发者应该注意的方面</h4><ol type="1"><li><strong>设计良好的继承层次结构：</strong>在使用多继承时，设计一个良好的继承层次结构非常重要。避免过于复杂的层次结构和过度深度的继承链。</li><li><strong>使用虚拟继承：</strong> 使用虚拟继承（virtualinheritance）来解决菱形继承问题，确保共同的基类只有一个实例。</li><li><strong>避免深度继承链：</strong>尽量避免深度继承链，过多的层次可能导致代码难以理解和维护。</li><li><strong>使用接口和抽象类：</strong>尽量使用接口和抽象类，将接口与实现分离，降低耦合度。</li><li><strong>考虑其他设计模式：</strong>在某些情况下，其他设计模式如组合、委托等可能更合适，可以减轻多继承可能带来的复杂性</li></ol><h3id="模板和实现可不可以不写在一个文件里面为什么">模板和实现可不可以不写在一个文件里面？为什么？</h3><p><strong>不能</strong>,因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p><p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p><p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以<strong>为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</strong></p><h3id="为什么拷贝构造函数必须传引用不能传值">为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化该类一个新的实例。如果传值的方式是非引用,那么构造形参需要调用拷贝构造函数,调用拷贝构造函数的过程又需要调用拷贝构造函数,会造成无限递归.</p><h3id="静态函数能定义为虚函数吗常函数呢">静态函数能定义为虚函数吗？常函数呢？</h3><ol type="1"><li><p>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p></li><li><p>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p></li></ol><p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且<strong>只能用this指针来访问它</strong>，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</p><p>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr-&gt; vtable -&gt;virtual function</p><h3 id="虚函数的代价是什么">虚函数的代价是什么？</h3><ol type="1"><li>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，<strong>增大类存储空间</strong>；</li><li>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会<strong>增加对象的空间</strong>大小；</li><li><strong>不能再是内联的函数</strong>，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数</li></ol><h3id="说一说你了解到的移动构造函数">说一说你了解到的移动构造函数？</h3><ol type="1"><li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的资源还要有一个释放的过程，既然a不再使用了，那么为什么我们不能直接让b使用a的空间？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li><li><strong>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制</strong>；</li></ol><h3 id="构造函数的执行顺序">构造函数的执行顺序</h3><ol type="1"><li>在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</li><li>如果有成员初始化列表；</li><li>构造函数体；</li><li>构造函数完毕之后,对象的vptr被初始化；</li></ol><h3id="哪些函数不能是虚函数把你知道的都说一说">哪些函数不能是虚函数？把你知道的都说一说</h3><ol type="1"><li>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</li><li>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</li><li>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</li><li>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</li><li>普通函数，普通函数<strong>不属于类的成员函数</strong>，不具有继承特性，因此普通函数没有虚函数。</li></ol><h3id="unique_ptr实际场景中有哪些应用">unique_ptr实际场景中有哪些应用？</h3><p>互斥锁、socket会用到unique_ptr。</p><h2 id="c-11-新特性">C++ 11 新特性</h2><h3 id="c-11有哪些新特性">C++ 11有哪些新特性？</h3><ul><li>nullptr替代 NULL</li><li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li><li>基于范围的 for 循环for(auto&amp; i : res){}</li><li>类和结构体的中初始化列表</li><li>Lambda 表达式（匿名函数）</li><li>std::forward_list（单向链表）</li><li>右值引用和move语义</li></ul><h3 id="空指针-nullptr">空指针 nullptr</h3><p>nullptr 出现的⽬的是为了替代 NULL。</p><p>在某种意义上来说，传统 C语言会把 NULL、 0视为同⼀种东⻄，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定 义为((void<em>)0)，有些则会直接将其定义为 0。C++ 不允许直接将 void </em>隐式转 换到其他类型，但如果 NULL 被定义为 ((void<em>)0)，那么当编译 char</em>ch = NULL; 时，NULL 只好被定义为 0。⽽这依然会产⽣问题，将导致了C++ 中重载特性 会发⽣混乱，考虑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span></span>;<br></code></pre></td></tr></table></figure><p>对于这两个函数来说，如果 NULL ⼜被定义为了 0 那么 func(NULL)这个语句将 会去调⽤ func(int)，从⽽导致代码违反直观。</p><p>为了解决这个问题，C++11 引入了 nullptr关键字，专门⽤来区分空指针、0。nullptr的类型为nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进⾏相等或者不等的⽐较。</p><p>当需要使⽤ NULL 时候，养成直接使⽤ nullptr 的习惯。</p><h3 id="lambda-表达式">Lambda 表达式</h3><p>详见<ahref="https://gstarmin.github.io/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/">Lambda表达式用法</a>。</p><h3 id="右值引用">右值引用</h3><p>详见<ahref="https://gstarmin.github.io/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">C++右值引用</a></p><h3 id="泛化的常量表达式-constexpr">泛化的常量表达式 constexpr</h3><p>constexpr告诉编译器这是⼀个编译期常量，甚⾄可以把⼀个函数声明为编译期常量表达式。</p><p>constexpr 和 const 的区别见 C++ 部分 <ahref="https://gstarmin.github.io/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/#const-%E5%92%8C-constexpr-%E7%9A%84%E5%8C%BA%E5%88%AB">const和 constexpr 的区别</a></p><h3 id="初始化列表">初始化列表</h3><p>接下来几个特性属于原有语⾔特性的使⽤性增强。这意味着这些操作原来也是可以实现的，不过现在语法上更加简洁。⽐如⾸先要介绍的初始化列表。</p><p>⽽ C++11 提供了 initializer_list 来接受变⻓的对象初始化列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-built_in">A</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; list);<br>&#125;;<br><br>A a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>注意初始化列表特性只是现有语法增强，并不是提供了动态的可变参数。该列表只能静态地构造。</p><h3 id="统的初始化语法">统⼀的初始化语法</h3><p>不同的数据类型具有不同的初始化语法。如何初始化字符串？如何初始化数组？如何初始化多维数组？如何初始化对象？</p><p>C++11给出了统⼀的初始化语法：均可使⽤“{}-初始化变量列表”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X x1 = X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>X x2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;     <span class="hljs-comment">// 此处的&#x27;=&#x27;可有可⽆</span><br>X x3&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>X* p = <span class="hljs-keyword">new</span> X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : X &#123;    <br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) :X&#123;x,y&#125; &#123; <span class="hljs-comment">/* … */</span> &#125;;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;    <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];    <span class="hljs-comment">// 对于旧有问题的解决方案    </span><br>    <span class="hljs-built_in">S</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z) :a&#123;x,y,z&#125; &#123; <span class="hljs-comment">/* … */</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="auto和decltype类型推导">auto和decltype类型推导</h2><p>C++ 提供了 auto 和 decltype来静态推导类型，在我们知道类型没有问题但⼜不想完整地写出类型的时候，便可以使⽤静态类型推导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it);<br><span class="hljs-comment">// 可以改写为</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it);<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>虽然写起来和动态语⾔（如JavaScript的 var）很像，但C++仍然是强类型的，会执⾏静态类型检查的语⾔。这只是语法上的简化，并未改变C++的静态类型检查</p></div><p>decltype ⽤于获取⼀个表达式的类型，⽽不对表达式进⾏求值（类似于sizeof）。 decltype(e) 规则如下：</p><ul><li>若 e为⼀个⽆括号的变量、函数参数、类成员，则返回类型为该变量/参数/类成员在源程序中的声明类型;</li><li>否则的话，根据表达式的值分类（value categories），设设 T 为 e的类型:<ul><li>若 e 是⼀个左值（lvalue，即“可寻址值”），返回 T&amp; ；</li><li>若 e 是⼀个临终值（xvalue），则返回值为 T&amp;&amp; ；</li><li>若 e 是⼀个纯右值（prvalue），则返回值为 T 。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回临终值：⽣命周期已结束但内存还未拿⾛</span><br><br><span class="hljs-keyword">auto</span> a = v[<span class="hljs-number">0</span>];          <span class="hljs-comment">// a 为 int</span><br><span class="hljs-keyword">decltype</span>(v[<span class="hljs-number">0</span>]) b = <span class="hljs-number">0</span>;  <span class="hljs-comment">// b 为 const int&amp;</span><br>                       <span class="hljs-comment">// 即 vector&lt;int&gt;::operator[](size_type) const 的返回值类型</span><br><span class="hljs-keyword">auto</span> c = <span class="hljs-number">0</span>;             <span class="hljs-comment">// c, d 均为 int</span><br><span class="hljs-keyword">auto</span> d = c;<br><span class="hljs-keyword">decltype</span>(c) e;          <span class="hljs-comment">// e 为 int，即 c 的类型</span><br><span class="hljs-keyword">decltype</span>((c)) f = e;    <span class="hljs-comment">// f 为 int&amp;，因为 c 是左值</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">0</span>) g;          <span class="hljs-comment">// g 为 int，因为 0 是右值</span><br></code></pre></td></tr></table></figure><h3 id="基于范围的for循环">基于范围的for循环</h3><p>Boost中定义了很多"范围"，很多标准库函数都使⽤了范围⻛格的实现。这⼀概念被C++11提了出来:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; x: arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: v);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x: v);<br></code></pre></td></tr></table></figure><h3 id="构造函数委托">构造函数委托</h3><p>在 C# 和 Java 中，⼀个构造函数可以调⽤另⼀个来实现代码复⽤，但C++⼀直不允许这样做.</p><p>现在可以了，这使得构造函数可以在同⼀个类中⼀个构造函数调⽤另⼀个构造函数，从⽽达到简化代码的⽬的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myBase</span>&#123;<br>    <span class="hljs-type">int</span> number;<br>    string name;<br>    <span class="hljs-built_in">myBase</span>(<span class="hljs-type">int</span> number, string&amp; s) : <span class="hljs-built_in">number</span>(number), <span class="hljs-built_in">name</span>(s)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myBase</span>() : <span class="hljs-built_in">myBase</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;invalid&quot;</span>)&#123;&#125;<br>    <span class="hljs-built_in">myBase</span>(<span class="hljs-type">int</span> number) : <span class="hljs-built_in">myBase</span>(number, <span class="hljs-string">&quot;guest&quot;</span>)&#123;&#125;<br>    <span class="hljs-built_in">myBase</span>(string&amp; s) : <span class="hljs-built_in">myBase</span>(<span class="hljs-number">1</span>, s)&#123;<span class="hljs-built_in">PostInit</span>();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="final-和-override">final 和 override</h3><p>C++ 借由虚函数实现运⾏时多态，但 C++ 的虚函数⼜很多脆弱的地方：</p><ul><li>⽆法禁⽌子类重写它。可能到某⼀层级时，我们不希望子类继续来重写当前虚函数了。</li><li>容易不小⼼隐藏父类的虚函数。⽐如在重写时，不小⼼声明了⼀个签名不⼀致但有同样名称的新函数。</li></ul><p>C++11 提供了 final 来禁⽌虚函数被重写/禁⽌类被继承， override来显示地重写虚函数。如果不使用override，当你手一抖，将<strong>foo()</strong>写成了<strong>f00()</strong>会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base1</span> <span class="hljs-keyword">final</span> &#123; &#125;;     <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived1</span> : Base1 &#123;&#125;;         <span class="hljs-comment">// 编译错：Base1不允许被继承 </span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base2</span> &#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived2</span> : Base2 &#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 编译错：f1不允许重写    </span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// 编译错：父类中没有 void f2(int)</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="static_assert">static_assert</h3><p>C++ 提供了两种方式来 assert ：⼀种是 assert 宏，另⼀种是预处理指令#error 。前者在运⾏期起作⽤，⽽后者是预处理期起作⽤。它们对模板都不好使，因为模板是编译期的概念。</p><p>static_assert 关键字的使⽤方式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Check</span> &#123;  <br>    <span class="hljs-built_in">static_assert</span>( <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;= <span class="hljs-built_in">sizeof</span>(T), <span class="hljs-string">&quot;T is not big enough!&quot;</span> ) ;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="智能指针">智能指针</h3><p>接下来介绍 C++11 对于 C++ 标准库的变更。C++11 把 TR1并入了进来，废弃了 C++98 中的 auto_ptr ， 同时将 shared_ptr 和 uniq_ptr并入 std 命名空间。</p><p>智能指针在 [Effective C++: Item 13]中已经有不少讨论了。这⾥给⼀个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">p_first</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">double</span>)</span></span>;     <br>    &#123;        <br>        std::shared_ptr&lt;<span class="hljs-type">double</span>&gt; p_copy = p_first;        <br>        *p_copy = <span class="hljs-number">21.2</span>;    <br>    &#125;  <span class="hljs-comment">// p_copy 被销毁，⾥面的 double 还有⼀个引⽤因此仍然保持    </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// p_first 及其⾥面的 double 销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正则表达式">正则表达式</h3><p>这个任何⼀门现代的编程语⾔都会提供的特性终于进标准：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *reg_esp = <span class="hljs-string">&quot;[ ,.\\t\\n;:]&quot;</span>;<span class="hljs-function">std::regex <span class="hljs-title">rgx</span><span class="hljs-params">(reg_esp)</span> </span>;std::cmatch match ;  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *target = <span class="hljs-string">&quot;Polytechnic University of Turin &quot;</span> ; <span class="hljs-keyword">if</span>( <span class="hljs-built_in">regex_search</span>( target, match, rgx ) ) &#123;  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> n = match.<span class="hljs-built_in">size</span>();  <span class="hljs-keyword">for</span>( <span class="hljs-type">size_t</span> a = <span class="hljs-number">0</span> ; a &lt; n ; a++ ) &#123;    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">( match[a].first, match[a].second )</span> </span>;    cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> ;  &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="增强的元组">增强的元组</h3><p>在 C++ 中本已有⼀个 pair 模板可以定义⼆元组，C++11更进⼀步地提供了边⻓参数的tuple 模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::tuple&lt; <span class="hljs-type">int</span> , <span class="hljs-type">double</span>, string&gt; tuple_1 t1;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> std::tuple&lt; <span class="hljs-type">char</span>, <span class="hljs-type">short</span> , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * &gt; tuple_2 <span class="hljs-title">t2</span> <span class="hljs-params">(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Hola!&quot;</span>)</span></span>;<br>t1 = t2 ;       <span class="hljs-comment">// 隐式类型转换</span><br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><p>C++ 的 map , multimap , set , multiset 使⽤红⿊树实现，插入和查询都是 O(lgn) 的复杂度</p><p>但 C++11 为这四种模板类提供了（底层哈希实现）以达到 O(1)的复杂度：</p><table><thead><tr class="header"><th>散列表类型</th><th>有无关系值</th><th>接受相同键值</th></tr></thead><tbody><tr class="odd"><td>std::unordered_map</td><td>是</td><td>否</td></tr><tr class="even"><td>std::unordered_multimap</td><td>是</td><td>是</td></tr><tr class="odd"><td>std::unordered_set</td><td>否</td><td>否</td></tr><tr class="even"><td>std::unordered_multiset</td><td>否</td><td>是</td></tr></tbody></table><h2 id="c内存管理">C++内存管理</h2><h3 id="类的对象存储空间大小">类的对象存储空间大小？</h3><ul><li>非静态成员的数据类型大小之和。</li><li>编译器加入的额外成员变量（如指向虚函数表的指针）。</li><li>为了边缘对齐优化加入的padding。</li></ul><p>空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0</p><h3 id="简要说明c的内存分区">简要说明C++的内存分区</h3><p>C++中的内存分区，分别是<strong>堆、栈、全局/静态存储区、常量存储区和代码区</strong>（CS225写的是4个区域）。如下图所示</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021689.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p><p><strong>堆</strong>：就是那些由<code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个<code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p><p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p><p><strong>代码区</strong>：存放函数体的二进制代码</p><h3 id="什么是内存池如何实现">什么是内存池，如何实现</h3><p>内存池（Memory Pool）是一种<strong>内存分配</strong>方式。通常我们习惯直接使用new、malloc等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p><h4 id="实现">实现</h4><p>这里<strong>简单描述一下《STL源码剖析》中的内存池实现机制</strong>：</p><p><strong>allocate 包装malloc，deallocate包装free</strong>，一般是一次20*2个的申请，先用一半，留着一半，C++委员会成员认为20是个比较好的数字，既不大也不小。</p><ol type="1"><li>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20* 32byte）</li><li>客户端之后有有内存需求，想申请（20 *64bytes）的空间，这时内存池只有（20 * 32bytes），就先将（10 *64bytes)个区块返回，1个区块交出，另外19个处于维护状态，此时内存池空空如也.</li><li>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</li><li>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</li></ol><p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。</p><p>内部实现，目前的所有编译器都是直接调用的::operator new()和::operatordelete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p><div class="admonition note"><p class="admonition-title">note</p><p>new和 operator new的区别：new是一个关键字，用于为对象动态分配内存，而operate new是一个分配原始内存的函数。程序员在使用new的时候会调用operatenew分配内存，然后它调用正确类型的对象的构造函数，因此结果是在该内存中创建的真实活动对象。</p></div><h3id="c中类的数据成员和成员函数内存分布情况">C++中类的数据成员和成员函数内存分布情况</h3><p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。类分为成员变量和成员函数，我们先来讨论成员变量。</p><p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">23</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;对象地址：&quot;</span>&lt;&lt; &amp;p &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age地址：&quot;</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;对象大小：&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age大小：&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(p.age) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//对象地址：0x7fffec0f15a8</span><br><span class="hljs-comment">//age地址：0x7fffec0f15a8</span><br><span class="hljs-comment">//对象大小：4</span><br><span class="hljs-comment">//age大小：4</span><br></code></pre></td></tr></table></figure><p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p><p>要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。</p><p>我们再来补充一下静态成员函数的存放问题：<strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员。</p><p>就像前面提到的，<strong>所有函数都存放在代码区，静态函数也不例外。所有有人一看到static 这个单词就主观的认为是存放在全局数据区，那是不对的。</strong></p><h3id="关于this指针你知道什么全说出来">关于this指针你知道什么？全说出来</h3><ul><li>this指针是类的指针，<strong>指向对象的首地址</strong>。</li><li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li><li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</li></ul><h4 id="this指针的用处"><strong>this指针的用处</strong></h4><p>一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象)的结果。this作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p><h4 id="this指针的使用"><strong>this指针的使用</strong></h4><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用return *this；</p><p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n（不能写成n = n）</p><h4id="类的this指针有以下特点"><strong>类的this指针有以下特点</strong></h4><p><strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>传入参数为当前对象地址，成员函数第一个参数为</strong>为<strong>T* const this</strong></p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;&#125;&#125;;<br></code></pre></td></tr></table></figure><p>其中，<strong>func</strong>的原型在编译器看来应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(A * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>,<span class="hljs-type">int</span> p)</span></span>;<br></code></pre></td></tr></table></figure><p>由此可见，<strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;a.<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//此处，编译器将会编译成：A::func(&amp;a,10);</span><br></code></pre></td></tr></table></figure><p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p><h3 id="几个this指针的易混问题">几个this指针的易混问题</h3><h4 id="this指针是什么时候创建的">this指针是什么时候创建的？</h4><p><strong>this在成员函数的开始执行前构造，在成员的执行结束后清除。</strong></p><p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPExx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p><h4id="this指针存放在何处堆栈全局变量还是其他">this指针存放在何处？堆、栈、全局变量，还是其他？</h4><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p><h4id="this指针是如何传递类中的函数的绑定还是在函数参数的首参数就是this指针那么this指针又是如何找到类实例后函数的">this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h4><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p><p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</p><h4id="this指针是如何访问类中的变量的">this指针是如何访问类中的变量的？</h4><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p><p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p><p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p><h4id="我们只有获得一个对象后才能通过对象使用this指针如果我们知道一个对象this指针的位置可以直接使用吗">我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h4><p><strong>this指针只有在成员函数中才有定义</strong>。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p><h4id="每个类编译后是否创建一个类中函数表保存函数指针以便用来调用函数">每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h4><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p><h3id="成员函数中调用delete-this会出现什么问题对象还可以使用吗">成员函数中调用deletethis会出现什么问题？对象还可以使用吗？</h3><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用deletethis时，类对象的内存空间被释放。在deletethis之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><h4 id="为什么是不可预期的问题">为什么是不可预期的问题？</h4><p>deletethis之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。deletethis释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p><h3id="如果在类的析构函数中调用delete-this会发生什么">如果在类的析构函数中调用deletethis，会发生什么？</h3><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，deletethis会去调用本对象的析构函数，而析构函数中又调用deletethis，形成无限递归，造成堆栈溢出，系统崩溃。</p><h3 id="你知道空类的大小是多少吗">你知道空类的大小是多少吗？</h3><ol type="1"><li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li><li><strong>C++标准指出，不允许一个对象（当然包括类对象）的大小为0</strong>，不同的对象不能具有相同的地址；</li><li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li><li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li></ol><h3id="请说一下以下几种情况下下面几个类的大小各是多少">请说一下以下几种情况下，下面几个类的大小各是多少？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++中空类会占一个字节，这是为了让对象的实例能够相互区别</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>空类的大小是1，在<strong>C++中空类会占一个字节，这是为了让对象的实例能够相互区别</strong>。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p><p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;&#125; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 4(32位机器)/8(64位机器);</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 4(32位机器)/8(64位机器);</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为有**虚函数的类对象中都有一个虚函数表指针__vptr，其大小是4字节**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> a; <span class="hljs-type">int</span> b; &#125;;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <span class="hljs-type">int</span> c; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>    <br>  <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>  B b; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(b)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>    <br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(C) &lt;&lt; endl; <span class="hljs-comment">// 输出4</span><br>  C c;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(c) &lt;&lt; endl; <span class="hljs-comment">// 输出4</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员存放在静态存储区，不占用类的大小,普通函数也不占用类大小。</p><h3id="this指针调用成员变量时堆栈会发生什么变化">this指针调用成员变量时，堆栈会发生什么变化？</h3><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p><p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p><p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p><h3 id="类对象的大小受哪些因素影响">类对象的大小受哪些因素影响？</h3><ol type="1"><li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li><li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li><li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li><li>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展</li></ol><h3 id="菱形继承和虚继承">菱形继承和虚继承</h3><p>详细见<ahref="https://zhuanlan.zhihu.com/p/365223471">菱形继承和虚继承</a>,这里只贴出几个重要结论：</p><ol type="1"><li>对于虚基类的初始化是由最后的派生类中负责初始化。在最后的派生类中不仅要对直接基类进行初始化，还要负责对虚基类初始化；</li><li>程序运行时，只有最后的派生类执行对基类的构造函数调用，而忽略其他派生类对虚基类的构造函数调用。从而避免对基类数据成员重复初始化。因此，虚基类只会构造一次。</li></ol><h2 id="stl模板库">STL模板库</h2><h3 id="说一下c左值引用和右值引用">说一下C++左值引用和右值引用</h3><ol type="1"><li>在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</li><li><strong>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型</strong>，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</li><li><strong>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</strong></li></ol><h3 id="stl中hashtable的实现">STL中hashtable的实现？</h3><p>STL中的hashtable使用的是<strong>拉链法</strong>解决hash冲突问题，如下图所示。</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035271.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p><p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97,193,...,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的bucketsvector，重新计算元素在新hashtable的位置。</p><h3 id="stl的两级空间配置器">STL的两级空间配置器</h3><p>动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p><p>于是就设置了二级空间配置器，<strong>当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p><p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。如果<strong>大于128字节再转去一级配置器器。</strong></p><h4 id="一级配置器">一级配置器</h4><p><strong>一级空间配置器</strong>中重要的函数就是allocate、deallocate、reallocate。一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置。大致过程是：</p><p>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</p><p>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</p><p>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035143.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="二级配置器">二级配置器</h4><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035104.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p></li><li><p>对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) *20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。</p></li><li><p>内存池为空，申请内存此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2* 所需节点内存大小（提升后）* 20 +一段额外空间），申请40块，一半拿来用，一半放内存池中。</p></li><li><p>malloc没有成功在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</p></li></ol><p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p><h4 id="二级空间配置器的优缺点">二级空间配置器的优缺点</h4><p>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多<strong>内部碎片</strong>；</p><p>2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p><h3 id="vector如何释放空间">Vector如何释放空间?</h3><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p><p>如果需要空间动态缩小，可以考虑使用deque。</p><p>如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>(Vec).<span class="hljs-built_in">swap</span>(Vec); <span class="hljs-comment">//将Vec中多余内存清除； </span><br><span class="hljs-built_in">vector</span>().<span class="hljs-built_in">swap</span>(Vec); <span class="hljs-comment">//清空Vec的全部内存；</span><br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span> <span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)</span></span>;   <span class="hljs-comment">// three ints with a value of 100</span><br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(vec).<span class="hljs-built_in">swap</span>(vec); <span class="hljs-comment">//清空vec中多余的空间，相当于vec.shrink_to_fit();</span><br><br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">swap</span>(vec); <span class="hljs-comment">//清空vec的全部空间</span><br><br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    运行结果：</span><br><span class="hljs-comment">    vec.size(): 102</span><br><span class="hljs-comment">    vec.capasity(): 200</span><br><span class="hljs-comment">    vec.size(): 102</span><br><span class="hljs-comment">    vec.capasity(): 102</span><br><span class="hljs-comment">    vec.size(): 0</span><br><span class="hljs-comment">    vec.capasity(): 0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="stl迭代器如何实现">STL迭代器如何实现</h3><p>1、迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p><p>2、迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p><p>3、最常用的迭代器的相应型别有五种：value type、differencetype、pointer、reference、iterator catagoly;</p><h3id="mapset是怎么实现的红黑树是怎么能够同时实现这两种容器-为什么使用红黑树">map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？为什么使用红黑树？</h3><ol type="1"><li>他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效的插入删除；</li><li>红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</li><li>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</li></ol><h3 id="map插入方式有哪几种">map插入方式有哪几种？</h3><ol type="1"><li>用insert函数插入pair数据</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;student_one&quot;</span>));  <br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>用insert函数插入value_type数据</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;student_one&quot;</span>)); <br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>在insert函数中使用make_pair()函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;student_one&quot;</span>)); <br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>用数组方式插入数据</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;student_one&quot;</span>; <br></code></pre></td></tr></table></figure><h3id="stl中unordered_maphash_map和map的区别hash_map如何解决冲突以及扩容">STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</h3><ol type="1"><li>unordered_map内部元素是无序的，而map会根据key的大小进行排序，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</li></ol><h3 id="stl中vector的实现">STL中vector的实现</h3><p>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，vector使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。扩容规则：以原大小的两倍(或1.5倍)配置另外一块较大的空间</p><div class="admonition note"><p class="admonition-title">note</p><p>Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2倍</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> size_type len  = old_size + <span class="hljs-built_in">max</span>(old_size, n);<br></code></pre></td></tr></table></figure><h3 id="stl中slist的实现">STL中slist的实现</h3><p>list是双向链表，而slist（single linkedlist）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectionaliterator，后者的迭代器属于单向的Forwarditerator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p><strong>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后</strong>，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的</p><p>slist的单向迭代器如下图所示：</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071953335.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allco</span> = alloc&gt;<br><span class="hljs-keyword">class</span> slist<br>&#123;<br>...<br><span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-type">static</span> list_node* <span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> value_type&amp; x)&#123;&#125;<span class="hljs-comment">//配置空间、构造元素</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-built_in">destroy_node</span>(list_node* node)&#123;&#125;<span class="hljs-comment">//析构函数、释放空间</span><br><span class="hljs-keyword">private</span>:<br>    list_node_base head; <span class="hljs-comment">//头部</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(slist&amp; L)</span></span>&#123;&#125;<span class="hljs-comment">//交换两个slist，只需要换head即可</span><br>    <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//取头部元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">const</span> value&amp; x)</span></span>&#123;&#125;<span class="hljs-comment">//头部插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//从头部取走元素</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++11中出现，它与slist的区别是没有size()方法。</p></div><p>slist的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>forward_list&lt;<span class="hljs-type">int</span>&gt; fl;<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">6</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">5</span>);<br><br>forward_list&lt;<span class="hljs-type">int</span>&gt;::iterator ite1 = fl.<span class="hljs-built_in">begin</span>();<br>forward_list&lt;<span class="hljs-type">int</span>&gt;::iterator ite2 = fl.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">for</span>(;ite1 != ite2; ++ite1)<br>&#123;<br>cout &lt;&lt; *ite1 &lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 5 6 2 3 1</span><br>&#125;<br>cout &lt;&lt; endl;<br><br>ite1 = <span class="hljs-built_in">find</span>(fl.<span class="hljs-built_in">begin</span>(), fl.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>); <span class="hljs-comment">//寻找2的位置</span><br><br><span class="hljs-keyword">if</span> (ite1 != ite2)<br>fl.<span class="hljs-built_in">insert_after</span>(ite1, <span class="hljs-number">99</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : fl)<br>&#123;<br>cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//5 6 2 99 3 1</span><br>&#125;<br>cout &lt;&lt; endl;<br><br>ite1 = <span class="hljs-built_in">find</span>(fl.<span class="hljs-built_in">begin</span>(), fl.<span class="hljs-built_in">end</span>(), <span class="hljs-number">6</span>); <span class="hljs-comment">//寻找6的位置</span><br><span class="hljs-keyword">if</span> (ite1 != ite2)<br>fl.<span class="hljs-built_in">erase_after</span>(ite1);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : fl)<br>&#123;<br>cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//5 6 99 3 1</span><br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stl中list的实现">STL中list的实现</h3><p>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是<strong>双向迭代器</strong>：Bidirectionaliterators。</p><p>list节点的结构见如下源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__list_node</span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* void_pointer;<br>    void_pointer prev;<br>    void_pointer next;<br>    T data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stl中的deque的实现">STL中的deque的实现</h3><p>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头部进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071953980.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>deque和vector的最大差异一个是deque运行在<strong>常数时间内对头端进行元素操作</strong>，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来</p><p>d<strong>eque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。</strong>如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque。</p><p>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性。</p><p>deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如下图所示。</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021322.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>deque的迭代器数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__deque_iterator</span><br>&#123;<br>    ...<br>    T* cur;<span class="hljs-comment">//迭代器所指缓冲区当前的元素</span><br>    T* first;<span class="hljs-comment">//迭代器所指缓冲区第一个元素</span><br>    T* last;<span class="hljs-comment">//迭代器所指缓冲区最后一个元素</span><br>    map_pointer node;<span class="hljs-comment">//指向map中的node</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素:</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021453.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p><h3 id="stl中stack和queue的实现">STL中stack和queue的实现</h3><h4 id="stack">Stack</h4><p>stack（栈）是一种先进后出（First In LastOut）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021348.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack<br>&#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>    Sequence c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();&#125;<br>    <span class="hljs-function">reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();&#125;<br>    <span class="hljs-function">const_reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="hljs-built_in">push_back</span>(x);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;c.<span class="hljs-built_in">pop_back</span>();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而<strong>Sequence默认是deque数据结构</strong>。stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为containeradapter而非container</p><p>stack<strong>除了默认使用deque作为其底层容器之外，也可以使用双向开口的list</strong>，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</p><h4 id="queue">Queue</h4><p>queue（队列）是一种先进先出（First In FirstOut）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> queue<br>&#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>    Sequence c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();&#125;<br>    <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>();&#125;<br>    <span class="hljs-function">const_reference <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="hljs-built_in">push_back</span>(x);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;c.<span class="hljs-built_in">pop_front</span>();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成</strong>，Sequence默认也是deque数据结构。queue也是一类containeradapter。</p><p>同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</p><h3 id="stl中的heap的实现">STL中的heap的实现</h3><p>heap（堆）并不是STL的容器组件，是priorityqueue（优先队列）的底层实现机制，因为binary maxheap（大根堆）总是最大值位于堆的根部，优先级最高。</p><p>binary heap本质是一种complete binary tree（完全二叉树），整棵binarytree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021792.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于<spanclass="math inline">\(i\)</span>处，其左节点必定位于<spanclass="math inline">\(2i\)</span>处，右节点位于<spanclass="math inline">\(2i+1\)</span>处，父节点位于<spanclass="math inline">\(i/2\)</span>（向下取整）处。这种以array表示tree的方式称为隐式表述法。</p><p>因此我们可以使用一个array和一组heap算法来实现maxheap（每个节点的值大于等于其子节点的值）和minheap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，可以用vector代替array。</p><h3 id="stl中的priority_queue的实现">STL中的priority_queue的实现</h3><p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022333-17059267793603.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。</p><p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ia[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span> &#125;;<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(ia, ia + <span class="hljs-number">9</span>)</span></span>;<br>cout &lt;&lt; pq.<span class="hljs-built_in">size</span>() &lt;&lt;endl;  <span class="hljs-comment">// 9</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pq.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 8 8 8 8 8 8 8 8 8</span><br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">// 8 7 6 5 4 3 2 1 0</span><br>pq.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stl中set的实现">STL中set的实现？</h3><p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</p><p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p><p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p><p>标准的STLset以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：</p><ul><li>每个节点不是红色就是黑色</li><li>根结点为黑色</li><li>如果节点为红色，其子节点必为黑</li><li>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</li></ul><p>关于红黑树的具体操作过程，比较复杂读者可以翻阅《算法导论》详细了解。</p><h3 id="stl中map的实现">STL中map的实现</h3><p>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</p><p>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constantiterator，也不是mutable iterator</p><p>标准STL map的底层机制是RB-tree（红黑树），另一种以hashtable为底层机制实现的称为hash_map。map的架构如下图所示</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022980.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p><h3id="set和map的区别multimap和multiset的区别">set和map的区别，multimap和multiset的区别</h3><p>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素。</p><p>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</p><p>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入。</p><p>multiset和multimap的区别也是一样的，只不过multiset和multimap使用insert_equal()。</p><p>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p><h3 id="红黑树"><strong>红黑树</strong></h3><p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p><ol type="1"><li>它是二叉排序树（继承二叉排序树特显）：</li></ol><ul><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。<ul><li>左、右子树也分别为二叉排序树。</li></ul></li></ul><ol start="2" type="1"><li>它满足如下几点要求：</li></ol><ul><li>树中所有节点非红即黑。</li><li>根节点必为黑节点。</li><li>红节点的子节点必为黑（黑节点子节点可为黑）。</li><li>从根到NULL的任何路径上黑结点数相同。</li></ul><ol start="3" type="1"><li>查找时间一定可以控制在O(logn)。</li></ol><h3id="stl中unordered_map和map的区别和应用场景">STL中unordered_map和map的区别和应用场景</h3><ul><li><p>map底层实现是红黑树，查询和维护时间复杂度均为<code>O(log n)</code>,而unordered_map的底层实现是哈希表，其查询时间复杂度为<code>O(1)</code>,维护时间与bucket桶锁维护的list长度有关，到那时建立hash表耗时比较大。</p></li><li><p>map支持键值自动排序，而unordered_map是无序容器</p></li></ul><p>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</p><h3id="hashtable中解决冲突有哪些方法">hashtable中解决冲突有哪些方法？</h3><ul><li><strong>线性探测法</strong>：使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</li><li><strong>拉链法</strong>：每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</li><li><strong>再散列</strong>：发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</li><li><strong>二次探测</strong>：使用hash函数计算出的位置如果已经有元素占用了，按照<spanclass="math inline">\(1^2\)</span>、<spanclass="math inline">\(2^2\)</span>、<spanclass="math inline">\(3^2\)</span>...的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</li></ul><h3 id="stl的六大组件">STL的六大组件</h3><ol type="1"><li>容器Containers：各种数据结构，如 vector、list、deque、set、map等。分为两大类，序列式容器和关联式容器。序列式容器（sequentialcontainer）为程序员提供了控制元素存储和访问顺序的能力。和序列式容器对应的是关联式容器（associative-container），关联容器中的元素是按关键字来保存和访问的。关联容器支持高效的关键字查找和访问，STL有两个主要的关联容器：map 和 set。</li><li>算法Algorithms：各种常用算法，提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作，比如sort、search、copy、erase。从实现的角度来看，STL 算法是一种 functiontemplate。</li><li>迭代器Iterator：迭代器（Iterators）：迭代器用于遍历对象集合的元素，扮演容器与算法之间的胶合剂，是所谓的“<strong>泛型指针</strong>”。</li><li>仿函数Functors：也称为函数对象（Functionobject），行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的 class 或者 class template。</li><li>适配器Adapters：一种用来修饰容器或者仿函数或迭代器接口的东西。例如STL 提供的 queue 和 stack，就是一种空间配接器，因为它们的底部完全借助于deque。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。</li><li>分配器allocator：也称为空间配置器，负责空间的配置与管理。从实现的角度来看，配置器是一个实现了动态配置空间、空间管理、空间释放的class template。</li></ol><h3 id="红黑树-1">红黑树</h3><p>红黑树是一种自平衡的二叉搜索树，它在每个节点上增加了一个额外的属性表示节点的颜色（红色或黑色），并通过一组规则来保持树的平衡。这些规则确保了红黑树的高度保持在对数级别，从而保证了各种基本操作的高效性。</p><p>红黑树的特性包括：</p><ol type="1"><li><strong>节点颜色：</strong><ul><li>每个节点都被标记为红色或黑色。</li></ul></li><li><strong>根节点：</strong><ul><li>根节点是黑色的。</li></ul></li><li><strong>叶子节点（NIL节点）：</strong><ul><li>所有叶子节点（NIL节点，也称为哨兵节点）都是黑色的。</li></ul></li><li><strong>红色节点规则：</strong><ul><li>父子节点之间不能同时为红色，也就是说，红色节点不能有红色的子节点。</li></ul></li><li><strong>路径黑高度相等：</strong><ul><li>从任意节点到其每个叶子节点的路径都包含相同数目的黑色节点，这被称为黑高度相等。</li></ul></li></ol><p>这些特性确保了红黑树的平衡，使得在最坏情况下，红黑树的高度是对数级别的。这样做的目的是保证插入、删除和查找等基本操作的时间复杂度始终是对数级别的，保证了红黑树的高效性。</p><p>红黑树的自平衡性质使其在动态插入和删除操作时能够有效地维持平衡，而不会退化为一棵高度不平衡的树。这使得红黑树在实际应用中被广泛使用，例如在STL中的<code>std::map</code>和<code>std::set</code>的实现中。</p><h3id="stl的vector的内存扩容为什么是2倍3倍可以吗">STL的vector的内存扩容为什么是2倍？3倍可以吗</h3><p>VS用的是两倍，GCC扩容是1.5倍。为什么不用3倍？（可能3倍太浪费）</p><p>标准库并没有提供直接设置容器扩容倍数的接口。所以想要用3倍需要自己实现一个新的容器。</p><h3 id="vector的初始容量是多少">vector的初始容量是多少？</h3><p>初始容量是0。</p><p><strong>初始为0怎么按照1.5或2倍的扩容规则扩容？</strong></p><p>初始为0的话第一次扩容是例外，会扩容到1，然后再按照1.5或2倍的规则扩容。</p><h2 id="项目">项目</h2><h3 id="epoll底层实现细节">epoll底层实现细节</h3><p>epoll 在 Linux 内核中申请了一个简易的文件系统，把原先的一个 select 或poll 调用分成了 3 部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events,<span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>; <br></code></pre></td></tr></table></figure><ol type="1"><li>调用 epoll_create 建立一个 epoll 对象(在 epoll文件系统中给这个句柄分配资源)；</li><li>调用 epoll_ctl 向 epoll 对象中添加这 100 万个连接的套接字；</li><li>调用 epoll_wait 收集发生事件的连接。</li></ol><p>这样只需要在进程启动时建立 1 个 epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用 epoll_wait 时并没有向它传递这 100万个连接，内核也不需要去遍历全部的连接。</p><p>当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll结构体，这个结构体中有两个成员与 epoll的使用方式密切相关，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> &#123;<br>　　...<br>　　<span class="hljs-comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，</span><br><span class="hljs-comment">　　也就是这个epoll监控的事件*/</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_root</span> rbr;<br>　　<span class="hljs-comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdllist;<br>　　...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在调用 epoll_create 时，<strong>内核除了帮我们在 epoll文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后epoll_ctl 传来的 socket 外，还会再建立一个 rdllist双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到timeout 时间到后即使链表没数据也返回。</strong>所以，epoll_wait非常高效。</p><p>所有添加到 epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p><p>在 epoll 中对于每一个事件都会建立一个 epitem 结构体，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epitem</span> &#123;<br>　　...<br>　　<span class="hljs-comment">//红黑树节点</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> rbn;<br>　　<span class="hljs-comment">//双向链表节点</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdllink;<br>　　<span class="hljs-comment">//事件句柄等信息</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_filefd</span> ffd;<br>　　<span class="hljs-comment">//指向其所属的eventepoll对象</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> *ep;<br>　　<span class="hljs-comment">//期待的事件类型</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br>　　...<br>&#125;; <span class="hljs-comment">// 这里包含每一个事件对应着的信息。</span><br></code></pre></td></tr></table></figure><p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查 eventpoll对象中的 rdllist 双向链表是否有 epitem 元素而已，如果 rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx 效率非常高。epoll_ctl 在向 epoll对象中添加、修改、删除事件时，从 rbr 红黑树中查找事件也非常快，也就是说epoll 是非常高效的，它可以轻易地处理百万级别的并发连接。</p><p><strong>总结</strong>：执行<strong>epoll_create()</strong>时，创建了红黑树和就绪链表；执行<strong>epoll_ctl()</strong>时，如果增加 socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表（是一个双向链表）中插入数据；执行<strong>epoll_wait()</strong>时,如果 rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。</p><h3id="lt模式和et模式分别适合哪种场景">LT模式和ET模式分别适合哪种场景？</h3><p>ET 模式（边缘触发）：</p><p>在 ET 模式下，当 I/O状态发生变化时，系统只通知一次，直到下次状态变化才会再次通知。也就是说，ET模式只在状态从未就绪变为就绪时通知一次。</p><p>适用场景：</p><p>对于 ET模式，通常需要使用<strong>非阻塞（non-blocking）I/O</strong>。因为 ET模式只在状态变化的瞬间通知一次，如果使用阻塞I/O，可能在数据未完全处理时就被阻塞。</p><p>ET模式适用于需要及时响应状态变化的场景，例如网络套接字的事件处理，可以在一次通知中处理多个事件。ET模式更容易实现高性能，因为事件只在状态变化时通知，减少了不必要的上下文切换。</p><p>LT 模式（水平触发）：</p><p>在 LT 模式下，当 I/O状态处于就绪时，系统会一直通知直到状态变为不可用。也就是说，LT模式会持续通知应用程序，直到应用程序处理完所有就绪的数据或事件。</p><p>适用场景：</p><p><strong>LT 模式更适合于使用阻塞 I/O 的场景</strong>，因为在 LT模式下，系统会持续通知应用程序，直到应用程序处理完成，避免了在数据未完全处理时被阻塞。</p><p>LT 模式适用于对于状态变化需要持续处理的场景，比如文件I/O。应用程序可以在每次通知中处理少量的数据，然后等待下一次通知。</p><h3 id="线程池怎么实现">线程池怎么实现</h3><p>先创建并启动一组线程，称为线程池threads_，由用户指定其大小maxQueueSize_。每个线程函数都是一样的，在其中会运行一个loop循环：从<strong>双端队列</strong>取出一个任务对象task，如果非空，就执行之，如此往复。</p><p>当有一个用户线程想要通过线程池运行一个用户任务时，就可以将用户任务函数及参数封装成一个可调用对象Taskf，然后通过线程池接口，将f加入双端队列末尾。当线程池有线程空闲时（未执行用户任务），就会从双端队列头部取出一个Task对象task，然后执行之。</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/741401-20220308114232593-1404677717-17093836488295.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>线程池主要由以下几个部分组成：</p><ol type="1"><li>工作队列queue_，用双端队列实现，能从尾部加入用户任务对应的可调用对象；</li><li>用户任务Task f，封装了用户任务，包含任务函数和参数；</li><li>线程组threads_，用于管理工作的线程数组；</li><li>工作线程，执行回调函数。</li></ol><h3 id="reactor实现">Reactor实现</h3><p>Reactor 模式主要有 Reactor 和 Event Handler 两个核心模块组成，其中Reactor负责监听事件，当事件发生时通过<strong>事件分发</strong>机制（Acceptor类）将其发给Event Handler进行处理。muduo有单reactor单线程和多reactor多线程，这里使用的是多reactor多线程，基于oneloop per thread的思想。</p><p>事件循环主要由EventLoop, Channel 和 Poller类实现，其中EventLoop是事件循环的“驱动者”：</p><ul><li>EventLoop 是整个事件循环的核心。核心功能是驱动 Poller将事件循环跑起来，并通过其提供的 <code>poll</code>方法进行事件循环(也就是上面的 IO 多路复用调用)</li><li>Poller 类是对 <strong>IO多路复用系统调用</strong>的一个封装类，可以向其中注册感兴趣的Channel，阻塞等待事件发生，事件发生之后返回发生的事件(通过 Channel类)。</li><li>Channel 类对某个文件描述符、相关事件、处理事件的方法进行了封装。更新Channel 中的感兴趣事件实际需要通过 EventLoop 进行，EventLoop通过其持有的 Poller 来实际执行，Channel 和 Poller并没有直接的联系。</li></ul><h3 id="设计个持最并发数的线程池">设计⼀个⽀持最⼤并发数的线程池</h3><p>仿照muduo的线程池，先创建并启动一组线程，称为线程池threads_，由用户指定其大小maxQueueSize_。每个线程会运行一个loop循环：从双端队列取出一个任务对象task，如果非空，就执行之，如此往复。</p><h4id="如果有个优先级的事件怎么处理">如果有个⾼优先级的事件怎么处理</h4><p>将高优先级队列插入到双端队列头</p><h4id="如果任务队列的任务之间有依赖关系要怎么处理呢">如果任务队列的任务之间有依赖关系要怎么处理呢？</h4><p>将前置任务先插入双端队列，后置任务后插入双端队列。</p><h3id="webserver中buffer是怎么设计的怎么实现自动增长">webserver中buffer是怎么设计的？怎么实现自动增长</h3><p>注：这里因为muduo的buffer是自适应的，可以实现自动增长。比如它一开始的初始值是1k，如果程序里边经常收发 10k 的数据，那么用几次之后它的 size()会自动增长到 10k，然后就保持不变。</p><p><strong>回答</strong>：</p><p>Buffer 的内部是一个 vector of char，它是一块连续的内存。此外，Buffer有两个 data members分别为read_index和write_imdex，指向该 vector中的元素。这两个 indices 的类型是 int，不是char*，目的是应对迭代器失效。这两个索引把vector分为三部分，prependable、readable、writable。</p><p>其中prependable可以让程序能以很低的代价在数据<strong>前面</strong>添加几个字节；全部数据读完了，readIndex和 writeIndex 返回原位以备新一轮使用。</p><p>因为使用的是vector所以可以自动增长。</p><h3 id="线程池的重要参数有哪些">线程池的重要参数有哪些</h3><p>工作队列的容量，线程池的容量</p><h3 id="内存泄漏如何检测和防">内存泄漏如何检测和防⽌？</h3><h4 id="检测">检测</h4><ol type="1"><li>检查代码：仔细检查代码中的内存分配和释放，确保每次分配内存后都有相应的释放操作。比如malloc和free、new和delete是否配对使用了。</li><li>使用调试器和工具：有一些工具可以帮助检测内存泄露。例如：<ol type="1"><li>Valgrind（仅限于Linux和macOS）：Valgrind是一个功能强大的内存管理分析工具，可以检测内存泄露、未初始化的内存访问、数组越界等问题。使用Valgrind分析程序时，只需在命令行中输入valgrind--leak-check=yes your_program即可。</li><li>Visual Studio中的CRT（C Runtime）调试功能：VisualStudio提供了一些用于检测内存泄露的CRuntime库调试功能。例如，_CrtDumpMemoryLeaks函数可以在程序结束时报告内存泄露。</li><li>AddressSanitizer：AddressSanitizer是一个用于检测内存错误的编译器插件，适用于GCC和Clang。要启用AddressSanitizer，只需在编译时添加-fsanitize=address选项。</li></ol></li></ol><h4 id="防止">防止</h4><ol type="1"><li>使用智能指针（C++）：在C++中，可以使用智能指针（如std::unique_ptr和std::shared_ptr）来自动管理内存。这些智能指针在作用域结束时会自动释放所指向的内存，从而降低忘记释放内存或者程序异常导致内存泄露的风险。</li><li>异常安全：在C++中，如果程序抛出异常，需要确保在异常处理过程中正确释放已分配的内存。使用try-catch块来捕获异常并在适当的位置释放内存。或者使用RAII（Resource Acquisition IsInitialization）技术，将资源（如内存）的管理与对象的生命周期绑定。</li></ol><h3 id="手写线程池">手写线程池</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// 构造函数，初始化线程池</span><br>    ThreadPool(<span class="hljs-type">size_t</span> numThreads) : stop(<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-comment">// 创建指定数量的工作线程，并将它们添加到线程池中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) &#123;<br>            workers.emplace_back([this] &#123;<br>                <span class="hljs-comment">// 线程主循环</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>()&gt; task;<br><br>                    &#123;<br>                        <span class="hljs-comment">// 使用互斥锁保护任务队列</span><br>                        <span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; lock(queueMutex);<br><br>                        <span class="hljs-comment">// 使用条件变量等待任务队列不为空或停止信号</span><br>                        <span class="hljs-comment">// 该wait函数内部会自动调用lock.unlock()对互斥锁解锁，使得其他被阻塞在互斥锁上的线程恢复执行</span><br>                        condition.wait(lock, [this] &#123; <span class="hljs-keyword">return</span> stop || !tasks.empty(); &#125;);<br><br>                        <span class="hljs-comment">// 如果收到停止信号且任务队列为空，线程退出</span><br>                        <span class="hljs-keyword">if</span> (stop &amp;&amp; tasks.empty()) &#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br><br>                        <span class="hljs-comment">// 取出队列头部的任务</span><br>                        task = <span class="hljs-built_in">std</span>::move(tasks.front());<br>                        tasks.pop();<br>                    &#125;<br><br>                    <span class="hljs-comment">// 执行取出的任务</span><br>                    task();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将任务加入到任务队列</span><br>    template&lt;class F&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(F&amp;&amp; func)</span> &#123;<br>        &#123;<br>            <span class="hljs-comment">// 使用互斥锁保护任务队列</span><br>            <span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">lock</span><span class="hljs-params">(queueMutex)</span>;<br>            <br>            <span class="hljs-comment">// 将任务移动到队列中</span><br>            tasks.emplace(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(func));<br>        &#125;<br><br>        <span class="hljs-comment">// 通知一个等待中的线程有新任务可以执行</span><br>        condition.notify_one();<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数，停止线程池，并等待所有线程结束</span><br>    ~ThreadPool() &#123;<br>        &#123;<br>            <span class="hljs-comment">// 使用互斥锁保护停止信号</span><br>            <span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">lock</span><span class="hljs-params">(queueMutex)</span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 唤醒所有等待中的线程</span><br>        condition.notify_all();<br><br>        <span class="hljs-comment">// 等待所有线程结束</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::thread &amp;worker : workers) &#123;<br>            worker.join();<br>        &#125;<br>    &#125;<br><br>private:<br>    <span class="hljs-comment">// 工作线程</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; workers;<br>    <br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br>    <br>    <span class="hljs-comment">// 互斥锁用于保护对任务队列的访问</span><br>    <span class="hljs-built_in">std</span>::mutex queueMutex;<br>    <br>    <span class="hljs-comment">// 条件变量用于通知工作线程有新任务</span><br>    <span class="hljs-built_in">std</span>::condition_variable condition;<br>    <br>    <span class="hljs-comment">// 停止信号，用于通知工作线程停止</span><br>    <span class="hljs-type">bool</span> stop;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建包含4个工作线程的线程池</span><br>    ThreadPool <span class="hljs-title function_">threadPool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>;<br><br>    <span class="hljs-comment">// 向线程池中提交8个任务</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>        threadPool.enqueue([i] &#123;<br>            <span class="hljs-comment">// 打印任务信息和执行线程的ID</span><br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; processed by thread &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 给予一些时间让任务被处理</span><br>    <span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-built_in">std</span>::chrono::seconds(<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法">算法</h2><h3 id="海量数据找中位数">海量数据找中位数</h3><h4 id="方法一桶排序">方法一：桶排序</h4><ol type="1"><li><p>创建多个小文件桶，设定每个桶的取值范围，然后把海量数据元素根据数值分配到对应的桶中，并记录桶中元素的个数</p></li><li><p>根据桶中元素的个数，计算出中位数所在的桶（比如 100 亿个数据，第 1个桶到第 18 个桶一共有 49 亿个数据，第 19 个桶有 2亿数据，那么中位数一定在第 19个桶中），然后针对该桶进行排序，就可以求出海量数据中位数的值（如果内存还是不够，可以继续对这个桶进行拆分；或者直接用BitMap 来排序）</p></li></ol><p>简单用 100 个数据画个图直观理解下：</p><figure><imgsrc="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/18dde9e7760129344e00545e74b348cb.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="方法二分治法-基于二进制比较">方法二：分治法 +基于二进制比较</h4><p>假设这 100 亿数据都是 int 类型，4 字节（32位）的有符号整数，存在一个超大文件中。</p><p>将每个数字用二进制表示，比较二进制的【<strong>最高位</strong>】 (第32 位)，如果数字的最高位为 0，则将这个数字写入 <code>file_0</code>文件中；如果最高位为 1，则将该数字写入 <code>file_1</code> 文件中。</p><blockquote><p>最高位为符号位，也就是说 file_1 中的数都是负数，而 file_0中的数都是正数。</p></blockquote><p>通过这样的操作，这 100 亿个数字分成了两个文件，假设 file_0 文件中有60 亿个数字，而 file_1 文件中有 40 亿个数字。</p><p>这样划分后，思考一下：所求的中位数在哪个文件中？</p><p>100 亿个数字的中位数是 100 亿个数排序之后的第 50 亿个数，现在 file_0有 60 亿个正数，file_1 有 40 亿个负数，file_0 中的数都比 file_1中的数要大，排序之后的第 50 亿个数是中位数，那么这个中位数一定位于file_0 中，并且是 file_0 文件中所有数字排序之后的第 <strong>10</strong>亿个数字。</p><p>现在，我们只需要处理 file_0 文件了（不需要再考虑 file_1 文件）。</p><p>而对于 file_0 文件，可以同样的采取上面的措施处理：将 file_0文件依次读一部分到内存，将每个数字用二进制表示，比较二进制的【<strong>次高位</strong>】（第31 位），如果数字的次高位为 0，写入 <code>file_0_0</code>文件中；如果次高位为 1 ，写入 <code>file_0_1</code> 文件中。</p><p>现假设 file_0_0 文件中有 30 亿个数字，file_0_1 中也有 30亿个数字，则中位数就是：file_0_0 文件中的数字从小到大排序之后的第 10亿个数字。</p><p>抛弃 file_0_1 文件，继续对 file_0_0 文件根据【<strong>次次高位</strong>】(第 30 位)划分，如此反复下去，便可以得到中位数。</p><h4 id="方法三堆排序">方法三：堆排序</h4><p>要用堆排序直接找到中位数，可以把问题转换为找到第K大的数（K是全部数据量的一半），但是由于数据量过大，所以内存不能设置一个大小为K的堆，所以可以考虑分为多步。首先用小根堆堆找到第k大的数（k&lt;K）,然后再找到第2k大的数（有了kth大的数之后，再次遍历数据，大于kth的数直接丢掉，小于的放到小根堆中，最后可以得到2kth大的数），如此循环往复即可。</p><h4 id="方法四外排序">方法四：外排序</h4><p>使用外部归并排序</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu配置Clash</title>
    <link href="/2023/11/02/ubuntu%E9%85%8D%E7%BD%AEClash/"/>
    <url>/2023/11/02/ubuntu%E9%85%8D%E7%BD%AEClash/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu配置clash">Ubuntu配置Clash</h1><h2 id="下载clash">下载Clash</h2><p>首先下载Clash,以当前最新版本为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/Dreamacro/clash/releases/download/v1.18.0/clash-linux-amd64-v1.18.0.gz<br></code></pre></td></tr></table></figure><p>使用以下命令解压下载的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gunzip clash-linux-amd64-v1.18.0.gz<br></code></pre></td></tr></table></figure><p>使用以下命令将解压后的文件移动到 <code>/usr/local/bin</code>目录，并重命名为 <code>clash</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mv</span> clash-linux-amd64-v1.18.0 /usr/local/bin/clash<br></code></pre></td></tr></table></figure><p>使用以下命令给 Clash 添加执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/clash<br></code></pre></td></tr></table></figure><div class="admonition info"><p class="admonition-title">info</p><p>这个重命名之后的clash文件就是clash的可执行文件，它和后面的clash配置文件夹是两个路径，注意区分</p></div><h2 id="更新订阅">更新订阅</h2><p>创建Clash的配置文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.config/clash<br></code></pre></td></tr></table></figure><p>订阅内容并保存为配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clash">curl https:/xxxx.yaml &gt; ~/.config/clash/config.yaml<br></code></pre></td></tr></table></figure><p>这里https:/xxxx.yaml为订阅链接，可以在clash订阅页面获取，通常这样下下载config.yaml文件里边是乱码，所以就需要自己把订阅的配置内容自己复制过去。</p><p>至此，Clash 的配置文件已经创建完成。现在就可以使用以下命令启动Clash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clash -d ~/.config/clash<br></code></pre></td></tr></table></figure><h2 id="设置快捷命令">设置快捷命令</h2><p>但是上面的方法每次都要输入完整的命令，所以可以设置快捷命令，在<code>~/.bashrc</code>文件中添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 Clash 服务</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">clash</span></span>() &#123;<br>    <span class="hljs-built_in">nohup</span> /usr/local/bin/clash  &gt; /dev/null 2&gt;&amp;1 &amp;<br>    <span class="hljs-built_in">disown</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Clash is started&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 关闭 Clash 服务</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">unclash</span></span>() &#123;<br>    pkill -f /usr/local/bin/clash<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Clash is stopped&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 开启 Clash 代理</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy</span></span>() &#123;<br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><br>    <span class="hljs-built_in">export</span> all_proxy=<span class="hljs-string">&quot;socks5://127.0.0.1:7891&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Clash proxy started&quot;</span><br>&#125;<br><span class="hljs-comment"># 关闭 Clash代理</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">unproxy</span></span>() &#123;<br>    <span class="hljs-built_in">unset</span> http_proxy<br>    <span class="hljs-built_in">unset</span> https_proxy<br>    <span class="hljs-built_in">unset</span> all_proxy<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Clash proxy stopped&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以在终端快速开启和关闭clash的服务和代理了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntu:~<span class="hljs-comment"># clash</span><br>&gt;&gt; [1] 5917<br>&gt;&gt; Clash is started<br>root@ubuntu:~<span class="hljs-comment"># proxy</span><br>&gt;&gt; Clash proxy started<br>root@ubuntu:~<span class="hljs-comment"># unproxy</span><br>&gt;&gt; Clash proxy stopped<br>root@ubuntu:~<span class="hljs-comment"># unclash</span><br>&gt;&gt; Clash is stopped<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>注意区分Clash的服务和代理的开启，执行<code>clash</code>命令开启服务，执行<code>proxy</code>命令开启代理，执行<code>unclash</code>命令关闭服务，执行<code>unproxy</code>命令关闭代理，单独开启服务而没有开启代理是没有用的，因为没有代理的话，就没有流量走clash，也就没有科学上网效果。</p></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>muduo例子流程解析</title>
    <link href="/2023/09/19/muduo%E4%BE%8B%E5%AD%90%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/09/19/muduo%E4%BE%8B%E5%AD%90%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo例子流程解析">muduo例子流程解析</h1><h2 id="muduo库架构">muduo库架构</h2><p>首先回顾一下muudo库的架构，如下图所示：</p><p><img src="/img/muduo/解析/muduo架构.png" /></p><p>muduo库使用了Reactor模式，所谓Reactor模式，是有一个循环的过程，监听对应事件是否触发，触发时调用对应的callback进行处理。</p><p>这里的事件在muduo中包括Socket可读写事件、定时器事件。在其他网络库中如libevent也包括了signal、用户自定义事件等。</p><p>负责事件循环的部分在muduo命名为<code>EventLoop</code>，其他库如netty、libevent也都有对应的组件。</p><p>负责监听事件是否触发的部分，在muduo中叫做Poller。muduo提供了epoll和poll两种来实现，默认是epoll实现。通过环境变量MUDUO_USE_POLL来决定是否使用poll:</p><h2 id="例子">例子</h2><p>下面用一个简单的例子来分析muduo库的基本使用以及运行流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    EventLoop loop;<br>    <span class="hljs-comment">//这个EventLoop就是main EventLoop，即负责循环事件监听处理新用户连接事件的事件循环器。第一章概述篇的图2里面的EventLoop1就是我们的main EventLoop。</span><br>    <br>    <span class="hljs-function">InetAddress <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-number">4567</span>)</span></span>;<br>    <span class="hljs-comment">//InetAddress其实是对socket编程中的sockaddr_in进行封装，使其变为更友好简单的接口而已。</span><br>    <br>    <span class="hljs-function">EchoServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;loop, addr, <span class="hljs-string">&quot;EchoServer-01&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//EchoServer类，自己等一下往下翻一下。</span><br>    <br>    server.<span class="hljs-built_in">start</span>(); <br>    <span class="hljs-comment">//启动TcpServer服务器</span><br>    <br>    loop.<span class="hljs-built_in">loop</span>(); <span class="hljs-comment">//执行EventLoop::loop()函数，这个函数在概述篇的EventLoop小节有提及，自己去看一下！！</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EchoServer</span>(EventLoop *loop,<br>            <span class="hljs-type">const</span> InetAddress &amp;addr, <br>            <span class="hljs-type">const</span> std::string &amp;name)<br>        : <span class="hljs-built_in">server_</span>(loop, addr, name)<br>        , <span class="hljs-built_in">loop_</span>(loop)<br>    &#123;<br>        server_.<span class="hljs-built_in">setConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1)<br>        );<br>        <span class="hljs-comment">// 将用户定义的连接事件处理函数注册进TcpServer中，TcpServer发生连接事件时会执行onConnection函数。</span><br>            <br>        server_.<span class="hljs-built_in">setMessageCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onMessage, <span class="hljs-keyword">this</span>,<br>                std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)<br>        );<br>        <span class="hljs-comment">//将用户定义的可读事件处理函数注册进TcpServer中，TcpServer发生可读事件时会执行onMessage函数。</span><br><br>        <br>        server_.<span class="hljs-built_in">setThreadNum</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置sub reactor数量，你这里设置为3，就和概述篇图2中的EventLoop2 EventLoop3 EventLoop4对应，有三个sub EventLoop。</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        server_.<span class="hljs-built_in">start</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//用户定义的连接事件处理函数：当服务端接收到新连接建立请求，则打印Connection UP，如果是关闭连接请求，则打印Connection Down</span><br>        <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">connected</span>())<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn,</span></span><br><span class="hljs-params"><span class="hljs-function">                   Buffer *buf,</span></span><br><span class="hljs-params"><span class="hljs-function">                   Timestamp time)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//用户定义的可读事件处理函数：当一个Tcp连接发生了可读事件就把它这个接收到的消息原封不动的还回去</span><br>        std::string msg = buf-&gt;<span class="hljs-built_in">retrieveAllAsString</span>();<br>        conn-&gt;<span class="hljs-built_in">send</span>(msg);<br>        conn-&gt;<span class="hljs-built_in">shutdown</span>(); <br>    &#125;<br>    EventLoop *loop_;<br>    TcpServer server_;<br>&#125;;<br> <br></code></pre></td></tr></table></figure><p>这个例子是一个简单的echo服务器，当客户端发送数据时，服务器将数据原样返回。</p><p>一个典型的muduo的TcpServer工作流程如下：</p><ol type="1"><li>建立一个事件循环器EventLoop</li><li>建立对应的业务服务器TcpServer</li><li>设置TcpServer的Callback</li><li>启动server</li><li>开启事件循环</li></ol><p>陈硕认为，TCP网络编程的本质是处理三个半事件，即：</p><ol type="1"><li>连接建立事件</li><li>连接断开事件:包括主动断开和被动断开</li><li>消息到达，文件描述符可读事件</li><li>消息发送完毕，文件描述符可写事件，这个算半个事件</li></ol><h3 id="连接建立">连接建立</h3><p><img src="/img/muduo/解析/连接建立代码逻辑.png" /></p><p>如果使用纯Linux api编写一个简单的TCP服务器，建立连接通常需要4步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- 创建socket: <span class="hljs-built_in">socket</span>() <span class="hljs-comment">// 调用socket函数建立监听socket</span><br>- 绑定地址: <span class="hljs-built_in">bind</span>()     <span class="hljs-comment">// 调用bind函数将socket和地址绑定</span><br>- 监听: <span class="hljs-built_in">listen</span>()       <span class="hljs-comment">// 调用listen函数监听socket</span><br>- 接受连接: <span class="hljs-built_in">accept</span>()   <span class="hljs-comment">// 调用accept函数接受连接</span><br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>注意下面所说的步骤指的是上图的<strong>代码方框编号</strong>，而且代码的方框编号不等于执行顺序。</p></div><p>在muduo中，TcpServer对象构建时，也就是图中<strong>编号1</strong>，TcpServer的属性acceptor同时也被建立,也就是图中<strong>编号5</strong>。在Acceptor的构造函数中分别<strong>调用了socket函数和bind函数</strong>完成了<strong>创建socket</strong>和<strong>绑定地址</strong>。（在<code>createNonblockingOrDie</code>函数中调用了socket函数，在<code>bindAddress</code>中调用了<code>bind</code>）</p><p>即，当<code>TcpServer server(&amp;loop, listenAddr);</code>执行结束时，监听socket已经建立好，并已绑定到对应地址和端口了。</p><p>而<code>server.start()</code>主要做了两个工作：</p><ol type="1"><li>在监听socket上启动listen函数（调用<code>Acceptor::listen()</code>函数），也就是步骤3；</li><li>将监听socket的可读事件注册到EventLoop中。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (started_.<span class="hljs-built_in">getAndSet</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>  &#123;<br>    threadPool_-&gt;<span class="hljs-built_in">start</span>(threadInitCallback_);<br>    <br>    <span class="hljs-built_in">assert</span>(!acceptor_-&gt;<span class="hljs-built_in">listenning</span>());<br><br>    <span class="hljs-comment">//让这个EventLoop，也就是mainloop来执行Acceptor的listen函数，开启服务端监听</span><br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>        boost::<span class="hljs-built_in">bind</span>(&amp;Acceptor::listen, <span class="hljs-built_in">get_pointer</span>(acceptor_)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用<code>loop_-&gt;loop()</code>，该函数就会循环的获取事件监听器的监听结果，并且根据监听结果调用注册在事件监听器上的Channel对象的事件处理函数。</p><p>说完主要的流程再看看<code>Accepter</code>构造函数中绑定的<code>Accepter::handleRead()</code>，当程序如果执行到了这个函数里面，说明acceptChannel_发生可读事件，程序处理新客户连接请求。该函数首先调用了Linux的函数<code>accept()</code>接受新客户连接。接着调用了<code>TcpServer::newConnection( )</code>函数，这个函数是在<strong>编号1</strong>中注册给<code>Acceptor</code>并由成员变量<code>newConnectionCallback_</code>保存。</p><p><code>TcpServer::newConnection()</code>的主要功能就是将建立好的连接进行封装（封装<code>TcpConnection</code>对象），并使用选择算法公平的选择一个subEventLoop，并调用<code>TcpConnection::connectEstablished()</code>将<code>TcpConnection::channel_</code>注册到刚刚选择的subEventLoop上。</p><h3 id="消息读取">消息读取</h3><p><img src="/img/muduo/解析/消息读取-前情回顾.png" /></p><p>在MainEventLoop中接受新连接请求之后，将这条Tcp连接封装成<code>TcpConnection</code>对象。<code>TcpConnection</code>对象的内容如上图所示，主要就是封装了连接套接字的fd(上图中的<code>socket_</code>)、连接套接字的<code>channel_</code>等。在<code>TcpConnection</code>的构造函数中会将<code>TcpConnection::handleRead()</code>等四个上图中的蓝色方法注册进这个<code>channel_</code>内。当<code>TcpConnection</code>对象建立完毕之后，MainEventLoop的<code>Acceptor</code>会将这个<code>TcpConnection</code>对象中的<code>channel_</code>注册到某一个SubEventLoop中。</p><p>消息读取逻辑：</p><p><img src="/img/muduo/解析/消息读取逻辑.png" /></p><p>如上图所示，SubEventLoop中的<code>EventLoop::loop()</code>函数内部会循环的执行上图中的<strong>步骤1</strong>和<strong>步骤2</strong>。<strong>步骤1</strong>就是调用Poller::poll()方法获取事件监听结果，这个事件监听结果是一个Channel集合，每一个Channel封装着[一个fd] 及 [fd感兴趣的事件] 和[事件监听器监听到该fd实际发生的事件]。<strong>步骤2</strong>就是调用每一个Channel的<code>Channel::HandlerEvent</code>方法。该方法会根据每一个Channel的感兴趣事件以及实际发生的事件调用提前注册在Channel内的对应的事件处理函数（<code>readCallback_</code>、<code>writeCallback_</code>、<code>closeCallback_</code>、<code>errorCallback_</code>)。</p><p><code>readCallback_</code>保存的函数其实是<code>TcpConnection::handleRead()</code>，消息读取的处理逻辑也就是由这个函数提供的，我们稍微剖析一下这个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleRead</span><span class="hljs-params">(TimeStamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>; <br>    <span class="hljs-type">ssize_t</span> n = inputBuffer_.<span class="hljs-built_in">readFd</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno);<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//从fd读到了数据，并且放在了inputBuffer_上</span><br>    &#123;<br>        <span class="hljs-built_in">messageCallback_</span>(<span class="hljs-built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">handleClose</span>();<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        errno = savedErrno;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleRead&quot;</span>);<br>        <span class="hljs-built_in">handleError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TcpConnection::handleRead()</code>函数首先调用<code>Buffer_.readFd(channel_-&gt;fd(), &amp;saveErrno)</code>，该函数底层调用Linux的函数<code>readv( )</code>，将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中<code>（inputBuffer_）</code>。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在<code>savedErrno</code>中。当<code>readFd()</code>返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用<code>messageCallback_</code>中保存的用户自定义的读取消息后的处理函数。<code>readFd()</code>返回值等于0，说明客户端连接关闭，这时候应该调用<code>TcpConnection::handleClose()</code>来处理连接关闭事件<code>readFd()</code>返回值等于-1，说明发生了错误，调用<code>TcpConnection::handleError( )</code>来处理<code>savedErrno</code>的错误事件。Moduo库只支持LT模式，所以读事件不会出现EAGAIN的错误，所以一旦出现错误，说明肯定是比较不好的非正常错误了。而<code>EAGAIN</code>错误只不过是非阻塞IO调用时的一种常见错误而已。</p><h3 id="消息发送">消息发送</h3><p>当用户调用了<code>TcpConnetion::send(buf)</code>函数时，相当于要求muduo库把数据buf发送给该Tcp连接的客户端。此时该<code>TcpConnection</code>注册在事件监听器上的感兴趣事件中是没有可写事件的。<code>TcpConnection::send(buf)</code>函数内部其实是调用了Linux的函数<code>write( )</code>。</p><ul><li>如果TCP发送缓冲区能一次性容纳buf，那这个<code>write( )</code>函数将buf全部拷贝到发送缓冲区中。</li><li>如果TCP发送缓冲区内不能一次性容纳buf：<ul><li>这时候write()函数buf数据尽可能地拷贝到TCP发送缓冲区中，并且将errno设置为<code>EWOULDBLOCK</code>。</li><li>剩余未拷贝到TCP发送缓冲区中的buf数据会被存放在TcpConnection::outputBuffer_中。并且向事件监听器上<strong>注册该<code>TcpConnection::channel_</code>的可写事件</strong>。</li><li>事件监听器监听到该Tcp连接可写事件，就会调用<code>TcpConnection::handleWrite( )</code>函数把<code>TcpConnection::outputBuffer_</code>中剩余的数据发送出去。</li><li>在<code>TcpConnection::handleWrite( )</code>函数中，通过调用<code>Buffer::writeFd()</code>函数将<code>outputBuffer_</code>的数据写入到Tcp发送缓冲区，如果Tcp发送缓冲区能容纳全部剩余的未发送数据，那最好不过了。如果Tcp发送缓冲区依旧没法容纳剩余的未发送数据，那就尽可能地将数据拷贝到Tcp发送缓冲区中，继续保持可写事件的监听。</li><li>当数据全部拷贝到Tcp发送缓冲区之后，就会调用用户自定义的【写完后的事件处理函数】，并且移除该<code>TcpConnection</code>在事件监听器上的可写事件。（移除可写事件是为了提高效率，不会让<code>epoll_wait()</code>毫无意义的频繁触发可写事件。因为大多数时候是没有数据需要发送的，频繁触发可写事件但又没有数据可写。）</li></ul></li></ul><h3 id="连接断开">连接断开</h3><h4 id="连接被动断开">连接被动断开</h4><p>服务端<code>TcpConnection::handleRead()</code>中感知到客户端把连接断开了。<code>TcpConnection::handleRead( )</code>函数内部调用了Linux的函数<code>readv( )</code>，当<code>readv( )</code>返回0的时候，服务端就知道客户端断开连接了。然后就接着调用<code>TcpConnection::handleClose( )</code>。</p><p><img src="/img/muduo/解析/连接被动断开.png" /></p><p>上图中的标号1、2、3是函数调用顺序，我们可以看到：</p><ol type="1"><li>在执行<code>TcpConnection::handle_Close()</code>的时候，该函数还是在SubEventLoop线程中运行的，接着调用<code>closeCallback_(connPtr)</code>回调函数，该函数保存的其实是<code>TcpServer::removeConnection()</code>函数</li><li><code>TcpServer::removeConnection()</code>函数调用了<code>remvoveConnectionInLoop()</code>函数，该函数的运行是在MainEventLoop线程中执行的，这里涉及到线程切换技术，后面再讲。<code>removeConnectionInLoop()</code>函数：<code>TcpServer</code>对象中有一个<code>connections_</code>成员变量，这是一个<code>unordered_map</code>，负责保存【string--&gt;TcpConnection】的映射，其实就是保存着Tcp连接的名字到<code>TcpConnection</code>对象的映射。因为这个Tcp连接要关闭了，所以也要把这个<code>TcpConnection</code>对象从<code>connections_</code>中删掉。然后再调用<code>TcpConnection::connectDestroyed</code>函数。</li><li>另外为什么<code>removeConnectionInLoop()</code>要在MainEventLoop中运行，因为该函数主要是从<code>TcpServer</code>对象中删除某条数据。而<code>TcpServer</code>对象是属于MainEventLoop的。这也是贯彻了OneLoop Per Thread的理念。</li><li><code>TcpConnection::connectDestroyed()</code>函数的执行是又跳回到了subEventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外SubEventLoop中的Poller类对象还保存着这条Tcp连接的<code>channel_</code>，所以调用<code>channel_.remove()</code>将这个Tcp连接的<code>channel</code>对象从Poller内的数据结构中删除。</li></ol><h4 id="服务器主动关闭导致连接断开">服务器主动关闭导致连接断开</h4><p>当服务器主动关闭时，调用TcpServer::~TcpServer()析构函数。</p><div class="admonition info"><p class="admonition-title">info</p><p>TcpConnection用到智能指针管理,这里涉及到TcpConnection对象的多线程安全问题</p></div><p>这里在提示一下<code>EventLoop::runInLoop()</code>函数的意义，假如你有一个EventLoop对象<code>loop_</code>，当你调用了<code>loop_-&gt;runInLoop(function)</code>函数时，这个function函数的执行会在这个<code>loop_</code>绑定的线程上运行！</p><p>所以我们画了下面这幅图，在创建<code>TcpConnection</code>对象时，<code>Acceptor</code>都要将这个对象分发给一个SubEventLoop来管理。这个<code>TcpConnection</code>对象的一切函数执行都要在其管理的SubEventLoop线程中运行。再一次贯彻OneLoop PerThread的设计模式。比如要想彻底删除一个<code>TcpConnection</code>对象，就必须要调用这个对象的<code>connecDestroyed()</code>方法，这个方法执行完后才能释放这个对象的堆内存。每个<code>TcpConnection</code>对象的<code>connectDestroyed()</code>方法都必须在这个<code>TcpConnection</code>对象所属的SubEventLoop绑定的线程中执行。</p><p><img src="/img/muduo/解析/连接主动断开.png" /></p><p>所有上面的<code>TcpServer::~TcpServer()</code>函数就是干这事儿的，不断循环的让这个<code>TcpConnection</code>对象所属的SubEventLoop线程执行<code>TcpConnection::connectDestroyed()</code>函数，同时在MainEventLoop的<code>TcpServer::~TcpServer()</code>函数中调用<code>item.second.reset()</code>释放保管<code>TcpConnection</code>对象的共享智能指针，以达到释放<code>TcpConnection</code>对象的堆内存空间的目的。</p><p>但是这里面其实有一个问题需要解决，<code>TcpConnection::connectDestroyed()</code>函数的执行以及这个<code>TcpConnection</code>对象的堆内存释放操作不在同一个线程中运行，所以要考虑怎么保证一个<code>TcpConnectino</code>对象的堆内存释放操作是在<code>TcpConnection::connectDestroyed()</code>调用完后。</p><p>这个析构函数巧妙利用了共享智能指针的特点，当没有共享智能指针指向这个<code>TcpConnection</code>对象时（引用计数为0），这个<code>TcpConnection</code>对象就会被析构删除（堆内存释放）。</p><p><strong>我们解读一下TcpServer::~TcpServer()中的代码逻辑</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TcpServer::~<span class="hljs-built_in">TcpServer</span>()<br>&#123;<br>    <span class="hljs-comment">//connections类型为std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item : connections_)<br>    &#123;<br>        <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(item.second)</span></span>;<br>        item.second.<span class="hljs-built_in">reset</span>(); <br>        conn-&gt;<span class="hljs-built_in">getLoop</span>()-&gt;<span class="hljs-built_in">runInLoop</span>(<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>首先<code>TcpServer::connections_</code>是一个<code>unordered_map&lt;string, TcpConnectionPtr&gt;</code>，其中<code>TcpConnectionPtr</code>的含义是指向<code>TcpConnection</code>的<code>shared_ptr</code>。</li><li>在一开始，每一个<code>TcpConnection</code>对象都被一个共享智能指针<code>TcpConnetionPtr</code>持有，当执行了<code>TcpConnectionPtr conn(item.second)</code>时，这个<code>TcpConnetion</code>对象就被<code>conn</code>和这个<code>item.second</code>共同持有，但是这个<code>conn</code>的生存周期很短，只要离开了当前的这一次for循环，<code>conn</code>就会被释放。</li><li>紧接着调用<code>item.second.reset()</code>释放掉<code>TcpServer</code>中保存的该<code>TcpConnectino</code>对象的智能指针。此时在当前情况下，只剩下<code>conn</code>还持有这个<code>TcpConnection</code>对象，因此当前<code>TcpConnection</code>对象还不会被析构。</li><li>接着调用了<code>conn-&gt;getLoop()-&gt;runInLoop(bind(&amp;TcpConnection::connectDestroyed, conn));</code></li><li>这句话的含义是让SubEventLoop线程去执行<code>TcpConnection::connectDestroyed()</code>函数。当你把这个<code>conn</code>的成员函数传进去的时候，<code>conn</code>所指向的资源的引用计数会加1。因为传给runInLoop的不只有函数，还有这个函数所属的对象<code>conn</code>。</li><li>SubEventLoop线程开始运行<code>TcpConnection::connectDestroyed()</code></li><li>MainEventLoop线程当前这一轮for循环跑完，共享智能指针conn离开代码块，因此被析构，但是<code>TcpConnection</code>对象还不会被释放，因为还有一个共享智能指针指向这个<code>TcpConnection</code>对象，而且这个智能指针在<code>TcpConnection::connectDestroyed()</code>中，只不过这个智能指针你看不到，它在这个函数中是一个隐式的this的存在。当这个函数执行完后，智能指针就真的被释放了。到此，就没有任何智能指针指向这个TcpConnection对象了。TcpConnection对象就彻底被析构删除了。</li></ol><h5id="如果tcpconnection中有正在发送的数据怎么保证在触发tcpconnection关闭机制后能先让tcpconnection先把数据发送完再释放tcpconnection对象的资源">如果TcpConnection中有正在发送的数据，怎么保证在触发TcpConnection关闭机制后，能先让TcpConnection先把数据发送完再释放TcpConnection对象的资源？</h5><p><strong>这个问题就要好好参考这部分代码的设计了，这部分代码也是很值得吸收的精华。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/***** TcpConnection.cc *****/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectEstablished</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">setState</span>(kConnected);<br>    channel_-&gt;<span class="hljs-built_in">tie</span>(<span class="hljs-built_in">shared_from_this</span>());<br>    channel_-&gt;<span class="hljs-built_in">enableReading</span>(); <span class="hljs-comment">//向poller注册channel的epollin事件</span><br>    <span class="hljs-comment">//新连接建立，执行回调</span><br>    <span class="hljs-built_in">connectionCallback_</span>(<span class="hljs-built_in">shared_from_this</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先了解一下<code>shared_from_this()</code>是什么意思，首先<code>TcpConnection</code>类继承了一个类继承了这个类之后才能使用shared_from_this()函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpConnection</span> :<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;<br></code></pre></td></tr></table></figure><p>假如我们在<code>TcpConnection</code>对象（我们管这个对象叫TCA）中的成员函数中调用了<code>shared_from_this()</code>，该函数可以返回一个<code>shared_ptr</code>，并且这个<code>shared_ptr</code>指向的对象是<code>TCA</code>。</p><p>接着这个<code>shared_ptr</code>就作为<code>channel_</code>的<code>Channel::tie()</code>函数的函数参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****  Channel.h   ******/</span><br>std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; tie_; <br><span class="hljs-comment">/*****  Channel.cc   ******/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::tie</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;<span class="hljs-type">void</span>&gt;&amp; obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    tie_ = obj;<br>    tied_ = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::HandlerEvent</span><span class="hljs-params">(TimeStamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tied_)&#123;<br>        shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>            <span class="hljs-built_in">HandleEventWithGuard</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        。。。。一般不会执行到这里其实。我实在想不到正常运行的情况下怎么会执行到这里，可能是我比较菜。<br>        <span class="hljs-built_in">HandleEventWithGuard</span>(receiveTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当事件监听器返回监听结果，就要对每一个发生事件的<code>channel</code>对象调用他们的<code>HandlerEvent()</code>函数。在这个<code>HandlerEvent</code>函数中，会先把<code>tie_</code>这个<code>weak_ptr</code>提升为强共享智能指针。这个强共享智能指针会指向当前的<code>TcpConnection</code>对象。就算你外面调用删除析构了其他所有的指向该<code>TcpConnection</code>对象的智能指针。你只要<code>HandleEventWithGuard()</code>函数没执行完，你这个<code>TcpConnetion</code>对象都不会被析构释放堆内存。而<code>HandleEventWithGuard()</code>函数里面就有负责处理消息发送事件的逻辑。当<code>HandleEventWithGuard()</code>函数调用完毕，这个<code>guard</code>智能指针就会被释放。</p><p>转载自<ahref="https://zhuanlan.zhihu.com/p/495016351">万字长文梳理Muduo库核心代码及优秀编程细节思想剖析</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络IO模型</title>
    <link href="/2023/09/13/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/09/13/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络io模型">网络IO模型</h1><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><h2 id="阻塞io">阻塞IO</h2><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="/img/网络IO模型/应用程序读取数据图.png" /></p><p><strong>具体流程如下图</strong>：</p><p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO。</p><p><strong>阶段一</strong>：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>此时用户进程也处于阻塞状态</li></ul><p><strong>阶段二</strong>：</p><ul><li>数据到达并拷贝到内核缓冲区，代表已就绪</li><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p><p><img src="/img/网络IO模型/应用程序读取数据流程图.png" /></p><p><strong>缺点</strong>：</p><p>当有client与服务器连接之后，服务器端就会调用read()函数等待client发送数据，如果client没有发送数据，那么服务器端就会一直阻塞等待，直到client发送数据。</p><p>若服务器端采用单线程处理用户请求，如果有client连接到服务器，在这个client与服务器断开连接之前，服务器端是无法处理其他client的请求的，这样就会导致服务器端的性能下降；如果服务器端是多线程的，即每当有一个client连接时，在新建一个线程去处理这个client的请求，那么当client连接数过多时，服务器端的线程数也会过多，这样会导致服务器端的性能下降，而且线程也是OS非常宝贵的资源，线程之间的切换也是需要消耗CPU资源的。</p><p>上述在多线程情况下的缺点有两种<strong>解决方案</strong>：</p><ul><li>采用线程池，即预先创建一定数量的线程，当有client连接时，从线程池中取出一个线程去处理client的请求，当client断开连接时，该线程回到线程池中，等待下一个client的连接。</li><li>NIO(非阻塞IO):</li></ul><h2 id="非阻塞io">非阻塞IO</h2><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p><p><img src="/img/网络IO模型/非阻塞IO流程图.png" /></p><p>NIO实质上是使用轮询来替代异步阻塞，即讲所有连接存在一个队列中，然后不断轮询这个队列，看看是否有连接有数据可读，如果有，就读取数据，如果没有，就继续轮询。</p><p>缺点：</p><ul><li>如果连接数量过大，轮询的效率会很低，因为大部分连接都是没有数据可读的，但是仍然需要轮询每个连接。</li><li>轮询遍历的过程是出于用户态的，而判断连接是否有数据可读是出于内核态的，这样就需要用户态和内核态之间的切换，这样会导致CPU资源的浪费。</li></ul><p><strong>解决方案</strong>：IO多路复用</p><h2 id="io多路复用">IO多路复用</h2><h3 id="select">select</h3><p>select是Linux最早是由的I/O多路复用技术。</p><p>前面有说到，采用NIO（非阻塞）的方式在高并发的情况下，会导致CPU空转，CPU使用率暴增，而且轮询的效率也会很低，因为大部分连接都是没有数据可读的，但是仍然需要轮询每个连接，而且需要频繁的用户态和内核态之间的切换，这样会导致CPU资源的浪费。</p><p>基于以上问题，select就应运而生了。它的思想是把需要轮询的fd集合复制到内核空间，然后由内核来负责轮询，这样就避免了用户态和内核态之间的切换，也避免了轮询的效率低下的问题。</p><p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据。</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情，比如说频繁的传递fd集合，频繁的去遍历FD等问题。</p><p><img src="/img/网络IO模型/select定义以及流程.png" /></p><p><strong>select的缺点</strong>：</p><ul><li>select中存放文件描述符(fd)的数组大小FD_SETSIZE为1024,进程的文件描述符上限默认是1024，正是因为这个原因，select设计时才把数组大小设计为1024，所以一个进程最多只能处理1024个客户端</li><li>fd数组拷贝到了内核态仍然有开销(只是相对于之前要从用户态切换到内核态少了系统调用切换上下文的开销。（内核层可以优化为异步事件通知）)。</li><li>select并没有通知用户态哪一个socket有数据，仍然需要用户态自己去做一次<spanclass="math inline">\(O(n)\)</span>的遍历。（可优化为只返回给用户就绪的文件描述符，无序用户做多余遍历）</li></ul><h3 id="poll">poll</h3><p>poll是select的改进版，但是性能提升不明显，部分流程如下：</p><ul><li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li></ul><p>与select对比：</p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用<strong>链表</strong>，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><p><img src="/img/网络IO模型/poll定义.png" /></p><p><strong>缺点</strong>：</p><ul><li>pollfd数组拷贝到了内核态仍然有开销，poll在每次调用的时候都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程.</li><li>poll并没有通知用户态哪一个socket有数据，仍然需要用户态自己去做一次<spanclass="math inline">\(O(n)\)</span>的遍历。</li></ul><h3 id="epoll">epoll</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>；<span class="hljs-comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>；</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br><br><span class="hljs-number">1.</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</span><br><span class="hljs-comment">// 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</span><br><br><span class="hljs-number">2.</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>；</span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function">函数是对指定描述符fd执行op操作。</span></span><br><span class="hljs-comment"><span class="hljs-function">- epfd：是epoll_create()的返回值。</span></span><br><span class="hljs-comment"><span class="hljs-function">- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="hljs-comment"><span class="hljs-function">- fd：是需要监听的fd（文件描述符）</span></span><br><span class="hljs-comment"><span class="hljs-function">- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> epoll_event </span>&#123;<br>  <span class="hljs-type">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-type">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><br><span class="hljs-comment">//events可以是以下几个宏的集合：</span><br><span class="hljs-comment">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="hljs-comment">// EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="hljs-comment">// EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="hljs-comment">// EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="hljs-comment">// EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="hljs-comment">// EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="hljs-comment">// EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="hljs-number">3.</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br><span class="hljs-comment">// 等待epfd上的io事件，最多返回maxevents个事件。</span><br><span class="hljs-comment">// 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</span><br></code></pre></td></tr></table></figure><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><ul><li>epoll_create:创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li><li>epoll_ctl: 函数是对指定描述符fd执行op操作。见上面注释。</li><li>epoll_wait:等待epfd上的io事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大。</li></ul><p>epoll和poll的一个很大的区别在于，poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而epoll内核中维护了一个<strong>内核事件表</strong>，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。</p><p>那么如何在内核中维护这个内核事件表呢？内核事件表时常要有插入、查找和删除的操作，而这些操作会对内核的效率产生不小的影响，因此需要一种插入、查找和删除效率都很高的数据结构，<strong>红黑树</strong>就是一个不错的选择。</p><p>epoll的优点：</p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数，即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li>与poll不同，epoll每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li></ul><h4 id="epoll底层实现细节">epoll底层实现细节</h4><p>epoll 在 Linux 内核中申请了一个简易的文件系统，把原先的一个 select 或poll 调用分成了 3 部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events,<span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>; <br></code></pre></td></tr></table></figure><ol type="1"><li>调用 epoll_create 建立一个 epoll 对象(在 epoll文件系统中给这个句柄分配资源)；</li><li>调用 epoll_ctl 向 epoll 对象中添加这 100 万个连接的套接字；</li><li>调用 epoll_wait 收集发生事件的连接。</li></ol><p>这样只需要在进程启动时建立 1 个 epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用 epoll_wait 时并没有向它传递这 100万个连接，内核也不需要去遍历全部的连接。</p><p>当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll结构体，这个结构体中有两个成员与 epoll的使用方式密切相关，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> &#123;<br>　　...<br>　　<span class="hljs-comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，</span><br><span class="hljs-comment">　　也就是这个epoll监控的事件*/</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_root</span> rbr;<br>　　<span class="hljs-comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdllist;<br>　　...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在调用 epoll_create 时，<strong>内核除了帮我们在 epoll文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后epoll_ctl 传来的 socket 外，还会再建立一个 rdllist双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到timeout 时间到后即使链表没数据也返回。</strong>所以，epoll_wait非常高效。</p><p>所有添加到 epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p><p>在 epoll 中对于每一个事件都会建立一个 epitem 结构体，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epitem</span> &#123;<br>　　...<br>　　<span class="hljs-comment">//红黑树节点</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> rbn;<br>　　<span class="hljs-comment">//双向链表节点</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdllink;<br>　　<span class="hljs-comment">//事件句柄等信息</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_filefd</span> ffd;<br>　　<span class="hljs-comment">//指向其所属的eventepoll对象</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> *ep;<br>　　<span class="hljs-comment">//期待的事件类型</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br>　　...<br>&#125;; <span class="hljs-comment">// 这里包含每一个事件对应着的信息。</span><br></code></pre></td></tr></table></figure><p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查 eventpoll对象中的 rdllist 双向链表是否有 epitem 元素而已，如果 rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx 效率非常高。epoll_ctl 在向 epoll对象中添加、修改、删除事件时，从 rbr 红黑树中查找事件也非常快，也就是说epoll 是非常高效的，它可以轻易地处理百万级别的并发连接。</p><p><strong>总结</strong>：执行<strong>epoll_create()</strong>时，创建了红黑树和就绪链表；执行<strong>epoll_ctl()</strong>时，如果增加 socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表（是一个双向链表）中插入数据；执行<strong>epoll_wait()</strong>时,如果 rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。</p><h3 id="小总结">小总结</h3><p><strong>select模式存在的三个问题</strong>：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p><strong>poll模式的问题</strong>：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p><strong>epoll模式中如何解决这些问题的？</strong></p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li></ul><p><img src="/img/网络IO模型/IO多路复用对比.png" /></p><h3 id="epoll中的et和lt">epoll中的ET和LT</h3><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>举个栗子：</p><ul><li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li><li>客户端socket发送了2kb的数据</li><li>服务端调用epoll_wait，得到通知说FD就绪</li><li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li></ul><p>两种不同通知方式的结果：</p><ul><li>如果我们采用LT模式，因为FD中仍有1kb数据，则第 3步依然会返回结果，并且得到通知</li><li>如果我们采用ET模式，因为第 3步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</li></ul><h3 id="基于epoll的服务器端流程">基于epoll的服务器端流程</h3><p><img src="/img/网络IO模型/IO复用模型流程.png" /></p><ol type="1"><li>服务器启动以后，服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据<ul><li>红黑树（初始为空）：rb_root 用来去记录需要被监听的FD</li><li>链表（初始为空）：list_head，用来存放已经就绪的FD</li></ul></li><li>创建好了之后，会去调用epoll_ctl函数，此函数会会将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去(但是此时并没有完成)</li><li>当第二步完成后，就会调用epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），在等待了一段时间后(可以进行配置)，如果等够了超时时间，则返回没有数据，如果有，则进一步判断当前是什么事件，如果是建立连接时间，则调用accept()接受客户端socket，拿到建立连接的socket，然后建立起来连接，如果是其他事件，则把数据进行写出</li></ol><p><img src="/img/网络IO模型/基于epoll的服务器端流程.png" /></p><h2 id="信号驱动io">信号驱动IO</h2><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：</p><ul><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li></ul><p>阶段二：</p><ul><li>收到SIGIO回调信号</li><li>调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><img src="/img/网络IO模型/信号驱动IO流程.png" /></p><p><strong>缺点</strong>：当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h2 id="异步io">异步IO</h2><p>上面的信号驱动方式用户调用recvfrom读取数据之后，需要等待内核将数据从内核空间拷贝到用户空间，而这个过程中用户是阻塞等待的，而异步IO则是用户调用recvfrom读取数据之后，内核会将数据从内核空间拷贝到用户空间，然后内核会给用户发送一个信号，告诉用户数据已经拷贝完成，此时用户就可以去处理数据了，这个过程用户不会阻塞。</p><p><img src="/img/网络IO模型/异步IO流程.png" /></p><h2 id="五个io模型对比">五个I/O模型对比</h2><p><img src="/img/网络IO模型/五个IO模型对比.png" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-高级篇-skiplist</title>
    <link href="/2023/09/11/Redis-%E9%AB%98%E7%BA%A7%E7%AF%87-skiplist/"/>
    <url>/2023/09/11/Redis-%E9%AB%98%E7%BA%A7%E7%AF%87-skiplist/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-skiplist">redis-skiplist</h1><h2 id="为什么引出跳表">为什么引出跳表</h2><ul><li><p>先从一个单链表来说对于一个单链表来讲，<font color = 'blue'>即便链表中存储的数据是有序的</font>，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高O(N)</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/55.单链表.png" /></p></li><li><p>痛点</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/56.单链表.png" /></p><p>解决方法：升维，也即空间换时间</p></li><li><p>优化</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/57.索引优化.png" /></p></li><li><p>案例：画一个包含64个节点的链表，按前面思路，建立五级索引</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/58.索引案例.png" /></p></li></ul><h2 id="是什么">是什么</h2><p>跳表是可以实现二分查找的有序链表</p><p><font color = 'red'>skiplist是一种以空间换取时间的结构</font>。由于链表，无法进行二分查找，因此借鉴数据库索引的思想，提取出链表中关键节点(索引)，先在关键节点上查找，再进入下层链表查找，提取多层关键节点，就形成了跳跃表。</p><p>但是，<font color = 'red'>由于索引也要占据一定空间的，所以，索引添加的越多，空间占用的越多</font></p><p>总结来说，跳表=链表+多级索引</p><h2id="跳表时间和空间复杂度介绍"><font color = 'red'>跳表时间和空间复杂度介绍</font></h2><ol type="1"><li><p>跳表的时间复杂度，O(logN)</p><p><font color = 'blue'>跳表查询的时间复杂度分析，如果链表里有N个结点，会有多少级索引呢？</font></p><p>按照我们前面笔记，两两取首。每两个结点会抽出一个结点作为上一级索引的结点，以此估算:</p><p>第一级索引的结点个数大约就是n/2</p><p>第二级索引的结点个数大约就是n/4.</p><p>第三级索引的结点个数大约就是n/8，依次类推......</p><p>也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2^k)</p><p>假设索引有h级，最高级的索引有2个结点。通过上面的公式，</p><p>我们可以得到n/(2^h)=2，从而求得h=log2n-1(log以2为底，n的对数)</p><p>如果包含原始链表这一层，整个跳表的高度就是log2n(log以2为底，n的对数)</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/59.跳表时间复杂度.png" /></p></li><li><p>跳表空间复杂度</p><p><font color = 'blue'>跳表查询的空间复杂度分析</font></p><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢?</p><p>我们来分析一下跳表的空间复杂度。</p><p><font color = 'red'>第一步：</font>首先原始链表长度为n，</p><p><font color = 'red'>第二步：</font>两两取首，每层索引的结点数:n/2,n/4,n/8 ...,8,4,2每上升一级就减少一半，直到剩下2个结点,以此类推，如果我们把每层索引的结点数写出来，就是一个等比数列。</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/60.跳表.png" /></p><p>这几级索引的结点总和就是n/2+n/4+/8.+8+4+2=n-2。所以，跳表的空间复杂度是O(n)。也就是说，如果将包含n个结点的单链表构造成跳表，我们需要额外再用接近n个结点的存储空间。</p><p>同理，若三三取首，每层索引的节点数： n/3, n/9, n/27, ..., 9, 3,1，以此类推：</p><p>第一级索引的结点个数大约就是n/3，第二级索引的节点个数大约就是n/9，第三级索引的结点个数大约就是n/27，每往上一级，索引节点个数都除以3，。为了方便计算，我们吧最高一级的索引节点个数视为1.我们把每级索引节点个数写出来，就是一个等比数列。</p><p><imgsrc="/img/redis/高级篇/五大经典类型源码以及底层实现/三三取首计算公式.png" /></p><p>通过等比数列求和公式，总的索引大概是n/3+n/9+n/27+...+9+3+1=n/2。所以，三三取首的跳表的空间复杂度也是O(n),但是比上面两两取首的跳表，节省了一半的索引空间。</p><p>一般来说使用两两取首和三三取首就已经足够了，不需要再增加了。因为，如果我们继续增加，比如四四取首，五五取首，那空间复杂度就会越来越大，跳表的优势就没有那么明显了。</p></li></ol><h2 id="优缺点">优缺点</h2><p><font color = 'blue'>优点：</font></p><p>跳表是一个最典型的空间换时间解决方案，而且只有在<font color = 'red'>数据量较大的情况下</font>才能体现出来优势。而且应该是<font color = 'red'>读多写少的情况下</font>才能使用，所以它的适用范围应该还是比较有限的</p><p><font color = 'blue'>缺点：</font></p><p>维护成本相对要高，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)but新增或者删除时需要把所有索引都更新一遍，为了保证原始链表中数据的有序性，我们需要先找到要动作的位置，这个查找操作就会比较耗时最后在新增和删除的过程中的更新，时间复杂度也是o(logn)</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis笔记</title>
    <link href="/2023/09/08/redis%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/08/redis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="redis笔记">redis笔记</h1><p>redis笔记见<ahref="https://tangzhi.blog.csdn.net/article/details/109210263">REDIS6_分布式存储极致性能目录</a></p><p>尚未完成，待续...</p><h2 id="redlcok算法">Redlcok算法</h2><p>Redlock算法是redis作者提出的一种分布式锁算法，它的思想是由多个redis（这些redis是相互独立的，不存在主从复制或集群协调机制）实现。在加锁时，客户端首先要设置一个锁的失效时间，然后对每个redis实例进行加锁，如果从大多数的redis节点都取到锁且时间不超过锁的失效时间，那么就视为成功获取了锁；如果未能成功获取锁，那么就在<strong>所有</strong>redis实例上解锁（即便是没有成功加锁的节点也要再解锁，这是为了防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新加锁）。</p><div class="admonition info"><p class="admonition-title">info</p><p>官方推荐Redlock的节点个数为5个，但是也可以是3个或者7个(一般情况都是奇数)，只要大多数节点都能成功加锁就可以了。</p></div><h2id="最低保证分布式锁有效性以及安全性的要求">最低保证分布式锁有效性以及安全性的要求</h2><ul><li>互斥：任何时刻只有一个客户端能持有锁</li><li>释放死锁：即使锁定资源的服务崩溃或者分区，仍然能释放锁</li><li>容错性：只要多数redis节点（一半以上）在使用，client就可以获取和释放锁</li></ul><h2 id="redis的底层数据结构">redis的底层数据结构</h2><h3 id="redis6相关的底层模型和结构">redis6相关的底层模型和结构</h3><ul><li>String = SDS</li><li>Set = intset + hashtable</li><li>ZSet = skiplist + zipList</li><li>List = quicklist + zipList</li><li>Hash = zipList + hashtable</li></ul><h3 id="redis7相关的底层模型和结构">redis7相关的底层模型和结构</h3><div class="admonition info"><p class="admonition-title">info</p><p>在redis7中zipList被listpack紧凑列表替代，有关zipList的配置参数也被listpack替代，但是为了向下兼容，在配置文件中关于zipList的配置参数仍然存在,只不过不再使用，当你修改listpack的参数时，zipList的参数也会跟着改变;修改ziplist的参数时，listpack的参数也会改变，这两个参数是同步的，而实际上使用的都是listpack。</p></div><ul><li>String = SDS</li><li>Set = intset + hashtable</li><li>ZSet = skiplist + listpack紧凑列表</li><li>List = quicklist + zipList</li><li>Hash = listpack + hashtable</li></ul><h3id="为什么有了ziplist还要有listpack">为什么有了ziplist还要有listpack</h3><p>ziplist在更新数据后可能会出现连锁更新的问题，所以设计出了listpack来替代ziplist，listpack通过每个节点记录自己的长度且放在节点的尾部，来彻底解决掉ziplist存在的连锁更新的问题。</p><h2 id="quicklist">quicklist</h2><h3 id="redis6中的quicklist">redis6中的quicklist</h3><p>redis6中的quicklist是一个双向链表，双向链表的每个节点都是一个ziplist,redis7中的quicklist也是一个双向链表，但是不同的是它的每个节点都是listpack。</p><div class="admonition info"><p class="admonition-title">info</p><p>在早期的quicklist是有两种的，当列表对象的长度比较小或者数量比较少的时候，采用压缩列表ziplist来存储。当列表对象中元素的长度比较大的或者数量比较多的时候，则会转向双向链表linkedlist来存储。</p><p>这两者各有优缺点：</p><ul><li>ziplist的优点是内存紧凑，访问效率高，缺点是插入和删除效率低，并且数据量较大的时候，可能会出现连锁更新的问题。</li><li>linkedlist的优点是插入和删除效率高，缺点是内存不紧凑，并且节点较多的时候，会产生大量的内存碎片。</li></ul></div><h2id="网络模型-redis是单线程的吗为什么使用单线程">网络模型-Redis是单线程的吗？为什么使用单线程？</h2><p>redis到底是单线程还是多线程？</p><ul><li>如果仅仅看Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是看整个Redis，那么答案就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redisv4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入多线程，进一步提高对于多核CPU的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。</p><p>为什么Redis要选择单线程？</p><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-STL-lower_bound和upper_bound高级用法</title>
    <link href="/2023/08/21/Cpp-STL-lower-bound-upper-bound%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <url>/2023/08/21/Cpp-STL-lower-bound-upper-bound%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1id="cpp-stl-lower_bound和upper_bound高级用法">Cpp-STL-lower_bound和upper_bound高级用法</h1><h2 id="基本用法">基本用法</h2><p>我们都知道C++STL中有两个函数lower_bound和upper_bound，它们都是在有序序列中进行二分查找的，lower_bound返回的是第一个<strong>大于等于</strong>给定值的元素的位置，upper_bound返回的是第一个<strong>大于</strong>给定值的元素的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>    cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>) &lt;&lt; endl;    <span class="hljs-comment">// 5</span><br>    cout &lt;&lt; *<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>) &lt;&lt; endl;    <span class="hljs-comment">// 6</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是最简单的用法，其实lower_bound和upper_bound有4个参数，上面使用的是默认的<code>cmp</code>,但是有的时候我们可能需要针对特定问题来定义我们自己的比较方式,或者我们想要使用一个没有默认cmp的类型，那么就需要用到自定义<code>cmp</code>了。</p><h2 id="自定义cmp">自定义cmp</h2><p>假如我们现在想对一个二维数组进行二分查找，那么我们就需要自定义一个<code>cmp</code>函数，这个函数的参数是两个<code>vector&lt;int&gt;</code>，返回值是<code>bool</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>    cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, [](vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 3</span><br>    cout &lt;&lt; *<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, [](vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面自定义了一个比较函数，这个函数的参数是两个<code>vector&lt;int&gt;</code>，返回值是<code>bool</code>，这个函数的作用是比较两个<code>vector&lt;int&gt;</code>的第一个元素的大小，那么该二分查找就是对vector<int>的第一个元素进行二分查找。</p><h2 id="进阶">进阶</h2><p>自定义比较函数的例子里，我们二分搜索的目标是一个<code>vector&lt;int&gt;</code>，也就是说搜索目标和被搜索的序列的类型是一样的，但是如果这里的搜索目标是一个数而不是vector<int>呢？（即搜索目标和待搜索的序列类型不一样）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><br>    cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, [](vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> b) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b;<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 3</span><br><br>    cout &lt;&lt; *<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, [](<span class="hljs-type">int</span> a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<br>        <span class="hljs-keyword">return</span> a &lt; b[<span class="hljs-number">0</span>];<br>    &#125;)[<span class="hljs-number">0</span>] &lt;&lt; endl;    <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们待二分搜索序列中的每个元素类型是<code>vector&lt;int&gt;</code>,而函数中的搜索目标却是一个<code>int</code>。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>这里需要注意的是，若要使用这种方法，上面的lower_bound和upper_bound的比较器是不一样的，以上面的例子来说，lower_bound的比较器是<code><ahref="vector%3Cint%3E%20a,%20int%20b"></a> &#123; return a[0] &lt; b;&#125;</code>，而upper_bound的比较器是<code><ahref="int%20a,%20vector%3Cint%3E%20b"></a> &#123; return a &lt; b[0];&#125;</code>，两个比较器的参数顺序以及函数体内的参数顺序刚好都是反过来的。</p></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂计算</title>
    <link href="/2023/08/15/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/08/15/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂计算">快速幂计算</h1><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在<span class="math inline">\(\Theta(\log n)\)</span> 的时间内计算 <spanclass="math inline">\(a^n\)</span> 的小技巧，而暴力的计算需要 <spanclass="math inline">\(\Theta(n)\)</span> 的时间。</p><p>计算 a 的 n 次方表示将 n 个 a 乘在一起： <spanclass="math inline">\(a^{n} = \underbrace{a \times a \cdots \timesa}_{n\text{a}}\)</span>。然而当 <span class="math inline">\(a,n\)</span>太大的时侯，这种方法就不太适用了。不过我们知道：<spanclass="math inline">\(a^{b+c} = a^b \cdot a^c,\,\,a^{2b} = a^b \cdot a^b= (a^b)^2\)</span>。二进制取幂的想法是，我们将取幂的任务按照指数的二进制表示 来分割成更小的任务。</p><p>快速幂的思想其实很简单，就是公式的转换</p><ol type="1"><li>当指数是偶数时，我们可以让指数除以2，底数乘以底数</li><li>当指数是奇数时，我们可以将指数变为偶数</li></ol><p><strong>例子</strong>：计算 <spanclass="math inline">\(2^{10}\)</span></p><ol type="1"><li>指数是偶数,<span class="math inline">\(2^{10} = 4^5\)</span></li><li>指数是奇数，<span class="math inline">\(4^{5} = 4 \times4^{4}\)</span></li><li>指数是偶数，<span class="math inline">\(4 \cdot 4^{4} = 4 \cdot 16^2= 4 \cdot 256^1\)</span></li><li>指数是奇数，<span class="math inline">\(4 \cdot 256^1 = 4 \cdot 256\cdot 256^0\)</span>，指数为<spanclass="math inline">\(0\)</span>时停止，那么答案就是<spanclass="math inline">\(4 \cdot 256 = 1024\)</span></li></ol><p>代码实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 递归实现</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">binpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-built_in">binpow</span>(a, b / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> res * res * a;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> res * res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 非递归实现</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">binpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a;<br>    a = a * a;<br>    b &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:</p><ul><li><ahref="https://oi-wiki.org/math/binary-exponentiation/">快速幂</a></li><li><ahref="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/solutions/2080665/kuai-su-mi-ji-suan-bei-tlezhi-pei-de-kon-houj/">快速幂计算——被TLE支配的恐惧</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp-string split函数</title>
    <link href="/2023/08/14/split%E5%87%BD%E6%95%B0/"/>
    <url>/2023/08/14/split%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="c-string-split函数">C++ string split函数</h1><p>C++标准库里面没有字符分割函数split,我们可以借助STL自己实现一个split函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s是需要分割的字符串, v是存放分割后的字符串的vector, c是分割符</span><br>string inputString = <span class="hljs-string">&quot;Hello,World,C++,String,Splitting&quot;</span>;<br><br><span class="hljs-comment">// 使用stringstream进行分割</span><br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(inputString)</span></span>;<br>string token;<br><br><span class="hljs-type">char</span> delimiter = <span class="hljs-string">&#x27;,&#x27;</span>;<br><br>vector&lt;string&gt; tokens;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ss, token, delimiter))<br>    tokens.<span class="hljs-built_in">push_back</span>(token);<br><br><span class="hljs-comment">// 输出分割后的结果</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; t : tokens) &#123;<br>    std::cout &lt;&lt; t &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 20-span容器</title>
    <link href="/2023/07/18/Cpp20-span%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/07/18/Cpp20-span%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="c-20-span容器">C++ 20-span容器</h1><p>span 是 C++20 中引入的一个新的标准容器,它类似于C++17的std::string_view，我们知道std::string_view可以创建std::string的一个视图，视图本身并不拥有实例，它只是保持视图映射的状态。在不修改实例的情况下，使用std::string_view会让字符串处理的性能大幅提升。实际上，对于那些连续的序列对象我们都可以创建这样一份视图，对于std::vector这样的对象可以提高某些操作中的性能，另外对原生数组可以提高其访问的安全性。而span 用于表示连续的一段内存区间，类似于一个轻量级的只读数组容器。</p><p>它的定义在头文件 <span> 中，并位于 std 命名空间中。span包含了一个指向连续内存区域的指针以及它所占用的大小，可以通过它来访问这个内存区域中的元素。</p><p>过去如果一个函数想接受无法确定数组长度的数组作为参数，那么一定需要声明两个参数：数组指针和长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_data</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> len)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> buf[<span class="hljs-number">128</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">set_data</span>(buf, <span class="hljs-number">128</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种人工输入增加了编码的风险，数组长度的错误输入会引发程序的未定义行为，甚至是成为可被利用的漏洞。C++20标准库为我们提供了一个很好解决方案std::span，通过它可以定义一个基于连续序列对象的视图，包括原生数组，并且保留连续序列对象的大小。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;span&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_data</span><span class="hljs-params">(std::span&lt;<span class="hljs-type">int</span>&gt; arr)</span> </span>&#123;<br>    std::cout &lt;&lt; arr.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> buf[<span class="hljs-number">128</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">set_data</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>除了原生数组，std::vector和std::array也在std::span的处理之列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; buf1&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>std::array&lt;<span class="hljs-type">int</span>, 3&gt; buf2&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-built_in">set_data</span>(buf1);<br><span class="hljs-built_in">set_data</span>(buf2);<br></code></pre></td></tr></table></figure><p>值得注意的是，std::span还可以通过构造函数设置连续序列对象的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> buf[<span class="hljs-number">128</span>]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">set_data</span>(&#123; buf, <span class="hljs-number">16</span> &#125;);<br></code></pre></td></tr></table></figure><p>从std::string_view到std::span，我们可以看出C++标准库很乐于这种视图设计，因为这种设计和抽象的实现可以提高C++程序的可靠性而又不牺牲性能和可移植性。</p><h2 id="stdspan的用法">std::span的用法</h2><p>span 主要用于以下场景：</p><ul><li>作为函数的参数，用于指示函数需要处理的数据范围；</li><li>作为类的成员变量，用于表示对象所管理的内存区域；</li><li>作为数组的视图，用于访问数组的一部分</li></ul><h3 id="将数组转换为-span">将数组转换为 span</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, <span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>这里将一个整型数组 arr 转换为 span类型，并使用数组首地址和元素个数作为参数。</p><h3 id="使用-span-来遍历一个容器">使用 span 来遍历一个容器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; x : <span class="hljs-built_in">span</span>(vec)) &#123;<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 span(vec) 来构造一个 span 对象，遍历其中的元素并输出。</p><h3 id="使用-span-来获取子序列">使用 span 来获取子序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">auto</span> s1 = s.<span class="hljs-built_in">subspan</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>这里将一个 span 对象 s 分割为从第 1 个元素开始，长度为 3的子序列，并将结果存储到 s1 中。</p><h3 id="将-span-转换为其他容器类型">将 span 转换为其他容器类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(s.begin(), s.end())</span></span>;<br></code></pre></td></tr></table></figure><p>这里使用 s.begin() 和 s.end() 将 span 对象 s转换为迭代器范围，并使用这个迭代器范围构造一个 vector 容器 vec。</p><h2 id="span-的底层原理">span 的底层原理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> Extent = std::dynamic_extent&gt;<br><span class="hljs-keyword">class</span> span &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义迭代器类型</span><br>    <span class="hljs-keyword">using</span> iterator = T*;<br>    <span class="hljs-keyword">using</span> const_iterator = <span class="hljs-type">const</span> T*;<br> <br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> : data_(nullptr), size_(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(T* ptr, std::<span class="hljs-type">size_t</span> count)</span> : data_(ptr), size_(count) &#123;</span>&#125;<br>    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(T(&amp;arr)[N])</span> <span class="hljs-keyword">noexcept</span> : data_(arr), size_(N) &#123;</span>&#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(Container&amp; c)</span> <span class="hljs-keyword">noexcept</span> : data_(c.data()), size_(c.size()) &#123;</span>&#125;<br> <br>    <span class="hljs-comment">// 拷贝构造函数和拷贝赋值运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">span</span><span class="hljs-params">(<span class="hljs-type">const</span> span&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>= <span class="hljs-keyword">default</span>;<br>    span&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> span&amp; other) <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br> <br>    <span class="hljs-comment">// 访问元素和迭代器操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T* <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> size_ == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> idx) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> data_[idx]; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_[<span class="hljs-number">0</span>]; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_[size_<span class="hljs-number">-1</span>]; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_ + size_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_iterator <span class="hljs-title">cbegin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_iterator <span class="hljs-title">cend</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> data_ + size_; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    T* data_;  <span class="hljs-comment">// 元素指针</span><br>    std::<span class="hljs-type">size_t</span> size_;  <span class="hljs-comment">// 元素数量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>具体实现方式是通过指针来引用连续的一段内存，从而实现 span的基本功能。由于 span没有实际的内存所有权，所以它不能拥有或释放内存。它只是提供了对现有内存块的访问。</p><p>标准库中的 span还提供了一些其他的功能，比如对子区间的切片和子区间的迭代器等。实际的实现可能会更加复杂，但其基本的思想是一致的。</p><h2 id="span-与-array-vector-数组指针-的区别">span 与 array ,vector，数组指针 的区别</h2><h3 id="span-与-array-vector的区别">span 与 array ,vector的区别</h3><p>与 array 和 vector 相比，span的主要区别在于它不拥有自己的存储空间，而是引用了另一个数组或容器的内存空间。因此，当我们需要使用一个连续的内存块时，可以使用span 来代替 array 或 vector。</p><p>具体来说，array是一个固定大小的数组容器，其大小在编译时就确定了，不能动态改变。vector是一个动态增长的数组容器，可以动态分配内存，并在需要时扩大容量。而 span是一个非拥有型的容器，可以看作是一个指向连续内存区域的引用，可以指向任何类型的元素。</p><p>在使用方面，array 和 vector可以用来存储数据，并通过下标或迭代器来访问其中的元素；span则更多地用来表示一段内存区域，并提供类似于迭代器的操作来访问其中的元素（就是只读），如 begin、end、rbegin、rend 等。</p><h3 id="span-与-数组指针的区别">span 与 数组指针的区别</h3><ul><li>span是一个封装了数组指针和长度的轻量级容器，它提供了对数组的安全访问。指针只是一个指向内存位置的地址，没有长度信息。因此，使用指针时需要显式地传递长度信息，否则可能会导致缓冲区溢出等问题;</li><li>span支持范围操作，它可以使用STL中的算法和其他支持范围操作的库进行操作。指针只能通过指针运算和下标操作来访问和操作数据;</li><li>span是可传递性的，可以传递到函数中作为参数，而指针不能。这是因为在函数中传递指针时，我们必须显式地传递指针所指向的内存块的大小，否则函数无法确定内存块的大小;</li><li>span是一个类模板，可以指定数据类型和长度类型。指针只能指向特定类型的数据。</li></ul><h2 id="参考">参考</h2><ul><li><ahref="https://www.jb51.net/article/277100.htm">C++20中的span容器及用法小结</a></li><li><ahref="https://0cch.com/2020/10/02/use-span-instead-of-array-pointer-to-pass-parameters/">使用std::span代替数组指针传参</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp17-std::string_view用法</title>
    <link href="/2023/07/17/Cpp17-std-string-view%E7%94%A8%E6%B3%95/"/>
    <url>/2023/07/17/Cpp17-std-string-view%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp17-stdstring_view">Cpp17-std::string_view</h1><h2 id="stdstring_view用法">std::string_view用法</h2><p>C++中有两种风格的字符串，分别是C风格的字符串、std::string字符串。C风格的字符串性能更高，但是叶不方便使用。如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//C风格字符串总是以null结尾</span><br>    <span class="hljs-type">char</span> cstr1[] = &#123; <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">char</span> cstr2[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">strcpy</span>(cstr1, cstr2);<br>    std::cout &lt;&lt; cstr2 &lt;&lt; std::endl;<br> <br>    <span class="hljs-comment">//C++风格的字符串操作更方便，但是性能不如C风格字符串</span><br>    std::string str = <span class="hljs-string">&quot;jam&quot;</span>;<br>    std::string str2 = str;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++17中我们可以使用std::string_view来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。std::string_view比std::string的性能要高很多，因为每个std::string都独自拥有一份字符串的拷贝，而std::string_view只是记录了自己对应的字符串的指针和偏移位置。当我们在只是查看字符串的函数中可以直接使用std::string_view来代替std::string。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;jam&quot;</span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView1</span><span class="hljs-params">(cstr)</span></span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView2</span><span class="hljs-params">(cstr, <span class="hljs-number">2</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;stringView1: &quot;</span> &lt;&lt; stringView1 &lt;&lt; <span class="hljs-string">&quot;, stringView2: &quot;</span> &lt;&lt; stringView2 &lt;&lt; std::endl;<br> <br>    std::string str = <span class="hljs-string">&quot;jam&quot;</span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView3</span><span class="hljs-params">(str.c_str())</span></span>;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">stringView4</span><span class="hljs-params">(str.c_str(), <span class="hljs-number">2</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;stringView3: &quot;</span> &lt;&lt; stringView3 &lt;&lt; <span class="hljs-string">&quot;, stringView4: &quot;</span> &lt;&lt; stringView4 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">stringView1: jam, stringView2: ja<br>stringView3: jam, stringView4: ja<br></code></pre></td></tr></table></figure><p>我们可以把原始的字符串当作一条马路，而我们是在马路边的一个房子里，我们只能通过房间的窗户来观察外面的马路。这个房子就是std::string_view，你只能看到马路上的车和行人，但是你无法去修改他们，可以理解你对这个马路是只读的。正是这样std::string_view比std::string会快上很多。</p><h2 id="stdstring_view容易踩坑的点">std::string_view容易踩坑的点</h2><p>在Effective C++和C++ primer中都提到过，当一个函数有 std::string类型的参数，如果这个参数它不会被修改，那么应该以 const-reference的方式传递。即使用<code>const string &amp;str</code>而不是<code>string str</code>。</p><p>而上面说过，使用std::string会有性能问题，因为当我们一个函数的参数为<code>const string&amp; str</code>时，如果传进来的参数是一个C风格的字符串，那么编译器会自动的创建一个std::string对象，编译器会使用这个C风格的字符串构造一个std::string,这样就会多一份std::string的构造开销。而如果我们使用std::string_view，那么就不会有这个问题，因为std::string_view只是一个指针，不会拷贝字符串。</p><p>但是我们要注意，std::string_view并不是一个完全的替代std::string的类型，因为std::string_view只是一个引用，它并不拥有字符串，所以当我们使用std::string_view时，我们必须保证这个字符串的生命周期要比std::string_view的生命周期要长。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>在使用std::string_view作为函数参数的时候，最好不要使用引用传参，因为std::string_view的本质就是一个引用，使用引用的引用并不会带来更多好处。</p></div><p>参考：</p><ul><li><a href="https://www.cnblogs.com/yangxunwu1992/p/14018837.html">C++17 std::string_view使用介绍</a></li><li><ahref="https://uint128.com/2022/02/16/C-17-%E7%89%B9%E6%80%A7-%E4%BD%BF%E7%94%A8-std-string-view-%E6%97%B6%E5%B0%8F%E5%BF%83%E8%B8%A9%E5%9D%91/">C++17特性:使用 std::string_view 时小心踩坑</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-StringPiece</title>
    <link href="/2023/07/17/muduo%E5%BA%93-StringPiece/"/>
    <url>/2023/07/17/muduo%E5%BA%93-StringPiece/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-stringpiece">muduo库-StringPiece</h1><p>在 StringPiece.h 文件中，声明了两个类类型，一个是 StringArg，另一个是StringPiece，前者用于在传递函数参数时同时兼容 C 风格的字符串(constchar*)和 C++风格的字符串(std::string)。而后者则可用于构建同时兼任这两种风格字符串的实例对象。</p><p>如果函数参数使用 const std::string&amp;作为形参，尽管可以同时兼容两种风格的字符串，但是当传入一个很长的 char*时，会生成一个很大的 string 对象，其开销较大。而且使用 std::string时不可避免会带来很多不必要的拷贝，拷贝多了必然影响性能。因此在很多高性能C++ 框架的实现中，都会使用 StringPiece 作为 std::string 类型的wrapper，该类只持有目标字符串的指针，而避免额外的拷贝，同时也保证了兼容性。当仅仅读取字符串的值，可以使用该类型。</p><p>常见的实现如下：</p><ul><li><ahref="https://github.com/vmg/pcre/blob/master/pcre_stringpiece.h.in">pcre</a></li><li><ahref="https://source.chromium.org/chromium/chromium/src/+/main:base/strings/string_piece.h;l=1?q=string_piece.h&amp;ss=chromium">Chromium</a></li></ul><p>因为 StringPiece 不控制字符串的声明周期，因此调用方要保证在StringPiece 的生命周期内，其指向的字符串是始终有效的。</p><div class="admonition note"><p class="admonition-title">note</p><p>如果想使用 StringPiece 作为 hash 的 key，需要自定义哈希函数，可以参考Chromium 实现。</p></div><p>由于 StringPiece 只持有目标指针，所以为 POD(Plain Old Data)类型，同时拥有 trival 构造函数，因此可以定义 __type_traits 以指示 STL采用更为高效的算法实现。</p><div class="admonition info"><p class="admonition-title">trival构造函数</p><p>见<a href="https://gstarmin.github.io/2023/07/17/Cpp-%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C++非平凡构造函数</a></p></div><p>转载自<ahref="https://www.cnblogs.com/tuilk/p/16791395.html">Muduo库之StringPiece、Time</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-非平凡构造函数</title>
    <link href="/2023/07/17/Cpp-%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/17/Cpp-%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="c-非平凡构造函数">C++ 非平凡构造函数</h1><p><strong>什么是非平凡(non-trival)构造函数？</strong></p><p>简单来说，“平凡”意味着这些特殊的成员函数用很朴素的方式完成它们的工作。而”很朴素的方式“这个说法对不同的函数有不同的意义。</p><ol type="1"><li>对默认构造函数和析构函数来说，“平凡”意味着什么也不做。</li><li>对拷贝构造函数和拷贝赋值函数来说，“平凡”意味着只做简单的内存拷贝。</li></ol><p>下面是具体的规则：</p><p><strong>规则一</strong>：如果你为类显式定义了一个构造函数，那么它就是非平凡的构造函数，即使这个构造函数里什么都没做。因此，平凡的构造函数一定是你没写构造函数，编译器为你生成的那个函数。这个规则对其他几类函数同样适用。</p><p>可以想象，如果一个类同时拥有平凡构造函数，平凡拷贝构造函数，平凡拷贝赋值函数，平凡析构函数，那么这个类应该是非常简单的结构（这些函数咱肯定都没写）。</p><p><strong>规则二</strong>：规则一只是平凡的必要条件，除了不主动实现这些函数之外，“平凡构造函数”不允许在对象创建做任何隐式的初始化，“平凡拷贝构造函数”和“平凡拷贝赋值函数”不允许在对象拷贝的过程中做任何额外的操作。</p><p>规则二不太好理解，举两个例子：如果类有虚函数，那么相比没有虚函数的类，编译器为你生成的构造函数里需要进行额外的初始化（初始化虚指针等），因此这个类的构造函数不能认为是平凡的。同理，如果一个类有虚基类，这个类的构造函数也不是平凡的，因为这个类在构造的时候也需要进行一些隐式的额外操作来支持虚继承机制。</p><p>有虚函数和有虚基类这两种情况下，对象不能由简单的原始内存复制例程（如memcpy）进行复制，而需要进行额外的操作才能正确地重新初始化副本中的隐藏指针。由于这个原因，上述两种类的拷贝构造函数和拷贝赋值操作符也都不是平凡的。</p><p><strong>规则三</strong>：“平凡”是递归定义的，意味着类的每个组件都要是平凡的。这里说的组件，包括基类，成员变量。因为我们知道，类构造时会先调用基类的构造函数，调用成员变量的构造函数，如果它们不是平凡的，那么自己的构造函数怎么会是平凡的？</p><p>对于如下两个类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 没有显式定义 ctor、copy、assignment、dtor 所以均为 trival</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> &#123;<br>  <span class="hljs-type">int</span> a; <span class="hljs-comment">// POD类型</span><br>&#125;;<br> <br><span class="hljs-comment">// 没有显式定义 copy、assignment、dtor 所以均为 trival</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> &#123;<br>  <span class="hljs-built_in">T1</span>() &#123;&#125; <span class="hljs-comment">// 显示定义 ctor，为 non-trival ctor</span><br>  <span class="hljs-type">int</span> a;  <span class="hljs-comment">// POD</span><br>  std::string b; <span class="hljs-comment">// 非POD</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如何判断一个类是否为trival构造函数呢？c++STL提供了判断平凡性的类型萃取器，只要<code>#include&lt;type_traits&gt;</code>就可以使用。</p><div class="admonition note"><p class="admonition-title">note</p><p>在C++ 11中，有了 =delete 和 =default关键字，如果使用这两个关键字，那么该函数就为 trival类型，编译器会为其做出进一步优化。相对于空函数体而言，则更具有优势。</p></div><p>对于如下测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TestA</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">TestA</span>() &#123;&#125;<br> <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TestB</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">TestB</span>() = <span class="hljs-keyword">default</span>;<br> <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a;<br>&#125;;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS_NUM 10000000</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">clock_t</span> start, end;<br>  start = <span class="hljs-built_in">clock</span>();<br>  TestA* a = <span class="hljs-keyword">new</span> TestA[CLASS_NUM];<br>  <span class="hljs-keyword">delete</span>[] a;<br>  end = <span class="hljs-built_in">clock</span>();<br>  cout &lt;&lt; <span class="hljs-string">&quot;non-trival: &quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;<br> <br>  start = <span class="hljs-built_in">clock</span>();<br>  TestB* b = <span class="hljs-keyword">new</span> TestB[CLASS_NUM];<br>  <span class="hljs-keyword">delete</span>[] b;<br>  end = <span class="hljs-built_in">clock</span>();<br>  cout &lt;&lt; <span class="hljs-string">&quot;trival: &quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">non-trival: 0.205<br>trival:     0.025<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://zhuanlan.zhihu.com/p/434531482">什么是非平凡(non-trivial)构造函数</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Buffer实现</title>
    <link href="/2023/07/15/muduo%E5%BA%93-Buffer%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/15/muduo%E5%BA%93-Buffer%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-buffer实现">muduo库-Buffer实现</h1><p>muduo库中的Buffer结构示意图如下图所示：</p><p><img src="/img/muduo/buffer/Buffer.png" /></p><p>它使用 vector来作为底层容器，可以进行动态的扩容操作。其次，前置的预留字节空间可用于填充数据序列化后的消息长度。该类的构造函数及其成员变量如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> : <span class="hljs-keyword">public</span> muduo::copyable &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kCheapPrepend = <span class="hljs-number">8</span>;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kInitialSize = <span class="hljs-number">1024</span>;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Buffer</span><span class="hljs-params">(<span class="hljs-type">size_t</span> initialSize = kInitialSize)</span></span><br><span class="hljs-function">    : buffer_(kCheapPrepend + initialSize),</span><br><span class="hljs-function">      readerIndex_(kCheapPrepend),</span><br><span class="hljs-function">      writerIndex_(kCheapPrepend) &#123;</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">writableBytes</span>() == initialSize);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">prependableBytes</span>() == kCheapPrepend);<br>  &#125;<br> <br><span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">char</span>&gt; buffer_;<br>  <span class="hljs-type">size_t</span> readerIndex_;<br>  <span class="hljs-type">size_t</span> writerIndex_;<br> <br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> kCRLF[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，Buffer 类对于预留空间默认为 8 字节，而其默认大小为 8 + 1024，即1032 字节。</p><p>如下三个函数分别返回预留空间大小、可读空间大小和可写空间大小，而peek() 则返回读指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">prependableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">readableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">writableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>如下函数用于在可读区域中寻找回车换行符，search()方法的第一个参数和第二个参数是查找的范围，第三个和第四个参数是要查找的子集的头部和尾部。对于kCRLF 而言， ASCII 码为 13，的 ASCII 码为10，所以这实际上是两个字符，这也是如下调用 search() 方法时最后一个参数是kCRLF + 2 的原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> Buffer::kCRLF[] = <span class="hljs-string">&quot;\r\n&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findCRLF</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* crlf = std::<span class="hljs-built_in">search</span>(<span class="hljs-built_in">peek</span>(), <span class="hljs-built_in">beginWrite</span>(), kCRLF, kCRLF+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> crlf == <span class="hljs-built_in">beginWrite</span>() ? <span class="hljs-literal">NULL</span> : crlf;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findCRLF</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* start)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">peek</span>() &lt;= start);<br>  <span class="hljs-built_in">assert</span>(start &lt;= <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* crlf = std::<span class="hljs-built_in">search</span>(start, <span class="hljs-built_in">beginWrite</span>(), kCRLF, kCRLF+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> crlf == <span class="hljs-built_in">beginWrite</span>() ? <span class="hljs-literal">NULL</span> : crlf;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，可读区域中查找结尾符的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findEOL</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* eol = <span class="hljs-built_in">memchr</span>(<span class="hljs-built_in">peek</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">readableBytes</span>());<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(eol);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">findEOL</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* start)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">peek</span>() &lt;= start);<br>  <span class="hljs-built_in">assert</span>(start &lt;= <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* eol = <span class="hljs-built_in">memchr</span>(start, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">beginWrite</span>() - start);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(eol);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下方法仅仅只是移动指针，而不操作数据。注意，在断言之后，len的大小只能小于等于可读空间的大小。因此，如果 len的长度小于可读空间的大小，说明数据还未读取完，移动读指针即可。而在 else中，则表示 len 的长度等于可读空间的大小，说明数据刚好读取完成，那么调用retrieveAll() 方法将读指针和写指针重置为初始化状态即可。而retrieveUntil() 则是移动可读指针直到指定位置为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(len &lt;= <span class="hljs-built_in">readableBytes</span>());<br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-built_in">readableBytes</span>())&#123;<br>    readerIndex_ += len;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">retrieveAll</span>();<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieveAll</span><span class="hljs-params">()</span> </span>&#123;<br>  readerIndex_ = kCheapPrepend;<br>  writerIndex_ = kCheapPrepend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieveUntil</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* end)</span></span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">peek</span>() &lt;= end);<br>  <span class="hljs-built_in">assert</span>(end &lt;= <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-built_in">retrieve</span>(end - <span class="hljs-built_in">peek</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>其过程如下图中最后两步操作所示：</p><p><img src="/img/muduo/buffer/Buffer-操作过程.png" /></p><p>如下函数则是从可读区域中读取数据，读取的数据大小与 int64的大小相同，读完之后，移动读指针并返回数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">readInt64</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int64_t</span> result = <span class="hljs-built_in">peekInt64</span>();<br>  <span class="hljs-built_in">retrieveInt64</span>();<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">peekInt64</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">readableBytes</span>() &gt;= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int64_t</span>));<br>  <span class="hljs-type">int64_t</span> be64 = <span class="hljs-number">0</span>;<br>  ::<span class="hljs-built_in">memcpy</span>(&amp;be64, <span class="hljs-built_in">peek</span>(), <span class="hljs-keyword">sizeof</span> be64);<br>  <span class="hljs-keyword">return</span> sockets::<span class="hljs-built_in">networkToHost64</span>(be64);<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">peek()函数</p><p>peek() 函数即 cin.peek() ,它与 cin.get() 类似,但有一个重要的区别，当 get函数被调用时，它将返回输入流中可用的下一个字符，并从流中移除该字符；但是，peek函数返回下一个可用字符的副本，而不从流中移除它。</p></div><p>如下函数是向可写区域追加数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece&amp; str)</span> </span>&#123;<br>  <span class="hljs-built_in">append</span>(str.<span class="hljs-built_in">data</span>(), str.<span class="hljs-built_in">size</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-comment">/*restrict*/</span> data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">ensureWritableBytes</span>(len);<br>  std::<span class="hljs-built_in">copy</span>(data, data+len, <span class="hljs-built_in">beginWrite</span>());<br>  <span class="hljs-built_in">hasWritten</span>(len);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-comment">/*restrict*/</span> data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">append</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data), len);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要追加的数据长度大于可写区域的长度，那么就需要扩容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ensureWritableBytes</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() &lt; len) &#123;<br>    <span class="hljs-built_in">makeSpace</span>(len);<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">writableBytes</span>() &gt;= len);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的扩容函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSpace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() + <span class="hljs-built_in">prependableBytes</span>() &lt; len + kCheapPrepend) <br>  &#123;<br>    buffer_.<span class="hljs-built_in">resize</span>(writerIndex_+len);<br>  &#125; <br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-built_in">assert</span>(kCheapPrepend &lt; readerIndex_);<br>    <span class="hljs-type">size_t</span> readable = <span class="hljs-built_in">readableBytes</span>();<br>    std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>()+readerIndex_,<br>              <span class="hljs-built_in">begin</span>()+writerIndex_,<br>              <span class="hljs-built_in">begin</span>()+kCheapPrepend);<br>    readerIndex_ = kCheapPrepend;<br>    writerIndex_ = readerIndex_ + readable;<br>    <span class="hljs-built_in">assert</span>(readable == <span class="hljs-built_in">readableBytes</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>可写区域的长度</strong>和<strong>预留区域的长度</strong>之和小于<strong>所需长度</strong>和<strong>初始化预留区域的长度</strong>(8)之和，就需要对缓冲区进行扩容，其过程如下图所示，可见，扩容后可写区域的长度即为所需长度len。</p><p><img src="/img/muduo/buffer/buffer扩容.png" /></p><p>否则，则表示预留空间和可写区域还很充足，为此需要将预留区域中多出来的部分移动到可写区域中去。其过程如下图所示，先将可写区域的内容向前移动，使得预留区域恢复为初始化大小，即8。然后移动读指针和写指针。</p><p><img src="/img/muduo/buffer/buffer扩容-1.png" /></p><p>对于如下函数，其目的是在可读区域前添加一段数据。而预留区域初始化的 8个字节便是为该函数所准备的，以便在可读区域前添加一些序列化后的数据长度信息，而无需进行数据的迁移，以少量的空间代价换取了时间。其过程如下：先将读指针前移len 个长度，然后将 data 中的数据拷贝进来即可。</p><!-- ![](/img/muduo/buffer/buffer前添加数据.png) --><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepend</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-comment">/*restrict*/</span> data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(len &lt;= <span class="hljs-built_in">prependableBytes</span>());<br>  readerIndex_ -= len;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* d = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data);<br>  std::<span class="hljs-built_in">copy</span>(d, d+len, <span class="hljs-built_in">begin</span>()+readerIndex_);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下方法是 Buffer 类最重要的方法，其目的是为了从 fd 上读取数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::readFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span>* savedErrno)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> extrabuf[<span class="hljs-number">65536</span>];<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> writable = <span class="hljs-built_in">writableBytes</span>();<br>  vec[<span class="hljs-number">0</span>].iov_base = <span class="hljs-built_in">begin</span>()+writerIndex_;<br>  vec[<span class="hljs-number">0</span>].iov_len = writable;<br>  vec[<span class="hljs-number">1</span>].iov_base = extrabuf;<br>  vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-keyword">sizeof</span> extrabuf;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> iovcnt = (writable &lt; <span class="hljs-keyword">sizeof</span> extrabuf) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">ssize_t</span> n = sockets::<span class="hljs-built_in">readv</span>(fd, vec, iovcnt);<br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    *savedErrno = errno;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(n) &lt;= writable) &#123;<br>    writerIndex_ += n;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    writerIndex_ = buffer_.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">append</span>(extrabuf, n - writable);<br>  &#125;<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 IP 数据包中有一个 16 位的长度字段，则说明 IP 数据包的最大长度为65536 字节，即 64K。同时由于 IP 数据包的分片机制，即单次发送的 IP报文长度不能超过 MTU(最大传输单元)，通常为 1500字节。为此，该函数在栈上申请了 64K的额外空间用于尽力接受一个完整的数据包，以防可写区域不足以容纳所接收到的网络数据。</p><p>而结构体 iovec 则用于定义一个向量元素，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> &#123;<br>    <span class="hljs-type">void</span>   *iov_base; <span class="hljs-comment">/* Starting address (内存起始地址）*/</span><br>    <span class="hljs-type">size_t</span> iov_len;   <span class="hljs-comment">/* Number of bytes to transfer（这块内存长度） */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>iov_base所指向的缓冲区用于存放网络接受的数据，或者是网络将要发送的数据。而iov_len 字段用于存放接受数据的最大长度，或者是实际写入的数据长度。</p><p>在 readFd 方法中，定义了两个 iovec结构体，一部分用于将读到的数据放在可写区域，另一部分用于将读到的数据放在额外缓冲区域。然后，使用如下方法进行分散读，即将数据从文件描述符读到分散的内存块中。其中的第三个参数表示iov 的数组长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span></span>;<br></code></pre></td></tr></table></figure><p>从 readFd 方法中可以看出，如果可写区域的长度小于65536，则两个内存块都使用，否则只使用可写区域即可。</p><p>最后根据 readv方法的返回值来确定是否需要额外缓冲区，如果返回的字节数要大于可写区域的长度，说明两个内存块都使用了，且可写区域中已经填充满了，其余的数据全部在额外缓冲区中，此时，只需移动写指针到缓冲区的数据末端，然后将额外缓冲区中的数据追加进来即可。</p><p>转载自<ahref="https://www.cnblogs.com/tuilk/p/16806370.html">Muduo库之Buffer</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++-手动实现堆</title>
    <link href="/2023/07/12/Cpp-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A0%86/"/>
    <url>/2023/07/12/Cpp-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="c-手动实现堆">C++ 手动实现堆</h1><p>在C++ STL中其实是有堆的实现的，C++中的<code>priority_queue</code>就是由堆实现的，但是在面试中堆排序还是非常常问的，所以还是非常有必要手动实现一下堆。</p><h2 id="堆的定义">堆的定义</h2><p>堆是一种特殊的完全二叉树，其满足以下两个条件：</p><ol type="1"><li>堆中任意节点的值总是不大于（或不小于）其子节点的值。</li><li>堆总是一棵完全二叉树。</li></ol><p>其中节点值不小于其子节点的堆称为<strong>大跟堆</strong>，节点值不大于其子节点的堆称为<strong>小跟堆</strong>。</p><h2 id="堆的实现">堆的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> n)</span>     <span class="hljs-comment">// 调整为大根堆</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = idx * <span class="hljs-number">2</span>, right = idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, largest = idx;<br>    <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; nums[left] &gt; nums[largest])<br>    &#123;<br>        largest = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(right &lt; n &amp;&amp; nums[right] &gt; nums[largest])<br>        largest = right;<br><br>    <span class="hljs-keyword">if</span>(largest != idx)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums[idx], nums[largest]);<br>        <span class="hljs-built_in">maxHeapify</span>(nums, largest, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> n)</span>     <span class="hljs-comment">// 建堆</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx = n / <span class="hljs-number">2</span>; idx &gt; <span class="hljs-number">-1</span>; --idx)<br>        <span class="hljs-built_in">maxHeapify</span>(nums, idx, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里初始给了一个数组，然后调用<code>buildMaxHeap</code>函数建堆，建堆的过程就是从最后一个非叶子节点开始，调用<code>maxHeapify</code>函数，将其调整为大根堆，然后再依次向前调整，直到根节点。</p><h2 id="堆排序">堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将nums从小到大排序, 直接在原数组上排序，没有返回值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMaxHeap</span>(nums, n);<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[n - <span class="hljs-number">1</span>]);     <span class="hljs-comment">// 弹出堆顶元素，并将堆大小-1，-1操作在下行</span><br>        <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, --n);       <span class="hljs-comment">// 调整为大根堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11-enable_shared_from_this类</title>
    <link href="/2023/07/11/Cpp11-enable-shared-from-this%E7%B1%BB/"/>
    <url>/2023/07/11/Cpp11-enable-shared-from-this%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1id="c11-enable_shared_from_this类">C++11-enable_shared_from_this类</h1><p>c++11 中的 shared_from_this() 来源于 boost 中的enable_shared_form_this 类和 shared_from_this()函数，功能为返回一个当前类的 std::share_ptr，使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>: <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Test</span>();<br>    ~<span class="hljs-built_in">Test</span>();<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">getSharedFromThis</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="enable_shared_from_this-的由来">enable_shared_from_this的由来</h2><p>在智能指针的使用过程中，我们会遇到这样一种情况，我们在类的成员函数调用某一个函数，而该函数需要传递一个当前对象的智能指针作为参数时，我们需要能够在成员函数中获得自己的智能指针。</p><p>在多线程程序中也存在这样的应用，如果我们的线程函数是一个成员函数，可以把该对象的智能指针作为参数传递到线程函数中，这种做法是人为的增加了对象的引用计数，延长对象的生命周期，防止线程函数在执行的时候对象被释放而引发内存错误。总之就是我们在实际的编码中会存在各种各样的应用。</p><p>我们可能有两个疑惑：</p><ol type="1"><li><p>把当前类对象作为参数传给其他函数时，为什么要传递 share_ptr呢？直接传递 this 指针不可以吗？</p><p>一个裸指针传递给调用者，谁也不知道调用者会干什么？假如调用者 delete了该对象，而 share_tr此时还指向该对象。</p></li><li><p>这样传递 share_ptr 可以吗？<code>share_ptr&lt;this&gt;</code>?</p><p>这样会造成2个非共享的share_ptr指向一个对象，最后造成2次析构该对象。</p></li></ol><p>我们不能人为地通过 this 来构造一个当前对象的 shared_ptr指标，如下错误的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(std::shared_ptr&lt;TestClass&gt; tt)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestClass</span>() &#123;&#125;    <br>    ~<span class="hljs-built_in">TestClass</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;TestClass&gt; tt = std::<span class="hljs-built_in">shared_ptr</span>&lt;TestClass&gt;(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-built_in">Test</span>(tt);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;TestClass&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t-&gt;<span class="hljs-built_in">TestPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>在 TestPtr() 函数中通过 this 构造出shared_ptr，就相当于把自己的的控制权交给了这个临时变量 tt，一旦 tt超出作用域就会释放，导致该对象也被释放。这是一个致命的错误。</p><p>为了解决这个问题，在 C++11 中提供了 enable_shared_from_this这个模板类（boost 库很早就提供了这个模板类），自己的对象继承自enable_shared_from_this 。enable_shared_from_this提供了一个shared_from_this()的方法返回自己的智能指针。与上面错误的例子区别在于，shared_from_this会增加该对象的引用计数，而不是重新建立一个临时的 shared_ptr来管理。看下面具体的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(std::shared_ptr&lt;TestClass&gt; tt)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TestClass&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestClass</span>() &#123;&#125;    <br>    ~<span class="hljs-built_in">TestClass</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;TestClass&gt; tt = <span class="hljs-built_in">shared_from_this</span>();<br>        <span class="hljs-built_in">Test</span>(tt);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;TestClass&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t-&gt;<span class="hljs-built_in">TestPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="shared_from_this-函数">shared_from_this() 函数</h2><p>shared_from_this的出现确实能够解决我们编码中所遇到的问题，但是它的坑也是比较多的。我们先来看看enable_shared_from_this 这个对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">enable_shared_from_this</span><br>&#123;<span class="hljs-comment">// provide member functions that create shared_ptr to this</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Ty _EStype;<br><br>    <span class="hljs-function">shared_ptr&lt;_Ty&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return shared_ptr</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr));<br>    &#125;<br><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">const</span> _Ty&gt; <span class="hljs-title">shared_from_this</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// return shared_ptr</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">const</span> _Ty&gt;(_Wptr));<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">enable_shared_from_this</span>()<br>    &#123;<span class="hljs-comment">// construct (do nothing)</span><br>    &#125;<br><br>    <span class="hljs-built_in">enable_shared_from_this</span>(<span class="hljs-type">const</span> enable_shared_from_this&amp;)<br>    &#123;<span class="hljs-comment">// construct (do nothing)</span><br>    &#125;<br><br>    enable_shared_from_this&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> enable_shared_from_this&amp;)<br>    &#123;<span class="hljs-comment">// assign (do nothing)</span><br>        <span class="hljs-built_in">return</span> (*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">enable_shared_from_this</span>()<br>    &#123;<span class="hljs-comment">// destroy (do nothing)</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty2</span>&gt;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> _Do_enable(<br>            _Ty1 *,<br>            enable_shared_from_this&lt;_Ty2&gt;*,<br>            _Ref_count_base *);<br><br>    <span class="hljs-keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty2</span>&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _Do_enable(<br>    _Ty1 *_Ptr,<br>            enable_shared_from_this&lt;_Ty2&gt; *_Es,<br>            _Ref_count_base *_Refptr)<br>&#123; <span class="hljs-comment">// reset internal weak pointer</span><br>    _Es-&gt;_Wptr._Resetw(_Ptr, _Refptr);<br>&#125; <br></code></pre></td></tr></table></figure><p>这是标准库的源码，我们看到在 enable_shared_from_this 内部储存了一个weak_ptr。shared_from_this 函数就是通过这个 weak_ptr得到了。但是另外一点，我们可以看到在enable_shared_from_this的构造函数中并没有对这个 weak_ptr 进行初始化。</p><p>这就是为什么我们不能在构造函数调用 shared_from_this()的原因，因为其内部的 weak_ptr 并没有初始化。所以会产生错误。</p><p>在实际的程序设计中如果我们需要在对象初始化中用到自己的shared_ptr。可以单独将初始化操作放到一个独立的 init 函数中，这时候再调用shared_from_this() 是没有问题的（但还是有点问题，下面会讲到）</p><p>熟悉 weak_ptr 的同学可能知道，我们在使用 weak_ptr 前，需要用一个shared_ptr 来对其进行初始化。对 weak_ptr初始化是要能获取到当前对象的引用计数对象，而引用计数对象可以通过shared_ptr 对象获取到。当然我们同样可以用一个已经初始化过的 weak_ptr来初始化另一个 weak_ptr，因为已初始化的weak_ptr也可能获取到对象的引用计数。</p><p>enable_shared_from_this 内部的 weak_ptr是通过<code>_Do_enable</code>函数初始化的。而<code>_Do_enable</code>函数实在shared_ptr的构造函数中调用的，这是至关重要的一个环节。正因为如此我们在调用shared_from_this 之前请确保程序已经显式地建立了 shared_ptr对象，要不然enable_shared_from_this 内部的 weak_ptr 始终是无效。</p><p>下面具体举例说明的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TestClass&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestClass</span>()<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">TestClass</span>()<br>    &#123;<br>        <span class="hljs-comment">//TestClassPtr tt = shared_from_this();</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;TestClass&gt; tt = <span class="hljs-built_in">shared_from_this</span>();<br>        <span class="hljs-built_in">Test</span>(tt);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TestClass t;<br>    t.<span class="hljs-built_in">TestPtr</span>(); <span class="hljs-comment">//shared_from_this()错误</span><br><br>    <span class="hljs-function">TestClass* <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t1-&gt;<span class="hljs-built_in">TestPtr</span>();<span class="hljs-comment">//shared_from_this()错误</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;TestClass&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TestClass())</span></span>;<br>    t2-&gt;<span class="hljs-built_in">TestPtr</span>(); <span class="hljs-comment">//正确，已提前建立了shared_ptr</span><br>&#125; <br></code></pre></td></tr></table></figure><p>同理在析构函数中也不能调用 shared_from_this()。</p><p>在析构时，引用计数已经变为零，weak_ptr已经相当于指向的是一个无效的对象，不能通过此无效的 weak_ptr 构造shared_ptr。</p><p>转载自<ahref="https://www.cnblogs.com/WindSun/p/14697066.html">C++11的enable_shared_from_this</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-TCP连接</title>
    <link href="/2023/07/10/muduo%E5%BA%93-TCP%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/07/10/muduo%E5%BA%93-TCP%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-tcp连接">muduo库-TCP连接</h1><p><img src="/img/muduo/TCP连接/TCP建立连接流程.png" /></p><p>TCP连接中，两端是对等的，TCP协议也没有区分客户端（client）与服务器端（server），但互联网中通信中，往往有一端提供资源给另一端访问，我们把拥有资源的一端称为服务器端，请求资源的一端称为客户端。</p><p>对于server，会启用一个监听循环，不断接受client连接请求（三次握手），进行数据通信，通信完成以后断开连接（四次挥手）;对于client，在server启用监听循环时，向server发出连接请求，接收server数据，如有必要向server发送数据，通信完成后，断开连接。连接是指物理上一端（client）到另一端（server）的通信链路，通过server端&lt;ip,port&gt;与客户端&lt;ip, port&gt;，来唯一标识一个TCP连接。</p><div class="admonition note"><p class="admonition-title">TCP连接有长连接、短连接之分</p><p>短连接：client和server建立连接后，一般只传递一次读写操作，然后由client发起close，发送FIN分节，关闭连接。短连接只完成一次read/write操作，就会自动关闭。</p><p>长连接：client和server建立连接后，并不会自动关闭，后续的read/write操作会继续用这个连接。长连接没有确切时间限制，可能会长时间存在。</p></div><h2 id="tcpserver类">TcpServer类</h2><p><strong>muduo使用TcpConnection类来管理TCP连接，使用接受器Acceptor来接受连接，连接器Connector发起连接</strong>。TcpServer管理accept获得TcpConnection，生命周期由用户控制。</p><p>下图是TcpServer新建连接的相关函数调用顺序。当Channel::handleEvent()的触发条件是listeningsocket可读时，表明有新连接请求达到。TcpServer为新连接创建对应的TcpConnection对象。</p><p><img src="/img/muduo/TCP连接/TCP建立连接调用顺序.png" /></p><h2 id="acceptor类">Acceptor类</h2><p>Acceptor是TcpServer的一个内部类，主要职责是用来获得新连接的fd。Accetpor封装了服务器监听套接字fd以及相关处理方法。Acceptor类内部其实没有贡献什么核心的处理函数，主要是对其他类的方法调用进行封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* TCP连接接受器</span><br><span class="hljs-comment">* 基础调用为accept(2)/accept4(2)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> : <span class="hljs-keyword">private</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;)&gt; NewConnectionCallback;<br><br>    <span class="hljs-built_in">Acceptor</span>(EventLoop* loop, <span class="hljs-type">const</span> InetAddress&amp; listenAddr, <span class="hljs-type">bool</span> reuseport);<br>    ~<span class="hljs-built_in">Acceptor</span>();<br><br>    <span class="hljs-comment">/* 设置新连接回调 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNewConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> NewConnectionCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; newConnectionCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">/* 监听本地端口 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/* 判断当前是否正在监听端口 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listening</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> listening_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 处理读事件</span><br><br>    EventLoop *loop_;        <span class="hljs-comment">// 所属EventLoop</span><br>    Socket acceptSocket_;    <span class="hljs-comment">// 专门用于接受连接的套接字(sock fd)</span><br>    Channel acceptChannel_;  <span class="hljs-comment">// 专门接受连接通道, 监听conn fd</span><br>    NewConnectionCallback newConnectionCallback_; <span class="hljs-comment">// 新建连接回调</span><br>    <span class="hljs-type">bool</span> listening_;         <span class="hljs-comment">// 监听状态</span><br>    <span class="hljs-type">int</span> idleFd_;             <span class="hljs-comment">// 空闲fd, 用于fd资源不够用时, 可以空一个出来作为新建连接conn fd</span><br>&#125;;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">如果fd资源不够用了，导致accept(2)/accept4(2)创建连接失败，比如达到系统上限，怎么办？</p><p>Accetor用了这样一种技术：先申请一个空闲的fd（idleFd_），等到发生由于fd资源不够用时，就把这个备用fd暂时用于accept接收连接，然后再马上关闭，以防止不断产生可读事件（连接请求），从而回调相同的失败代码。及早建立连接后并关闭连接，让程序不会频繁响应同一个连接请求。</p></div><h3 id="acceptor封装的重要成员变量">Acceptor封装的重要成员变量</h3><ul><li>acceptSocket_：服务器监听套接字的文件描述符</li><li>acceptChannel_：是一个Channel类，把acceptSocket_及其感兴趣事件和事件对应的处理函数都封装进去。</li><li>EventLoop*loop：监听套接字的fd由哪个EventLoop负责循环监听以及处理相应事件，其实这个EventLoop就是mainEventLoop。</li><li>newConnectionCallback_:TcpServer构造函数中将TcpServer::newConnection()函数注册给了这个成员变量。这个TcpServer::newConnection函数的功能是公平的选择一个subEventLoop，并把已经接受的连接分发给这个subEventLoop。</li></ul><h3 id="acceptor封装的重要成员方法">Acceptor封装的重要成员方法</h3><ul><li>listen( )：该函数底层调用了linux的函数listen()，开启对acceptSocket_的监听同时将acceptChannel及其感兴趣事件（可读事件）注册到mainEventLoop的事件监听器上。换言之就是让mainEventLoop事件监听器去监听acceptSocket_</li><li>handleRead()：这是一个私有成员方法，这个方法是要注册到acceptChannel_上的，同时handleRead()方法内部还调用了成员变量newConnectionCallback_保存的函数。当mainEventLoop监听到acceptChannel_上发生了可读事件时（新用户连接事件），就是调用这个handleRead()方法。</li></ul><p>简单来说，handleRead()最终实现的功能就是接受新连接，并且以负载均衡的选择方式选择一个subEventLoop，并把这个新连接分发到这个subEventLoop上。</p><h3 id="acceptor构造与析构">Acceptor构造与析构</h3><p>Acceptor构造时，创建sockfd（套接字），待后续交给TcpServer来start监听套接字。空闲fd指向文件"/dev/null"，用来解决服务器fd资源耗尽问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.cc</span><br>Acceptor::<span class="hljs-built_in">Acceptor</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">bool</span> reuseport)<br>: <span class="hljs-built_in">loop_</span>(loop),<br>  <span class="hljs-built_in">acceptSocket_</span>(sockets::<span class="hljs-built_in">createNonblockingOrDie</span>(listenAddr.<span class="hljs-built_in">family</span>())),<br>  <span class="hljs-built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="hljs-built_in">fd</span>()),<br>  <span class="hljs-built_in">listening_</span>(<span class="hljs-literal">false</span>),<br>  <span class="hljs-built_in">idleFd_</span>(::<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC)) <span class="hljs-comment">// 申请空闲fd</span><br>&#123;<br>    <span class="hljs-built_in">assert</span>(idleFd_ &gt;= <span class="hljs-number">0</span>);<br>    acceptSocket_.<span class="hljs-built_in">setReuseAddr</span>(<span class="hljs-literal">true</span>);<br>    acceptSocket_.<span class="hljs-built_in">setReusePort</span>(reuseport);<br>    acceptSocket_.<span class="hljs-built_in">bindAddress</span>(listenAddr);<br>    acceptChannel_.<span class="hljs-built_in">setReadCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::handleRead, <span class="hljs-keyword">this</span>));<br>&#125;<br><br>Acceptor::~<span class="hljs-built_in">Acceptor</span>()<br>&#123;<br>    acceptChannel_.<span class="hljs-built_in">disableAll</span>(); <span class="hljs-comment">// disable all event of the channel</span><br>    acceptChannel_.<span class="hljs-built_in">remove</span>(); <span class="hljs-comment">// remove the channel from poller</span><br>    ::<span class="hljs-built_in">close</span>(idleFd_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acceptor监听">Acceptor监听</h3><p>Acceptor包含2类监听：</p><ol type="1"><li>监听套接字，即本地ip地址&amp;端口。</li><li>监听通道事件，读事件。</li></ol><div class="admonition attention"><p class="admonition-title">为什么不在构造时，就调用listen监听sockfd呢？</p><p>将非必要资源的初始化，延迟到需要时，用户可以通过调用TcpSever::start()来启动。这样，用户可以更灵活控制资源的申请和释放。</p></div><h3 id="acceptor接受连接">Acceptor接受连接</h3><p>Acceptor内部有一个Channel成员，当Poller监听到有Tcp连接请求时，就通过Channel的可读事件，在loop线程，来回调Acceptor::handleRead()。从而将connfd和IP地址传递给上一层TcpServer，用于创建TcpConnection对象管理Tcp连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.cc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理读Channel事件, accept连接</span><br><span class="hljs-comment">* @note 先accept, 然后将相关资源通过回调交由上一层的TcpServer进行处理(管理)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acceptor::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    InetAddress peerAddr;<br>    <span class="hljs-comment">// FIXME loop until no more</span><br>    <span class="hljs-type">int</span> connfd = acceptSocket_.<span class="hljs-built_in">accept</span>(&amp;peerAddr); <span class="hljs-comment">// 获取连接fd及对端ip地址</span><br>    <span class="hljs-keyword">if</span> (connfd &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (newConnectionCallback_)<br>        &#123; <span class="hljs-comment">// 创建新连接回调</span><br>            <span class="hljs-built_in">newConnectionCallback_</span>(connfd, peerAddr);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            sockets::<span class="hljs-built_in">close</span>(connfd);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// 错误</span><br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;in Acceptor::handleRead&quot;</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Read the section named &quot;The special problem of</span><br><span class="hljs-comment">         * accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span><br><span class="hljs-comment">         * By Marc Lehmann, author of libev.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * The per-process limit of open file descriptors has been reached.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (errno == EMFILE)<br>        &#123; <span class="hljs-comment">// 文件描述符资源耗尽错误</span><br>            ::<span class="hljs-built_in">close</span>(idleFd_);<br>            idleFd_ = ::<span class="hljs-built_in">accept</span>(acceptSocket_.<span class="hljs-built_in">fd</span>(), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>            ::<span class="hljs-built_in">close</span>(idleFd_);<br>            <span class="hljs-comment">// reopen /dev/null, it dose not matter whether it succeeds or fails.</span><br>            idleFd_ = ::<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcpserver类-1">TcpServer类</h3><p>TcpServer类管理TcpConnection，供用户直接使用，生命周期由用户控制。接口如下，用户只需要设置好callback，然后调用start()即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.h</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tcp Server, 支持单线程和thread-poll模型.</span><br><span class="hljs-comment">* 接口类, 因此不要暴露太多细节.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpServer</span> : <span class="hljs-keyword">private</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span> (EventLoop*)&gt; ThreadInitCallback;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span><br>    &#123;<br>        kNoReusePort, <span class="hljs-comment">// 不允许重用本地端口</span><br>        kReusePort,   <span class="hljs-comment">// 允许重用本地端口</span><br>    &#125;;<br><br><span class="hljs-comment">//    TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span><br>    <span class="hljs-built_in">TcpServer</span>(EventLoop* loop,<br>              <span class="hljs-type">const</span> InetAddress&amp; listenAddr,<br>              <span class="hljs-type">const</span> std::string&amp; nameArg,<br>              Option option = kNoReusePort);<br>    ~<span class="hljs-built_in">TcpServer</span>(); <span class="hljs-comment">// force out-line dtor, for std::unique_ptr members.</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果没有监听, 就启动服务器(监听).</span><br><span class="hljs-comment">     * 多次调用没有副作用.</span><br><span class="hljs-comment">     * 线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置连接回调.</span><br><span class="hljs-comment">     * 非线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; connectionCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置消息回调.</span><br><span class="hljs-comment">     * 非线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMessageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> MessageCallback &amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; messageCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置写完成回调.</span><br><span class="hljs-comment">     * 非线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCompleteCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteCompleteCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; writeCompleteCallback_ = cb; &#125;<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>并没有连接关闭的回调，这是由TcpServer::removeConnection()负责的，进而把工作转交给TcpConnection::connectDestroyed()，用户不可更改设置。</p></div><h3 id="tcpserver的构造与析构">TcpServer的构造与析构</h3><p>TcpServer构造函数主要工作是为成员申请资源，为各回调设置回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TcpServer::<span class="hljs-built_in">TcpServer</span>(EventLoop* loop,<br>                     <span class="hljs-type">const</span> InetAddress&amp; listenAddr,<br>                     <span class="hljs-type">const</span> std::string&amp; nameArg,<br>                     Option option)<br>: <span class="hljs-built_in">loop_</span>(<span class="hljs-built_in">CHECK_NOTNULL</span>(loop)), <span class="hljs-comment">// 确保loop非空</span><br>  <span class="hljs-built_in">ipPort_</span>(listenAddr.<span class="hljs-built_in">toIpPort</span>()),  <span class="hljs-comment">// 将Ip, port转换为字符串</span><br>  <span class="hljs-built_in">name_</span>(nameArg), <span class="hljs-comment">// 名称</span><br>  <span class="hljs-built_in">acceptor_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Acceptor</span>(loop, listenAddr, option == kReusePort)),<br>  <span class="hljs-built_in">threadPool_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThreadPool</span>(loop, name_)), <span class="hljs-comment">// 初始化事件循环线程池</span><br>  <span class="hljs-built_in">connectionCallback_</span>(defaultConnectionCallback),    <span class="hljs-comment">// 连接回调为默认连接回调</span><br>  <span class="hljs-built_in">messageCallback_</span>(defaultMessageCallback),          <span class="hljs-comment">// 消息回调为默认消息回调</span><br>  <span class="hljs-built_in">nextConnId_</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 连接id</span><br>&#123;<br>    acceptor_-&gt;<span class="hljs-built_in">setNewConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::newConnection, <span class="hljs-keyword">this</span>, _1, _2)); <span class="hljs-comment">// 设置新建连接时的回调</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">同样是连接回调，TcpServer::newConnection()和connectionCallback_有何区别？</p><p>前者是Acceptor发生连接请求事件时，回调，用来新建一个Tcp连接；后者是在TcpServer内部新建连接即调用TcpServer::newConnection()时，回调connectionCallback_。</p></div><p>TcpServer析构工作内容很简单，主要销毁ConnectionMap中所有Tcp连接，而每个Tcp连接用的是一个TcpConnection对象来管理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 析构TcpServer对象, 销毁ConnectionMap中所有连接</span><br><span class="hljs-comment">*/</span><br>TcpServer::~<span class="hljs-built_in">TcpServer</span>()<br>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;] destructing&quot;</span>;<br><br><br>    <span class="hljs-comment">// reset all connection of @c connections_</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : connections_)<br>    &#123;<br>        <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(item.second)</span></span>; <span class="hljs-comment">// shared_ptr manage TcpConnection</span><br>        item.second.<span class="hljs-built_in">reset</span>();<br>        conn-&gt;<span class="hljs-built_in">getLoop</span>()-&gt;<span class="hljs-built_in">runInLoop</span>(<br>                std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TcpServer启动Tcp服务器，主要完成</p><ol type="1"><li>线程池的启动；</li><li>Acceptor监听Tcp连接请求。</li></ol><p>线程池需要指定其初始数量，当然，这需要在start()之前调用TcpServer::setThreadNum()设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 启动TcpServer, 初始化线程池, 连接接受器Accept开始监听(Tcp连接请求)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (started_.<span class="hljs-built_in">getAndSet</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        threadPool_-&gt;<span class="hljs-built_in">start</span>(threadInitCallback_);<br><br><br>        <span class="hljs-built_in">assert</span>(!acceptor_-&gt;<span class="hljs-built_in">listening</span>());<br>        loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>                std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::listen, <span class="hljs-built_in">get_pointer</span>(acceptor_)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">TcpServer如何获得新连接的connfd(accept返回值)?</p><p>TcpServer内部用Acceptor，保存用户提供的Connection-Callback和MessageCallback，新建TcpConnection对象（newConn()）的时候直接传递给TcpConnection的构造函数</p></div><div class="admonition attention"><p class="admonition-title">如何创建TcpConnection对象？</p><p>新连接请求到达时，Acceptor回调newConnection()，通过TcpServer::newConnection创建一个新TcpConnection对象，用于管理一个Tcp连接。</p><p>即，TcpServer::newConnection回调顺序 EventLoop =&gt; Channel =&gt;Acceptor =&gt; TcpServer</p></div><p>下面是用于创建TcpConnection对象的函数TcpServer::newConnection()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.cc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 新建一个TcpConnection对象, 用于连接管理.</span><br><span class="hljs-comment">* @details 新建的TcpConnection对象会加入内部ConnectionMap.</span><br><span class="hljs-comment">* @param sockfd accept返回的连接fd (accepted socket fd)</span><br><span class="hljs-comment">* @param peerAddr 对端ip地址信息</span><br><span class="hljs-comment">* @note 必须在所属loop线程运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::newConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-comment">/* 从EventLoop线程池中，取出一个EventLoop对象构造TcpConnection对象，便于均衡各EventLoop负责的连接数　*/</span><br>    EventLoop* ioLoop = threadPool_-&gt;<span class="hljs-built_in">getNextLoop</span>(); <span class="hljs-comment">// next event loop from the event loop thread pool</span><br><br>    <span class="hljs-comment">/* 设置连接对象名称, 包含基础名称+ip地址+端口号+连接Id</span><br><span class="hljs-comment">     * 因为要作为ConnectionMap的key, 要确保运行时唯一性 */</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="hljs-built_in">c_str</span>(), nextConnId_);<br>    ++nextConnId_;<br>    std::string connName = name_ + buf;<br><br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_<br>    &lt;&lt; <span class="hljs-string">&quot;] - new connection [&quot;</span> &lt;&lt; connName<br>    &lt;&lt; <span class="hljs-string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="hljs-built_in">toIpPort</span>();<br>    <br>    <span class="hljs-function">InetAddress <span class="hljs-title">localAddr</span><span class="hljs-params">(sockets::getLocalAddr(sockfd))</span></span>; <span class="hljs-comment">// 本地ip地址信息</span><br>    <span class="hljs-comment">// FIXME poll with zero timeout to double confirm the new connection</span><br>    <span class="hljs-comment">// FIXME use make_shared if necessary</span><br>    <span class="hljs-comment">/* 新建TcpConnection对象,　并加入ConnectionMap */</span><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;<br>    connections_[connName] = conn;<br>    <span class="hljs-comment">/* 为新建TcpConnection对象设置各种回调 */</span><br>    conn-&gt;<span class="hljs-built_in">setConnectionCallback</span>(connectionCallback_); <span class="hljs-comment">// 连接回调</span><br>    conn-&gt;<span class="hljs-built_in">setMessageCallback</span>(messageCallback_);       <span class="hljs-comment">// 消息回调</span><br>    conn-&gt;<span class="hljs-built_in">setWriteCompleteCallback</span>(writeCompleteCallback_); <span class="hljs-comment">// 写完成回调</span><br>    conn-&gt;<span class="hljs-built_in">setCloseCallback</span>( <span class="hljs-comment">// 关闭连接回调</span><br>            std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="hljs-keyword">this</span>, _1)); <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> unsafe</span><br>    <span class="hljs-comment">/* 确认连接是否已建立, 并初始化连接建立后的状态 */</span><br>    ioLoop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tcpconnection类">TcpConnection类</h2><p>这个类主要封装了一个已建立的TCP连接，以及控制该TCP连接的方法（连接建立和关闭和销毁），以及该连接发生的各种事件（读/写/错误/连接）对应的处理函数，以及这个TCP连接的服务端和客户端的套接字地址信息等。</p><p>TcpConnection类是唯一默认用shared_ptr来管理的类，唯一继承自enable_shared_from_this的类。这是因为其生命周期模糊：可能在连接断开时，还有其他地方持有它的引用，贸然delete会造成空悬指针。只有确保其他地方没有持有该对象的引用的时候，才能安全地销毁对象。</p><p><strong>我个人觉得TcpConnection类和Acceptor类是兄弟关系，Acceptor用于mainEventLoop中，对服务器监听套接字fd及其相关方法进行封装（监听、接受连接、分发连接给SubEventLoop等），TcpConnection用于SubEventLoop中，对连接套接字fd及其相关方法进行封装（读消息事件、发送消息事件、连接关闭事件、错误事件等）。</strong></p><h3 id="tcpconnection的重要变量">TcpConnection的重要变量</h3><ul><li>ocket_：用于保存已连接套接字文件描述符。</li><li>channel_：封装了上面的socket_及其各类事件的处理函数（读、写、错误、关闭等事件处理函数）。这个Channel种保存的各类事件的处理函数是在TcpConnection对象构造函数中注册的。</li><li>loop_：这是一个EventLoop*类型，该Tcp连接的Channel注册到了哪一个subEventLoop上。这个loop_就是那一个sub EventLoop。</li><li>inputBuffer_：这是一个Buffer类，是该TCP连接对应的用户接收缓冲区。</li><li>outputBuffer_：也是一个Buffer类，不过是用于暂存那些暂时发送不出去的待发送数据。因为Tcp发送缓冲区是有大小限制的，假如达到了高水位线，就没办法把发送的数据通过send()直接拷贝到Tcp发送缓冲区，而是暂存在这个outputBuffer_中，等TCP发送缓冲区有空间了，触发可写事件了，再把outputBuffer_中的数据拷贝到Tcp发送缓冲区中。</li><li>state_：这个成员变量标识了当前TCP连接的状态（Connected、Connecting、Disconnecting、Disconnected）</li><li>connetionCallback_、messageCallback_、writeCompleteCallback_、closeCallback_： 用户会自定义 [连接建立/关闭后的处理函数]、[收到消息后的处理函数]、[消息发送完后的处理函数]以及Muduo库中定义的[连接关闭后的处理函数]。这四个函数都会分别注册给这四个成员变量保存。</li></ul><h3 id="tcpconnection的重要成员方法">TcpConnection的重要成员方法</h3><p>handleRead()、handleWrite()、handleClose()、handleError()：这四个函数都是私有成员方法，在一个已经建立好的Tcp连接上主要会发生四类事件：可读事件、可写事件、连接关闭事件、错误事件。当事件监听器监听到一个连接发生了以上的事件，那么就会在EventLoop中调用这些事件对应的处理函数。</p><ul><li>handleRead()负责处理Tcp连接的可读事件，它会将客户端发送来的数据拷贝到用户缓冲区中（inputBuffer_），然后再调用connectionCallback_保存的[连接建立后的处理函数]。</li><li>handleWrite( )负责处理Tcp连接的可写事件。</li><li>handleClose()负责处理Tcp连接关闭的事件。大概的处理逻辑就是将这个TcpConnection对象中的channel_从事件监听器中移除。然后调用connectionCallback_和closeCallback_保存的回调函数。这closeCallback_中保存的函数是由Muduo库提供的，connectionCallback_保存的回调函数则由用户提供的（可有可无其实）</li></ul><p>TcpConnection表示的是“一次Tcp连接”，不可再生，一旦连接断开，该TcpConnection对象就没用了。TcpConnection没用发起连接的功能，构造函数参数是已经建立好连接的socketfd，初始状态是kConnecting。连接可以是TcpServer或TcpClient发起。</p><p>接收到消息时，通过Channel::handleEvent会将可读事件转交给TcpConnection::handleRead处理，而TcpConnection::handleRead又会通过messageCallback_将可读事件转交给TcpServer::messageCallback_，进而传递给用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpConnection.cc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从输入缓存inputBuffer_读取数据, 交给回调messageCallback_处理</span><br><span class="hljs-comment">* @param receiveTime 接收到读事件的时间点</span><br><span class="hljs-comment">* @details 通常是TcpServer/TcpClient运行回调messageCallback_, 将处理机会传递给用户</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleRead</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ssize_t</span> n = inputBuffer_.<span class="hljs-built_in">readFd</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno); <span class="hljs-comment">// 从指定fd读取数据到内部缓冲</span><br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">messageCallback_</span>(<span class="hljs-built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">handleClose</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        errno = savedErrno;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;TcpConnection::handleRead&quot;</span>;<br>        <span class="hljs-built_in">handleError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断开tcp连接">断开Tcp连接</h3><p>muduo中有2种关闭连接的方式：</p><ol type="1"><li>被动关闭：即对端先关闭连接，本地read(2)返回0，触发关闭逻辑，调用handleClose。</li><li>主动关闭：利用forceClose()或forceCloseWithDelay()成员函数调用handleClose，强制关闭或强制延时关闭连接。</li></ol><p>被动关闭流程见下图，图中“X”表示TcpConnection对象通常在此析构。</p><p><img src="/img/muduo/TCP连接/TCP被动断开.png" /></p><div class="admonition info"><p class="admonition-title">info</p><p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1,并在Channel中维护一个weak_ptr(tie_)，将这个shared_ptr对象赋值给tie_，由weak_ptr的特性，引用计数仍然为1</p><p>当连接关闭，在handleEvent，将tie_提升，得到一个shared_ptr,这时候引用计数就变成了2，然后erase，引用计数变为1，所以TcpConnection计数变为1，并没有销毁，然后再调用closeCallback_，closeCallback_在TcpServer::newConnection()为新连接新建TcpConnection时，已设为TcpServer::removeConnection()，而removeConnection()最终会调用TcpConnection::connectDestroyed()来销毁连接资源。</p></div><h3 id="channel与断开连接">Channel与断开连接</h3><p>Channel中有关闭连接的事件回调CloseCallback，由Channel::handleEvent()调用，从而触发TcpConnection::handleClose()：</p><p>调用链路：</p><p>Poller::poll()检测到Channel事件就绪 =&gt; EventLoop::loop()=&gt;Channel::handleEvent() =&gt; Channel::closeCallback_ =&gt;TcpConnection::handleClose()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Channel.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEvent</span><span class="hljs-params">(Timestamp recevieTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard;<br>    <span class="hljs-keyword">if</span> (tied_)<br>    &#123;<br>        guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>        &#123;<br>            <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据不同的激活原因, 调用不同的回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    eventHandling_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 正在处理事件</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-built_in">reventsToString</span>(); <span class="hljs-comment">// 打印fd及就绪事件</span><br>    <span class="hljs-keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))<br>    &#123; <span class="hljs-comment">// fd挂起(套接字已不在连接中), 并且没有数据可读</span><br>        <span class="hljs-keyword">if</span> (logHup_)<br>        &#123; <span class="hljs-comment">// 打印挂起log</span><br>            LOG_WARN &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="hljs-string">&quot; Channel::handle_event() POLLHUP&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 调用关闭回调</span><br>        <span class="hljs-keyword">if</span> (closeCallback_) <span class="hljs-built_in">closeCallback_</span>();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcpconnection与断开连接">TcpConnection与断开连接</h3><p>TcpConnection中有关闭连接的事件回调CloseCallback，由TcpConnection::handleClose()调用，从而触发TcpServer::removeConnection()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpConnection.h</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 关闭写半连接 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// NOT thread safe, no simultaneous calling</span><br><span class="hljs-comment">//    void shutdownAndForceCloseAfter(double seconds); // NOT thread safe, no simultaneous calling</span><br><br>    <span class="hljs-comment">/* 强制关闭连接 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forceClose</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 强制延时关闭连接 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forceCloseWithDelay</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span></span>;<br><br>    ...<br><br>    <span class="hljs-comment">/* Internal use only */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> CloseCallback&amp; cb)</span></span><br><span class="hljs-function">    </span>&#123; closeCallback_ = cb; &#125;<br><br>    <span class="hljs-comment">// called when TcpServer accepts a new connection</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectEstablished</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// should be called only once per connection</span><br>    <span class="hljs-comment">// called when TcpServer has removed me from its map</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectDestroyed</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// should be called only once per connection</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleClose</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// 处理关闭连接事件</span><br></code></pre></td></tr></table></figure><p><strong>被动关闭连接</strong></p><p>当收到对端FIN分节时，本地read返回0,，Tcp连接被动关闭，会触发调用本地TcpConnection::handleClose()，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理Tcp连接关闭</span><br><span class="hljs-comment">* @details 更新状态为kDisconnected, 清除所有事件通道监听</span><br><span class="hljs-comment">* @note 必须在所属loop线程中运行.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleClose</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>(); <span class="hljs-comment">// 确保在所属loop线程中运行</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="hljs-built_in">fd</span>() &lt;&lt; <span class="hljs-string">&quot; state = &quot;</span> &lt;&lt; <span class="hljs-built_in">stateToString</span>();<br>    <span class="hljs-built_in">assert</span>(state_ == kConnected || state_ == kDisconnecting);<br>    <span class="hljs-comment">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span><br>    <span class="hljs-built_in">setState</span>(kDisconnected); <span class="hljs-comment">// 更新Tcp连接状态</span><br>    channel_-&gt;<span class="hljs-built_in">disableAll</span>();     <span class="hljs-comment">// 停止监听所有通道事件(读写事件)</span><br><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">guardThis</span><span class="hljs-params">(shared_from_this())</span></span>;<br>    <span class="hljs-built_in">connectionCallback_</span>(guardThis); <span class="hljs-comment">// 连接回调</span><br>    <span class="hljs-comment">// must be the last line</span><br>    <span class="hljs-built_in">closeCallback_</span>(guardThis);      <span class="hljs-comment">//　关闭连接回调</span><br>&#125;<br></code></pre></td></tr></table></figure><p>closeCallback_在TcpServer::newConnection()为新连接新建TcpConnection时，已设为TcpServer::removeConnection()，而removeConnection()最终会调用TcpConnection::connectDestroyed()来销毁连接资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 主动销毁当前tcp连接, 移除通道事件</span><br><span class="hljs-comment">* @note 只有处于已连接状态(kConnected)的tcp连接, 才需要先更新状态, 关闭通道事件监听</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectDestroyed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">if</span> (state_ == kConnected) <span class="hljs-comment">// 只有kConnected的连接, 才有必要采取断开连接动作</span><br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnected);<br>        channel_-&gt;<span class="hljs-built_in">disableAll</span>(); <span class="hljs-comment">// 关闭通道事件监听</span><br><br>        <span class="hljs-built_in">connectionCallback_</span>(<span class="hljs-built_in">shared_from_this</span>()); <span class="hljs-comment">// 调用连接回调</span><br>    &#125;<br>    channel_-&gt;<span class="hljs-built_in">remove</span>(); <span class="hljs-comment">// 从EventLoop和Poller中移除监听通道事件</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>主动关闭连接</strong>:</p><p>主动关闭连接有两种方式：</p><ul><li>强制close连接</li><li>关闭一个方向的连接（读或写方向）</li></ul><p><strong>强制关闭连接</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 强制关闭连接, 只对连接为kConnected或kDisconnecting状态才有效</span><br><span class="hljs-comment">* @details 为防止意外, 动作应该放到loop末尾去做</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::forceClose</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> use compare and swap</span><br>    <span class="hljs-keyword">if</span> (state_ == kConnected || state_ == kDisconnecting)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        loop_-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::forceCloseInLoop, <span class="hljs-built_in">shared_from_this</span>()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop循环中强制关闭连接, 只对连接为kConnected或kDisconnecting状态才有效</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::forceCloseInLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">if</span> (state_ == kConnected || state_ == kDisconnecting)<br>    &#123;<br>        <span class="hljs-comment">// as if we received 0 byte in handleRead()</span><br>        <span class="hljs-built_in">handleClose</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，除了状态更新，对于关闭连接的真正操作，被动、主动关闭连接都是由handleClose来完成的。</p><p>假设想延迟一段时间再关闭连接，可以调用forceCloseWithDelay()，区别在于交给EventLoop:runAfter()延时运行，而不是交给EventLoop::queueInLoop()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::forceCloseWithDelay</span><span class="hljs-params">(<span class="hljs-type">double</span> seconds)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state_ == kConnected || state_ == kDisconnecting)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        loop_-&gt;<span class="hljs-built_in">runAfter</span>(seconds,<br>                        <span class="hljs-built_in">makeWeakCallback</span>(<span class="hljs-built_in">shared_from_this</span>(),<br>                                          &amp;TcpConnection::forceClose)); <span class="hljs-comment">// not forceCloseInLoop to avoid race condition</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关闭一个方向的连接</strong>:</p><p>TcpConnection::shutdown()用于关闭写半连接，即发送FIN分节，关闭写通道，但仍然可以接收数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 关闭连接写方向, 只有已连接状态才有效</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::shutdown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> use compare and swap</span><br>    <span class="hljs-keyword">if</span> (state_ == kConnected)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> shared_from_this()?</span><br>        loop_-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::shutDownInLoop, <span class="hljs-built_in">shared_from_this</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于close和shutdown的区别，详见<ahref="https://www.cnblogs.com/fortunely/p/14854299.html">Linuxshutdown与clos</a></p><h3 id="tcpserver与断开连接">TcpServer与断开连接</h3><p>当新建一个tcp连接时，TcpServer会调用newConnection创建一个新TcpConnection对象管理Tcp连接，并将对象加入自己的ConnectionMap进行管理。</p><p>而当tcp连接断开时，需要调用removeConnection进行移除工作，而removeConnection会将工作转交给removeConnectionInLoop,确保在所属loop线程中执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 转交给removeConnectionInLoop, 在所属loop线程中执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> unsafe</span><br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="hljs-keyword">this</span>, conn));<br>&#125;<br></code></pre></td></tr></table></figure><p>removeConnectionInLoop要做的工作是将要移除的tcp连接对应TcpConnection对象，从ConnectionMap移除，然后销毁该对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop线程循环中, 排队移除指定tcp连接 conn</span><br><span class="hljs-comment">* @param conn 指向待移除tcp连接对应TcpConnection对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnectionInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_<br>    &lt;&lt; <span class="hljs-string">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">name</span>();<br>    <span class="hljs-type">size_t</span> n = connections_.<span class="hljs-built_in">erase</span>(conn-&gt;<span class="hljs-built_in">name</span>()); <span class="hljs-comment">// 从ConnectionMap中擦除待移除TcpConnection对象</span><br>    (<span class="hljs-type">void</span>)n;<br>    <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>);<br>    EventLoop* ioLoop = conn-&gt;<span class="hljs-built_in">getLoop</span>();<br>    ioLoop-&gt;<span class="hljs-built_in">queueInLoop</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn)); <span class="hljs-comment">// 在所属loop线程中排队销毁TcpConnection对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理">错误处理</h2><p>用于发送数据的TcpConnection::send()重载了下面几个版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">/* 发送消息给连接对端 */</span><br><span class="hljs-comment">//    void send(std::string&amp;&amp; mesage); // C++11</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* message, <span class="hljs-type">int</span> len)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece&amp; message)</span></span>;<br><span class="hljs-comment">//    void send(Buffer&amp;&amp; message);</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Buffer* message)</span></span>; <span class="hljs-comment">// this one will swap data</span><br><br><span class="hljs-number">3</span>个<span class="hljs-built_in">send</span>() 重载版本，最终都会转交给<span class="hljs-built_in">sendInLoop</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)，在所属loop线程中执行发送工作。<br><br><br><span class="hljs-comment">// 转发给send(const StringPiece&amp;), 最终转交给sendInLoop(const char*, int)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *message, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">send</span>(<span class="hljs-built_in">StringPiece</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(message), len));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 转交给 sendInLoop(const char*, int)</span><br><span class="hljs-comment">* 发送消息给对端, 允许在其他线程调用</span><br><span class="hljs-comment">* @param message 要发送的消息. StringPiece兼容C/C++风格字符串, 二进制缓存, 提供统一字符串接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state_ == kConnected)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (loop_-&gt;<span class="hljs-built_in">isInLoopThread</span>())<br>        &#123; <span class="hljs-comment">// 当前线程是所属loop线程</span><br>            <span class="hljs-built_in">sendInLoop</span>(message);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">// 当前线程并非所属loop线程</span><br>            <span class="hljs-built_in">void</span> (TcpConnection::*fp)(<span class="hljs-type">const</span> StringPiece&amp; message);<br>            fp = &amp;TcpConnection::sendInLoop;<br>            loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>                    std::<span class="hljs-built_in">bind</span>(fp,<br>                              <span class="hljs-keyword">this</span>, <span class="hljs-comment">// FIXME</span><br>                              message.<span class="hljs-built_in">as_string</span>()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 转交给sendInLoop(const char*, int)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> StringPiece &amp;message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sendInLoop</span>(message.<span class="hljs-built_in">data</span>(), message.<span class="hljs-built_in">size</span>());<br>&#125;<br><br><span class="hljs-comment">// 转交给sendInLoop(const char*, int)</span><br><span class="hljs-comment">// FIXME efficiency!!!</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(Buffer *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (state_ == kConnected)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (loop_-&gt;<span class="hljs-built_in">isInLoopThread</span>())<br>        &#123;<br>            <span class="hljs-comment">// send all readable bytes</span><br>            <span class="hljs-built_in">sendInLoop</span>(buf-&gt;<span class="hljs-built_in">peek</span>(), buf-&gt;<span class="hljs-built_in">readableBytes</span>());<br>            buf-&gt;<span class="hljs-built_in">retrieveAll</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sendInLoop定义如下，主要是向对端发送一次数据，如果发送完一次，就进行一次回调；如果待发送数据超高水位，就进行高水位回调；如果发生错误，就进行错误回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop线程中, 发送data[len]</span><br><span class="hljs-comment">* @param data 要发送的缓冲区首地址</span><br><span class="hljs-comment">* @param len　要发送的缓冲区大小(bytes)</span><br><span class="hljs-comment">* @details 发生write错误, 如果发送缓冲区未满,　对端已发FIN/RST分节 表明tcp连接发生致命错误(faultError为true)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-type">ssize_t</span> nwrote = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> remaining = len;<br>    <span class="hljs-type">bool</span> faultError = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (state_ == kDisconnected) <span class="hljs-comment">// 如果已经断开连接(kDisconnected), 就无需发送, 打印log(LOG_WARN)</span><br>    &#123;<br>        LOG_WARN &lt;&lt; <span class="hljs-string">&quot;disconnected, give up writing&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// write一次, 往对端发送数据, 后面再看是否发生错误, 是否需要高水位回调</span><br>    <span class="hljs-comment">// if no thing output queue, try writing directly</span><br>    <span class="hljs-keyword">if</span> (!channel_-&gt;<span class="hljs-built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// 如果通道没有使能监听写事件, 并且outputBuffer　没有待发送数据, 就直接通过socket写</span><br>        nwrote = sockets::<span class="hljs-built_in">write</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), data, len);<br>        <span class="hljs-keyword">if</span> (nwrote &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            remaining = len - nwrote;<br>            <span class="hljs-keyword">if</span> (remaining == <span class="hljs-number">0</span> &amp;&amp; writeCompleteCallback_)<br>            &#123;<br>                loop_-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(writeCompleteCallback_, <span class="hljs-built_in">shared_from_this</span>()));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// nwrote &lt; 0, error</span><br>        &#123;<br>            nwrote = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK) <span class="hljs-comment">// EWOULDBLOCK: 发送缓冲区已满, 且fd已设为nonblocking</span><br>            &#123; <span class="hljs-comment">// O_NONBLOCK fd, write block but return EWOULDBLOCK error</span><br>                LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;TcpConnection::sendInLoop&quot;</span>;<br>                <span class="hljs-keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> any others?</span><br>                &#123; <span class="hljs-comment">// EPIPE: reading end is closed; ECONNRESET: connection reset by peer</span><br>                    faultError = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余待发送数据</span><br>    <span class="hljs-built_in">assert</span>(remaining &lt;= len);<br>    <span class="hljs-keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有故障, 并且还有待发送数据, 可能是发送太快, 对方来不及接收</span><br>    &#123; <span class="hljs-comment">// no error and data remaining to be written</span><br>        <span class="hljs-type">size_t</span> oldLen = outputBuffer_.<span class="hljs-built_in">readableBytes</span>(); <span class="hljs-comment">// Buffer中待发送数据量</span><br><br>        <span class="hljs-keyword">if</span> (oldLen + remaining &gt;= highWaterMark_ <span class="hljs-comment">// Buffer及当前要发送的数据量之和 超 高水位(highWaterMark)</span><br>        &amp;&amp; oldLen &lt; highWaterMark_ <span class="hljs-comment">// 单独的Buffer中待发送数据量 未超 高水位</span><br>        &amp;&amp; highWaterMarkCallback_)<br>        &#123;<br>            loop_-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(highWaterMarkCallback_, <span class="hljs-built_in">shared_from_this</span>(), oldLen + remaining));<br>        &#125;<br>        <span class="hljs-comment">// append data to be written to the output buffer</span><br>        outputBuffer_.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data) + nwrote, remaining);<br>        <span class="hljs-comment">// enable write event for channel_</span><br>        <span class="hljs-keyword">if</span> (!channel_-&gt;<span class="hljs-built_in">isWriting</span>())<br>        &#123; <span class="hljs-comment">// 如果没有在监听通道写事件, 就使能通道写事件</span><br>            channel_-&gt;<span class="hljs-built_in">enableWriting</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition info"><p class="admonition-title">info</p><p>HighWaterMarkCallback指的是如果输出缓冲的长度超过用户指定大小，就会触发回调（只在上升沿触发一次）。</p></div><h3id="用户使用tcpserver与客户端进行通信">用户使用TcpServer与客户端进行通信</h3><div class="admonition attention"><p class="admonition-title">假设客户端请求与服务器建立连接，用户（库的使用者）如何在建立连接、发送数据时，执行自定义任务？</p><p>可以在TcpServer启动前，利用TcpServer::setConnectionCallback()、TcpServer::setMessageCallback()等设置回调接口注册任务，等Tcp连接达到指定状态后，会回调用户任务。</p></div><p><strong>示例：使用TcpServer接口类创建Tcp连接</strong></p><p>例如，用户自定义服务EchoServer回传收到的客户端消息，EchoServer使用TcpServer注册连接回调（setConnectionCallback）和消息回调（setMessageCallback）。</p><p>如果需要分阶段向客户端发送数据，还可以注册写完成回调（setWriteCompleteCallback）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// examples/simple/echo</span><br>EchoServer::<span class="hljs-built_in">EchoServer</span>(muduo::net::EventLoop *loop, <span class="hljs-type">const</span> muduo::net::InetAddress &amp;listenAddr)<br>: <span class="hljs-built_in">server_</span>(loop, listenAddr, <span class="hljs-string">&quot;EchoServer&quot;</span>)<br>&#123;<br>    server_.<span class="hljs-built_in">setConnectionCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onConnection, <span class="hljs-keyword">this</span>, _1));<br>    server_.<span class="hljs-built_in">setMessageCallback</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;EchoServer::onMessage, <span class="hljs-keyword">this</span>, _1, _2, _3));<br><br>    LOG_INFO &lt;&lt; server_.<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; listen on &quot;</span> &lt;&lt; listenAddr.<span class="hljs-built_in">toIpPort</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EchoServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    server_.<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EchoServer::onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;EchoServer - &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span><br>    &lt;&lt; conn-&gt;<span class="hljs-built_in">localAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot; is &quot;</span><br>    &lt;&lt; (conn-&gt;<span class="hljs-built_in">connected</span>() ? <span class="hljs-string">&quot;UP&quot;</span> : <span class="hljs-string">&quot;DOWN&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EchoServer::onMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buf, muduo::Timestamp time)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">muduo::string <span class="hljs-title">msg</span><span class="hljs-params">(buf-&gt;retrieveAllAsString())</span></span>;<br>    LOG_INFO &lt;&lt; conn-&gt;<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; echo &quot;</span> &lt;&lt; msg.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; bytes, &quot;</span><br>    &lt;&lt; <span class="hljs-string">&quot;data received at &quot;</span> &lt;&lt; time.<span class="hljs-built_in">toString</span>();<br>    conn-&gt;<span class="hljs-built_in">send</span>(msg);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_INFO &lt;&lt; <span class="hljs-string">&quot;pid = &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>();<br>    muduo::net::EventLoop loop; <span class="hljs-comment">// 创建EventLoop对象</span><br>    muduo::<span class="hljs-function">net::InetAddress <span class="hljs-title">listenAddr</span><span class="hljs-params">(<span class="hljs-number">2007</span>)</span></span>; <span class="hljs-comment">// 创建包含ip地址、端口号的对象</span><br>    <span class="hljs-function">EchoServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;loop, listenAddr)</span></span>; <span class="hljs-comment">// 创建用户自定义EchoServer对象</span><br>    server.<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 启动EchoServer服务器</span><br>    loop.<span class="hljs-built_in">loop</span>();     <span class="hljs-comment">// 启动loop循环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://www.cnblogs.com/fortunely/p/16048017.html">muduo笔记网络库（七）TCP连接TcpConnection、Acceptor、TcpServer</a></li><li><ahref="https://zhuanlan.zhihu.com/p/495016351">万字长文梳理Muduo库核心代码及优秀编程细节思想剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Socket</title>
    <link href="/2023/07/06/muduo%E5%BA%93-Socket/"/>
    <url>/2023/07/06/muduo%E5%BA%93-Socket/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-socket">muduo库-Socket</h1><h2 id="socket类">Socket类</h2><p>Socket类是socket 文件描述符（sockfd）的一个轻量级封装，提供操作底层sockfd的常用方法。采用RTII方式管理sock fd，但本身并不创建sockfd，也不打开它，只负责关闭。</p><p>提供的public方法主要包括：获取tcp协议栈信息（tcp_info）；绑定ip地址（bind）；监听套接字（listen）；接收连接请求（accept）；关闭连接写方向（shutdown），等等。</p><div class="admonition note"><p class="admonition-title">note</p><p>Socket并不提供close sockfd的public方法，因为析构时，调用close关闭套接字。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* socket fd 包装类</span><br><span class="hljs-comment">*　RAII机制管理socket fd: 对close socket fd负责, 但不包括open/create.</span><br><span class="hljs-comment">* 监听socket, 常用于server socket.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function">    : sockfd_(sockfd)</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-comment">// Socket(Socket&amp;&amp;) // move ctor in c++11</span><br>    ~<span class="hljs-built_in">Socket</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sockfd_; &#125;<br>    <span class="hljs-comment">/* 获取tcp信息, 存放到tcp_info结构 */</span><br>    <span class="hljs-comment">// return true if success.</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getTcpInfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tcp_info*)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取tcp信息字符串形式(NUL结尾), 存放到字符串数组buf[len] */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getTcpInfoString</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> len)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">/* 绑定socket fd与本地ip地址,端口, 核心调用bind(2).</span><br><span class="hljs-comment">     * 失败则终止程序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// abort if address in use</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> InetAddress&amp; addr)</span></span>;<br>    <span class="hljs-comment">/* 监听socket fd, 核心调用listen(2).</span><br><span class="hljs-comment">     * 失败则终止程序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// abort if address in use</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接受连接请求, 返回conn fd(连接文件描述符). 核心调用accept(2).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * On success, returns a non-negative integer that is</span><br><span class="hljs-comment">     * a descriptor for the accepted socket, which has been</span><br><span class="hljs-comment">     * set to non-blocking and close-on-exec. *peeraddr is assigned.</span><br><span class="hljs-comment">     * On error, -1 is returned, and *peeraddr is untouched.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(InetAddress* peeraddr)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接写方向</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownWrite</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable TCP_NODELAY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTcpNoDelay</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable SO_REUSEADDR</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReuseAddr</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable SO_REUSEPORT</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReusePort</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enable/disable SO_KEEPALIVE</span><br><span class="hljs-comment">     * @param on</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setKeepAlive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sockfd_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实现主要转交给SocketsOps包装库函数后的包装函数。</p><h3 id="socket的构造与析构">Socket的构造与析构</h3><p>Socket构造和析构很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function">: sockfd_(sockfd)</span><br><span class="hljs-function">&#123;</span> &#125;<br><br>Socket::~<span class="hljs-built_in">Socket</span>()<br>&#123;<br>    sockets::<span class="hljs-built_in">close</span>(sockfd_);<br>&#125;<br></code></pre></td></tr></table></figure><p>Socket类不创建sockfd，其含义取决于构造Socket对象的调用者。如果是由调用socket(2)创建的sockfd，那就是本地套接字；如果是由accept(2)返回的sockfd，那就是acceptedsocket，代表一个连接。</p><p>例如，Acceptor持有的Socket对象，是由socket(2)创建的，代表一个套接字；TcpConnection只有一个Socket对象，是由TcpServer在新建TcpConnection对象时传入，而由Acceptor::handleRead()中通过Socket::accept()创建的sockfd参数的实参。</p><h3 id="socket获取tcp协议栈信息">Socket获取Tcp协议栈信息</h3><p>利用getsockopt + TCP_INFO选项，获取tcp协议栈信息。</p><ul><li><p>方法一：getTcpInfo获取tcp协议栈信息，存放到tcp_info结构对象;</p></li><li><p>方法二：getTcpInfoString获取tcp协议栈字符串形式，存放到数组buf[len]；</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 获取TcpInfo(Tcp信息), 存放到tcp_info结构对象tcpi中.</span><br><span class="hljs-comment">* @details 调用getsockopt获取TcpInfo, 对应opt name为TCP_INFO.</span><br><span class="hljs-comment">* @param tcpi [in] 指向tcp_info结构, 用来存放TcpInfo</span><br><span class="hljs-comment">* @return 获取TcpInfo结果</span><br><span class="hljs-comment">* - true 获取成功</span><br><span class="hljs-comment">* - false 获取失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Socket::getTcpInfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tcp_info *tcpi)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(*tcpi);<br>    <span class="hljs-built_in">memZero</span>(tcpi, len);<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">getsockopt</span>(sockfd_, SOL_TCP, TCP_INFO, tcpi, &amp;len) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将从getTcpInfo得到的TcpInfo转换为字符串, 存放到长度为len的buf中.</span><br><span class="hljs-comment">* @param buf 存放TcpInfo字符串的缓存</span><br><span class="hljs-comment">* @param len 缓存buf的长度, 单位是字节数</span><br><span class="hljs-comment">* @return 调用结果</span><br><span class="hljs-comment">* - true 返回存放到buf的TcpInfo有效</span><br><span class="hljs-comment">* - false 调用getsockopt()出错</span><br><span class="hljs-comment">* @see</span><br><span class="hljs-comment">* https://blog.csdn.net/zhangskd/article/details/8561950</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Socket::getTcpInfoString</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> len)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tcp_info</span> tcpi;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-built_in">getTcpInfo</span>(&amp;tcpi);<br>    <span class="hljs-keyword">if</span> (ok)<br>    &#123;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(len), <span class="hljs-string">&quot;unrecovered=%u &quot;</span><br>                           <span class="hljs-string">&quot;rto=%u ato=%u snd_mss=%u rcv_mss=%u &quot;</span><br>                           <span class="hljs-string">&quot;lost=%u retrans=%u rtt=%u rttvar=%u &quot;</span><br>                           <span class="hljs-string">&quot;sshthresh=%u cwnd=%u total_retrans=%u&quot;</span>,<br>                 tcpi.tcpi_retransmits,  <span class="hljs-comment">// 重传数, 当前待重传的包数, 重传完成后清零 //　Number of unrecovered [RTO] timeouts</span><br>                 tcpi.tcpi_rto,          <span class="hljs-comment">// 重传超时时间(usec)　// Retransmit timeout in usec</span><br>                 tcpi.tcpi_ato,          <span class="hljs-comment">// 延时确认的估值(usec) // Predicted tick of soft clock in usec</span><br>                 tcpi.tcpi_snd_mss,      <span class="hljs-comment">// 发送端MSS(最大报文段长度)</span><br>                 tcpi.tcpi_rcv_mss,      <span class="hljs-comment">// 接收端MSS(最大报文段长度)</span><br>                 tcpi.tcpi_lost,         <span class="hljs-comment">// 丢失且未恢复的数据段数 // Lost packets</span><br>                 tcpi.tcpi_retrans,      <span class="hljs-comment">// 重传且未确认的数据段数 // Retransmitted packets out</span><br>                 tcpi.tcpi_rtt,          <span class="hljs-comment">// 平滑的RTT(usec)　//　Smoothed round trip time in usec</span><br>                 tcpi.tcpi_rttvar,       <span class="hljs-comment">// 1/4 mdev (usec) // Medium deviation</span><br>                 tcpi.tcpi_snd_ssthresh, <span class="hljs-comment">// 慢启动阈值</span><br>                 tcpi.tcpi_snd_cwnd,     <span class="hljs-comment">// 拥塞窗口</span><br>                 tcpi.tcpi_total_retrans <span class="hljs-comment">// 本连接的总重传个数  // Total retransmits for entire connection</span><br>                           );<br>    &#125;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他常用接口">其他常用接口</h3><p>比如bindAddress、listen、accept等，与基础网络编程接口bind、listen、accept类似，不过由SocketOps进行轻度包裹。</p><p>值得一提的是setTcpNoDelay()，用于设置TCP_NODELAY选项，以禁用Nagle算法，从而不会等到收到ACK才进行下一次数据发送，而是tcp协议栈缓冲存中有数据就立即发送。适用于对性能要求较高的情况。</p><h2 id="inetaddress类">InetAddress类</h2><p>InetAddress类对地址信息进行了包装，是sockaddr_in的包装类。</p><p><strong>既然是表示ip地址，可以直接用sockaddr_in，为什么要用InetAddress重新包装一下？</strong></p><p>因为表示IPv4地址的sockaddr_in是C语言数据类型，并不包含对数据类型的操作，另外，支持IPv6的地址结构是sockaddr_in6。如果直接使用C风格的sockaddr_in，那么其他类要用来表示地址，不得不使用大量底层C接口。而使用C++类InetAddress包装sockaddr_in/sockaddr_in6，提供必要的C++接口，可以有效解决参数兼容问题。</p><p>InetAddress 声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* sockaddr_in包装类.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* POD(Plain Old Data) 接口类, 便于Ｃ++和Ｃ之间数据类型的兼容性.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InetAddress</span> : <span class="hljs-keyword">public</span> muduo::copyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用给定端口号构造一个端(ip + port).</span><br><span class="hljs-comment">     * 常用于TcpServer, 监听本地地址.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> portArg = <span class="hljs-number">0</span>, <span class="hljs-type">bool</span> loopbackOnly = <span class="hljs-literal">false</span>, <span class="hljs-type">bool</span> ipv6 = <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建一个InetAddress对象, 用于将一个port + 字符串形式的ip地址转化为InetAddress对象.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">InetAddress</span>(StringArg ip, <span class="hljs-type">uint16_t</span> portArg, <span class="hljs-type">bool</span> ipv6 = <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in&amp; addr)</span></span><br><span class="hljs-function">            : addr_(addr)</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6&amp; addr)</span></span><br><span class="hljs-function">            : addr6_(addr)</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-comment">/* 获取协议族类型 */</span><br>    <span class="hljs-function"><span class="hljs-type">sa_family_t</span> <span class="hljs-title">family</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> addr_.sin_family; &#125;<br>    <span class="hljs-comment">/* 获取ip地址字符串形式.</span><br><span class="hljs-comment">     * 对于ipv4, 为点分十进制; 对于ipv6, 为冒号十六进制. */</span><br>    <span class="hljs-function">string <span class="hljs-title">toIp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取ip地址+port字符串形式. */</span><br>    <span class="hljs-function">string <span class="hljs-title">toIpPort</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取端口号(主机端) */</span><br>    <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">port</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// default copy/assignment are Okay</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">getSockAddr</span>() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> sockets::<span class="hljs-built_in">sockaddr_cast</span>(&amp;addr6_); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSockAddrInet6</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6&amp; addr6)</span> </span>&#123; addr6_ = addr6; &#125;<br><br>    <span class="hljs-comment">/* 获取ipv4地址网络端(大端) */</span><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">ipv4NetEndian</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 获取端口号网络端(大端) */</span><br>    <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">portNetEndian</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> addr_.sin_port; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将hostname转换为IP地址, 存放到result, 而不改变port或sin_family.</span><br><span class="hljs-comment">     * 线程安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">resolve</span><span class="hljs-params">(StringArg hostname, InetAddress* result)</span></span>;<br><br>    <span class="hljs-comment">/* 设置IPv6 ScopeID(域ID) */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setScopedId</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> scope_id)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">union</span><br>    &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr_;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> addr6_;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>InetAddress是值语义的，便于在传递时拷贝。数据成员是一个union，对于IPv4，使用addr_；对于IPv6，则使用addr6_。</p><p>5个静态断言（static_assert）确保数据成员大小及联合体内部位段偏移，因为后面会直接将sockaddr_in6转换为sockaddr_in。</p><h3 id="inetaddress构造">InetAddress构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">in_addr_t</span> kInaddrAny = INADDR_ANY;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">in_addr_t</span> kInaddrLoopback = INADDR_LOOPBACK;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构造InetAddress对象</span><br><span class="hljs-comment">* @param portArg 端口号</span><br><span class="hljs-comment">* @param loopbackOnly　决定是否为回环地址</span><br><span class="hljs-comment">* @param ipv6　决定是否为ipv6地址</span><br><span class="hljs-comment">* @note 注意addr_/addr6_中存放的是网络字节序</span><br><span class="hljs-comment">*/</span><br>InetAddress::<span class="hljs-built_in">InetAddress</span>(<span class="hljs-type">uint16_t</span> portArg, <span class="hljs-type">bool</span> loopbackOnly, <span class="hljs-type">bool</span> ipv6)<br>&#123;<br>    <span class="hljs-comment">// 确保addr6_/addr_ 在InetAddress class内存中的偏移</span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">offsetof</span>(InetAddress, addr6_) == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;addr6_ offset 0&quot;</span>);<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">offsetof</span>(InetAddress, addr_) == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;addr_ offset 0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ipv6)<br>    &#123; <span class="hljs-comment">// ipv6地址</span><br>        <span class="hljs-built_in">memZero</span>(&amp;addr6_, <span class="hljs-built_in">sizeof</span>(addr6_));<br>        addr6_.sin6_family = AF_INET6;<br>        <span class="hljs-comment">// in6addr_loopback: 回环地址; in6addr_any： 任意地址</span><br>        in6_addr ip = loopbackOnly ? in6addr_loopback : in6addr_any;<br>        addr6_.sin6_addr = ip; <span class="hljs-comment">// ip地址</span><br>        addr6_.sin6_port = sockets::<span class="hljs-built_in">hostToNetwork16</span>(portArg); <span class="hljs-comment">// 端口号</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// ipv4地址</span><br>        <span class="hljs-built_in">memZero</span>(&amp;addr_, <span class="hljs-built_in">sizeof</span>(addr_));<br>        addr_.sin_family = AF_INET;<br>        <span class="hljs-comment">// kInaddrLoopback: 回环地址; kInaddrAny： 任意地址</span><br>        <span class="hljs-type">in_addr_t</span> ip = loopbackOnly ? kInaddrLoopback : kInaddrAny;<br>        addr_.sin_addr.s_addr = sockets::<span class="hljs-built_in">hostToNetwork32</span>(ip); <span class="hljs-comment">// ip地址</span><br>        addr_.sin_port = sockets::<span class="hljs-built_in">hostToNetwork16</span>(portArg);   <span class="hljs-comment">// 端口号</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 根据ip地址字符串形式 + 端口号, 构造InetAddress对象</span><br><span class="hljs-comment">* IPv6: 2409:8a4c:662f:2900:9b2:63:9618:56c0</span><br><span class="hljs-comment">* IPv4: 127.0.0.1</span><br><span class="hljs-comment">*/</span><br>InetAddress::<span class="hljs-built_in">InetAddress</span>(StringArg ip, <span class="hljs-type">uint16_t</span> portArg, <span class="hljs-type">bool</span> ipv6)<br>&#123;<br>    <span class="hljs-keyword">if</span> (ipv6 || <span class="hljs-built_in">strchr</span>(ip.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&#x27;:&#x27;</span>))<br>    &#123; <span class="hljs-comment">// 指定为ipv6地址类型, 或ip地址字符串中包含&#x27;:&#x27;</span><br>        <span class="hljs-built_in">memZero</span>(&amp;addr6_, <span class="hljs-built_in">sizeof</span>(addr6_));<br>        sockets::<span class="hljs-built_in">fromIpPort</span>(ip.<span class="hljs-built_in">c_str</span>(), portArg, &amp;addr6_); <span class="hljs-comment">// 将冒号16进制表示的ip地址+port, 转化为addr6_结构</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">memZero</span>(&amp;addr_, <span class="hljs-built_in">sizeof</span>(addr_));<br>        sockets::<span class="hljs-built_in">fromIpPort</span>(ip.<span class="hljs-built_in">c_str</span>(), portArg, &amp;addr_); <span class="hljs-comment">// 将冒号16进制表示的ip地址+port, 转化为addr6_结构</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 根据sockaddr_in构造InetAddress对象 */</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in&amp; addr)</span></span><br><span class="hljs-function">        : addr_(addr)</span><br><span class="hljs-function">&#123;</span> &#125;<br><br><span class="hljs-comment">/* 根据sockaddr_in6构造InetAddress对象 */</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InetAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6&amp; addr)</span></span><br><span class="hljs-function">        : addr6_(addr)</span><br><span class="hljs-function">&#123;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="将ip地址信息转换为字符串">将IP地址信息转换为字符串</h3><p>将IP地址、端口号转换为字符串形式，这种打印log、debug的时候，是需要常用的方法，可以调用toIp(),toIpPort()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 当对象ip地址转换为字符串, 如果是IPv4, 就转换为点分十进制; 如果是IPv6, 就转换为冒号十六进制.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">InetAddress::toIp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    sockets::<span class="hljs-built_in">toIp</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-built_in">getSockAddr</span>());<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 当对象ip地址＆port信息 转换为字符串, 如果是IPv4, 就转换为点分十进制; 如果是IPv6, 就转换为冒号十六进制.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">string <span class="hljs-title">InetAddress::toIpPort</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    sockets::<span class="hljs-built_in">toIpPort</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-built_in">getSockAddr</span>());<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="将主机名或ipv4地址转换为inetaddress结构对象">将主机名或IPv4地址转换为InetAddress结构对象</h3><p>可以用InetAddress::resolve</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 转换用的临时缓存. 因为占用空间比较大, 不用函数栈; 又要确保线程安全, 有可能经常调用, 因此用thread local 变量 */</span><br><span class="hljs-type">static</span> __thread <span class="hljs-type">char</span> t_resolveBuffer[<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>]; <span class="hljs-comment">// 64KB = 64*1024</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* hostname转换为InetAddress</span><br><span class="hljs-comment">* @param hostname 主机名, 可以是本地主机名, 如&quot;localhost&quot;; 也可以是远程域名, 如&quot;google.com&quot;, &quot;192.168.0.10&quot;,</span><br><span class="hljs-comment">* @param out[out] 指向一个InetAddress对象, 存放地址信息</span><br><span class="hljs-comment">* @return 转换结果. true: 表示转换成功; false: 表示转换失败.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InetAddress::resolve</span><span class="hljs-params">(StringArg hostname, InetAddress *out)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(out != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> hent;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span>* he = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> herrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memZero</span>(&amp;hent, <span class="hljs-built_in">sizeof</span>(hent));<br><br><br>    <span class="hljs-comment">/* 将主机名或IPv4地址(点分十进制)转换为hostent结构 */</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">gethostbyname_r</span>(hostname.<span class="hljs-built_in">c_str</span>(), &amp;hent, t_resolveBuffer, <span class="hljs-built_in">sizeof</span>(t_resolveBuffer),<br>                              &amp;he, &amp;herrno);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span> &amp;&amp; he != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(he-&gt;h_addrtype == AF_INET &amp;&amp; he-&gt;h_length == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)); <span class="hljs-comment">// AF_INET: ipv4</span><br>        out-&gt;addr_.sin_addr = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">struct</span> in_addr*&gt;(he-&gt;h_addr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// error, gai_strerror(3) 能获取错误字符串信息</span><br>        <span class="hljs-keyword">if</span> (ret)<br>        &#123;<br>            LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;InetAddress::resolve&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="socketsops">SocketsOps</h3><p>SocketsOps准确来说是一个模块，而不是一个class，在sockets命名空间封装了系统底层提供的socket操作，比如socket(),bind(), listen(), accept(), connect(), close(), read(), readv(),write(), close(), shutdown()等等。</p><p>包裹函数的主要意义是为函数提供基本的出错处理，避免每次调用都要重写一次异常处理，使之更容易融入程序的框架。</p><p>我把包裹的函数分为4类：</p><ol type="1"><li>基础的sock fd操作</li><li>便于交互的转换操作</li><li>地址类型转型</li><li>协议栈信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基础的sock fd操作</span><br><br><span class="hljs-comment">/* 包裹socket(2), 创建非阻塞sockfd. 失败终止程序(LOG_SYSFATAL) */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createNonblockingOrDie</span><span class="hljs-params">(<span class="hljs-type">sa_family_t</span> family)</span></span>;<br><br><span class="hljs-comment">/* 包裹connect(2), 连接指定对端地址(addr) */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><span class="hljs-comment">/* 包裹bind(2), 绑定本地sockfd与本地ip地址addr. 失败终止程序(LOG_SYSFATAL) */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><span class="hljs-comment">/* 包裹listen(2), 监听本地sockfd. 失败终止程序(LOG_SYSFATAL) */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listenOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><span class="hljs-comment">/* 包裹accept(2)/accept4(2), 接受客户端请求连接, 返回连接sockfd */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr_in6* addr)</span></span>;<br><span class="hljs-comment">/* 包裹read(2), 从sockfd读取数据, 存放到数组buf[count] */</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-comment">/* 包裹readv(2), 从sockfd读取数据, 存放到不连续内存iov[iovcnt]中 */</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec* iov, <span class="hljs-type">int</span> iovcnt)</span></span>;<br><span class="hljs-comment">/* 包裹write(2), 将buf[count]中的数据写到sockfd连接 */</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-comment">/* 包裹close(2), 关闭sockfd */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><span class="hljs-comment">/* 包裹shutdown(8), 关闭连接写方向 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><br><span class="hljs-comment">// 便于交互的转换操作</span><br><br><span class="hljs-comment">/* 将地址addr中包含的ip地址+port信息转换为C风格字符串, 存放到数组buf[size] */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toIpPort</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><span class="hljs-comment">/* 将地址addr中包含的ip地址转换为C风格字符串, 存放到数组buf[size] */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toIp</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span>;<br><br><span class="hljs-comment">/* 将参数ip, port转换为sockaddr_in结构的addr */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in* addr)</span></span>;<br><span class="hljs-comment">/* 将参数ip, port转换为sockaddr_in6结构的addr */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in6* addr)</span></span>;<br><br><br><span class="hljs-comment">// 地址类型转型</span><br><br><span class="hljs-comment">/* const sockaddr_in转型为const sockaddr　*/</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in* addr);<br><span class="hljs-comment">/* const sockaddr_in6转型为const sockaddr　*/</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6* addr);<br><span class="hljs-comment">/* sockaddr_in6转型为sockaddr　*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* <span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-keyword">struct</span> sockaddr_in6* addr);<br><span class="hljs-comment">/* const sockaddr转型为const sockaddr_in */</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* <span class="hljs-built_in">sockaddr_in_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr);<br><span class="hljs-comment">/* const sockaddr转型为const sockaddr_in6 */</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* <span class="hljs-built_in">sockaddr_in6_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr);<br><br><span class="hljs-comment">// 协议栈信息</span><br><br><span class="hljs-comment">/* 获取tcp/ip协议栈错误 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSocketError</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br><span class="hljs-comment">/* 获取sockfd对应的本地地址 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> <span class="hljs-built_in">getLocalAddr</span>(<span class="hljs-type">int</span> sockfd);<br><span class="hljs-comment">/* 获取sockfd对应的对端地址 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> <span class="hljs-built_in">getPeerAddr</span>(<span class="hljs-type">int</span> sockfd);<br><span class="hljs-comment">/* 判断sockfd是否为自连接 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSelfConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="createnonblockingordie函数">createNonblockingOrDie()函数</h4><p>创建非阻塞sock fd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 创建一个非阻塞sock fd</span><br><span class="hljs-comment">* @param family 协议族, 可取值AF_UNIX/AF_INET/AF_INET6 etc.</span><br><span class="hljs-comment">* @return 成功, 返回sock fd; 失败, 程序终止(LOG_SYSFATAL)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::createNonblockingOrDie</span><span class="hljs-params">(<span class="hljs-type">sa_family_t</span> family)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> VALGRIND <span class="hljs-comment">// a kind of memory test tool</span></span><br>    <span class="hljs-type">int</span> sockfd = ::<span class="hljs-built_in">socket</span>(family, SOCK_STREAM, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::createNonblockingOrDie&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">setNonBlockAndCloseOnExec</span>(sockfd);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">int</span> sockfd = ::<span class="hljs-built_in">socket</span>(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::createNonblockingOrDie&quot;</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="connect函数">connect()函数</h4><p>请求连接服务器端addr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">connect</span>(sockfd, addr, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in6)));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bindordie函数">bindOrDie()函数</h4><p>绑定sock fd与本地地址addr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::bindOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = ::<span class="hljs-built_in">bind</span>(sockfd, addr, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in6)));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::bindOrDie&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="listenordie函数">listenOrDie()函数</h4><p>监听本地sockfd。如果协议支持重传（如TCP协议），那么listen第二个参数backlog会被忽略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::listenOrDie</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = ::<span class="hljs-built_in">listen</span>(sockfd, SOMAXCONN);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;sockets::listenOrDie&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="accept函数">accept函数</h4><p>接受连接请求。被包裹函数accept或accep4，其区别为：accept4一次调用能同时指定SOCK_NONBLOCK和SOCK_CLOEXEC选项；如果要用accept，则还需要额外调用setNonBlockAndCloseOnExec()，来设置sockfd的non-block、close-on-exec属性。</p><p>accept调用出错时，跟log记录错误号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* accept(2)/accept4(2)包裹函数, 接受连接并获取对端ip地址</span><br><span class="hljs-comment">* @param sockfd 服务器sock fd, 指向本地监听的套接字资源</span><br><span class="hljs-comment">* @param addr ip地址信息</span><br><span class="hljs-comment">* @return 由sockfd接收连接请求得到到连接fd</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr_in6 *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(*addr));<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> VALGRIND || defined(NO_ACCEPT4) <span class="hljs-comment">// VALGRIND: memory check tool</span></span><br>    <span class="hljs-type">int</span> connfd = ::<span class="hljs-built_in">accept</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(addr), &amp;addrlen);<br>    <span class="hljs-built_in">setNonBlockAndCloseOnExec</span>(connfd);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// set flags for conn fd returned by accept() at one time</span><br>    <span class="hljs-type">int</span> connfd = ::<span class="hljs-built_in">accept4</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(addr),<br>                           &amp;addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> savedErrno = errno;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;Socket::accept&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (savedErrno)<br>        &#123;<br>            <span class="hljs-keyword">case</span> EAGAIN:<br>            <span class="hljs-keyword">case</span> ECONNABORTED:<br>            <span class="hljs-keyword">case</span> EINTR:<br>            <span class="hljs-keyword">case</span> EPROTO:<br>            <span class="hljs-keyword">case</span> EMFILE:<br>                <span class="hljs-comment">// expected errors</span><br>                errno = savedErrno;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EBADF:<br>            <span class="hljs-keyword">case</span> EFAULT:<br>            <span class="hljs-keyword">case</span> EINVAL:<br>            <span class="hljs-keyword">case</span> ENFILE:<br>            <span class="hljs-keyword">case</span> ENOBUFS:<br>            <span class="hljs-keyword">case</span> ENOMEM:<br>            <span class="hljs-keyword">case</span> ENOTSOCK:<br>            <span class="hljs-keyword">case</span> EOPNOTSUPP:<br>                <span class="hljs-comment">// unexpected errors</span><br>                LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;unexpected error of ::accept &quot;</span> &lt;&lt; savedErrno;<br><br>            <span class="hljs-keyword">default</span>:<br>                LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;unknown error of ::accept &quot;</span> &lt;&lt; savedErrno;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> connfd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="readreadv函数">read()、readv()函数</h4><p>read直接转发给read(2)，没有特殊处理；readv直接转发给readv(2)，没有特殊处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sockets::read</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">read</span>(sockfd, buf, count);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sockets::readv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">readv</span>(sockfd, iov, iovcnt);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write函数">write()函数</h4><p>write直接转发给write(2)，没有特殊处理；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sockets::write</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">write</span>(sockfd, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="close函数">close()函数</h4><p>关闭sockfd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::close</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">close</span>(sockfd) &lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::close&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shutdownwrite函数">shutdownWrite()函数</h4><p>shutdownWrite关闭连接写方向：shutdown(2) + SHUT_WR</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::shutdownWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">shutdown</span>(sockfd, SHUT_WR) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::shutdownWrite&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="toipport-toip函数">toIpPort(), toIp()函数</h4><p>将ip地址、port信息由sockaddr对象，转换为字符串。核心调用inet_ntop(2)，将IPv4、IPv6地址由二进制转化为文本。利用snprintf，将ip地址和port文本信息组装到一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert struct sockaddr containing ip info to ip string pointed by buf</span><br><span class="hljs-comment">* @param buf [out] point to ip string buffer</span><br><span class="hljs-comment">* @param size size of buf (bytes)</span><br><span class="hljs-comment">* @param addr [in] point to struct sockaddr containing ip address and port info</span><br><span class="hljs-comment">* @note port of struct sockaddr is network byte order, but local operation needs</span><br><span class="hljs-comment">* host byte order.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::toIpPort</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (addr-&gt;sa_family == AF_INET6)<br>    &#123; <span class="hljs-comment">// IPv6</span><br>        buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;[&#x27;</span>;<br>        <span class="hljs-built_in">toIp</span>(buf + <span class="hljs-number">1</span>, size - <span class="hljs-number">1</span>, addr);<br>        <span class="hljs-type">size_t</span> end = ::<span class="hljs-built_in">strlen</span>(buf);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* addr6 = <span class="hljs-built_in">sockaddr_in6_cast</span>(addr);<br>        <span class="hljs-type">uint16_t</span> port = sockets::<span class="hljs-built_in">networkToHost16</span>(addr6-&gt;sin6_port);<br>        <span class="hljs-built_in">assert</span>(size &gt; end);<br>        <span class="hljs-built_in">snprintf</span>(buf + end, size - end, <span class="hljs-string">&quot;]:%u&quot;</span>, port);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// IPv4</span><br>    <span class="hljs-built_in">toIp</span>(buf, size, addr);<br>    <span class="hljs-type">size_t</span> end = ::<span class="hljs-built_in">strlen</span>(buf);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* addr4 = <span class="hljs-built_in">sockaddr_in_cast</span>(addr);<br>    <span class="hljs-type">uint16_t</span> port = sockets::<span class="hljs-built_in">networkToHost16</span>(addr4-&gt;sin_port);<br>    <span class="hljs-built_in">assert</span>(size &gt; end);<br>    <span class="hljs-built_in">snprintf</span>(buf + end, size - end, <span class="hljs-string">&quot;:%u&quot;</span>, port);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert IP address info from struct sockaddr to string buffer</span><br><span class="hljs-comment">* @param buf [out] string buffer with NUL-byte</span><br><span class="hljs-comment">* @param size length of string buffer</span><br><span class="hljs-comment">* @param addr [in] point to struct sockaddr, which contains ip, port info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::toIp</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (addr-&gt;sa_family == AF_INET)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(size &gt;= INET_ADDRSTRLEN);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* addr4 = <span class="hljs-built_in">sockaddr_in_cast</span>(addr);<br>        ::<span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;addr4-&gt;sin_addr, buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(size));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr-&gt;sa_family == AF_INET6)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(size &gt;= INET6_ADDRSTRLEN);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* addr6 = <span class="hljs-built_in">sockaddr_in6_cast</span>(addr);<br>        ::<span class="hljs-built_in">inet_ntop</span>(AF_INET6, &amp;addr6-&gt;sin6_addr, buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(size));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fromipport函数">fromIPPort()函数</h4><p>将ip地址、端口号文本转换为二进制（sockaddr_in/sockaddr_in6），sockaddr_in适用于IPv4，sockaddr_in6适用于IPv6。2个重载函数是toIpPort()的逆过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert ipv4 string to struct sockaddr_in</span><br><span class="hljs-comment">* @param ip ipv4 address string with format like &quot;127.0.0.1&quot;</span><br><span class="hljs-comment">* @param port local port for TCP/UDP</span><br><span class="hljs-comment">* @param addr [out] store ipv4 info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    addr-&gt;sin_family = AF_INET;<br>    addr-&gt;sin_port = <span class="hljs-built_in">hostToNetwork16</span>(port);<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;addr-&gt;sin_addr) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::fromIpPort&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* convert ipv6 string to struct socket_in6</span><br><span class="hljs-comment">* @param ip ipv6 address string with format like &quot;2409:8a4c:662f:2900:b42c:a0d9:fe5:2037&quot;</span><br><span class="hljs-comment">* @param port local port for TCP/UDP</span><br><span class="hljs-comment">* @param addr [out] store ipv6 info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sockets::fromIpPort</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip, <span class="hljs-type">uint16_t</span> port, <span class="hljs-keyword">struct</span> sockaddr_in6 *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    addr-&gt;sin6_family = AF_INET6;<br>    addr-&gt;sin6_port = <span class="hljs-built_in">hostToNetwork16</span>(port);<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">inet_pton</span>(AF_INET6, ip, &amp;addr-&gt;sin6_addr) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::fromIpPort&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="地址转型函数">地址转型函数</h4><p>提供不同地址类型之间的转型，如sockaddr_in/sockaddr_in6/sockaddr*，要求成员内存布局必须是一样的。这也是为什么前面用static_assert来断言sockaddr_in/sockaddr_in6成员偏移的原因（offsetof），因为如果成员偏移不一样，也就是说对象的内存布局不一样，通过指针直接转型是不对的。</p><div class="admonition attention"><p class="admonition-title">为什么用static_cast对指针进行转型，而不用reinterpret_cast？</p><p>单独的static_cast，是无法将一种指针类型转换为另一种指针类型的，需要先利用implicit_cast（隐式转型）/static_cast（显式转型）将指针类型转换为void/constvoid （无类型）指针，然后才能转换为模板类型指针。</p><p>而reinterpret_cast可以直接做到，但reinterpret_cast通常并不安全，编译期也不会在编译期报错，通常不推荐使用。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// const sockaddr_in6* =&gt; const sockaddr*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* sockets::<span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6* addr)<br>&#123;<br><span class="hljs-comment">//    reinterpret_cast&lt;const struct sockaddr*&gt;();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// sockaddr_in6* =&gt; sockaddr*</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* sockets::<span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-keyword">struct</span> sockaddr_in6* addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-keyword">struct</span> sockaddr*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// const sockaddr_in* =&gt; const sockaddr*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>* sockets::<span class="hljs-built_in">sockaddr_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in* addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// const sockaddr* =&gt; const sockaddr_in*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* sockets::<span class="hljs-built_in">sockaddr_in_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br><br><span class="hljs-comment">// const sockaddr* =&gt; const sockaddr_in6*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span>* sockets::<span class="hljs-built_in">sockaddr_in6_cast</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr_in6*&gt;(<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(addr));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getsocketerror函数">getSocketError()函数</h4><p>获取tcp协议栈错误。利用getsockopt +SO_ERROR选项，获取tcp协议栈内部错误。通常，在处理连接的读写事件时调用，检查是否发生错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sockets::getSocketError</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> optval;<br>    <span class="hljs-type">socklen_t</span> optlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(optval));<br><br><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getsockopt</span>(sockfd, SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen))<br>    &#123;<br>        <span class="hljs-keyword">return</span> errno;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> optval;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getlocaladdr函数">getLocalAddr()函数</h4><p>从连接获取本地ip地址（包括端口号）。不论IPv4，还是IPv6，统一存放到sockaddr_in6结构对象中，因为该对象长度最长。核心调用getsockname(2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get a local ip address from an opened sock fd</span><br><span class="hljs-comment">* @param sockfd an opened sockfd</span><br><span class="hljs-comment">* @return local ip address info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> sockets::<span class="hljs-built_in">getLocalAddr</span>(<span class="hljs-type">int</span> sockfd)<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> localaddr;<br>    <span class="hljs-built_in">memZero</span>(&amp;localaddr, <span class="hljs-built_in">sizeof</span>(localaddr));<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(localaddr));<br>    <span class="hljs-comment">// get local ip addr info bound to sockfd</span><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getsockname</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(&amp;localaddr), &amp;addrlen) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::getLocalAddr&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> localaddr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getpeeraddr函数">getPeerAddr()函数</h4><p>获取连接对端的ip地址（包括端口号）。类似于getLocalAddr，地址信息都存放到sockaddr_in6结构对象中。核心调用getpeername(2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Get a peer ip address from an opened sock fd</span><br><span class="hljs-comment">* @param sockfd an opened sockfd</span><br><span class="hljs-comment">* @return peer ip address info</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> sockets::<span class="hljs-built_in">getPeerAddr</span>(<span class="hljs-type">int</span> sockfd)<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> peeraddr;<br>    <span class="hljs-built_in">memZero</span>(&amp;peeraddr, <span class="hljs-built_in">sizeof</span>(peeraddr));<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">socklen_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(peeraddr));<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getpeername</span>(sockfd, <span class="hljs-built_in">sockaddr_cast</span>(&amp;peeraddr), &amp;addrlen))<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;sockets::getPeerAddr&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> peeraddr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="isselfconnect函数">isSelfConnect()函数</h4><p>检查是否为自连接。利用了getLocalAddr()和getPeerAddr()，检查ip地址是否相同，来判断连接对端地址信息是否为本机。</p><p>isSelfConnect()函数同样分IPv4和IPv6两种情况，依据是sockaddr_in6的sin6_family成员。</p><div class="admonition note"><p class="admonition-title">note</p><p>对于IPv4，地址sin_addr.s_addr是32bit，能用“”判断是否相等；而对于IPv6，地址sin6_addr是28byte，无法用“”判断，需要用memcmp来比较二进制位。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 检查是否为自连接, 判断连接sockfd两端ip地址信息是否相同.</span><br><span class="hljs-comment">* @param sockfd 连接对应的文件描述符</span><br><span class="hljs-comment">* @return true: 是自连接; false: 不是自连接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sockets::isSelfConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> localaddr = <span class="hljs-built_in">getLocalAddr</span>(sockfd);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> peeraddr = <span class="hljs-built_in">getPeerAddr</span>(sockfd);<br>    <span class="hljs-keyword">if</span> (localaddr.sin6_family == AF_INET)<br>    &#123; <span class="hljs-comment">// IPv4</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* laddr4 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">struct</span> sockaddr_in*&gt;(&amp;localaddr);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>* raddr4 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-keyword">struct</span> sockaddr_in*&gt;(&amp;peeraddr);<br>        <span class="hljs-keyword">return</span> laddr4-&gt;sin_port == raddr4-&gt;sin_port<br>        &amp;&amp; laddr4-&gt;sin_addr.s_addr == raddr4-&gt;sin_addr.s_addr;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (localaddr.sin6_family == AF_INET6)<br>    &#123; <span class="hljs-comment">// IPv6</span><br>        <span class="hljs-keyword">return</span> localaddr.sin6_port == peeraddr.sin6_port<br>        &amp;&amp; <span class="hljs-built_in">memcmp</span>(&amp;localaddr.sin6_addr, &amp;peeraddr.sin6_addr, <span class="hljs-built_in">sizeof</span>(localaddr.sin6_addr)) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/16048037.html">muduo笔记网络库（六）Socket类及SocketsOps库函数封装</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo-事件驱动EventLoop</title>
    <link href="/2023/07/03/muduo-EventLoop/"/>
    <url>/2023/07/03/muduo-EventLoop/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo-事件驱动eventloop">muduo-事件驱动EventLoop</h1><p>之前说过，muduo网络库处理事件是Reactor模式，one loop perthread，一个线程一个事件循环。这个循环称为EventLoop，这种以事件为驱动的编程模式，称为事件驱动模式。</p><p>这种事件驱动模型要求所有任务是非阻塞的，其典型特点是：如果一个任务需要很长时间才能完成，或者中间可能导致阻塞，就需要对任务进行分段，将其设置为非阻塞的，每次监听到前次任务完成，触发事件回调，从而接着完成后续任务。例如，要发送一个大文件，可以先发送一段，完成后，在写完成事件回调中又发送下一段，这样每次都发生一段，从而完成整个文件发送。</p><p>EventLoop是实现事件驱动模型的关键之一。核心是为线程提供运行循环，不断监听事件、处理事件，为用户提供在loop循环中运行的接口。</p><p>EventLoop事件驱动相关类图关系如下：</p><p><img src="/img/muduo/eventloop/eventloop事件驱动类图.png" /></p><p>上面的类图中有两种不同的关系表示：</p><p>聚合关系：has-a，表示拥有的关系，两种生命周期没有必然关联，可以独立存在。</p><p><img src="/img/muduo/eventloop/has-a.png" /></p><p>组合关系：contain-a，表包含的关系，是一种强聚合关系，强调整体与部分，生命周期一致。</p><p><img src="/img/muduo/eventloop/contain-a.png" /></p><h2 id="eventloop类">EventLoop类</h2><p>EventLoop是一个接口类，不宜暴露太多内部细节给客户，接口及其使用应尽量简洁。EventLoop的主要职责是：</p><ol type="1"><li>提供定时执行用户指定任务的方法，支持一次性、周期执行用户任务；</li><li>提供一个运行循环，每当Poller监听到有通道对应事件发生时，会将通道加入激活通道列表，运行循环要不断从取出激活通道，然后调用事件回调处理事件；</li><li><strong>每个EventLoop对应一个线程，不允许一对多或者多对一</strong>，提供判断当前线程是否为创建EventLoop对象的线程的方法；</li><li>允许在其他线程中调用EventLoop的public接口，但同时要确保线程安全；</li></ol><p>EventLoop类声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Reactor模式， 每个线程最多一个EventLoop (One loop per thread).</span><br><span class="hljs-comment">* 接口类, 不要暴露太多细节给客户</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span> : <span class="hljs-keyword">public</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; Functor;<br><br>    <span class="hljs-built_in">EventLoop</span>();<br>    ~<span class="hljs-built_in">EventLoop</span>(); <span class="hljs-comment">// force out-line dtor, for std::unique_ptr members.</span><br><br>    <span class="hljs-comment">/* loop循环, 运行一个死循环.</span><br><span class="hljs-comment">     * 必须在当前对象的创建线程中运行.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 退出loop循环.</span><br><span class="hljs-comment">     * 如果通过原始指针(raw pointer)调用, 不是100%线程安全;</span><br><span class="hljs-comment">     * 为了100%安全, 最好通过shared_ptr&lt;EventLoop&gt;调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Poller::poll()返回的时间, 通常意味着有数据达到.</span><br><span class="hljs-comment">     * 对于PollPoller, 是调用完poll(); 对于EPollPoller, 是调用完epoll_wait()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">pollReturnTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pollReturnTime_; &#125;<br><br>    <span class="hljs-comment">/* 获取loop循环次数 */</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> iteration_; &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在loop线程中, 立即运行回调cb.</span><br><span class="hljs-comment">     * 如果没在loop线程, 就会唤醒loop, (排队)运行回调cb.</span><br><span class="hljs-comment">     * 如果用户在同一个loop线程, cb会在该函数内运行; 否则， 会在loop线程中排队运行.</span><br><span class="hljs-comment">     * 因此, 在其他线程中调用该函数是安全的.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInLoop</span><span class="hljs-params">(Functor cb)</span></span>;<br><br>    <span class="hljs-comment">/* 排队回调cb进loop线程.</span><br><span class="hljs-comment">     * 回调cb在loop中完成polling后运行.</span><br><span class="hljs-comment">     * 从其他线程调用是安全的.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queueInLoop</span><span class="hljs-params">(Functor cb)</span></span>;<br><br>    <span class="hljs-comment">/* 排队的回调cb个数 */</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">queueSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// timers</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在指定时间点运行回调cb.</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">runAt</span><span class="hljs-params">(Timestamp time, TimerCallback cb)</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在当前时间点+delay延时后运行回调cb.</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">runAfter</span><span class="hljs-params">(<span class="hljs-type">double</span> delay, TimerCallback cb)</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 每隔interval sec周期运行回调cb.</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">runEvery</span><span class="hljs-params">(<span class="hljs-type">double</span> interval, TimerCallback cb)</span></span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 取消定时器, timerId唯一标识定时器Timer</span><br><span class="hljs-comment">     * 从其他线程调用安全.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">(TimerId timerId)</span></span>;<br><br>    <span class="hljs-comment">// internal usage</span><br><br>    <span class="hljs-comment">/* 唤醒loop线程, 没有事件就绪时, loop线程可能阻塞在poll()/epoll_wait() */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 更新Poller监听的channel, 只能在channel所属loop线程中调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span></span>;<br>    <span class="hljs-comment">/* 移除Poller监听的channel, 只能在channel所属loop线程中调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span></span>;<br>    <span class="hljs-comment">/* 判断Poller是否正在监听channel, 只能在channel所属loop线程中调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasChannel</span><span class="hljs-params">(Channel* channel)</span></span>;<br><br>    <span class="hljs-comment">// pid_t threadId() const &#123; return threadId_; &#125;</span><br>    <span class="hljs-comment">/* 断言当前线程是创建当前对象的线程, 如果不是就终止程序(LOG_FATAL) */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assertInLoopThread</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 判断前线程是否创建当前对象的线程.</span><br><span class="hljs-comment">     * threadId_是创建当前EventLoop对象时, 记录的线程tid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 判断是否有待调用的回调函数(pending functor).</span><br><span class="hljs-comment">     * 由其他线程调用runAt/runAfter/runEvery, 会导致回调入队列待调用.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">callingPendingFunctors</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> callingPendingFunctors_; &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 判断loop线程是否正在处理事件, 执行事件回调.</span><br><span class="hljs-comment">     * loop线程正在遍历,执行激活channels时, eventHandling_会置位; 其余时候, 会清除.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eventHandling</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> eventHandling_; &#125;<br>    <span class="hljs-comment">/* context_ 用于应用程序传参, 由网络库用户定义数据 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setContext</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::any&amp; context)</span></span><br><span class="hljs-function">    </span>&#123; context_ = context; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> boost::any&amp; <span class="hljs-title">getContext</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> context_; &#125;<br>    <span class="hljs-function">boost::any* <span class="hljs-title">getMutableContext</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> &amp;context_; &#125;<br><br>    <span class="hljs-comment">/* 获取当前线程的EventLoop对象指针 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> EventLoop* <span class="hljs-title">getEventLoopOfCurrentThread</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* 终止程序(LOG_FATAL), 当前线程不是创建当前EventLoop对象的线程时,</span><br><span class="hljs-comment">     * 由assertInLoopThread()调用  */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abortNotInLoopThread</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 唤醒所属loop线程, 也是wakeupFd_的事件回调 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// waked up</span><br>    <span class="hljs-comment">/* 处理pending函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPendingFunctors</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 打印激活通道的事件信息, 用于debug */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printActiveChannels</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// DEBUG</span><br><br>    <span class="hljs-keyword">typedef</span> std::vector&lt;Channel*&gt; ChannelList;<br><br>    <span class="hljs-type">bool</span> looping_;                <span class="hljs-comment">/* atomic, true表示loop循环执行中 */</span><br>    std::atomic&lt;<span class="hljs-type">bool</span>&gt; quit_;      <span class="hljs-comment">/* loop循环退出条件 */</span><br>    <span class="hljs-type">bool</span> eventHandling_;          <span class="hljs-comment">/* atomic, true表示loop循环正在处理事件回调 */</span><br>    <span class="hljs-type">bool</span> callingPendingFunctors_; <span class="hljs-comment">/* atomic, true表示loop循环正在调用pending函数 */</span><br>    <span class="hljs-type">int64_t</span> iteration_;           <span class="hljs-comment">/* loop迭代次数 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">pid_t</span> threadId_;                   <span class="hljs-comment">/* 线程id, 对象构造时初始化 */</span><br>    Timestamp pollReturnTime_;               <span class="hljs-comment">/* poll()返回时间点 */</span><br>    std::unique_ptr&lt;Poller&gt; poller_;         <span class="hljs-comment">/* 轮询器, 用于监听事件 */</span><br>    std::unique_ptr&lt;TimerQueue&gt; timerQueue_; <span class="hljs-comment">/* 定时器队列 */</span><br>    <span class="hljs-type">int</span> wakeupFd_;                           <span class="hljs-comment">/* 唤醒loop线程的eventfd */</span><br>    <span class="hljs-comment">/* 用于唤醒loop线程的channel.</span><br><span class="hljs-comment">     * 不像TimerQueue是内部类, 不应该暴露Channel给客户. */</span><br>    std::unique_ptr&lt;Channel&gt; wakeupChannel_;<br>    boost::any context_;            <span class="hljs-comment">/* 用于应用程序通过当前对象传参的变量, 由用户定义数据 */</span><br><br>    <span class="hljs-comment">/* 临时辅助变量 */</span><br>    ChannelList activeChannels_;    <span class="hljs-comment">/* 激活事件的通道列表 */</span><br>    Channel* currentActiveChannel_; <span class="hljs-comment">/* 当前激活的通道, 即正在调用事件回调的通道 */</span><br><br>    <span class="hljs-keyword">mutable</span> MutexLock mutex_;<br>    <span class="hljs-comment">/* 待调用函数列表, 存放不在loop线程的其他线程调用 runAt/runAfter/runEvery, 而要运行的函数 */</span><br>    <span class="hljs-function">std::vector&lt;Functor&gt; pendingFunctors_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>EventLoop不可拷贝，因为与之关联的不仅对象本身，还有线程以及threadlocal数据等资源。其功能主要分为下面这几大类：</p><ol type="1"><li>提供运行循环；</li><li>运行定时任务，一次性 or 周期；</li><li>处理激活通道事件；</li><li>线程安全。</li></ol><ul><li>对于1,loop()提供运行循环，quit()退出循环，iterator()查询循环次数，wakeup()用于唤醒loop线程，handleRead()读取唤醒消息;</li><li>对于2,runInLoop()在loop线程中“立即”运行一次用户任务，runAt()/runAfter()添加一次性定时任务，runEvery()添加周期定时任务，doPendingFunctors()回调所有的pending函数，vectorpendingFunctors_用于排队待处理函数到loop线程执行，queueSize()获取该vector大小；cancel()取消定时任务。</li><li>对于3,updateChannel()/removeChannel()/hasChannel()用于通道更新/移除/判断，vectoractiveChannels_存储当前所有激活的通道，currentActiveChannel_存储当前正在处理的激活通道；</li><li>对于4，isInLoopThread()/assertInLoopThread()判断/断言当前线程是创建当前EventLoop对象的线程，互斥锁mutex_用来做互斥访问需要保护数据。</li></ul><p>值得一提的是，boost::any类型的成员context_用来给用户提供利用EventLoop传数据的方式，相当于C里面的void*，用户可利用boost::any_cast进行转型。</p><h3 id="eventloop构造函数与析构函数">EventLoop构造函数与析构函数</h3><p>构造函数要点：</p><ul><li>检查当前线程是否已经创建了EventLoop对象，遇到错误就终止程序（LOG_FATAL）；</li><li>记住本对象所属线程id（threadId_）；</li></ul><p>析构函数要点：</p><ul><li>清除当前线程EventLoop指针，便于下次再创建EventLoop对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__thread EventLoop* t_loopInThisThread = <span class="hljs-number">0</span>; <span class="hljs-comment">// thread local变量, 指向当前线程创建的EventLoop对象</span><br><br>EventLoop::<span class="hljs-built_in">EventLoop</span>()<br>: <span class="hljs-built_in">looping_</span>(<span class="hljs-literal">false</span>),<br><span class="hljs-built_in">threadId_</span>(CurrentThread::<span class="hljs-built_in">tid</span>()),<br>&#123;<br>    LOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;EventLoop create &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; in thread &quot;</span> &lt;&lt; threadId_;<br>    <span class="hljs-keyword">if</span> (t_loopInThisThread) <span class="hljs-comment">// 当前线程已经包含了EventLoop对象</span><br>    &#123;<br>        LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;Another EventLoop &quot;</span> &lt;&lt; t_loopInThisThread<br>        &lt;&lt; <span class="hljs-string">&quot; exists in this thread &quot;</span> &lt;&lt; threadId_;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 当前线程尚未包含EventLoop对象</span><br>    &#123;<br>        t_loopInThisThread = <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br>EventLoop::~<span class="hljs-built_in">EventLoop</span>()<br>&#123;<br>    LOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; of thread &quot;</span> &lt;&lt; threadId_<br>    &lt;&lt; <span class="hljs-string">&quot; destructs in thread &quot;</span> &lt;&lt; CurrentThread::<span class="hljs-built_in">tid</span>();<br>    t_loopInThisThread = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>再次强调，一个线程只能有一个EventLoop对象。</p></div><p>这里通过threadlocal变量t_loopInThisThread指向创建的EventLoop对象，来确保每个线程只有一个EventLoop对象。同一个线程内，可通过static函数getEventLoopOfCurrentThread，返回该EventLoop对象指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">EventLoop *<span class="hljs-title">EventLoop::getEventLoopOfCurrentThread</span><span class="hljs-params">()</span> <span class="hljs-comment">// static</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t_loopInThisThread;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="assertinloopthread">assertInLoopThread</h3><p>有些成员函数只能在EventLoop对象所在线程调用,EventLoop提供了isInLoopThread()、assertInLoopThread()，分别用于判断、断言当前线程为创建EventLoop对象线程。</p><p>当assertInLoopThread()断言失败时，调用abortNotInLoopThread()终止程序（LOG_FATAL）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::assertInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-comment">// 断言当前线程（tid()）是调用当前EventLoop对象的持有者线程（threadId_）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">abortNotInLoopThread</span>();      <span class="hljs-comment">// 断言失败则终止程序</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventLoop::isInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 判断当前线程是否为当前EventLoop对象的持有者线程</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> threadId_ == CurrentThread::<span class="hljs-built_in">tid</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::abortNotInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-comment">// LOG_FATAL 终止程序</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_FATAL &lt;&lt; <span class="hljs-string">&quot;EventLoop::abortNotInLoopThread - EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span><br>    &lt;&lt; <span class="hljs-string">&quot; was created in threadId_ = &quot;</span> &lt;&lt; threadId_<br>    &lt;&lt; <span class="hljs-string">&quot;, current thread id = &quot;</span> &lt;&lt; CurrentThread::<span class="hljs-built_in">tid</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="loop循环">loop循环</h3><p>提供运行循环，不断监听事件、处理事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  真正的工作循环.</span><br><span class="hljs-comment">*  获得所有当前激活事件的通道，用Poller-&gt;poll()填到activeChannels_,</span><br><span class="hljs-comment">*  然后调用Channel::handleEvent()处理每个激活通道.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*  最后排队运行所有pending函数, 通常是其他线程通过loop来调用运行用户任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(!looping_);    <span class="hljs-comment">// to avoid reduplicate loop</span><br>    <span class="hljs-built_in">assertInLoopThread</span>(); <span class="hljs-comment">// to avoid new EventLoop() and loop() are not one thread</span><br>    looping_ = <span class="hljs-literal">true</span>;<br>    quit_ = <span class="hljs-literal">false</span>; <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> what if someone calls quit() before loop() ?</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; start looping&quot;</span>;<br><br>    <span class="hljs-keyword">while</span> (!quit_)<br>    &#123;<br>        activeChannels_.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清除激活事件的通道列表</span><br>        <span class="hljs-comment">// 监听所有通道, 可能阻塞线程, 所有激活事件对应通道会填入activeChannels_</span><br>        pollReturnTime_ = poller_-&gt;<span class="hljs-built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);<br>        ++iteration_; <span class="hljs-comment">// 循环次数+1</span><br>        <span class="hljs-keyword">if</span> (Logger::<span class="hljs-built_in">logLevel</span>() &lt;= Logger::TRACE)<br>        &#123;<br>            <span class="hljs-built_in">printActiveChannels</span>();<br>        &#125;<br>        <span class="hljs-comment">// TODO sort channel by priority</span><br>        <span class="hljs-comment">// 处理所有激活事件</span><br><br>        eventHandling_ = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (Channel* channel : activeChannels_)<br>        &#123;<br>            currentActiveChannel_ = channel;<br>            <span class="hljs-comment">// 通过Channel::handleEvent回调事件处理函数</span><br>            currentActiveChannel_-&gt;<span class="hljs-built_in">handleEvent</span>(pollReturnTime_);<br>        &#125;<br>        currentActiveChannel_ = <span class="hljs-literal">NULL</span>;<br>        eventHandling_ = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 运行pending函数, 由其他线程请求调用的用户任务</span><br>        <span class="hljs-built_in">doPendingFunctors</span>();<br>    &#125;<br><br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; stop looping&quot;</span>;<br>    looping_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>loop线程运行事件回调的关键是，用Poller::poll()将激活事件的通道填入通道列表activeChannels_，然后逐一调用每个通道的handleEvent，从而调用为Channel注册的事件回调来处理事件。</p><h3 id="添加更新删除通道">添加、更新、删除通道</h3><p>loop循环用来处理激活事件，用户可以用updateChannel/removeChannel更新/移除 Poller 监听的通道。</p><p>Poller类详见<ahref="https://gstarmin.github.io/2023/07/02/muduo%E5%BA%93-I-O%E5%A4%8D%E7%94%A8/">muduo库-I/O复用</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据具体poller对象, 来更新通道.</span><br><span class="hljs-comment">* 会修改poller对象监听的通道数组.</span><br><span class="hljs-comment">* @note 必须在channel所属loop线程运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    poller_-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据具体poller对象, 来删除通道.</span><br><span class="hljs-comment">* 会删除poller对象监听的通道数组.</span><br><span class="hljs-comment">* @note 如果待移除通道正在激活事件队列, 应该先从激活事件队列中移除</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">if</span> (eventHandling_)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(currentActiveChannel_ == channel ||<br>        std::<span class="hljs-built_in">find</span>(activeChannels_.<span class="hljs-built_in">begin</span>(), activeChannels_.<span class="hljs-built_in">end</span>(), channel) == activeChannels_.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    poller_-&gt;<span class="hljs-built_in">removeChannel</span>(channel);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可用hasChannel来判断Poller是否正在监听channel。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 判断poller是否正在监听通道channel</span><br><span class="hljs-comment">* @note 必须在channel所属loop线程运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventLoop::hasChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-keyword">return</span> poller_-&gt;<span class="hljs-built_in">hasChannel</span>(channel);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定时任务">定时任务</h3><p>EventLoop提供了runAt、runAfter、runEvery三个函数，用于在指定时间点、延迟时间、周期性时间运行用户任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能，由用户指定绝对时间</span><br><span class="hljs-comment">* @details 每为定时器队列timerQueue添加一个Timer,</span><br><span class="hljs-comment">* timerQueue内部就会新建一个Timer对象, TimerId就保含了这个对象的唯一标识(序列号)</span><br><span class="hljs-comment">* @param time 时间戳对象, 单位1us</span><br><span class="hljs-comment">* @param cb 超时回调函数. 当前时间超过time代表时间时, EventLoop就会调用cb</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAt</span><span class="hljs-params">(Timestamp time, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户相对时间, 通过runAt实现</span><br><span class="hljs-comment">* @param delay 相对时间, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAfter</span><span class="hljs-params">(<span class="hljs-type">double</span> delay, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), delay))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">runAt</span>(time, std::<span class="hljs-built_in">move</span>(cb));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户指定周期, 重复运行</span><br><span class="hljs-comment">* @param interval 运行周期, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runEvery</span><span class="hljs-params">(<span class="hljs-type">double</span> interval, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), interval))</span></span>;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, interval);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 取消指定定时器</span><br><span class="hljs-comment">* @param timerId Timer id, 唯一对应一个Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::cancel</span><span class="hljs-params">(TimerId timerId)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">cancel</span>(timerId);<br>&#125;<br></code></pre></td></tr></table></figure><p>用户运行一个loop线程，并添加定时任务示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(EventLoop::<span class="hljs-built_in">getEventLoopOfCurrentThread</span>() == <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 断言当前线程没有创建EventLoop对象</span><br>    EventLoop loop; <span class="hljs-comment">// 创建EventLoop对象</span><br>    <span class="hljs-built_in">assert</span>(EventLoop::<span class="hljs-built_in">getEventLoopOfCurrentThread</span>() == &amp;loop); <span class="hljs-comment">// 断言当前线程创建了EventLoop对象</span><br>    loop.<span class="hljs-built_in">runAfter</span>(<span class="hljs-number">1.0</span>, callback); <span class="hljs-comment">// 1sec后运行callback</span><br>    loop.<span class="hljs-built_in">loop</span>(); <span class="hljs-comment">// 启动loop循环</span><br>&#125;<br></code></pre></td></tr></table></figure><h3id="runinloop与queueinloop执行用户任务">runInLoop与queueInLoop执行用户任务</h3><p>同样是运行用户任务函数，runInLoop和queueInLoop都可以被多个线程执行，分为2种情况：1）如果当前线程是创建当前EventLoop对象的线程，那么立即执行用户任务；2）如果不是，那么在loop循环中排队执行（本次循环末尾），实际上这点也是由queueInLoop完成的。</p><p>queueInLoop只做了runInLoop的第2）种情况的工作，也就是只会在loop循环中排队执行用户任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行用户任务</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 可以被多个线程执行：</span><br><span class="hljs-comment">* 如果当前线程是创建当前EventLoop对象的线程，直接执行；</span><br><span class="hljs-comment">* 否则，用户任务函数入队列pendingFunctors_成为一个pending functor，在loop循环中排队执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::runInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInLoopThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">cb</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 排队进入pendingFunctors_，等待执行</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 如果当前线程不是创建当前EventLoop对象的线程 或者正在调用pending functor，</span><br><span class="hljs-comment">* 就唤醒loop线程，避免loop线程阻塞.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::queueInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        pendingFunctors_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || callingPendingFunctors_)<br>    &#123;<br>        <span class="hljs-built_in">wakeup</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要对pendingFunctors_加锁？</strong></p><p>因为queueInLoop可以被多个线程访问，意味着pendingFunctors_也能被多个线程访问，加锁确保线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行用户任务</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 可以被多个线程执行：</span><br><span class="hljs-comment">* 如果当前线程是创建当前EventLoop对象的线程，直接执行；</span><br><span class="hljs-comment">* 否则，用户任务函数入队列pendingFunctors_成为一个pending functor，在loop循环中排队执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::runInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInLoopThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">cb</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 排队进入pendingFunctors_，等待执行</span><br><span class="hljs-comment">* @param cb 用户任务函数</span><br><span class="hljs-comment">* @note 如果当前线程不是创建当前EventLoop对象的线程 或者正在调用pending functor，</span><br><span class="hljs-comment">* 就唤醒loop线程，避免loop线程阻塞.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::queueInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        pendingFunctors_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(cb));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || callingPendingFunctors_)<br>    &#123;<br>        <span class="hljs-built_in">wakeup</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个问题：</p><ul><li>为什么要唤醒 EventLoop？</li><li>wakeup 是怎么实现的?</li><li>pendingFunctors_是如何被消费的?</li></ul><p><strong>为什么要唤醒 EventLoop</strong>:</p><p>我们首先调用了 pendingFunctors_.push_back(cb), 将该函数放在pendingFunctors_中。EventLoop::loop 的每一轮循环在最后会调用doPendingFunctors 依次执行这些函数。</p><p>而 EventLoop 的唤醒是通过 Poller::poll()中调用poll()/epoll_wait()实现的，如果此时该 EventLoop 中迟迟没有事件触发，那么poll()/epoll_wait() 一直就会阻塞。这样会导致，pendingFunctors_中的任务迟迟不能被执行了。</p><p>所以必须要唤醒 EventLoop，从而让pendingFunctors_中的任务尽快被执行。</p><p><strong>wakeup 是怎么实现的</strong>:</p><p>muduo 这里采用了对 eventfd 的读写来实现对 EventLoop 的唤醒。</p><p>在 EventLoop 建立之后，就创建一个 eventfd，并将其可读事件注册到EventLoop 中。</p><p>wakeup() 的过程本质上是对这个 eventfd 进行写操作，以触发该 eventfd的可读事件。这样就起到了唤醒 EventLoop 的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>  sockets::<span class="hljs-built_in">write</span>(wakeupFd_, &amp;one, <span class="hljs-keyword">sizeof</span> one);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多库为了兼容 macOS，往往使用 pipe 来实现这个功能。muduo 采用了eventfd，性能更好些，但代价是不能支持 macOS 了。但是muduo似乎从一开始的定位就只支持 Linux。</p><p><strong>pendingFunctors_是如何被消费的</strong>：</p><p>下面讲下 doPendingFunctors 的实现，muduo是如何处理这些待处理的函数的，以及中间用了哪些优化操作。</p><p>代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::doPendingFunctors</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::vector&lt;Functor&gt; functors;<br><br>  callingPendingFunctors_ = <span class="hljs-literal">true</span>;<br><br>  &#123;<br>  <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>  functors.<span class="hljs-built_in">swap</span>(pendingFunctors_);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; functors.<span class="hljs-built_in">size</span>(); ++i)<br>  &#123;<br>    functors[i]();<br>  &#125;<br>  callingPendingFunctors_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行代码中却有两个非常巧妙的地方。</p><ol type="1"><li>callingPendingFunctors_的作用</li></ol><p>从代码可以看出，如果 callingPendingFunctors_为false，则说明此时尚未开始执行 doPendingFunctors 函数。</p><p>这个有什么作用呢，我们需要结合下 queueInLoop 中，对是否执行 wakeup()的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || callingPendingFunctors_)<br>&#123;<br>  <span class="hljs-built_in">wakeup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还需要结合下 EventLoop 循环的实现，其中 doPendingFunctors() 是每轮循环的最后一步处理。</p><p>如果调用 queueInLoop 和 EventLoop 在同一个线程，且callingPendingFunctors_为 false 时，则说明：此时尚未执行到doPendingFunctors()。</p><p>那么此时即使不用 wakeup，也可以在之后照旧执行 doPendingFunctors()了。</p><p>这么做的好处非常明显，可以减少对 eventfd 的 IO 读写。</p><ol start="2" type="1"><li>锁范围的减小</li></ol><p>在此函数中，有一段特别的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;Functor&gt; functors;<br>&#123;<br>  <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>  functors.<span class="hljs-built_in">swap</span>(pendingFunctors_);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个作用是 pendingFunctors_和 functors 的内容进行交换，实际上就是此时functors 持有了 pendingFunctors_的内容，而pendingFunctors_被清空了。</p><p>这个好处是什么呢？ 如果不这么做，直接遍历 pendingFunctors_,然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop将不可用。</p><p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是 swap那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用queueInLoop。</p><h4 id="eventfd唤醒线程">eventfd唤醒线程</h4><p>eventfd是Linux（Linux2.6以后）特有的，专用于事件通知的机制，类似于管道（pipe）、域套接字（UNIXDomain Socket）。</p><p>创建eventfd 函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-comment">/* 创建一个文件描述符(event fd), 用于事件通知 </span><br><span class="hljs-comment"> *  initval 计数初值</span><br><span class="hljs-comment"> * flags 标志位, 如果没用到可设为0, 也可以用以下选项 按位或 取值: </span><br><span class="hljs-comment"> *     EFD_CLOEXEC 为新建的fd设置close-on-exec(FD_CLOEXEC), 等效于以O_CLOEXEC方式open(2)</span><br><span class="hljs-comment"> *     EFD_NONBLOCK 等效于fcntl(2)设置O_NONBLOCK</span><br><span class="hljs-comment"> *     EFD_SEMAPHORE 将eventfd当信号量一样调用, read 将导致计数-1, write 将导致计数+1; 如果没指定该标志, read将返回8byte计数值, 且计数值归0, write将计数值+指定值.</span><br><span class="hljs-comment"> * 返回 新建的fd, 用于事件通知, 绑定到一个eventfd对象; 失败, 返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eventfd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> initval, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>创建完event fd后，可用read()读取eventfd，如果fd是阻塞的，read可能阻塞线程；如果eventfd设置了EFD_NONBLOCK，read返回EAGIAN错误。直到另外一个线程对eventfd进行write。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为wakeupChannel_设置读回调</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;EventLoop::handleRead, <span class="hljs-keyword">this</span>));<br><span class="hljs-comment">// we are always reading the wakeupfd</span><br><span class="hljs-comment">// 使能wakeupChannel_读事件</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">enableReading</span>();<br></code></pre></td></tr></table></figure><p>eventfd使用示例：</p><p>线程1阻塞等待，线程2唤醒线程1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_FORMAT_MACROS <span class="hljs-comment">// for 跨平台打印</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_func1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> <span class="hljs-comment">/* 等待线程 */</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> wakeupfd = *(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func1 start\n&quot;</span>);<br>    <span class="hljs-type">uint64_t</span> rdata;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">read</span>(wakeupfd, &amp;rdata, <span class="hljs-built_in">sizeof</span>(rdata));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;thread_func1 read error&quot;</span>);<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func1 success to be waked up, rdata = %&quot;</span> PRId64 <span class="hljs-string">&quot;\n&quot;</span>, rdata);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">thread_func2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> <span class="hljs-comment">/* 唤醒线程 */</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> wakeupfd = *(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func2 ready to sleep 1 sec\n&quot;</span>);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">uint64_t</span> wdata = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">write</span>(wakeupfd, &amp;wdata, <span class="hljs-built_in">sizeof</span>(wdata));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;thread_func2 write error&quot;</span>);<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_func2 success to wake up another thread, wdata = %&quot;</span> PRId64 <span class="hljs-string">&quot;\n&quot;</span>, wdata);<br>&#125;<br><br><span class="hljs-comment">/* 创建2个线程，thread_func1阻塞等待eventfd，thread_func2唤醒等等eventfd的线程 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> evfd = <span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (evfd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;eventfd error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">pthread_t</span> th1, th2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;th1, <span class="hljs-literal">NULL</span>, thread_func1, (<span class="hljs-type">void</span>*)&amp;evfd);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;th2, <span class="hljs-literal">NULL</span>, thread_func2, (<span class="hljs-type">void</span>*)&amp;evfd);<br>    <span class="hljs-built_in">pthread_join</span>(th1, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(th2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="eventloop使用eventfd唤醒loop线程">EventLoop使用eventfd唤醒loop线程</h3><ol type="1"><li>创建event fd</li></ol><p>构造函数中，wakeupFd_ 初值为createEventfd()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createEventfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> evtfd = ::<span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (evtfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSERR &lt;&lt; <span class="hljs-string">&quot;Failed in eventfd&quot;</span>;<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> evtfd;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>绑定event fd与唤醒通道wakeupChannel_,利用eventfd构造一个Channel对象后，传递给wakeupChannel_，便于Poller监听、事件回调</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为wakeupChannel_设置读回调</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;EventLoop::handleRead, <span class="hljs-keyword">this</span>));<br><span class="hljs-comment">// we are always reading the wakeupfd</span><br><span class="hljs-comment">// 使能wakeupChannel_读事件</span><br>wakeupChannel_-&gt;<span class="hljs-built_in">enableReading</span>();<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>启动loop循环，可能阻塞在poll()/epoll_wait()</li><li>其他线程通过queueInLoop()调用wakeup()，唤醒阻塞的loop线程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 其他线程唤醒等待在wakeupFd_上的线程, 产生读就绪事件.</span><br><span class="hljs-comment">* @note write将添加8byte数据到内部计数器. 被唤醒线程必须调用read读取8byte数据.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = sockets::<span class="hljs-built_in">write</span>(wakeupFd_, &amp;one, <span class="hljs-built_in">sizeof</span>(one));<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">sizeof</span>(one))<br>    &#123;<br>        LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;EventLoop::wakeup() writes &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; bytes instead of 8&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>loop线程被唤醒后，读取event fd</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理wakeupChannel_读事件</span><br><span class="hljs-comment">* @note read wakeupfd_</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = sockets::<span class="hljs-built_in">read</span>(wakeupFd_, &amp;one, <span class="hljs-built_in">sizeof</span>(one));<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">sizeof</span>(one))<br>    &#123;<br>        LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;EventLoop::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; bytes instead of 8&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://www.cnblogs.com/fortunely/p/16127237.html">muduo笔记网络库（五）事件循环EventLoop</a></li><li><a href="https://www.cyhone.com/articles/analysis-of-muduo/">muduo源码剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-TimerQueue定时器队列</title>
    <link href="/2023/07/02/muduo%E5%BA%93-TimerQueue%E5%AE%9A%E6%97%B6%E5%99%A8%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/02/muduo%E5%BA%93-TimerQueue%E5%AE%9A%E6%97%B6%E5%99%A8%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-timerqueue定时器队列">muduo库-TimerQueue定时器队列</h1><p>网络编程中，有一类非常重要的事件，跟IO事件没有直接联系，而是内部产生的事件，即定时事件。</p><p>muduo网络库中的定时功能是如何实现的呢？传统的Reactor通过控制select和poll的等待时间，来实现定时，而Linux中，可以用timerfd来实现。前面讲过，timerfd是Linux特有的定时器，能有效融入select/poll/epoll框架，来做超时事件处理。</p><h2 id="timerfd简要介绍">timerfd简要介绍</h2><p>timerfd的特点是有一个与之关联fd，可绑定Channel，交由Poller监听感兴趣的事件（读、写等）。</p><p>timerfd 3个接口：timerfd_create，timerfd_settime，timerfd_gettime。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/timerfd.h&gt;</span></span><br><br><span class="hljs-comment">/* 创建一个定时器对象, 返回与之关联的fd</span><br><span class="hljs-comment">* clockid 可指定为CLOCK_REALTIME（系统范围时钟）或CLOCK_MONOTONIC（不可设置的时钟，不能手动修改）</span><br><span class="hljs-comment">* flags 可指定为TFD_NONBLOCK（为fd设置O_NONBLOCK），TFD_CLOEXEC（为fd设置close-on-exec）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">timerfd_create</span><span class="hljs-params">(<span class="hljs-type">int</span> clockid, <span class="hljs-type">int</span> flags)</span></span>;<br><br><span class="hljs-comment">/* 启动或停止绑定到fd的定时器</span><br><span class="hljs-comment"> * flags 指定0：启动一个相对定时器，由new_value-&gt;it_value指定相对定时值；TFD_TIMER_ABSTIME启动一个绝对定时器，由new_value-&gt;it_value指定定时值</span><br><span class="hljs-comment"> * old_value 保存旧定时值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">timerfd_settime</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> flags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerspec *new_value, <span class="hljs-keyword">struct</span> itimerspec *old_value)</span></span>;<br><br><span class="hljs-comment">/* 获取fd对应定时器的当前时间值  */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">timerfd_gettime</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> itimerspec *curr_value)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="定时功能相关类">定时功能相关类</h2><p>muduo库中，定时相关功能由3个class实现：TimerID、Timer、TimerQueue。用户可见的只有TimerId。</p><p>Timestamp类是时间戳类，用来保存超时时刻（精确到1us），保存的是UTC时间，即从Unix Epoch（1970-01-01 00:00:00）到指定时间的微秒数。</p><p>Timer类对应一个超时任务，保存了超时时刻Timestamp，超时回调函数，以及超时任务类型（一次or 周期）。</p><p>TimerId类用于保存Timer对象，以及独一无二的id。</p><p>TimerQueue类用于设置所有超时任务（Timer），需要高效组织尚未到期的Timer，快速查找已到期Timer，以及高效添加和删除Timer。TimerQueue用std::set存储，set会对Timer按到期时间先后顺序进行二叉搜索树排序，时间复杂度O(logN)。</p><p>TimerQueue的定时接口并不是直接暴露给库的使用者的，而是通过EventLoop的runAfter和runEvery来运行用户任务的。其中，runAfter延迟固定秒数后运行一次指定用户任务；runEvery延迟固定秒数后运行用户任务，后续以指定周期运行用户任务。</p><p>TimerQueue回调用户代码onTimer()的时序：</p><p><img src="/img/muduo/定时器/定时器时序图.png" /></p><p>时序图里的TimerQueue获取超时Timer（getExpired()）后，User及onTimer()是指用户自定义的超时处理函数，并非库本身的。</p><p>与普通Channel事件一样，超时任务TimerQueue也会使用一个Channel，专门用于绑定timerfd，交由Poller监听，发生可读事件（代表超时）后加入激活通道列表，然后EventLoop::loop()逐个Channel调用对应的回调，从而处理超时事件。</p><div class="admonition note"><p class="admonition-title">note</p><p>一个EventLoop只持有一个TimerQueue对象，而TimerQueue通过std::set持有多个Timer对象，但只会设置一个Channel。</p></div><h2 id="timer类">Timer类</h2><p>Timer类代表一个超时任务，但并不直接绑定Channel。Timer主要包含超时时刻（expiration_），超时回调（callback_），周期时间值（interval_），全局唯一id（sequence_）。</p><p>其声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用于定时事件的内部类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Timer</span>(TimerCallback cb, Timestamp when, <span class="hljs-type">double</span> interval)<br>    : <span class="hljs-built_in">callback_</span>(std::<span class="hljs-built_in">move</span>(cb)),<br>    <span class="hljs-built_in">expiration_</span>(when),<br>    <span class="hljs-built_in">interval_</span>(interval),<br>    <span class="hljs-built_in">repeat_</span>(interval &gt; <span class="hljs-number">0.0</span>),<br>    <span class="hljs-built_in">sequence_</span>(s_numCreated_.<span class="hljs-built_in">incrementAndGet</span>())<br>    &#123; &#125;<br>    <span class="hljs-comment">/* 运行超时回调函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">callback_</span>();<br>    &#125;<br>    <span class="hljs-comment">/* 返回超时时刻 */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">expiration</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> expiration_; &#125;<br>    <span class="hljs-comment">/* 周期重复标志 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> repeat_; &#125;<br>    <span class="hljs-comment">/* 全局唯一序列号, 用来表示当前Timer对象 */</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">sequence</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sequence_; &#125;<br>    <span class="hljs-comment">/* 重启定时器, 只对周期Timer有效(repeat_为true) */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">(Timestamp now)</span></span>;<br>    <span class="hljs-comment">/* 当前创建的Timer对象个数, 每新建一个Timer对象就会自增1 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int64_t</span> <span class="hljs-title">numCreated</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> s_numCreated_.<span class="hljs-built_in">get</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> TimerCallback callback_; <span class="hljs-comment">/* 超时回调 */</span><br>    Timestamp expiration_;         <span class="hljs-comment">/* 超时时刻 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> interval_;        <span class="hljs-comment">/* 周期时间, 单位秒, 可用来结合基础时刻expiration_, 计算新的时刻 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> repeat_;            <span class="hljs-comment">/* 重复标记. true: 周期Timer; false: 一次Timer */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> sequence_;       <span class="hljs-comment">/* 全局唯一序列号 */</span><br><br>    <span class="hljs-comment">// global increasing number, atomic. help to identify different Timer</span><br>    <span class="hljs-type">static</span> AtomicInt64 s_numCreated_; <span class="hljs-comment">/* 类变量, 创建Timer对象的个数, 用来实现全局唯一序列号 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每当创建一个新Timer对象时，原子变量s_numCreated_就会自增1，作为全剧唯一序列号sequence_，用来标识该Timer对象。</p><h3 id="周期timer">周期Timer</h3><p>创建Timer时，超时时刻when决定了回调超时事件时间点，而interval决定了Timer是一次性的，还是周期性的。如果是周期性的，会在TimerQueue::reset中，调用Timer::restart，在当前时间点基础上，重启定时器。</p><h3 id="restart函数">restart函数</h3><p>restart重启Timer，根据Timer是否为周期类型，分为两种情况：</p><ol type="1"><li>周期Timer，restart将重置超时时刻expiration_为当前时间 +周期间隔时间；</li><li>非周期Timer，即一次性Timer，将restart将expiration_置为无效时间（默认自UTCEpoch以来的微妙数为0）；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Timer::restart</span><span class="hljs-params">(Timestamp now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (repeat_)<br>    &#123;<br>        expiration_ = <span class="hljs-built_in">addTime</span>(now, interval_);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        expiration_ = Timestamp::<span class="hljs-built_in">invalid</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="timerid类">TimerId类</h2><p>TimerId来主要用来作为Timer的唯一标识，用于取消（canceling）Timer。</p><p>TimerId类声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* An opaque identifier, for canceling Timer.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerId</span> : <span class="hljs-keyword">public</span> muduo::copyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimerId</span>()<br>    : <span class="hljs-built_in">timer_</span>(<span class="hljs-literal">NULL</span>),<br>    <span class="hljs-built_in">sequence_</span>(<span class="hljs-number">0</span>)<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">TimerId</span>(Timer* timer, <span class="hljs-type">int64_t</span> seq)<br>    : <span class="hljs-built_in">timer_</span>(timer),<br>    <span class="hljs-built_in">sequence_</span>(seq)<br>    &#123; &#125;<br><br>    <span class="hljs-comment">// default copy-ctor, dtor and assignment are okay</span><br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerQueue</span>;<br><br><span class="hljs-keyword">private</span>:<br>    Timer* timer_;<br>    <span class="hljs-type">int64_t</span> sequence_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：TimerId并不直接生成Timer序列号sequence_，这是由Timer来生成的，通过构造函数传递给TimerId。而生成Timer标识的方式，在Timer类介绍中也提到过，只需要创建一个Timer对象即可，然后通过Timer::sequence()方法就可以取得该序列号。</p><h2 id="timerqueue类">TimerQueue类</h2><p>定时器队列TimerQueue是定时功能的核心，由所在EventLoop持有，绑定一个Channel，同时维护多个定时任务（Timer）。为用户（EventLoop）提供添加定时器（addTimer）、取消定时器（cancel）接口。</p><p><strong>同样是定时，TimerQueue与Timer有什么区别？</strong></p><p>TimerQueue包含2个Timer集合：</p><ol type="1"><li>timers_定时器集合：包含用户添加的所有Timer对象，std::set会用AVL搜索树，对集合元素按时间戳（Timestamp）从小到大顺序；</li><li>activeTimers_激活定时器集合：包含激活的Timer对象，与timers_包含的Timer对象相同，个数也相同，std::set会根据Timer*指针大小，对元素进行排序；</li><li>cancelingTimers_取消定时器集合：包含所有取消的Timer对象，与activeTimers_相对。</li></ol><p>注意：timers_和activeTimers_的类型并不相同，只是包含的Timer*相同。cancelingTimers_和activeTimers_的类型相同。</p><p>这也是TimerQueue并非Timer的原因，<strong>TimerQueue是一个Timer集合，根据其时间戳大小进行排序，更像是一个队列，先到期的先触发超时事件。因此，可称为Timer队列，即TimerQueue</strong>。</p><p>调用TimerQueue::addTimer的，只有EventLoop中这3个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能，由用户指定绝对时间</span><br><span class="hljs-comment">* @details 每为定时器队列timerQueue添加一个Timer,</span><br><span class="hljs-comment">* timerQueue内部就会新建一个Timer对象, TimerId就保含了这个对象的唯一标识(序列号)</span><br><span class="hljs-comment">* @param time 时间戳对象, 单位1us</span><br><span class="hljs-comment">* @param cb 超时回调函数. 当前时间超过time代表时间时, EventLoop就会调用cb</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAt</span><span class="hljs-params">(Timestamp time, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户相对时间, 通过runAt实现</span><br><span class="hljs-comment">* @param delay 相对时间, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runAfter</span><span class="hljs-params">(<span class="hljs-type">double</span> delay, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), delay))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">runAt</span>(time, std::<span class="hljs-built_in">move</span>(cb));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时功能, 由用户指定周期, 重复运行</span><br><span class="hljs-comment">* @param interval 运行周期, 单位s, 精度1us(小数)</span><br><span class="hljs-comment">* @param cb 超时回调</span><br><span class="hljs-comment">* @return 一个绑定timerQueue内部新增的Timer对象的TimerId对象, 用来唯一标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">EventLoop::runEvery</span><span class="hljs-params">(<span class="hljs-type">double</span> interval, TimerCallback cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">time</span><span class="hljs-params">(addTime(Timestamp::now(), interval))</span></span>;<br>    <span class="hljs-keyword">return</span> timerQueue_-&gt;<span class="hljs-built_in">addTimer</span>(std::<span class="hljs-built_in">move</span>(cb), time, interval);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是TimerQueue中，3个集合相关的类型及成员定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;<br><span class="hljs-keyword">typedef</span> std::set&lt;Entry&gt; TimerList;<br><span class="hljs-keyword">typedef</span> std::pair&lt;Timer*, <span class="hljs-type">int64_t</span>&gt; ActiveTimer;<br><span class="hljs-keyword">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;<br><br><span class="hljs-comment">// Timer list sorted by expiration</span><br><span class="hljs-comment">/* 用户添加的所有Timer对象集合</span><br><span class="hljs-comment"> * 需要为set元素比较实现operator&lt; */</span><br>TimerList timers_;<br><br><span class="hljs-comment">// for cancel()</span><br>ActiveTimerSet activeTimers_;<br><span class="hljs-type">bool</span> callingExpiredTimers_; <span class="hljs-comment">/* atomic */</span><br>ActiveTimerSet cancelingTimers_;<br></code></pre></td></tr></table></figure><p>下面是TimerQueue中，3个集合相关的类型及成员定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;<br><span class="hljs-keyword">typedef</span> std::set&lt;Entry&gt; TimerList;<br><span class="hljs-keyword">typedef</span> std::pair&lt;Timer*, <span class="hljs-type">int64_t</span>&gt; ActiveTimer;<br><span class="hljs-keyword">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;<br><br><span class="hljs-comment">// Timer list sorted by expiration</span><br><span class="hljs-comment">/* 用户添加的所有Timer对象集合</span><br><span class="hljs-comment"> * 需要为set元素比较实现operator&lt; */</span><br>TimerList timers_;<br><br><span class="hljs-comment">// for cancel()</span><br>ActiveTimerSet activeTimers_;<br><span class="hljs-type">bool</span> callingExpiredTimers_; <span class="hljs-comment">/* atomic */</span><br>ActiveTimerSet cancelingTimers_;<br></code></pre></td></tr></table></figure><h3 id="timerqueue声明">TimerQueue声明</h3><p>除了前面提到的3个集合相关类型及成员，其他成员函数和变量声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时器队列.</span><br><span class="hljs-comment">* 不能保证回调能及时调用.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 只能在所在loop线程中运行, 因此线程安全是非必须的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerQueue</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TimerQueue</span><span class="hljs-params">(EventLoop* loop)</span></span>;<br>    ~<span class="hljs-built_in">TimerQueue</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 添加一个定时器.</span><br><span class="hljs-comment">     * 运行到指定时间， 调度相应的回调函数.</span><br><span class="hljs-comment">     * 如果interval参数 &gt; 0.0, 就周期重复运行.</span><br><span class="hljs-comment">     * 必须线程安全: 可能会由其他线程调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TimerId <span class="hljs-title">addTimer</span><span class="hljs-params">(TimerCallback cb, Timestamp when, <span class="hljs-type">double</span> interval)</span></span>;<br>    <span class="hljs-comment">/* 取消指定TimerId的定时器 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">(TimerId)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTimerInLoop</span><span class="hljs-params">(Timer* timer)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancelInLoop</span><span class="hljs-params">(TimerId timerId)</span></span>;<br>    <span class="hljs-comment">// called when timerfd alarms</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// move out all expired timers</span><br>    <span class="hljs-function">std::vector&lt;Entry&gt; <span class="hljs-title">getExpired</span><span class="hljs-params">(Timestamp now)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(Timer* timer)</span></span>;<br><br>    EventLoop* loop_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> timerfd_;<br>    Channel timerfdChannel_; <span class="hljs-comment">// watch readable event of timerfd</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerQueue所属EventLoop对象，通过一个EventLoop*来传递，注意这是一个rawpointer，而非smartpointer。EventLoop对象与TimerQueue对象生命周期相同，而且只会通过EventLoop对象来调用TimerQueue对象方法，因此不存在与之相关的内存泄漏或非法访问的问题。</p><h3 id="timerqueue构造函数">TimerQueue构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TimerQueue::<span class="hljs-built_in">TimerQueue</span>(EventLoop *loop)<br>: <span class="hljs-built_in">loop_</span>(loop),<br><span class="hljs-built_in">timerfd_</span>(<span class="hljs-built_in">createTimerfd</span>()),<br><span class="hljs-built_in">timerfdChannel_</span>(loop, timerfd_),<br><span class="hljs-built_in">timers_</span>(),<br><span class="hljs-built_in">callingExpiredTimers_</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>    timerfdChannel_.<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">// we are always reading the timerfd, we disrm it with timerfd_settime.</span><br>    timerfdChannel_.<span class="hljs-built_in">enableReading</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>构造TimerQueue对象时，就会绑定TimerQueue所属EventLoop，即创建TimerQueue的EventLoop对象。另外，调用Channel::enableReading()，会将通道事件加入Poller的监听通道列表中。</p><p>交给Poller监听的timerfd，是由createTimerfd创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createTimerfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// create timers that notify via fd</span><br>    <span class="hljs-type">int</span> timerfd = ::<span class="hljs-built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (timerfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in timerfd_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> timerfd;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造TimerQueue对象时，就会绑定TimerQueue所属EventLoop，即创建TimerQueue的EventLoop对象。另外，调用Channel::enableReading()，会将通道事件加入Poller的监听通道列表中。</p><p>交给Poller监听的timerfd，是由createTimerfd创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createTimerfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// create timers that notify via fd</span><br>    <span class="hljs-type">int</span> timerfd = ::<span class="hljs-built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (timerfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in timerfd_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> timerfd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerqueue构造函数-1">TimerQueue构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TimerQueue::<span class="hljs-built_in">TimerQueue</span>(EventLoop *loop)<br>: <span class="hljs-built_in">loop_</span>(loop),<br><span class="hljs-built_in">timerfd_</span>(<span class="hljs-built_in">createTimerfd</span>()),<br><span class="hljs-built_in">timerfdChannel_</span>(loop, timerfd_),<br><span class="hljs-built_in">timers_</span>(),<br><span class="hljs-built_in">callingExpiredTimers_</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>    timerfdChannel_.<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">// we are always reading the timerfd, we disrm it with timerfd_settime.</span><br>    timerfdChannel_.<span class="hljs-built_in">enableReading</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>构造TimerQueue对象时，就会绑定TimerQueue所属EventLoop，即创建TimerQueue的EventLoop对象。另外，调用Channel::enableReading()，会将通道事件加入Poller的监听通道列表中。</p><p>交给Poller监听的timerfd，是由createTimerfd创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createTimerfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// create timers that notify via fd</span><br>    <span class="hljs-type">int</span> timerfd = ::<span class="hljs-built_in">timerfd_create</span>(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (timerfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in timerfd_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> timerfd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerqueue析构">TimerQueue析构</h3><p>析构有2点需要注意：</p><ol type="1"><li>在remove绑定的通道前，要先disableAll停止监听所有通道事件；</li><li>timers_中Timer对象是在TimerQueue::addTimer中new出来的，需要手动delete；</li></ol><!-- 另外，对注释"do not remove channel, since we're in EventLoop::dtor();"并不明白是何用意。 --><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TimerQueue::~<span class="hljs-built_in">TimerQueue</span>()<br>&#123;<br>    <span class="hljs-comment">// 关闭所有(通道)事件, Poller不再监听该通道</span><br>    timerfdChannel_.<span class="hljs-built_in">disableAll</span>();<br>    <span class="hljs-comment">// 如果正在处理该通道, 会从激活的通道列表中移除, 同时Poller不再监听该通道</span><br>    timerfdChannel_.<span class="hljs-built_in">remove</span>();<br>    <span class="hljs-comment">// 关闭通道对应timerfd</span><br>    ::<span class="hljs-built_in">close</span>(timerfd_);<br><br>    <span class="hljs-comment">// do not remove channel, since we&#x27;re in EventLoop::dtor();</span><br><br>    <span class="hljs-comment">// TimerQueue::addTimer中new出来的Timer对象, 需要手动delete</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; timer : timers_)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> timer.second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timerqueue重要接口">TimerQueue重要接口</h3><h4 id="addtimer-添加定时器">addTimer 添加定时器</h4><p>注意到addTimer会在构造一个Timer对象后，将其添加到timers_的工作转交给addTimerInLoop完成了。这是为什么？</p><p>因为调用EventLoop::runAt/runEvery的线程，可能并非TimerQueue的loop线程，而修改TimerQueue数据成员时，必须在所属loop线程中进行，因此需要通过loop_-&gt;runInLoop将工作转交给所属loop线程。runInLoop：如果当前线程是所属loop线程，则直接运行函数；如果不是，就排队到所属loop线程末尾，等待运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加一个定时器.</span><br><span class="hljs-comment">* @details 运行到指定时间点when, 调度相应的回调函数cb.</span><br><span class="hljs-comment">* 如果interval参数 &gt; 0.0, 就周期重复运行.</span><br><span class="hljs-comment">* 可能会由其他线程调用, 需要让对TimerQueue数据成员有修改的部分, 在所属loop所在线程中运行.</span><br><span class="hljs-comment">* @param cb 超时回调函数</span><br><span class="hljs-comment">* @param when 触发超时的时间点</span><br><span class="hljs-comment">* @param interval 循环周期. &gt; 0.0 代表周期定时器; 否则, 代表一次性定时器</span><br><span class="hljs-comment">* @return 返回添加的Timer对应TimerId, 用来标识该Timer对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">TimerId <span class="hljs-title">TimerQueue::addTimer</span><span class="hljs-params">(TimerCallback cb, Timestamp when, <span class="hljs-type">double</span> interval)</span></span><br><span class="hljs-function"></span>&#123;<br>    Timer* timer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Timer</span>(std::<span class="hljs-built_in">move</span>(cb), when, interval);<br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="hljs-keyword">this</span>, timer)); <span class="hljs-comment">// 转交所属loop线程运行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">TimerId</span>(timer, timer-&gt;<span class="hljs-built_in">sequence</span>());<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在loop线程中添加一个定时器.</span><br><span class="hljs-comment">* @details addTimerInLoop 必须在所属loop线程中运行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::addTimerInLoop</span><span class="hljs-params">(Timer *timer)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-type">bool</span> earliestChanged = <span class="hljs-built_in">insert</span>(timer);<br><br>    <span class="hljs-keyword">if</span> (earliestChanged)<br>    &#123;<br>        <span class="hljs-built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="hljs-built_in">expiration</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>addTimerInLoop的主要工作由2个函数来完成：insert，resetTimerfd。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 插入一个timer指向的定时器</span><br><span class="hljs-comment">* @details timers_是std::set&lt;std::pair&lt;Timestamp, Timer*&gt;&gt;类型, 容器会自动对元素进行排序,</span><br><span class="hljs-comment">* 默认先按pair.first即Timestamp进行排序, 其次是pair.second(.first相同情况下才比较second),</span><br><span class="hljs-comment">* 这样第一个元素就是时间戳最小的元素.</span><br><span class="hljs-comment">* @return 定时器timer当前是否已经超时</span><br><span class="hljs-comment">* - true timers_为空或已经超时</span><br><span class="hljs-comment">* - false timers_非空, 且最近的一个定时器尚未超时</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TimerQueue::insert</span><span class="hljs-params">(Timer *timer)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">bool</span> earliestChanged = <span class="hljs-literal">false</span>;<br>    Timestamp when = timer-&gt;<span class="hljs-built_in">expiration</span>(); <span class="hljs-comment">// 超时时刻</span><br>    TimerList::iterator it = timers_.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">if</span> (it == timers_.<span class="hljs-built_in">end</span>() || when &lt; it-&gt;first)<br>    &#123; <span class="hljs-comment">// 定时器集合为空 或者 新添加的timer已经超时(因为it指向的Timer超时时刻是距离当前最近的)</span><br>        earliestChanged = <span class="hljs-literal">true</span>; <span class="hljs-comment">// timer已经超时</span><br>    &#125;<br><br>    <span class="hljs-comment">// 同时往timers_和activeTimers_集合中, 添加timer</span><br>    <span class="hljs-comment">// 注意: timers_和activeTimers_元素类型不同, 但所包含的Timer是相同的, 个数也相同</span><br><br>    &#123; <span class="hljs-comment">// ensure insert new timer to timers_ successfully</span><br>        std::pair&lt;TimerList::iterator, <span class="hljs-type">bool</span>&gt; result<br>        = timers_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Entry</span>(when, timer));<br>        <span class="hljs-built_in">assert</span>(result.second); (<span class="hljs-type">void</span>)result;<br>    &#125;<br><br>    &#123; <span class="hljs-comment">// ensure insert new timer to activeTimers_ successfully</span><br>        std::pair&lt;ActiveTimerSet::iterator, <span class="hljs-type">bool</span>&gt; result<br>        = activeTimers_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">ActiveTimer</span>(timer, timer-&gt;<span class="hljs-built_in">sequence</span>()));<br>        <span class="hljs-built_in">assert</span>(result.second); (<span class="hljs-type">void</span>)result;<br>    &#125;<br><br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> earliestChanged;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cancel-取消定时器">cancel 取消定时器</h3><p>一个已超时的定时器，会通过TimerQueue::getExpired自动清除，但一个尚未到期的定时器如何取消？</p><p>可以通过调用TimerQueue::cancel。类似于addTimer，cancel也可能在别的线程被调用，因此需要将其转交给cancelInLoop执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 取消一个定时器, 函数可能在别的线程调用</span><br><span class="hljs-comment">* @param timerId 每个定时器都有一个唯一的TimerId作为标识</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::cancel</span><span class="hljs-params">(TimerId timerId)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">runInLoop</span>(<br>            std::<span class="hljs-built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="hljs-keyword">this</span>, timerId));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 在所属loop线程中, 取消一个定时器</span><br><span class="hljs-comment">* @details 同时擦出timers_, activeTimers_中包含的Timer对象, timerId用来查找该Timer对象.</span><br><span class="hljs-comment">* @param timerId 待取消Timer的唯一Id标识</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::cancelInLoop</span><span class="hljs-params">(TimerId timerId)</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>(); <span class="hljs-comment">// 确保当前线程是所属loop线程</span><br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-function">ActiveTimer <span class="hljs-title">timer</span><span class="hljs-params">(timerId.timer_, timerId.sequence_)</span></span>;<br>    ActiveTimerSet::const_iterator it = activeTimers_.<span class="hljs-built_in">find</span>(timer);<br>    <span class="hljs-keyword">if</span> (it != activeTimers_.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        <span class="hljs-comment">// 注意timers_和activeTimers_的Timer指针指向相同对象, 只能delete一次</span><br>        <span class="hljs-type">size_t</span> n = timers_.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">Entry</span>(it-&gt;first-&gt;<span class="hljs-built_in">expiration</span>(), it-&gt;first));<br>        <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>); (<span class="hljs-type">void</span>)n;<br>        <span class="hljs-keyword">delete</span> it-&gt;first; <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> no delete please</span><br>        activeTimers_.<span class="hljs-built_in">erase</span>(it);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (callingExpiredTimers_)<br>    &#123; <span class="hljs-comment">// 如果正在处理超时定时器</span><br>        cancelingTimers_.<span class="hljs-built_in">insert</span>(timer);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3id="handleread处理timerqueue上所有超时任务">handleRead处理TimerQueue上所有超时任务</h3><p>handleRead有几个要点：</p><ul><li>必须在所在loop线程运行；</li><li>可能不止一个定时任务超时，可用getExpired()获取；</li><li>所有超时任务执行完后，重置周期定时任务，释放一次性定时任务；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理读事件, 只能是所属loop线程调用</span><br><span class="hljs-comment">* @details 当PollPoller监听到超时发生时, 将channel加入激活通道列表, loop中回调</span><br><span class="hljs-comment">* 事件处理函数, TimerQueue::handleRead.</span><br><span class="hljs-comment">* 发生超时事件时, 可能会有多个超时任务超时, 需要通过getExpired一次性全部获取, 然后逐个执行回调.</span><br><span class="hljs-comment">* @note timerfd只会发生读事件.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    loop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    <span class="hljs-function">Timestamp <span class="hljs-title">now</span><span class="hljs-params">(Timestamp::now())</span></span>;<br>    <span class="hljs-built_in">readTimerfd</span>(timerfd_, now);<br><br>    std::vector&lt;Entry&gt; expired = <span class="hljs-built_in">getExpired</span>(now); <span class="hljs-comment">// 获取所有超时任务</span><br><br>    <span class="hljs-comment">// 正在调用超时任务回调时, 先清除取消的超时任务cancelingTimers_, 再逐个执行超时回调.</span><br>    <span class="hljs-comment">// 可由getExpired()获取的所有超时任务.</span><br>    callingExpiredTimers_ = <span class="hljs-literal">true</span>;<br>    cancelingTimers_.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">// safe to callback outside critical section</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; it : expired)<br>    &#123;<br>        it.second-&gt;<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 通过Timer::run()回调超时处理函数</span><br>    &#125;<br>    callingExpiredTimers_ = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 重置所有已超时任务</span><br>    <span class="hljs-built_in">reset</span>(expired, now);<br>&#125;<br></code></pre></td></tr></table></figure><p>getExpired以参数时间点now为界限，查找settimers_中所有超时定时任务（Timer）。set会对timers_元素进行排序，std::set::lower_bound()会找到第一个时间点&lt; now时间点的定时任务。</p><p>getExpired调用reset重置所有超时的周期定时任务，释放超时的一次性任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 定时任务超时时, 从set timers_中取出所有的超时任务, 以vector形式返回给调用者</span><br><span class="hljs-comment">* @note 注意从set timers_要和从set activeTimers_同步取出超时任务, 两者保留的定时任务是相同的</span><br><span class="hljs-comment">* @param now 当前时间点, 用来判断从set中的定时器是否超时</span><br><span class="hljs-comment">* @return set timers_中超时的定时器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">std::vector&lt;TimerQueue::Entry&gt; <span class="hljs-title">TimerQueue::getExpired</span><span class="hljs-params">(Timestamp now)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    std::vector&lt;Entry&gt; expired;<br>    <span class="hljs-function">Entry <span class="hljs-title">sentry</span><span class="hljs-params">(now, <span class="hljs-keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;<br>    <span class="hljs-comment">// end.key &gt;= sentry.key, Entry.key is pair&lt;Timestamp, Timer*&gt;</span><br>    <span class="hljs-comment">// in that end.key.second &lt; sentry.key.second(MAX PTR)</span><br>    <span class="hljs-comment">// =&gt; end.key == sentry.key is impossible</span><br>    <span class="hljs-comment">// =&gt; end.key &gt; sentry.key</span><br>    TimerList::iterator end = timers_.<span class="hljs-built_in">lower_bound</span>(sentry);<br>    <span class="hljs-built_in">assert</span>(end == timers_.<span class="hljs-built_in">end</span>() || now &lt; end-&gt;first);<br>    std::<span class="hljs-built_in">copy</span>(timers_.<span class="hljs-built_in">begin</span>(), end, <span class="hljs-built_in">back_inserter</span>(expired));<br>    timers_.<span class="hljs-built_in">erase</span>(timers_.<span class="hljs-built_in">begin</span>(), end);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; it : expired)<br>    &#123;<br>        <span class="hljs-function">ActiveTimer <span class="hljs-title">timer</span><span class="hljs-params">(it.second, it.second-&gt;sequence())</span></span>;<br>        <span class="hljs-type">size_t</span> n = activeTimers_.<span class="hljs-built_in">erase</span>(timer);<br>        <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>); (<span class="hljs-type">void</span>)n;<br>    &#125;<br><br>    <span class="hljs-built_in">assert</span>(timers_.<span class="hljs-built_in">size</span>() == activeTimers_.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> expired;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据指定时间now重置所有超时任务, 只对周期定时任务有效</span><br><span class="hljs-comment">* @param expired 所有超时任务</span><br><span class="hljs-comment">* @param now 指定的reset基准时间点, 新的超时时间点以此为基准</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimerQueue::reset</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Entry&gt; &amp;expired, Timestamp now)</span></span><br><span class="hljs-function"></span>&#123;<br>    Timestamp nextExpire;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Entry&amp; it : expired)<br>    &#123;<br>        <span class="hljs-function">ActiveTimer <span class="hljs-title">timer</span><span class="hljs-params">(it.second, it.second-&gt;sequence())</span></span>;<br>        <span class="hljs-comment">// 只重置周期定时任务和没有取消的定时任务, 释放一次性超时的定时任务</span><br>        <span class="hljs-keyword">if</span> (it.second-&gt;<span class="hljs-built_in">repeat</span>()<br>        &amp;&amp; cancelingTimers_.<span class="hljs-built_in">find</span>(timer) == cancelingTimers_.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            it.second-&gt;<span class="hljs-built_in">restart</span>(now);<br>            <span class="hljs-built_in">insert</span>(it.second);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// FIXME move to a free list</span><br>            <span class="hljs-keyword">delete</span> it.second; <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> no delete please</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据最近的尚未达到的超时任务, 重置timerfd下一次超时时间</span><br>    <span class="hljs-keyword">if</span> (!timers_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        nextExpire = timers_.<span class="hljs-built_in">begin</span>()-&gt;second-&gt;<span class="hljs-built_in">expiration</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextExpire.<span class="hljs-built_in">valid</span>())<br>    &#123;<br>        <span class="hljs-built_in">resetTimerfd</span>(timerfd_, nextExpire);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/16001655.html">muduo笔记网络库（四）TimerQueue定时器队列</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-事件通道Channel</title>
    <link href="/2023/07/02/muduo%E5%BA%93-%E4%BA%8B%E4%BB%B6%E9%80%9A%E9%81%93Channel/"/>
    <url>/2023/07/02/muduo%E5%BA%93-%E4%BA%8B%E4%BB%B6%E9%80%9A%E9%81%93Channel/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-事件通道channel">muduo库-事件通道Channel</h1><p>之前说过，Poller的存在是为了监听事件，那么具体监听什么事件呢？</p><p>这就需要用到Channel类，它是muduo库负责注册读写事件的类，并<strong>保存了fd读写事件发生时调用的回调函数，如果poll/epoll有读写事件发生则将这些事件添加到对应的通道中。一个通道对应唯一EventLoop，一个EventLoop可以有多个通道</strong>。</p><p>一个通道对应唯一EventLoop，一个EventLoop可以有多个通道。</p><p><strong>一个Channel对象绑定了一个fd（文件描述符），可以用来监听发生在fd上的事件，事件包括空事件（不监听）、可读事件、写完成事件</strong>。当fd上被监听事件就绪时，对应Channel对象就会被Poller放入<strong>激活队列（activeChannels_）</strong>，进而在loop循环中调用封装在Channel的相应回调来处理事件。</p><div class="admonition attention"><p class="admonition-title">attention</p><p>Channel类不负责fd的生存期，fd的生存期是由socket决定的，断开连接关闭描述符。</p></div><p>Channel可以通过EventLoop，向Poller更新自己关心的（监听）事件（通过mapPoller::channels_存储）。具体来说，对于PollPoller对象，会同步更新（poll）传给内核的poll事件数组pollfds_；对于EPollPoller对象，会同步更新（epoll）传递给内核的epoll事件数组events_；</p><p>可以这样理解，poll/epoll监听的是fd（上指定的事件pollfd.events），Poller监听的是Channel对象（上指定的事件events_），当监听到事件就绪时，将对应通道加入激活通道队列，在EventLoop的loop循环中依次调用Channel中注册的事件回调。</p><p>EventLoop、Poller、Channel这3个类构成了Reactor模式的核心，其时序关系如下图：</p><p><img src="/img/muduo/事件通道channel/时序图.png" /></p><h2 id="channel-类">Channel 类</h2><p>每个Channel对象从始至终只负责一个文件描述符（fd）的IO事件分发，但<strong>不拥有fd，也不会在析构时关闭fd</strong>。而是由诸如TcpConnection、Acceptor、EventLoop等，这样需要监听指定文件描述符上事件的类，将fd通过构造函数传递给Channel。</p><p>Channel会把不同的IO事件分发为不同的回调，如ReadCallback、WriteCallback，回调对象类型用std::function&lt;&gt;表示，用来定义某个可调用类型。</p><p>事件回调类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; EventCallback;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(Timestamp)&gt; ReadEventCallback;<br></code></pre></td></tr></table></figure><p>Channel成员函数主要包括：</p><ol type="1"><li>设置事件处理的回调函数setCallback（如setReadCallback）；</li><li>开启fd关心的事件events_，可调用enable（如enableReading），该fd及关心的事件会注册到Poller中进行监听；</li><li>关闭fd关心的事件events_，可调用disable*（如disableReading），会更新该fd在Poller中监听的事件；</li><li>关闭fd关心的所有事件events_，可调用disableAll，会更新该fd在Poller中监听的事件；</li><li>删除对fd的监听，会将其从Poller的ChannelMap中移除；</li><li>Poller监听到Channel事件被激活时，将其加入到激活列表，在EventLoop中回调handleEvent。</li></ol><h2 id="channel类内部结构">Channel类内部结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Channel绑定一个fd, 用于设置fd上要监听的事件, 以及相应的回调函数.</span><br><span class="hljs-comment">* Poller监听到有通道绑定的事件发生, 就会将其加入激活的通道列表,</span><br><span class="hljs-comment">* 然后在EventLoop::loop()中调用该Channel对应事件注册的回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span> : <span class="hljs-keyword">private</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; EventCallback; <span class="hljs-comment">// 除了读事件, 用于其他事件(如写/关闭/错误)回调类型</span><br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(Timestamp)&gt; ReadEventCallback; <span class="hljs-comment">// 读事件回调类型</span><br><br>    <span class="hljs-built_in">Channel</span>(EventLoop* loop, <span class="hljs-type">int</span> fd__);<br>    ~<span class="hljs-built_in">Channel</span>()<br><br>    <span class="hljs-comment">/* 处理事件, 监听事件激活时, 由EventLoop::loop调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(Timestamp recevieTime)</span></span>;<br>    <span class="hljs-comment">/* 设置事件回调，由Channel对象持有者配置Channel事件回调时调用 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadCallback</span><span class="hljs-params">(ReadEventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; readCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCallback</span><span class="hljs-params">(EventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; writeCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(EventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; closeCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setErrorCallback</span><span class="hljs-params">(EventCallback cb)</span></span><br><span class="hljs-function">    </span>&#123; errorCallback_ = std::<span class="hljs-built_in">move</span>(cb); &#125;<br><br>    <span class="hljs-comment">/* 将shared_ptr管理的对象系到本地weak_ptr管理的tie_, 可用于保存TcpConnection指针 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tie</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">void</span>&gt;&amp;)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> fd_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">events</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_revents</span><span class="hljs-params">(<span class="hljs-type">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class="hljs-comment">// used by poller</span><br><span class="hljs-comment">//    int revents() const &#123; return revents_; &#125;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNoneEvent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_ == kNoneEvent; &#125;<br><br>    <span class="hljs-comment">/* 使能/禁用 监听 可读/可写事件, 会影响Poller监听的通道列表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableReading</span><span class="hljs-params">()</span> </span>&#123; events_ |= kReadEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableReading</span><span class="hljs-params">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableWriting</span><span class="hljs-params">()</span> </span>&#123; events_ |= kWriteEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableWriting</span><span class="hljs-params">()</span> </span>&#123; events_ &amp;= ~kWriteEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableAll</span><span class="hljs-params">()</span> </span>&#123; events_ = kNoneEvent; <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-comment">/* 判断是否请求监听 可写事件 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isWriting</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_ &amp; kWriteEvent; &#125;<br>    <span class="hljs-comment">/* 判断是否请求监听 可读事件 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isReading</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> events_ &amp; kReadEvent; &#125;<br><br>    <span class="hljs-comment">// for Poller</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> index_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_index</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123; index_ = idx; &#125;<br><br>    <span class="hljs-comment">// for debug</span><br>    <span class="hljs-function">string <span class="hljs-title">reventsToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">string <span class="hljs-title">eventsToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doNotLogHup</span><span class="hljs-params">()</span> </span>&#123; logHup_ = <span class="hljs-literal">false</span>; &#125;<br><br>    <span class="hljs-function">EventLoop* <span class="hljs-title">ownerLoop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> loop_; &#125;<br>    <span class="hljs-comment">/* 从EventLoop中移除当前通道.</span><br><span class="hljs-comment">     * 建议在移除前禁用所有事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* 将fd对应事件转化为字符串 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> string <span class="hljs-title">eventsToString</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ev)</span></span>;<br>    <span class="hljs-comment">/* update()将调用EventLoop::updateChannel更新监听的通道 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/* 根据不同的事件源激活不同的回调函数，来处理事件 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNoneEvent;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kReadEvent;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kWriteEvent;<br><br>    EventLoop* loop_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> fd_; <span class="hljs-comment">// file descriptor</span><br>    <span class="hljs-type">int</span> events_;   <span class="hljs-comment">// request events, set by user</span><br>    <span class="hljs-type">int</span> revents_;  <span class="hljs-comment">// returned events, current active events, set by EventLoop/Poller</span><br>    <span class="hljs-comment">// used by Poller</span><br>    <span class="hljs-comment">// PollPoller: index of poll fds array mapped to fd_</span><br>    <span class="hljs-comment">// EPollPoller: operation type for fd: kNew, kAdded, kDeleted</span><br>    <span class="hljs-type">int</span> index_;<br>    <span class="hljs-type">bool</span> logHup_;<br>    <span class="hljs-comment">/* 使用weak_ptr指向shared_ptr所指对象, 防止循环引用. 通常是生命周期不确定的对象, 如TcpConnection */</span><br>    std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; tie_;<br>    <span class="hljs-type">bool</span> tied_; <span class="hljs-comment">/* weak_ptr tie_绑定对象的标志 */</span><br>    <span class="hljs-type">bool</span> eventHandling_; <span class="hljs-comment">/* 正在处理事件的标志 */</span><br>    <span class="hljs-type">bool</span> addedToLoop_;   <span class="hljs-comment">/* 加入到loop中, 被监听/处理的标志 */</span><br>    ReadEventCallback readCallback_; <span class="hljs-comment">/* 可读事件回调 */</span><br>    EventCallback writeCallback_;    <span class="hljs-comment">/* 可写事件回调 */</span><br>    EventCallback closeCallback_;    <span class="hljs-comment">/* 关闭事件回调 */</span><br>    EventCallback errorCallback_;    <span class="hljs-comment">/* 错误事件回调 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="handleevent-处理事件">handleEvent 处理事件</h3><p>处理激活的Channel事件，由Poller更新激活的Channel列表，EventLoop::loop()根据激活Channel列表，逐个执行Channel中已注册好的相应回调。实际事件处理工作，由handleEventWithGuard完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 处理激活的Channel事件</span><br><span class="hljs-comment">* @details Poller中监听到激活事件的Channel后, 将其加入激活Channel列表,</span><br><span class="hljs-comment">* EventLoop::loop根据激活Channel回调对应事件处理函数.</span><br><span class="hljs-comment">* @param recevieTime Poller中调用epoll_wait/poll返回后的时间. 用户可能需要该参数.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEvent</span><span class="hljs-params">(Timestamp recevieTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * shared_ptr通过RAII方式管理对象资源guard</span><br><span class="hljs-comment">     * weak_ptr::lock可将weak_ptr提升为shared_ptr, 引用计数+1</span><br><span class="hljs-comment">     */</span><br>    std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard;<br>    <span class="hljs-keyword">if</span> (tied_)<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 为什么使用 tie?</span><br><span class="hljs-comment">         * 确保在执行事件处理动作时, 所需的对象不会被释放, 但又不能用shared_ptr,</span><br><span class="hljs-comment">         * 否则可能导致循环引用. 最好使用weak_ptr, 然后lock提升为shared_ptr, 这样更安全.</span><br><span class="hljs-comment">         */</span><br>        guard = tie_.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>        &#123;<br>            <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">handleEventWithGuard</span>(recevieTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="handleeventwithguard-识别事件并回调">handleEventWithGuard识别事件并回调</h3><p>根据不同的激活原因，调用不的回调函数。这些回调函数，是在持有Channel对象，需要进行事件监听的class中进行设置，比如TcpConnection，EventLoop，Acceptor，TimerQueue等。而有些回调函数，经过层层传递，会呈现可网络库的调用者，比如TcpConnection会将处理一个socketfd的读事件回调（新建连接请求），传递给TcpServer::newConnection，这样用户就能通过TcpServer::setConnectionCallback设置其回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据不同的激活原因, 调用不同的回调函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    eventHandling_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 正在处理事件</span><br>    LOG_TRACE &lt;&lt; <span class="hljs-built_in">reventsToString</span>(); <span class="hljs-comment">// 打印fd及就绪事件</span><br>    <span class="hljs-keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))<br>    &#123; <span class="hljs-comment">// fd挂起(套接字已不在连接中), 并且没有数据可读</span><br>        <span class="hljs-keyword">if</span> (logHup_)<br>        &#123; <span class="hljs-comment">// 打印挂起log</span><br>            LOG_WARN &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="hljs-string">&quot; Channel::handle_event() POLLHUP&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 调用关闭回调</span><br>        <span class="hljs-keyword">if</span> (closeCallback_) <span class="hljs-built_in">closeCallback_</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; POLLNVAL) <span class="hljs-comment">// 无效请求, fd没打开</span><br>    &#123; <span class="hljs-comment">// fd dont be opened</span><br>        LOG_WARN &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="hljs-string">&quot; Channel::handle_event() POLLNVAL&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL)) <span class="hljs-comment">// 错误条件, 或 无效请求, fd没打开</span><br>    &#123; <span class="hljs-comment">// error or fd dont be opened</span><br>        <span class="hljs-keyword">if</span> (errorCallback_) <span class="hljs-built_in">errorCallback_</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) <span class="hljs-comment">// 有待读数据, 或 紧急数据(e.g. TCP带外数据), 或流套接字对端关闭连接/写半连接</span><br>    &#123; <span class="hljs-comment">// there is data, urgent data,  to be read</span><br>        <span class="hljs-keyword">if</span> (readCallback_) <span class="hljs-built_in">readCallback_</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (revents_ &amp; POLLOUT)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (writeCallback_) <span class="hljs-built_in">writeCallback_</span>();<br>    &#125;<br>    eventHandling_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update-更新通道">update 更新通道</h3><p>通过EventLoop对象，传递给Poller对象，然后更新其监听的通道列表中对应通道。支持ADD/MOD操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    addedToLoop_ = <span class="hljs-literal">true</span>;<br>    loop_-&gt;<span class="hljs-built_in">updateChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    poller_-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Update array pollfds_</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* O(logN)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PollPoller::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    Poller::<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="hljs-built_in">fd</span>() &lt;&lt; <span class="hljs-string">&quot; events = &quot;</span> &lt;&lt; channel-&gt;<span class="hljs-built_in">events</span>();<br>    <span class="hljs-keyword">if</span> (channel-&gt;<span class="hljs-built_in">index</span>() &lt; <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// a new one, add to pollfds_</span><br>        <span class="hljs-comment">// ensure channel point to a new one</span><br>        <span class="hljs-built_in">assert</span>(channels_.<span class="hljs-built_in">find</span>(channel-&gt;<span class="hljs-built_in">fd</span>()) == channels_.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> pfd;<br>        pfd.fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>        pfd.events = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">short</span>&gt;(channel-&gt;<span class="hljs-built_in">events</span>());<br>        pfd.revents = <span class="hljs-number">0</span>;<br>        pollfds_.<span class="hljs-built_in">push_back</span>(pfd);<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pollfds_.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>        channel-&gt;<span class="hljs-built_in">set_index</span>(idx);<br>        channels_[pfd.fd] = channel; <span class="hljs-comment">// insert (fd, channel)</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// update existing one</span><br>        <span class="hljs-built_in">assert</span>(channels_.<span class="hljs-built_in">find</span>(channel-&gt;<span class="hljs-built_in">fd</span>()) != channels_.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">assert</span>(channels_[channel-&gt;<span class="hljs-built_in">fd</span>()] == channel);<br>        <span class="hljs-type">int</span> idx = channel-&gt;<span class="hljs-built_in">index</span>();<br>        <span class="hljs-comment">// ensure channel does exist in pollfds_</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= idx &amp;&amp; idx &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pollfds_.<span class="hljs-built_in">size</span>()));<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span>&amp; pfd = pollfds_[idx];<br>        <span class="hljs-built_in">assert</span>(pfd.fd == channel-&gt;<span class="hljs-built_in">fd</span>() || pfd.fd == -channel-&gt;<span class="hljs-built_in">fd</span>() - <span class="hljs-number">1</span>);<br>        pfd.fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>        pfd.events = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">short</span>&gt;(channel-&gt;<span class="hljs-built_in">events</span>());<br>        pfd.revents = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (channel-&gt;<span class="hljs-built_in">isNoneEvent</span>())<br>        &#123;<br>            <span class="hljs-comment">// ignore this pollfd</span><br>            pfd.fd = -channel-&gt;<span class="hljs-built_in">fd</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="remove-移除通道">remove 移除通道</h3><p>与update类似，也是通过EventLoop传递给Poller对象，将当前通道从Poller的事件列表中删除。支持DEL操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    addedToLoop_ = <span class="hljs-literal">true</span>;<br>    loop_-&gt;<span class="hljs-built_in">updateChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">ownerLoop</span>() == <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">assertInLoopThread</span>();<br>    poller_-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从监听的通道数组channels_中, 移除指定通道</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PollPoller::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    Poller::<span class="hljs-built_in">assertInLoopThread</span>();<br>    LOG_TRACE &lt;&lt; <span class="hljs-string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="hljs-built_in">fd</span>();<br>    <span class="hljs-built_in">assert</span>(channels_.<span class="hljs-built_in">find</span>(channel-&gt;<span class="hljs-built_in">fd</span>()) != channels_.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">assert</span>(channels_[channel-&gt;<span class="hljs-built_in">fd</span>()] == channel);<br>    <span class="hljs-built_in">assert</span>(channel-&gt;<span class="hljs-built_in">isNoneEvent</span>());<br>    <span class="hljs-type">int</span> idx = channel-&gt;<span class="hljs-built_in">index</span>();<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= idx &amp;&amp; idx &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pollfds_.<span class="hljs-built_in">size</span>()));<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span>&amp; pfd = pollfds_[idx]; (<span class="hljs-type">void</span>)pfd;<br><br>    <span class="hljs-comment">// ensure remove one invalid channel from channels_</span><br>    <span class="hljs-built_in">assert</span>(pfd.fd == -channel-&gt;<span class="hljs-built_in">fd</span>() - <span class="hljs-number">1</span> &amp;&amp; pfd.events == channel-&gt;<span class="hljs-built_in">events</span>());<br>    <span class="hljs-type">size_t</span> n = channels_.<span class="hljs-built_in">erase</span>(channel-&gt;<span class="hljs-built_in">fd</span>());<br>    <span class="hljs-built_in">assert</span>(n == <span class="hljs-number">1</span>); (<span class="hljs-type">void</span>)n;<br><br>    <span class="hljs-comment">// remove pollfd from pollfds_ by index</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(idx) == pollfds_.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    &#123; <span class="hljs-comment">// last of pollfds_</span><br>        pollfds_.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// swap the pollfd to be removed with the last of pollfds_,</span><br>        <span class="hljs-comment">// then remove the last</span><br>        <span class="hljs-type">int</span> channelAtEnd = pollfds_.<span class="hljs-built_in">back</span>().fd;<br>        <span class="hljs-built_in">iter_swap</span>(pollfds_.<span class="hljs-built_in">begin</span>() + idx, pollfds_.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (channelAtEnd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            channelAtEnd = -channelAtEnd - <span class="hljs-number">1</span>;<br>        &#125;<br>        channels_[channelAtEnd]-&gt;<span class="hljs-built_in">set_index</span>(idx);<br>        pollfds_.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://www.cnblogs.com/fortunely/p/15997694.html">muduo笔记网络库（三）事件通道Channel</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-I/O复用</title>
    <link href="/2023/07/02/muduo%E5%BA%93-I-O%E5%A4%8D%E7%94%A8/"/>
    <url>/2023/07/02/muduo%E5%BA%93-I-O%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-io复用">muduo库-I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符，能有效提高程序性能。Linux下，实现I/O复用的系统调用主要有3个：</p><ol type="1"><li>select</li><li>poll</li><li>epoll</li></ol><p>muduo采用了2和3，分别用PollPoller/EPollPoller对poll/epoll进行了封装，基类Poller主要用于提供统一的接口。</p><h2 id="poller类">Poller类</h2><p>先来看看基类Poller定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO Multiplexing Interface</span><br><span class="hljs-comment">* Support poll(2), epoll(7)</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Only owner EventLoop IO thread can invoke it, so thread safe is not necessary.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO复用接口</span><br><span class="hljs-comment">* 禁止编译器生成copy构造函数和copy assignment</span><br><span class="hljs-comment">* 支持poll(2), epoll(7)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poller</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::vector&lt;Channel*&gt; ChannelList;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Poller</span><span class="hljs-params">(EventLoop* loop)</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Poller</span>();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Polls the I/O events.</span><br><span class="hljs-comment">     * Must be called in the loop thread.</span><br><span class="hljs-comment">     * poll(2) for PollPoller, epoll_wait(2) for EPollPoller</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 监听函数，根据激活的通道列表，监听指定fd的相应事件</span><br><span class="hljs-comment">     * 对于PollPoller会调用epoll_wait(2), 对于EPollPoller会调用poll(2)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 返回调用完epoll_wait/poll的当前时间（Timestamp对象）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList* activeChannels)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Update channel listened</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* 更新监听通道的事件 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 删除监听通道 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 判断当前Poller对象是否持有指定通道 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">hasChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">/* 默认创建Poller对象的类函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Poller* <span class="hljs-title">newDefaultPoller</span><span class="hljs-params">(EventLoop* loop)</span></span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 断言所属EventLoop为当前线程.</span><br><span class="hljs-comment">     * 如果断言失败，将终止程序（LOG_FATAL）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assertInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        ownerLoop_-&gt;<span class="hljs-built_in">assertInLoopThread</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 该类型保存fd和需要监听的events，以及各种事件回调函数（可读/可写/错误/关闭等）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">typedef</span> std::map&lt;<span class="hljs-type">int</span>, Channel*&gt; ChannelMap;<br>    <span class="hljs-comment">// Poller don&#x27;t own the Channel, so the channel must be unregister(EventLoop::removeChannel) before its dtor.</span><br>    <span class="hljs-comment">// std::map used for speeding up to find out a channel by fd</span><br>    <span class="hljs-comment">/* 保存所有事件的Channel，一个Channel绑定一个fd */</span><br>    ChannelMap channels_;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 事件驱动循环, 用于调用poll监听fd事件</span><br><span class="hljs-comment">     */</span><br>    EventLoop* ownerLoop_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个EventLoop类都有一个Poller派生类的实例化对象，该对象的所有操作都在同一个IO线程完成的，不存在多线程抢占的问题，只有拥有EventLoop的IO线程，才能调用EventLoop所拥有的Poller对象的接口。因此只需要判断当前执行线程是否在EventLoop对象的创建线程即可，所以考虑Poller的线程安全不是必要的。</p><p>一个Channel对应一个fd（文件描述符），一个fd有三种事件状态：空事件（kNoneEvent），读事件（kReadEvent，即POLLIN|POLLPRI），写事件（kWriteEvent，即POLLOUT）。只有后2个，poll/epoll才会进行监听。</p><p>EventLoop会根据Poller::newDefaultPoller()，Poller对象。实际策略是根据是否设置了环境变量，来选择创建PollPoller，还是EPollPoller。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Poller *<span class="hljs-title">Poller::newDefaultPoller</span><span class="hljs-params">(EventLoop *loop)</span> <span class="hljs-comment">// static</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;MUDUO_USE_POLL&quot;</span>)) <span class="hljs-comment">// 如果设置了环境变量</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PollPoller</span>(loop);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">EPollPoller</span>(loop);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="epollpoller类">EPollPoller类</h2><p>EPollPoller以epoll为核心，实现了基类Poller的virtual函数，在其中调用了epoll_create/ctl/wait等接口。poll返回后，会将就绪的fd添加到激活队列activeChannels中管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO Multiplexing with epoll(7).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EPollPoller</span> : <span class="hljs-keyword">public</span> Poller<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EPollPoller</span>(EventLoop* loop);<br>    ~<span class="hljs-built_in">EPollPoller</span>() <span class="hljs-keyword">override</span>;<br>    <span class="hljs-comment">/* 监听函数, 调用epoll_wait() */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* ADD/MOD/DEL */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* DEL */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* events_数组初始大小 */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInitEventListSize = <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">/* 将op(EPOLL_CTL_Add/MOD/DEL)转换成字符串 */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">operationToString</span><span class="hljs-params">(<span class="hljs-type">int</span> op)</span></span>;<br>    <span class="hljs-comment">/* poll返回后将就绪的fd添加到激活通道中activeChannels */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents,</span></span><br><span class="hljs-params"><span class="hljs-function">                            ChannelList* activeChannels)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">/* 由updateChannel/removeChannel调用，真正执行epoll_ctl()控制epoll的函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> operation, Channel* channel)</span></span>;<br><br>    <span class="hljs-keyword">typedef</span> std::vector&lt;<span class="hljs-keyword">struct</span> epoll_event&gt; EventList;<br>    <span class="hljs-comment">/* epoll文件描述符，由epoll_create返回 */</span><br>    <span class="hljs-type">int</span> epollfd_;<br>    <span class="hljs-comment">/* epoll事件数组，为了适配epoll_wait参数要求 */</span><br>    EventList events_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>muduo在实现时，创建epoll fd时，并没有用epoll_create，而是用epoll_create1。原因在于：epoll_create1在打开epoll文件描述符时，可以直接指定FD_CLOEXEC选项，相当于open时指定O_CLOSEXEC。另外，epoll_create的size参数在Linux2.6.8以后，就已经没用了（&gt;0即可），内核会实现自动增长内部数据结构以描述监听事件。</p><p>值得一提的是，在Channel中定义了一个名为index_的成员，由Channel构造初值为0，可通过Channel::index()/set_index()访问，在不同的Poller中有不同的含义：在EPollPoller中，index_用来表示事件类型（kNew/kAdded/kDeleted）；在PollPoller中的含义，到PollPoller类解析中再讲。</p><h2 id="pollpoller类">PollPoller类</h2><p>PollPoller是Poller的另外一个派生类，以poll为核心，实现Poller的virtual函数，在其中调用了poll接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* IO Multiplexing with poll(2).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PollPoller</span> : <span class="hljs-keyword">public</span> Poller<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PollPoller</span>(EventLoop* loop);<br>    ~<span class="hljs-built_in">PollPoller</span>() <span class="hljs-keyword">override</span>;<br>    <span class="hljs-comment">/* 监听函数，调用poll() */</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList* activeChannels)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* ADD/MOD */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">/* DEL */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel* channel)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* poll返回后将就绪的fd添加到激活通道中activeChannels */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents,</span></span><br><span class="hljs-params"><span class="hljs-function">                            ChannelList* activeChannels)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">typedef</span> std::vector&lt;<span class="hljs-keyword">struct</span> pollfd&gt; PollFdList;<br>    <span class="hljs-comment">/* poll事件数组，适配poll(2)参数要求 */</span><br>    PollFdList pollfds_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在PollPoller中的index_表示一个事件在poll事件数组（pollfds_）中的索引：如果值为-1，表明该事件尚未在事件数组中；如果值&gt;=0，表明该事件已经在事件数组中。可以用来对Channel对应事件做标记，便于判断Channel是否已经位于事件数组，从而决定后续是执行添加、修改，还是删除操作。</p><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/15997621.html">muduo笔记网络库（二）I/O复用封装Poller</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-网络库概括</title>
    <link href="/2023/07/02/muduo%E5%BA%93-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%A6%82%E6%8B%AC/"/>
    <url>/2023/07/02/muduo%E5%BA%93-%E7%BD%91%E7%BB%9C%E5%BA%93%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-网络库概括">muduo库-网络库概括</h1><h2 id="网络事件的处理模式">网络事件的处理模式</h2><p>服务器编程中，通常有两种高效的事件处理模式：reactor模式，proactor模式。</p><h3 id="reactor模式">Reactor模式</h3><p>要求<strong>主线程</strong>（I/O单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知<strong>工作线程</strong>（逻辑单元）。除此之外，主线程不做其他任何实质性的工作。读写数据，接受新连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型（以epoll为例）实现Reactor模式工作流程：</p><ol type="1"><li>主线程往epoll内核事件表注册socket上的读就绪事件（epoll_ctl +EPOLL_CTL_ADD）；</li><li>主线程调用epoll_wait等待socket上有数据可读；</li><li>当socket上有数可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列；</li><li>阻塞在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上写就绪事件。</li><li>主线程调用epoll_wait等待socket可写；</li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li><li>阻塞在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li></ol><p>当然，epoll不止能监听socket上的事件，其他文件描述符都能监听。</p><p>下图是Reactor模式的工作流程示意：</p><p><img src="/img/muduo/网络库概括/reactor模式工作流程.png" /></p><h3 id="proactor模式">Proactor模式</h3><p>Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅负责业务逻辑。</p><p>使用异步I/O模型（以aio为例）实现Proactor模式工作流程：</p><ol type="1"><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置以及读操作完成时如何通知应用程序（回调函数）；</li><li>主线程继续处理其他逻辑；</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用；</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_write向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写完成时如何通知应用程序（仍以信号为例）；</li><li>main线程继续处理其他逻辑；</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕；</li><li>应用程序预先定义好的信号处理函数，选择一个工作线程来做善后处理，如决定是否关闭socket；</li></ol><p>下图是Proactor模式的工作流程示意：</p><p><img src="/img/muduo/网络库概括/proactor模式工作流程.png" /></p><h2 id="muduo网络库中的reactor模式">muduo网络库中的Reactor模式</h2><p>muduo网络库采用的是Reactor模式。服务器软件框架是one loop perthread，即一个线程一个事件循环。这个循环称为EventLoop，loop线程是指运行EventLoop::loop()的线程。这种以事件为驱动的编程模式称为事件驱动模式。</p><p>网络库是由<strong>Reactor +线程池</strong>来完成的，线程池中每个线程都是一个Reactor模型。这种结构在处理大量并发I/O连接任务的服务器上，就很有优势。</p><p>下图是实现Reactor模式各关键类及类图关系：</p><p><img src="/img/muduo/网络库概括/Reactor模式关键类图.png" /></p><h2 id="参考">参考</h2><p>转载自<ahref="https://www.cnblogs.com/fortunely/p/15998209.html">muduo笔记网络库（一）概括</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake的使用</title>
    <link href="/2023/07/01/Cmake%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/01/Cmake%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake的使用">Cmake的使用</h1><p>CMake是一个跨平台的安装(编译)工具,可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件,能测试编译器所支持的C++特性,类似UNIX下的automake。</p><h2 id="编译一个独立的cpp文件">编译一个独立的cpp文件</h2><p>文件结构如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">singleFile/<br><span class="hljs-string">| -- CMakeLists.txt</span><br><span class="hljs-string">| -- helloWorld.cpp</span><br></code></pre></td></tr></table></figure><p>CMakeLists.txt的文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span> (<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.12</span>) <span class="hljs-comment"># camke版本号</span><br><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST) <span class="hljs-comment"># 将./下的所有*.cpp加入到SRC_LIST中</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>在singleFile文件夹下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ./<br></code></pre></td></tr></table></figure><p>可以看到编译生成的文件已经在当前目录下生成了：</p><p><img src="/img/CMake/单个文件cmake命令.png" /></p><p>然后执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>就可以生成我们程序的可执行文件了：</p><p><img src="/img/CMake/单个文件make命令.png" /></p><p>但是这样会有一个问题，就是编译生成的文件都在当前目录下，这样会导致文件夹很乱，所以我们可以创建一个build文件夹，那么文件结构就变为如下所示：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">singleFile/<br><span class="hljs-string">| -- CMakeLists.txt</span><br><span class="hljs-string">| -- build/</span><br><span class="hljs-string">| -- helloWorld.cpp</span><br></code></pre></td></tr></table></figure><p>然后在singleFile/build文件夹下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p>可以看到编译生成的文件全部都在build文件夹里生成了</p><p><img src="/img/CMake/单个文件-build文件夹cmake命令.png" /></p><div class="admonition note"><p class="admonition-title">note</p><p>这里需要注意的是，build文件夹的位置是可以改变的，甚至其名字也可以改，但是习惯上使用build作为文件夹的名字，示例里cmake命令后面的参数是两个点，是因为CMakelists.txt文件在上一级目录，所以需要用两个点来表示上一级目录,如果将build文件夹放在其他的地方，那么需要保证执行<code>cmake</code>命令的之后后边跟的路径是CMakeLists.txt文件所在的路径。</p></div><p>然后执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>就可以生成我们程序的可执行文件了：</p><p><img src="/img/CMake/单个文件-build文件夹make命令.png" /></p><h2 id="编译多个cpp文件">编译多个cpp文件</h2><p>文件结构如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">multiFile/<br>| <span class="hljs-comment">-- CMakeList.txt </span><br>| <span class="hljs-comment">-- main.cpp</span><br>| <span class="hljs-comment">-- build/</span><br>| <span class="hljs-comment">-- src/ </span><br>    <span class="hljs-comment">-- CMakeList.txt  </span><br>    <span class="hljs-comment">-- test.h</span><br>    <span class="hljs-comment">-- test.cpp</span><br></code></pre></td></tr></table></figure><p><code>main.cpp</code>,<code>test.cpp</code>,以及<code>test.h</code>文件的内容如下：</p><p>test.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>();<br>    ~<span class="hljs-built_in">Test</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>test.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;test.h&quot;</span></span><br><br>Test::<span class="hljs-built_in">Test</span>()<br>&#123;<br>&#125;<br><br>Test::~<span class="hljs-built_in">Test</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;src/test.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Test test;<br>    test.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根目录下CMakeLists.txt文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(main)<br><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src)<br><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_SRCS)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(main <span class="hljs-variable">$&#123;DIR_SRCS&#125;</span>)<br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main <span class="hljs-keyword">TEST</span>)<br></code></pre></td></tr></table></figure><p>src文件夹下的CMakeLists.txt文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_TEST_SRC)<br><span class="hljs-comment"># generate *.so</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(<span class="hljs-keyword">TEST</span> SHARED <span class="hljs-variable">$&#123;DIR_TEST_SRC&#125;</span>)<br></code></pre></td></tr></table></figure><p>在multiFile/build文件夹下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/img/CMake/多文件-build文件夹cmake命令.png" /></p><p>与编译单个文件时一样，执行<code>make</code>命令就可以生成可执行文件了：</p><p><img src="/img/CMake/多文件-build文件夹make命令.png" /></p><p>同时可以看到在"multiFile/build/src"文件夹下生成了.so文件</p><p><img src="/img/CMake/生成so文件.png" /></p><h2 id="调用-.so-.h文件结构">调用 *.so, *.h，文件结构:</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">libTest/<br>| <span class="hljs-comment">-- build/</span><br>| <span class="hljs-comment">-- include/</span><br>    <span class="hljs-comment">--  test.h</span><br>| <span class="hljs-comment">-- libs/</span><br>    <span class="hljs-comment">-- libTEST.so</span><br>| <span class="hljs-comment">-- CMakeLists.txt</span><br>| <span class="hljs-comment">-- main.cpp</span><br></code></pre></td></tr></table></figure><p>这里的<code>libTEST.so</code>文件是上面使用<code>cmake</code>命令生成的.so文件，<code>test.h</code>是之前的<code>test.h</code>文件，<code>main.cpp</code>文件的内容如下：</p><p>CMakeLists.txt的文件为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(main)<br><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(./<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_SRCS)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(main <span class="hljs-variable">$&#123;DIR_SRCS&#125;</span>)<br><span class="hljs-comment"># 绝对路径添加 *.so</span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main /home/starmin/Code/testCode/cmakeTest/libTest/libs/libTEST.so)<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>这里需要注意的是，<code>TARGET_LINK_LIBRARIES</code>后面的<code>libTEST.so</code>路径必须绝对路径,如果想要使用相对路径，需要设置链接库搜索目录（见下文<strong>设置链接库搜索目录</strong>）</p></div><p>在build文件夹下执行<code>cmake</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p><img src="/img/CMake/lib-build文件夹cmake.png" /></p><p>然后执行<code>make</code>命令：</p><p><img src="/img/CMake/lib-build文件夹make.png" /></p><h2 id="cmakelists.txt的常用选项">CMakelists.txt的常用选项</h2><p>上面是CMake最基本的集中使用方法，还有一些CMake常用的选项见下文</p><h3 id="指定cmake的最小版本">指定cmake的最小版本</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">3.12</span>)    <span class="hljs-comment"># 指定cmake的最小版本</span><br></code></pre></td></tr></table></figure><h3 id="定义工程名称">定义工程名称</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(main)   <span class="hljs-comment"># 定义工程名称</span><br></code></pre></td></tr></table></figure><h3 id="显示定义变量">显示定义变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(var [value]) <span class="hljs-comment"># 显示定义变量</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 第一种用法，生成代码文件列表</span><br><span class="hljs-comment"># 先直接设置SRC_LIST的值</span><br><span class="hljs-keyword">set</span>(SRC_LIST add.h add.cpp)<br><span class="hljs-comment"># 然后再在SRC_LIST中追加main.cpp </span><br><span class="hljs-keyword">set</span>(SRC_LIST <span class="hljs-variable">$&#123;SRC_LIST&#125;</span> main.cpp)<br><br><span class="hljs-comment"># 第二中用法，设置库生成目录或者可执行文件生成目录</span><br><span class="hljs-keyword">set</span>( LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/linux) <br><span class="hljs-keyword">set</span>( EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br></code></pre></td></tr></table></figure><h3 id="编译链接库可执行程序">编译链接库/可执行程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 编译静态库</span><br><span class="hljs-keyword">add_library</span>(库名称 STATIC 代码文件名称) <br><br><span class="hljs-comment"># 编译动态库</span><br><span class="hljs-keyword">add_library</span>(库名称 SHARED 代码文件名称) <br><br><span class="hljs-comment"># 编译可执行程序</span><br><span class="hljs-keyword">add_executable</span>(可执行程序名 代码文件名称)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 编译静态库</span><br><span class="hljs-keyword">add_library</span>(add STATIC add.h add.cpp)<br><span class="hljs-keyword">add_library</span>(add STATIC <span class="hljs-variable">$&#123;ADD_SRC&#125;</span> <span class="hljs-variable">$&#123;ADD_HDR&#125;</span>)<br><br><span class="hljs-comment"># 编译动态库</span><br><span class="hljs-keyword">add_library</span>(add  SHARED add.h add.cpp) <br><span class="hljs-keyword">add_library</span>(add SHARED  <span class="hljs-variable">$&#123;ADD_SRC&#125;</span> <span class="hljs-variable">$&#123;ADD_HDR&#125;</span>)<br><br><span class="hljs-comment"># 编译可执行程序</span><br><span class="hljs-keyword">add_executable</span>(main add.h add.cpp mai.cpp)<br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;MAIN_SRC&#125;</span> <span class="hljs-variable">$&#123;MAIN_HDR&#125;</span>)<br></code></pre></td></tr></table></figure><h3id="指定静态库或者动态库编译输出目录">指定静态库或者动态库编译输出目录</h3><p>例如将当前编译的静态库或者动态库输出到当前项目文件夹lib子目录下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH  <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure><h3 id="指定可执行程序编译输出目录">指定可执行程序编译输出目录</h3><p>例如将当前可执行程序输出到当前项目文件夹的bin子目录下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#设定可执行二进制文件的目录</span><br><span class="hljs-keyword">set</span>( EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br></code></pre></td></tr></table></figure><h3 id="设置链接库搜索目录">设置链接库搜索目录</h3><p>例如将链接库搜索目录设置为当前项目文件夹下lib/linux文件夹</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>( <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/linux)<br></code></pre></td></tr></table></figure><h3 id="设置包含目录">设置包含目录</h3><p>例如将包含目录设置为当前项目文件夹下include文件夹</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><h3 id="设置宏定义">设置宏定义</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#预定义宏</span><br><span class="hljs-keyword">add_definitions</span>(-D宏名称)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_definitions</span>(-DWINDOWS)<br><span class="hljs-keyword">add_definitions</span>(-DLINUX)<br></code></pre></td></tr></table></figure><h3 id="静态链接库">静态链接库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main <span class="hljs-keyword">TEST</span>.so)    <span class="hljs-comment"># 链接库</span><br></code></pre></td></tr></table></figure><h3 id="添加子文件夹">添加子文件夹</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>该语句会在执行完当前文件夹CMakeLists.txt之后执行src子目录下的CMakeLists.txt</p></div><h3 id="add_subdirectory">ADD_SUBDIRECTORY</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src)   <span class="hljs-comment"># 添加子目录</span><br></code></pre></td></tr></table></figure><h3 id="源文件名赋值给变量">源文件名赋值给变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">AUX_SOURCE_DIRECTORY</span>(. DIR_SRCS)   <span class="hljs-comment"># 将当前目录下的所有源文件名赋值给变量DIR_SRCS</span><br></code></pre></td></tr></table></figure><p>参考：</p><ul><li><ahref="https://segmentfault.com/a/1190000021336082">CMake--使用教程基础篇</a></li><li><ahref="https://zhuanlan.zhihu.com/p/315768216">cmake常用命令的一些整理</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-日志类</title>
    <link href="/2023/06/29/muduo%E5%BA%93-%E6%97%A5%E5%BF%97%E7%B1%BB/"/>
    <url>/2023/06/29/muduo%E5%BA%93-%E6%97%A5%E5%BF%97%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-日志类">muduo库-日志类</h1><p>muduo库中的日志为诊断日志，用于将代码运行时的重要信息进行保存，方便故障诊断和追踪。日志通常分为如下两种：</p><ul><li><strong>同步日志</strong>：当需要写出一条日志消息时，只有等到这条日志消息完全写出时才能执行后续的程序，其问题在于可能会阻塞在磁盘写操作上；</li><li><strong>异步日志</strong>：当需要写日志消息时，只是将日志消息进行存储，当积累到一定量时或者达到时间间隔后，由后台线程自动将存储的所有日志进行数据；</li></ul><p>综上所述，异步日志的好处是前台线程不会阻塞在写日志上，后台线程真正写日志时，日志消息往往已经积累了很多，此时只需一次IO 操作，从而减少了 IO 函数的调用次数，提高了效率。</p><p>而一个日志库大体可以分为前端和后端两部分：</p><ul><li>前端：生成日志消息到缓冲区</li><li>后端：将缓冲区中的日志消息输出到本地文件</li></ul><p>日志的前端与后端就是一个典型的 "多生产者——单消费者" 问题：</p><ul><li>对于生产者而言，要尽可能坐到低延迟、低 CPU 开销、无阻塞；</li><li>对于消费者而言，要做到足够大的吞吐量，并占用少的资源；</li></ul><p>对于日志消息而言，要做到以下几点：</p><ol type="1"><li>每条日志消息占一行，且格式明确，便于 awk、grep 工具分析；</li><li>打印线程ID、日志级别、源文件、行号；</li><li>时间戳精确到微秒；</li><li>对于分布式系统而言，使用 GMT 时区；</li></ol><h2 id="日志框架设计思路">日志框架设计思路</h2><p>每一次日志操作，都进行三个步骤：</p><ol type="1"><li>打开文件</li><li>写文件</li><li>关闭文件</li></ol><p>但是，当写入日志的频率较高时，磁盘 IO占用较高。尽管在多线程文件操作中是线程安全的，但是多个线程写入日志的顺序确难以保证。</p><p>为此，可以在应用程序启动之初打开全局文件一次，后续每次日志操作，只需写入文件即可。</p><p>由于文件操作默认是存在缓冲区的，只有当缓冲区存满后，才将缓冲区的内容输出到文件中。相较于频繁的打开文件，此方案减少了打开文件、关闭文件的次数，效率得到了提升。</p><div class="admonition note"><p class="admonition-title">note</p><p>C++ 中的 ostream 并非线程安全，而 C 中的 fwrite 则是线程安全的。</p></div><p>为了进一步提高效率，尽可能地减少磁盘 IO的操作。可以使用一个线程安全队列，一边负责写日志消息，一边负责取日志消息。当所取日志条数或总长度达到一定数量时，我们才写入一次磁盘，以此来降低磁盘IO 的操作次数。</p><p>除此之外，多个线程还可以共用一个日志前端，使用多缓冲技术。例如 muduo库所采用的双缓冲技术，前端负责向 Buffer 中填入数据，后端则负责将 Buffer中的数据取出来写入到文件。</p><p>如图所示，准备两块缓冲区 Buffer A 和 Buffer B，前端负责往 Buffer A中写入日志消息，后端负责将 Buffer B 中的日志消息写入文件：</p><p><img src="/img/muduo/日志类/多缓冲技术.png" /></p><p>当 Buffer A 写满之后，交换 A 和 B，让后端将 Buffer A中的日志消息写入文件，而前端则往 Buffer B中写入新的日志消息，如此反复。</p><p><img src="/img/muduo/日志类/多缓冲技术-1.png" /></p><p>在大部分的时间中，前端线程和后端线程不会操作同一个缓冲区，这也就意味着前端线程的操作，不需要等待后端线程缓慢的写文件操作，因为不需要锁定临界区。</p><div class="admonition note"><p class="admonition-title">note</p><p>前端线程和后端线程仅仅只在交换缓冲区时会存在线程同步问题，因此只需要在交换缓冲区时使用互斥锁来保护临界区即可，这个时间极其短暂，这也就是提高吞吐量的关键所在。</p></div><p>同时，后端线程将缓冲区中的日志消息写入到文件系统中的频率，完全由自己的写入策略来决定，避免了每条新的日志消息都唤醒后端线程。</p><p>换言之，前端线程不是将一条条日志消息分别传送给后端线程，而是将多条消息组成一个大的Buffer 传递给后端进行处理，相当于批量处理，减少了线程唤醒的频率和 IO操作次数，降低开销。</p><p>在 Muduo的实现中，它在后端设置了一个已满缓冲区的队列，用于缓冲一个周期内临时要写的日志消息：</p><p><img src="/img/muduo/日志类/后端缓冲区队列.png" /></p><h2 id="logstream">LogStream</h2><p><code>FixedBuffer</code> 类是作为 <code>LogStream</code>类类型的缓冲区对象，其是一个模板类，传入一个非类型参数 <code>SIZE</code>用来表示缓冲区的大小，其示意图如图所示：</p><p><img src="/img/muduo/日志类/SIZE大小.png" /></p><p>如图所示，其在栈上维护一段大小为 <code>SIZE</code>的内存区域，<code>length</code> 为已写入数据的长度，而<code>avail</code> 为剩余可用的数据长度。</p><p><code>SmallBuffer</code> 的默认大小为 4KB，为前端的<code>LogStream</code> 所持有。而 <code>LargeBuffer</code> 的默认大小为4MB，为后端 的 <code>AsyncLogging</code> 所持有。</p><p>对于 <code>LogStream</code> 类类型来说，它将要输出的信息加载到<code>FixedBuffer</code> 的缓冲区中，等待后续的处理。它通过重载<code>&lt;&lt;</code>运算符来输出基本的数据类型到缓冲区。各种输入类型的调用链如下所示：</p><p><img src="/img/muduo/日志类/输入类型调用链.png" /></p><div class="admonition note"><p class="admonition-title">note</p><p>LogStream 不是线程安全的，因此对于每个 log 消息应当构造一个临时的LogStream，用完之后随即销毁。</p></div><p>在该类中，设计了大量的运算符重载函数，其效率要优于<code>iostream</code> 和 <code>stdio</code>，使用的思想源于 MatthewWilson 的 “带符号整形数据的除法与余数”算法实现。其巧妙之处在于，用一个对称的 <code>digits</code>数组搞定了负数转换的边界条件(二进制补码的正负数表示范围不对称):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> digits[] = <span class="hljs-string">&quot;9876543210123456789&quot;</span>;<br></code></pre></td></tr></table></figure><p>此外，由于 <code>LogStream</code> 本身并不支持格式化，因此设计 Fmt类类型将数值类型数据转化为一个长度不超过 32 位的字符对象Fmt，并重载了支持 Fmt 输出到 <code>LogStream</code> 的<code>&lt;&lt;</code> 操作符模板函数。</p><h2 id="logging">Logging</h2><p>在 <code>Logger</code> 类中定义了枚举变量 <code>LogLevel</code>来作为日志等级：</p><p>表格如下所示：</p><table><thead><tr class="header"><th>日志等级</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>TRACE</td><td>跟踪：指明程序的运行轨迹，比 DEBUG 级别的粒度更细</td></tr><tr class="even"><td>DEBUG</td><td>调试：指明细致的事件信息，对调试应用最有用</td></tr><tr class="odd"><td>INFO</td><td>信息：指明描述信息，从粗粒度上描述了应用的运行过程</td></tr><tr class="even"><td>WARN</td><td>警告：指明潜在的有害状况</td></tr><tr class="odd"><td>ERROR</td><td>错误：指明错误事件，但应用可能还能继续运行</td></tr><tr class="even"><td>FATAL</td><td>致命：指明非常严重的可能导致应用终止执行的错误事件</td></tr></tbody></table><p>如果日志设置为 <span class="math inline">\(L\)</span>，一个日志级别为<span class="math inline">\(P\)</span> 的输出日志只有满足 <spanclass="math inline">\(P≥L\)</span>时日志才会输出。</p><p>具体的输出关系见下表，其中横向表头为日志级别，纵向表头为输出级别：</p><table><thead><tr class="header"><th></th><th>TRACE</th><th>DEBUG</th><th>INFO</th><th>WARN</th><th>ERROR</th><th>FATAL</th></tr></thead><tbody><tr class="odd"><td>TRACE</td><td>✔️</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>DEBUG</td><td>✔️</td><td>✔️</td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>INFO</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td><td></td><td></td></tr><tr class="even"><td>WARN</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td><td></td></tr><tr class="odd"><td>ERROR</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td></tr><tr class="even"><td>FATAL</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr></tbody></table><p>0110 <code>Logger</code> 类使用了桥接模式，其具体实现交给内嵌类 Impl来完成，它主要负责整合日志信息，主要包括：日期、时间、微秒、线程、日志级别、日志正文、源文件名、行号。其通过成员变量<code>stream_</code>将日志输出到缓冲区中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">日期</span>      <span class="hljs-string">时间</span>     <span class="hljs-string">微秒</span>     <span class="hljs-string">线程</span>  <span class="hljs-string">级别</span>  <span class="hljs-string">正文</span>     <span class="hljs-string">源文件名:</span>       <span class="hljs-string">行号</span><br><span class="hljs-number">20220306</span> <span class="hljs-number">09</span><span class="hljs-string">:15:44.681220Z</span> <span class="hljs-number">4013 </span><span class="hljs-string">WARN</span>  <span class="hljs-string">Hello</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Logging_test.cpp:75</span><br></code></pre></td></tr></table></figure><p>除此之外，内嵌类 <code>SourceFile</code>的目的是为了在编译期计算源文件的名称。</p><p><code>Logger</code> 内部有两个成员变量 <code>OutputFunc</code> 和<code>FlushFunc</code>，均为函数指针，分别指向输出函数和刷新函数，默认的输出函数使用线程安全的<code>fwrite()</code> 函数，默认的刷新函数使用<code>fflush()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultOutput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> n = <span class="hljs-built_in">fwrite</span>(msg, <span class="hljs-number">1</span>, len, stdout);<br>  (<span class="hljs-type">void</span>)n;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFlush</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，通过全局变量 <code>g_output</code> 和 <code>g_flush</code>来控制输出函数和刷新函数，使用 <code>g_logTimeZone</code>来设置时区：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Logger::OutputFunc g_output = defaultOutput;<br>Logger::FlushFunc g_flush = defaultFlush;<br>TimeZone g_logTimeZone;<br></code></pre></td></tr></table></figure><p>文件内部定义了多个宏来便于调用 <code>Logger</code>将日志追加到缓冲区中，如果当前日志消息等级低于<code>g_logLevel</code>，就不会进行任何操作，几乎 0 操作，这是通过宏中的<code>if</code> 语句实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TRACE <span class="hljs-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \</span><br><span class="hljs-meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_DEBUG <span class="hljs-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \</span><br><span class="hljs-meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_INFO <span class="hljs-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \</span><br><span class="hljs-meta">  muduo::Logger(__FILE__, __LINE__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span><br></code></pre></td></tr></table></figure><p>在 <code>Logger</code> 的析构函数中，先由 <code>impl_</code>往缓冲区后添加后缀，即文件名和行数以及换行符，然后调用<code>g_output</code> 将缓冲区内容输出到指定的文件流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Logger::~<span class="hljs-built_in">Logger</span>() &#123;<br>  impl_.<span class="hljs-built_in">finish</span>();<br>  <span class="hljs-function"><span class="hljs-type">const</span> LogStream::Buffer&amp; <span class="hljs-title">buf</span><span class="hljs-params">(stream().buffer())</span></span>;<br>  <span class="hljs-built_in">g_output</span>(buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">length</span>());<br>  <span class="hljs-keyword">if</span> (impl_.level_ == FATAL) &#123;<br>    <span class="hljs-built_in">g_flush</span>();<br>    <span class="hljs-built_in">abort</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端日志的时序图如:</p><p><img src="/img/muduo/日志类/前端日志时序图.png" /></p><h2 id="日志类">日志类</h2><p><code>LogFile</code>主要负责对日志文件的操作，包括日志文件的滚动和写入，其构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LogFile::<span class="hljs-built_in">LogFile</span>(<span class="hljs-type">const</span> string&amp; basename,<br>                 <span class="hljs-type">off_t</span> rollSize,<br>                 <span class="hljs-type">bool</span> threadSafe,<br>                 <span class="hljs-type">int</span> flushInterval,<br>                 <span class="hljs-type">int</span> checkEveryN)<br>  : <span class="hljs-built_in">basename_</span>(basename),<br>    <span class="hljs-built_in">rollSize_</span>(rollSize),<br>    <span class="hljs-built_in">flushInterval_</span>(flushInterval),<br>    <span class="hljs-built_in">checkEveryN_</span>(checkEveryN),<br>    <span class="hljs-built_in">count_</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">mutex_</span>(threadSafe ? <span class="hljs-keyword">new</span> MutexLock : <span class="hljs-literal">NULL</span>),<br>    <span class="hljs-built_in">startOfPeriod_</span>(<span class="hljs-number">0</span>),  <span class="hljs-comment">// 本次写日志的起始时间</span><br>    <span class="hljs-built_in">lastRoll_</span>(<span class="hljs-number">0</span>), <span class="hljs-comment">// 上次滚动日志文件的时间</span><br>    <span class="hljs-built_in">lastFlush_</span>(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 上次刷新日志文件的时间</span><br>  <span class="hljs-built_in">assert</span>(basename.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;/&#x27;</span>) == string::npos);<br>  <span class="hljs-built_in">rollFile</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 <code>threadSafe</code> 主要用于控制日志后端的线程安全，默认为<code>true</code>。当只有一个后端线程来处理日志消息时，则无需线程安全。<code>rollSize</code>表示一次最大刷新的字节数，flushInterval表示刷新的时间间隔，单位为毫秒。</p><p><code>checkEveryN</code> 表示写数据的次数限制，默认为1024。<code>count_</code> 用来计数当前写数据的次数，如果超过<code>checkEveryN</code> 则清除以重新计数。</p><p><code>mutex_</code>根据是否需要开启线程安全来决定是否需要初始化互斥锁指针。</p><p>当写数据的次数超过指定的写数据限制时，需要写入新的日志文件，这是通过<code>rollFile()</code> 来实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LogFile::rollFile</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">time_t</span> now = <span class="hljs-number">0</span>;<br>  string filename = <span class="hljs-built_in">getLogFileName</span>(basename_, &amp;now);<br>  <span class="hljs-type">time_t</span> start = now / kRollPerSeconds_ * kRollPerSeconds_;<br> <br>  <span class="hljs-keyword">if</span> (now &gt; lastRoll_) &#123;<br>    lastRoll_ = now;<br>    lastFlush_ = now;<br>    startOfPeriod_ = start;<br>    file_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> FileUtil::<span class="hljs-built_in">AppendFile</span>(filename));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其创建并打开一个新的日志文件，然后更改 <code>unique_ptr</code>所指向的文件对象。</p><p>为了避免频繁的创建新的文件，该函数确保上次滚动事件到现在如果不足 1秒，就不会发生滚动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogFile::append_unlocked</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  file_-&gt;<span class="hljs-built_in">append</span>(logline, len);<br>  <span class="hljs-keyword">if</span> (file_-&gt;<span class="hljs-built_in">writtenBytes</span>() &gt; rollSize_) &#123;<br>    <span class="hljs-built_in">rollFile</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ++count_;<br>    <span class="hljs-keyword">if</span> (count_ &gt;= checkEveryN_) &#123;<br>      count_ = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">time_t</span> now = ::<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>      <span class="hljs-type">time_t</span> thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;<br>      <span class="hljs-keyword">if</span> (thisPeriod_ != startOfPeriod_) &#123;<br>        <span class="hljs-built_in">rollFile</span>();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now - lastFlush_ &gt; flushInterval_) &#123;<br>        lastFlush_ = now;<br>        file_-&gt;<span class="hljs-built_in">flush</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志名的生成是通过如下函数实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">LogFile::getLogFileName</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; basename, <span class="hljs-type">time_t</span>* now)</span> </span>&#123;<br>  string filename;<br>  filename.<span class="hljs-built_in">reserve</span>(basename.<span class="hljs-built_in">size</span>() + <span class="hljs-number">64</span>);<br>  filename = basename;<br>  <span class="hljs-type">char</span> timebuf[<span class="hljs-number">32</span>];<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> tm;<br>  *now = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">gmtime_r</span>(now, &amp;tm);<br>  <span class="hljs-built_in">strftime</span>(timebuf, <span class="hljs-keyword">sizeof</span> timebuf, <span class="hljs-string">&quot;.%Y%m%d-%H%M%S.&quot;</span>, &amp;tm);<br>  filename += timebuf;<br>  filename += ProcessInfo::<span class="hljs-built_in">hostname</span>();<br>  <span class="hljs-type">char</span> pidbuf[<span class="hljs-number">32</span>];<br>  <span class="hljs-built_in">snprintf</span>(pidbuf, <span class="hljs-keyword">sizeof</span> pidbuf, <span class="hljs-string">&quot;.%d&quot;</span>, ProcessInfo::<span class="hljs-built_in">pid</span>());<br>  filename += pidbuf;<br>  filename += <span class="hljs-string">&quot;.log&quot;</span>;<br>  <span class="hljs-keyword">return</span> filename;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志的文件名是通过<code>[基础名].[当前时间].[主机名].[进程号].log</code> 来构成的。</p><p><code>LogFile</code> 通过 <code>append()</code>方法将日志写入文件，它实质上调用的是 <code>append_unlocked()</code>方法，同时根据是否开启线程安全来决定是否需要添加互斥锁来保护临界区。</p><p>同样地，刷新操作也是根据是否启用线程安全来决定是否添加互斥锁保护临界区，其内部调用的是<code>AppendFile::flush()</code> 方法。</p><h2 id="asynclogging">AsyncLogging</h2><p><code>AsyncLogging</code> 主要负责提供大缓冲区，即<code>LargeBuffer</code>，默认大小为 4MB，以存放多条日志消息，而成员变量<code>BufferVector</code> 则用于存放多个<code>LargeBuffer</code>。其构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncLogging</span> : noncopyable &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Large Buffer Type</span><br>  <span class="hljs-keyword">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;<br>  <span class="hljs-keyword">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector; <span class="hljs-comment">// 已满缓冲队列类型</span><br>  <span class="hljs-keyword">typedef</span> BufferVector::value_type BufferPtr;<br> <br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> flushInterval_;                    <span class="hljs-comment">// 冲刷缓冲数据到文件的超时时间, 默认3秒</span><br>  std::atomic&lt;<span class="hljs-type">bool</span>&gt; running_;                  <span class="hljs-comment">// 后端线程loop是否运行标志</span><br>  <span class="hljs-type">const</span> string basename_;                      <span class="hljs-comment">// 日志文件基本名称</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">off_t</span> rollSize_;                       <span class="hljs-comment">// 日志文件滚动大小</span><br>  muduo::Thread thread_;                       <span class="hljs-comment">// 后端线程</span><br>  muduo::CountDownLatch latch_;                <span class="hljs-comment">// 门阀, 同步调用线程与新建的后端线程</span><br>  muduo::MutexLock mutex_;                     <span class="hljs-comment">// 互斥锁, 功能相当于std::mutex</span><br>  <span class="hljs-function">muduo::Condition cond_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;   <span class="hljs-comment">// 条件变量, 与mutex_配合使用, 等待特定条件满足</span><br>  <span class="hljs-function">BufferPtr currentBuffer_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>; <span class="hljs-comment">// 当前缓冲</span><br>  <span class="hljs-function">BufferPtr nextBuffer_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;    <span class="hljs-comment">// 空闲缓冲</span><br>  <span class="hljs-function">BufferVector buffers_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;    <span class="hljs-comment">// 已满缓冲队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前端线程通过调用 LOG_XXX &lt;&lt; "..." 输出日志消息时，可以通过调用AsyncLogging::append() 方法将日志消息传递给后端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsyncLogging::append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *logline, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-function">muduo::MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>  <span class="hljs-keyword">if</span> (currentBuffer_-&gt;<span class="hljs-built_in">avail</span>() &gt; len) &#123;<br>      currentBuffer_-&gt;<span class="hljs-built_in">append</span>(logline, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(len));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    buffers_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(currentBuffer_));<br> <br>    <span class="hljs-keyword">if</span> (nextBuffer_) &#123;<br>      currentBuffer_ = std::<span class="hljs-built_in">move</span>(nextBuffer_);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      currentBuffer_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Buffer);<br>    &#125;<br> <br>    currentBuffer_-&gt;<span class="hljs-built_in">append</span>(logline, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(len));<br>    cond_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>append()</code>可能被多个前端线程调用，因此必须考虑线程安全，采用互斥锁加锁。其基本思路如下图所示：</p><p><img src="/img/muduo/日志类/append互斥锁.png" /></p><p>最后需要唤醒后端线程，是因为后端线程很可能阻塞等待日志消息，当缓冲区满时，能及时唤醒后端线程将已满的数据写入到磁盘上，否则短时间内如果产生大量的日志消息，会造成数据堆积，甚至丢失，而后端线程一直休眠，直到3 秒超时后唤醒。</p><p>后端线程的启动和结束是在如下两个方法中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>  running_ = <span class="hljs-literal">true</span>;<br>  thread_.<span class="hljs-built_in">start</span>();<br>  latch_.<span class="hljs-built_in">wait</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;<br>  running_ = <span class="hljs-literal">false</span>;<br>  cond_.<span class="hljs-built_in">notify</span>();<br>  thread_.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中变量 <code>latch_</code> 的作用是等待 <code>thread_</code>线程启动完成。<code>stop()</code>则用于关闭后端线程，通常实在析构函数中自动调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">AsyncLogging</span>() &#123;<br>  <span class="hljs-keyword">if</span> (running_) &#123;<br>    <span class="hljs-built_in">stop</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后端线程函数 <code>threadFunc</code>，会创建 1 个<code>LogFile</code> 对象，用于控制日志文件的创建和写日志数据，创建 2个空闲缓冲区<code>buffer1</code>、<code>buffer2</code>，和一个待写缓冲队列<code>buffersToWrite</code>，分别用于替换当前缓冲<code>currentBuffer_</code>、空闲缓冲<code>nextBuffer_</code>、已满缓冲队列<code>buffers_</code>，避免在写文件过程中，锁住缓冲区和队列，导致前端无法写数据到后端缓冲。</p><p>threadFunc 内部的 loop 流程如下：</p><!-- ![](/img/muduo/日志类/threadFunc内部loop流程.png) --><p><img src="/img/muduo/日志类/threadFunc内部loop流程.png"  width = "100%" height = "25%"  align=center /></p><h2 id="总结">总结</h2><p>转载自 <ahref="https://www.cnblogs.com/tuilk/p/16793625.html">Muduo库之异步日志</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-ThreadLocalSingleton类</title>
    <link href="/2023/06/28/muduo%E5%BA%93-ThreadLocalSingleton%E7%B1%BB/"/>
    <url>/2023/06/28/muduo%E5%BA%93-ThreadLocalSingleton%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-threadlocalsingleton类">muduo库-ThreadLocalSingleton类</h1><p>ThreadLocalSingleton类图如下：</p><p><imgsrc="/img/muduo/ThreadLocalSingleton/ThreadLocalSingleton类图.png" /></p><p>ThreadLocalSingleton 类封装为了线程本地存储单例类。在 <ahref="https://gstarmin.github.io/2023/06/27/muduo%E5%BA%93-Singleton%E7%B1%BB/">Signleton</a>中提到过，常见的单例模式设计分为四种：</p><ul><li>懒汉式</li><li>双检锁</li><li>饿汉式</li><li>局部静态式</li></ul><p><code>ThreadLocalSingleton</code>类则采用了懒汉式的构建方法，而且由于是线程本地存储，则无需互斥锁来保证线程安全：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!t_value_) &#123;<br>    t_value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>    deleter_.<span class="hljs-built_in">set</span>(t_value_);<br>  &#125;<br>  <span class="hljs-keyword">return</span> *t_value_;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalSignleton 类有两个成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> __thread T* t_value_;<br><span class="hljs-type">static</span> Deleter deleter_;<br></code></pre></td></tr></table></figure><p>其中，<code>t_value_</code> 用于构建单例对象，由于 <code>T*</code>为指针类型，即 <code>POD</code> 类型，因此可以使用 <code>__thread</code>关键字进行修饰，使其成为线程本地存储数据，而无需使用<code>ThreadLocal</code> 类型。其次，<code>deleter_</code>变量则用于声明一个 Deleter 类对象，该类用于销毁<code>t_value_</code>所指的对象，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deleter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Deleter</span>() &#123;<br>    <span class="hljs-built_in">pthread_key_create</span>(&amp;pkey_, &amp;ThreadLocalSingleton::destructor);<br>  &#125;<br> <br>  ~<span class="hljs-built_in">Deleter</span>() &#123;<br>    <span class="hljs-built_in">pthread_key_delete</span>(pkey_);<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T* newObj)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">pthread_getspecific</span>(pkey_) == <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_setspecific</span>(pkey_, newObj);<br>  &#125;<br> <br>  <span class="hljs-type">pthread_key_t</span> pkey_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，<code>Deleter</code> 是一个 <code>TSD</code>(Thread SpecificData) 类型，只为线程本地所拥有。类似于 <code>ThreadLocal</code>类型，它使用 <strong>RAII</strong> 方式，在构造函数中创建<code>key</code>，以绑定 <code>ThreadLocalSingleton</code>类中的销毁函数，而在析构函数中则删除 <code>key</code>。</p><p>销毁对象的函数则如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-type">void</span>* obj)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(obj == t_value_);<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];<br>  T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy;<br>  <span class="hljs-keyword">delete</span> t_value_;<br>  t_value_ = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，首先判断类型 <code>T</code>是否为不完全类型，如果是，则会在编译期发生错误，否则可以调用<code>delete</code> 以调用析构函数，销毁该对象。</p><h2 id="总结">总结</h2><p><code>ThreadLocalSingleton</code> 类的结构图如下：</p><p><imgsrc="/img/muduo/ThreadLocalSingleton/ThreadLocalSingleton结构图.png" /></p><p>参考：</p><ul><li><ahref="https://www.cnblogs.com/tuilk/p/16796365.html#threadlocalsingleton">Muduo库之线程</a></li><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89069063">muduo/base库学习笔记（9）-----ThreadLocalSingleton类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Threadlocal类</title>
    <link href="/2023/06/27/muduo%E5%BA%93-Threadlocal%E7%B1%BB/"/>
    <url>/2023/06/27/muduo%E5%BA%93-Threadlocal%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-threadlocal类">muduo库-Threadlocal类</h1><p>首先来看一个概念：<strong>线程特定数据</strong></p><p>在单线程程序中，我们经常用全局变量共享数据。多线程环境下，全部变量被所有线程所共有。但有时应用程序设计中有必要提供线程私有的全局变量，仅在某个线程中有效。POSIX线程库通过维护一定的数据结构来解决这个问题，这些数据称之为<strong>线程特定数据(Thread-specificData，或TSD)</strong>。对于POD类型，可以用__thread来解决。</p><div class="admonition note"><p class="admonition-title">POD类型</p><p>POD(Plain Old Data)类型是C++ 定义的一类数据结构概念，比如 int、float等都是 POD 类型的。Plain 代表它是一个普通类型，Old代表它是旧的，与几十年前的 C 语言兼容，那么就意味着可以使用 memcpy()这种最原始的函数进行操作。两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有POD特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变。也就是说，能用C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据。</p></div><p>POSIX线程库通过四个函数操作线程特定数据，分别是<code>pthread_key_create</code>，<code>pthread_key_delete</code>，<code>pthread_getspecific</code>，<code>pthread_setspecific</code>。</p><p><img src="/img/muduo/ThreadLocal/线程特定数据.png" /></p><p>一旦某个线程创建了一个<code>key</code>，比如<code>key[1]</code>，那么其他线程也有自己的<code>key[1]</code>，它们通过各自的<code>key[1]</code>访问到的实际数据（堆上内存分配的空间）是不同的，<code>pthread_key_delete</code>只是删除<code>key</code>，实际数据空间的释放需要在<code>pthread_key_create</code>中注册一个回调函数<code>destructor</code>去<code>delete T*</code>。</p><p><code>ThreadLocal</code>类结构图如下：</p><p><img src="/img/muduo/ThreadLocal/ThreadLocal结构图.png" /></p><p>类的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_THREADLOCAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_THREADLOCAL_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Mutex.h&gt;</span>  <span class="hljs-comment">// MCHECK</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ThreadLocal</span>()<br>  &#123;<br>    <span class="hljs-comment">//构造函数中创建key，数据的销毁由destructor来销毁</span><br>    <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_key_create</span>(&amp;pkey_, &amp;ThreadLocal::destructor));  <br>  &#125;<br> <br>  ~<span class="hljs-built_in">ThreadLocal</span>()<br>  &#123;<br>    <span class="hljs-comment">//析构函数中销毁key</span><br>    <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_key_delete</span>(pkey_));<br>  &#125;<br> <br>  <span class="hljs-comment">//获取线程特定数据</span><br>  <span class="hljs-function">T&amp; <span class="hljs-title">value</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    T* perThreadValue = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-built_in">pthread_getspecific</span>(pkey_)); <span class="hljs-comment">//通过key获取线程特定数据</span><br>    <span class="hljs-keyword">if</span> (!perThreadValue)  <span class="hljs-comment">//如果是空的，说明特定数据还没有创建，那么就空构造一个</span><br>    &#123;<br>      T* newObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>      <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_setspecific</span>(pkey_, newObj));  <span class="hljs-comment">//设置特定数据</span><br>      perThreadValue = newObj;   <span class="hljs-comment">//返回</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> *perThreadValue;   <span class="hljs-comment">//返回对象引用，所以需要*</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destructor</span><span class="hljs-params">(<span class="hljs-type">void</span> *x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    T* obj = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(x);<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];   <span class="hljs-comment">//检测是否是完全类型</span><br>    T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy; <br>    <span class="hljs-keyword">delete</span> obj;   <span class="hljs-comment">//如果是，我们就可以删除它了</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">pthread_key_t</span> pkey_;    <span class="hljs-comment">//key的类型是pthread_key_t类型</span><br>&#125;;<br> <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>muduo库注册的destroy()函数直接将它的入口参数x指针强制转化为T类型指针。然后直接调用delete。这是什么原因呢？</p><p>在pthread_key_create()函数中，传入了一个&amp;ThreadLocal::destructor的成员指针，当线成局部变量销毁时，如果传入的第二个参数不为NULL，系统将调用该函数取销毁实际的数据。由于是类成员函数，隐藏了一个指针是this指针，这时候void*x，x的地址实际上就是this的地址，也就是该对象的地址。</p><p>上面我们知道，<code>ThreadLocal</code>类只有一个成员，就是<code>pthread_key_t</code>类型成员<code>pkey_</code>(不是指针类型)，我们可以再回头看<code>pthread_key_create()</code>函数，我们发现它传入的第一个参数正是pkey_的地址，也就是pthread_key_t*类型。所以我们在<code>destructor()</code>函数中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T* obj = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(x);<br><span class="hljs-keyword">delete</span> obj; <br></code></pre></td></tr></table></figure><p>由于<code>pkey_</code>是传入<code>pthread_key_create()</code>的第一个参数，所以它的地址就是实际数据存放的地址。而<code>(void*)this == (void*)&amp;pkey_</code>，所以直接强制转化<code>this</code>指针为<code>T*</code>类型，然后以<code>T*</code>类型的方式<code>delete</code>，就会真实释放线程局部存储的数据。</p><p>参考：</p><ul><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89066789">muduo/base库学习笔记-ThreadLocal类</a></li><li><ahref="https://blog.csdn.net/FreeeLinux/article/details/53431275">muduo库的ThreadLocal类剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-Singleton类</title>
    <link href="/2023/06/27/muduo%E5%BA%93-Singleton%E7%B1%BB/"/>
    <url>/2023/06/27/muduo%E5%BA%93-Singleton%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-singleton类">muduo库-Singleton类</h1><h2 id="singleton类的实现">Singleton类的实现</h2><p>常见的单例模式实现主要分为以下几种：</p><h3 id="懒汉式">懒汉式</h3><p>懒汉式要求先声明单例对象，然后在调用时才完成实例化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Signleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>      instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>  <span class="hljs-type">static</span> Signleton* instance;<br>&#125;;<br> <br>Signleton* Signleton::instance = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>这种写法并没有考虑到多线程的情况，因此在多线程情况下可能产生多个实例对象，违背单例原则。</p><h3 id="双检锁">双检锁</h3><p>为了解决 “懒汉式”中存在的多线程问题，我们可以通过互斥锁来避免多个实例的创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>      mutex.<span class="hljs-built_in">lock</span>();<br>      <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">nullptr</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Signleton</span>();<br>      &#125;<br>      mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>      instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>  <span class="hljs-type">static</span> Signleton* instance;<br>  <span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> mutex;<br>&#125;;<br> <br>Signleton* Signleton::instance = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">pthread_mutex_t</span> Signleton::mutex = PTHREAD_MUTEX_INITIALIZER;<br></code></pre></td></tr></table></figure><p>进行两次判断以避免多次加锁和解锁操作，保证线程安全。这两次判空的意义如下：</p><ul><li>第一层判空是为了提高效率，即当有一个线程 new出来对象后，第二个线程就不用竞争第一个线程的对象锁而进行等待；</li><li>第二层判空是为了保证线程安全，防止多次实例化操作；</li></ul><p>但是，如果该单例对象比较大，那么加锁操作就会成为一个性能瓶颈。</p><h3 id="饿汉式">饿汉式</h3><p>为了解决双检锁所存在的性能瓶颈问题，设计出了 “饿汉式”的单例模式。饿汉式则要求单例对象的声明和实例化同时完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span> instance;<br>      instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>  <span class="hljs-type">static</span> Signleton* instance;<br>&#125;;<br> <br>Signleton* Signleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Signleton</span>();<br></code></pre></td></tr></table></figure><p>因为单例对象的静态初始化是在程序开始之前，在静态资源区中已经初始化了实例对象，所以静态初始化也就保证了线程安全性。在性能要求较高时，可以采用这种方式，从而避免了频繁的加锁、解锁操作造成的资源浪费。</p><h3 id="静态内部类">静态内部类</h3><p>但是如果单例对象无需考虑销毁操作，单例对象的生命周期伴随着整个程序的生命周期，程序结束时，由操作系统自动回收资源。那么如果无需考虑销毁操作，则可以用静态内部类的方式进行实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Signleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Signleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> Signleton instance;<br>    <span class="hljs-keyword">return</span> &amp;instance;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Signleton</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="muduo库的singleton类实现">muduo库的Singleton类实现</h2><p>其类图如下图所示：</p><p><img src="/img/muduo/Singleton/Singleton类图.png" /></p><p>在 muduo 的实现中，模板类 <code>Singleton</code>的内部定义有两个静态成员变量：<code>ponce_</code>和<code>value_</code>。其中，前者是 <code>pthread_once_t</code>类型，以保证单例且线程安全。后者则是一个指针类型，指向单例对象。它们的初始化操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* Singleton&lt;T&gt;::value_ = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>类中的获取实例及初始化函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">pthread_once</span>(&amp;ponce_, &amp;Singleton::init);<br>  <span class="hljs-built_in">assert</span>(value_ != <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> *value_;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>  <span class="hljs-keyword">if</span> (!detail::has_no_destroy&lt;T&gt;::value)&#123;<br>    ::<span class="hljs-built_in">atexit</span>(destroy);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>pthread_once()</code> 保证 <code>init()</code>函数只调用一次，避免多线程竞争，保证了线程安全。而<code>has_no_destroy&lt;T&gt;</code> 则是为了判断该类型是否含有<code>no_destory()</code> 函数，如果不存在，则调用<code>atexit()</code>注册 <code>destroy()</code>函数，当程序正常终结时，调用指定的 <code>destroy()</code>函数以回收资源。</p><p>其中的 <code>has_no_destory&lt;T&gt;</code> 定义如下，这是利用了 C++中的 <strong>SFINEA(Substitution failure is not an error)</strong>机制，即“匹配失败不是错误”。具体来说，就是当重载的模板参数展开时，如果展开导致一些类型不匹配，编译器并不报错。而正好可以利用该机制来判断类是否存在某个成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_no_destroy</span> &#123;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">decltype</span>(&amp;C::no_destroy))</span></span>;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>假如类中存在 <code>no_destory()</code> 函数，那么<code>decltype(&amp;C::no_destory)</code>表达式会返回一个函数指针，该指针指向类中的 <code>no_destory()</code>函数。此时 <code>test&lt;T&gt;(0)</code> 就会匹配为<code>char test()</code> 函数，并返回 <code>char</code>，由于<code>sizeof(char)</code> 为 <code>1</code>，所以<code>sizeof(test&lt;T&gt;(0) == 1</code> 表达式会返回<code>true</code>，表示存在该函数。</p><p>假如类中不存在该函数，那么在匹配函数 <code>char test()</code>时就会匹配错误，进而选择次一级的匹配选项，即<code>int32_t test(...)</code>函数，由于该函数参数中为可变参数，所以可以接受任意类型的函数参数，<code>test&lt;T&gt;(0)</code>与该函数匹配成功，进而返回 <code>int32_t</code>。最后由于<code>sizeof(int32_t) == 1</code> 返回<code>false</code>，则表示不存在该函数。</p><p>该类中的 <code>destory()</code> 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];<br>  T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy;<br>  <span class="hljs-keyword">delete</span> value_;<br>  value_ = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中使用 <code>typedef</code>关键字定义了一个数组类型，用于在编译期判断类型 <code>T</code>是否是不完全类型，不完全类型指的是只有声明却没有定义的类，那么不完全类型在<code>delete</code> 操作时也就无法调用析构函数，因此在<code>delete value_</code> 操作之前需要判断类型 <code>T</code>是否为不完全类型。</p><p>muduo的单例模式采用模板类实现，它内部维护一个模板参数的指针，可以生成任何一个模板参数的单例。凭借SFINAE技术muduo库可以检测模板参数如果是类的话，并且该类注册了一个no_destroy()方法，那么muduo库不会去自动销毁它。否则muduo库会在init时，利用pthread_once()函数为模板参数，注册一个atexit时的destroy()垃圾回收方法，实现自动垃圾回收。智能指针也能达到类似的效果，我们平时写的单例模式在Singleton中写一个Garbage类也可以完成垃圾回收。</p><p>如果是不完全类型，那么 <code>sizeof(T) == 0</code> 为真，数组大小为<code>-1</code>，编译错误；如果是完全类型，那么<code>sizeof(T) == 0</code> 为假，数组大小为<code>1</code>，编译成功。</p><h2 id="总结">总结</h2><p>Singleton类的整体结构如下：</p><p><img src="/img/muduo/Singleton/Singleton.png" /></p><!-- ## Singleton类的实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_SINGLETON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_SINGLETON_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">// atexit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">namespace</span> detail<br>&#123;<br><span class="hljs-comment">//不能侦测继承的成员函数</span><br><span class="hljs-comment">// This doesn&#x27;t detect inherited member functions!</span><br><span class="hljs-comment">// http://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_no_destroy</span>      <br>&#123;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-title">test</span><span class="hljs-params">(typeof(&amp;C::no_destroy))</span></span>; <span class="hljs-comment">// or decltype in C++11</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>;    <span class="hljs-comment">//判断如果是类的话，是否有no_destroy方法。</span><br>&#125;;<br>&#125;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span>   <span class="hljs-comment">//得到对象</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">pthread_once</span>(&amp;ponce_, &amp;Singleton::init);   <span class="hljs-comment">//第一次调用会在init函数内部创建，pthread_once保证该函数只被调用一次！！！！</span><br>       <span class="hljs-comment">//并且pthread_once()能保证线程安全，效率高于mutex</span><br>    <span class="hljs-built_in">assert</span>(value_ != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> *value_;    <span class="hljs-comment">//利用pthread_once只构造一次对象</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Singleton</span>();<br>  ~<span class="hljs-built_in">Singleton</span>();<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>   <span class="hljs-comment">//客户端初始化该类</span></span><br><span class="hljs-function">  </span>&#123;<br>    value_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();   <span class="hljs-comment">//直接调用构造函数</span><br>    <span class="hljs-keyword">if</span> (!detail::has_no_destroy&lt;T&gt;::value)   <span class="hljs-comment">//当参数是类且没有&quot;no_destroy&quot;方法才会注册atexit的destroy</span><br>    &#123;<br>      ::<span class="hljs-built_in">atexit</span>(destroy);   <span class="hljs-comment">//登记atexit时调用的销毁函数，防止内存泄漏</span><br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span>  <span class="hljs-comment">//程序结束后自动调用该函数销毁</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">//用typedef定义了一个数组类型，数组的大小不能为-1，利用这个方法，如果是不完全类型，编译阶段就会发现错误</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> T_must_be_complete_type[<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>];  <span class="hljs-comment">//要销毁这个类型，这个类型必须是完全类型</span><br>    T_must_be_complete_type dummy; (<span class="hljs-type">void</span>) dummy;  <span class="hljs-comment">//这个</span><br> <br>    <span class="hljs-keyword">delete</span> value_;   <span class="hljs-comment">//销毁</span><br>    value_ = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">//赋空</span><br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">pthread_once_t</span> ponce_;     <span class="hljs-comment">//pthread_once的参数</span><br>  <span class="hljs-type">static</span> T*             value_;        <span class="hljs-comment">//模板T类型的指针</span><br>&#125;;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;   <span class="hljs-comment">//初始化pthread_once</span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T* Singleton&lt;T&gt;::value_ = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//静态成员外部会初始化为空</span><br> <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>muduo库与我们平时使用mutex取get_instance不同，我们平时通常在get_Instance中只产生对象，在此之前需要先手动调用init()方法。但muduo库使用了pthread_once()函数，该函数只会执行一次，且是线程安全的函数，所以只有在我们第一次get_instance()时，才会自动调用Init()方法。此后只会获取实例。--&gt;</p><p>参考：</p><ul><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89066488">muduo/base库学习笔记-Singleton类</a></li><li><ahref="https://blog.csdn.net/FreeeLinux/article/details/53428867">muduo库的Singleton类剖析</a></li><li><ahref="https://www.cnblogs.com/tuilk/p/16791415.html">Muduo库之WeakCallback、Singleton</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-BlockingQueue和BounderBlockingQueue</title>
    <link href="/2023/06/26/muduo%E5%BA%93-BlockingQueue%E5%92%8CBounderBlockingQueue/"/>
    <url>/2023/06/26/muduo%E5%BA%93-BlockingQueue%E5%92%8CBounderBlockingQueue/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-blockingqueue和bounderblockingqueue">muduo库-BlockingQueue和BounderBlockingQueue</h1><h2 id="无界阻塞队列-blockingqueue">无界阻塞队列 BlockingQueue</h2><p>muduo库的<code>BlcokingQueue</code>实际上用的生产这消费者模型。我们知道生产者消费者模型一般有两种实现方式，可以利用信号量也可以利用条件变量实现，muduo库采用条件变量实现。</p><p><code>BlockingQueue</code>比较简单，它是线程安全的，我们在外部调用它时无需加锁。</p><p><code>BlockingQueue</code>结构如下：</p><p><img src="/img/muduo/BlockingQueue/BlockingQueue结构图.png" /></p><p>其代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_BLOCKINGQUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_BLOCKINGQUEUE_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Condition.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Mutex.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">BlockingQueue</span>()<br>    : <span class="hljs-built_in">mutex_</span>(),<br>      <span class="hljs-built_in">notEmpty_</span>(mutex_),<br>      <span class="hljs-built_in">queue_</span>()    <span class="hljs-comment">//使用deque</span><br>  &#123;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span>    <span class="hljs-comment">//往阻塞队列放任务</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    queue_.<span class="hljs-built_in">push_back</span>(x);<br>    notEmpty_.<span class="hljs-built_in">notify</span>(); <span class="hljs-comment">// wait morphing saves us     //不空唤醒</span><br>    <span class="hljs-comment">// http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/</span><br>  &#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GXX_EXPERIMENTAL_CXX0X__</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    queue_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(x));<br>    notEmpty_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> emplace()</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br>  <span class="hljs-function">T <span class="hljs-title">take</span><span class="hljs-params">()</span>    <span class="hljs-comment">//取任务</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;     <span class="hljs-comment">//取任务时也要保证线程安全</span><br>    <span class="hljs-comment">// always use a while-loop, due to spurious wakeup</span><br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>())    <span class="hljs-comment">//如果为空就阻塞在这里啦，用while循环不必多说</span><br>    &#123;<br>      notEmpty_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(!queue_.<span class="hljs-built_in">empty</span>());    <span class="hljs-comment">//确保队列不空</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GXX_EXPERIMENTAL_CXX0X__</span><br>    <span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">(std::move(queue_.front()))</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">(queue_.front())</span></span>;   <span class="hljs-comment">//取出队头</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    queue_.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-comment">//弹出队头。</span><br>    <span class="hljs-keyword">return</span> front;   <span class="hljs-comment">//返回</span><br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     <span class="hljs-comment">//返回队列大小</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">size</span>();<br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">mutable</span> MutexLock mutex_;<br>  Condition         notEmpty_;<br>  std::deque&lt;T&gt;     queue_;<br>&#125;;<br> <br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// MUDUO_BASE_BLOCKINGQUEUE_H</span></span><br></code></pre></td></tr></table></figure><h2 id="有界阻塞队列-boundblockingqueue">有界阻塞队列BoundBlockingQueue</h2><p><code>BoundBlockingQueue</code>有界阻塞队列，实际上就是实现了一个循环队列。功能和上面的BlockingQueue都是一样的。</p><p><imgsrc="/img/muduo/BlockingQueue/BoundBlockingQueue结构图.png" /></p><p>muduo库实现该队列实际上是内部把<code>boost::circular_buffer</code>类作为底层数据结构实现的。</p><p>其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Condition.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Mutex.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/circular_buffer.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/noncopyable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-keyword">namespace</span> muduo<br>&#123;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBlockingQueue</span> : boost::noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BoundedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span></span><br><span class="hljs-function">    : mutex_(),</span><br><span class="hljs-function">      notEmpty_(mutex_),</span><br><span class="hljs-function">      notFull_(mutex_),</span><br><span class="hljs-function">      queue_(maxSize)</span><br><span class="hljs-function">  &#123;</span><br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">full</span>())<br>    &#123;<br>      notFull_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(!queue_.<span class="hljs-built_in">full</span>());<br>    queue_.<span class="hljs-built_in">push_back</span>(x);<br>    notEmpty_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br> <br>  <span class="hljs-function">T <span class="hljs-title">take</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>      notEmpty_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(!queue_.<span class="hljs-built_in">empty</span>());<br>    <span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">(queue_.front())</span></span>;<br>    queue_.<span class="hljs-built_in">pop_front</span>();<br>    notFull_.<span class="hljs-built_in">notify</span>();<br>    <span class="hljs-keyword">return</span> front;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">empty</span>();<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">full</span>();<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     <span class="hljs-comment">//返回大小</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">size</span>();<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     <span class="hljs-comment">//返回容量</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">capacity</span>();<br>  &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">mutable</span> MutexLock          mutex_;<br>  Condition                  notEmpty_;<br>  Condition                  notFull_;<br>  boost::circular_buffer&lt;T&gt;  queue_;      <span class="hljs-comment">//使用boost的环形缓冲区</span><br>&#125;;<br> <br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span></span><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>这两个阻塞队列其实没啥区别，只是底层采用不同数据结构存储数据而已。</p><p>参考：</p><ul><li><ahref="https://blog.csdn.net/FreeeLinux/article/details/53428629">muduo库的BlockingQueue和BoundBlockingQueue类剖析</a></li><li><ahref="https://blog.csdn.net/daaikuaichuan/article/details/86499175">【muduo】base篇-BlockingQueue和BounderBlockingQueue</a></li><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89069643">muduo/base库学习笔记-BoundedBlockingQueue类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-ThreadPool类</title>
    <link href="/2023/06/26/muduo%E5%BA%93-ThreadPool%E7%B1%BB/"/>
    <url>/2023/06/26/muduo%E5%BA%93-ThreadPool%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-threadpool类">muduo库-ThreadPool类</h1><h2 id="线程池模型">线程池模型</h2><p>模型图如下：</p><p><img src="/img/muduo/ThreadPool/线程池模型.png" /></p><p>这个是通用线程池，双端队列存放的是多个可调用对象（即用户任务），而非函数指针，因此可以通过<code>std::bind</code>配接器传参。双端队列<code>queue_</code>，有时也称为工作队列。</p><p><strong>工作原理</strong>：首先创建并启动一组线程，称为线程池<code>threads_</code>，由用户指定其大小<code>maxQueueSize_</code>，每个元素对对应一个线程。每个线程函数都是一样的，在其中会运行一个loop循环：从双端队列取出一个任务对象task，如果非空，就执行之，如此往复。当有一个用户线程想要通过线程池运行一个用户任务时，就可以将用户任务函数及参数封装成一个可调用对象Taskf，然后通过线程池接口，将f加入双端队列末尾。当线程池有线程空闲时（未执行用户任务），就会从双端队列头部取出一个Task对象task，然后执行之。</p><h2 id="threadpool结构">ThreadPool结构</h2><p><img src="/img/muduo/ThreadPool/ThreadPool.png" /></p><h2 id="线程池的构造">线程池的构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ThreadPool::<span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> string &amp;nameArg)<br>: <span class="hljs-built_in">mutex_</span>(),<br>  <span class="hljs-built_in">notEmpty_</span>(mutex_),<br>  <span class="hljs-built_in">notFull_</span>(mutex_),<br>  <span class="hljs-built_in">name_</span>(nameArg),<br>  <span class="hljs-built_in">maxQueueSize_</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">running_</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户可以指定线程池名称，默认为"ThreadPool"，便于调试跟踪，日志诊断问题；值得注意的是工作队列最大大小maxQueueSize_初值0，用户可通过setMaxQueueSize修改其大小；</p><h2 id="启动与停止">启动与停止</h2><p>用户可通过<code>start()</code>启动线程池，需要指定线程组中子线程数量，一旦创建成功后，各子线程就会投入运行，直到调用<code>stop()</code>停止线程池运行。</p><p>由于<code>Thread</code>已内含一个门阀，会让调用线程等待新线程函数启动，因此，这里不必再设置门阀等待线程池中线程的启动。相反，如果有子线程运行所需要的数据，就需要在创建之前就准备好，比如<code>running_</code>，要在线程循环前就设置为<code>true</code>，否则子线程loop不会运行，而是直接退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::start</span><span class="hljs-params">(<span class="hljs-type">int</span> numThreads)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(threads_.<span class="hljs-built_in">empty</span>());<br>    running_ = <span class="hljs-literal">true</span>;<br>    threads_.<span class="hljs-built_in">reserve</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(numThreads));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i)<br>    &#123;<br>        <span class="hljs-type">char</span> id[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(id, <span class="hljs-built_in">sizeof</span>(id), <span class="hljs-string">&quot;%d&quot;</span>, i + <span class="hljs-number">1</span>);<br>        threads_.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> muduo::<span class="hljs-built_in">Thread</span>(<br>                std::<span class="hljs-built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="hljs-keyword">this</span>), name_ + id));<br>        threads_[i]-&gt;<span class="hljs-built_in">start</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (numThreads == <span class="hljs-number">0</span> &amp;&amp; threadInitCallback_)<br>    &#123;<br>        <span class="hljs-built_in">threadInitCallback_</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        running_ = <span class="hljs-literal">false</span>;<br>        notEmpty_.<span class="hljs-built_in">notifyAll</span>();<br>        notFull_.<span class="hljs-built_in">notifyAll</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; thr : threads_)<br>    &#123;<br>        thr-&gt;<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么<code>start()</code>中不加锁，而<code>stop()</code>却要加锁？因为<code>start()</code>中，在子线程启动后，并没有对共享数据进行访问，也就不存在竞态条件。而<code>stop()</code>中，有对共享数据，如<code>running_</code>、<code>notEmpty</code>、<code>notFull</code>，因此，需要加锁对这些数据进行保护。</p><p>这里，子线程退出方式是连接（join）线程，而非分离（detach）线程。个人认为两种方案都可以，不过，join更容易在开发阶段，排查问题，因为如果线程无法正常退出，调用线程会阻塞在join调用上。</p><h2 id="往工作队列加入任务对象">往工作队列加入任务对象</h2><p>调用线程通过<code>run()</code>，向线程池的请求运行用户指定的任务对象，该对象会被加入到工作队列末尾，空闲子线程会自动从工作队列中取任务对象执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::run</span><span class="hljs-params">(Task task)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (threads_.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">// 子线程数量为0</span><br>    &#123;<br>        <span class="hljs-built_in">task</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// 子线程数量非0</span><br>        MutexLockGuard <span class="hljs-built_in">lock</span>(mutex_);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isFull</span>() &amp;&amp; running_)<br>        &#123;<br>            notFull_.<span class="hljs-built_in">wait</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!running_) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">isFull</span>());<br><br>        queue_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(task));<br>        notEmpty_.<span class="hljs-built_in">notify</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有2个特殊情况需要注意：</p><ol type="1"><li><code>threads_</code>为空，即没有创建线程，可能是用户指定线程数为<code>0</code>或非法数量（如负数），也有可能是进程创建的线程数达到系统限制，从而创建线程失败。不论什么原因，为避免进程崩溃，可以直接在当前线程中调用用户任务。</li><li>采用的是isFull()成员来判断工作队列是否满，而不是容器自带的size()来判断。在isFull()内部，添加了一个互斥锁断言，确保isFull()的调用线程已经取得了mutex_锁；否则，一旦有其他线程在未取得锁的情况下，访问应受锁保护工作队列成员，可能导致意外情况。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadPool::isFull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    mutex_.<span class="hljs-built_in">assertLocked</span>();<br>    <span class="hljs-keyword">return</span> maxQueueSize_ &gt; <span class="hljs-number">0</span> &amp;&amp; queue_.<span class="hljs-built_in">size</span>() &gt;= maxQueueSize_;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从工作队列取任务对象">从工作队列取任务对象</h2><p>用take从工作队列头部取出一个任务对象。通常是子线程空闲时调用，取出后，用来执行用户任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ThreadPool::Task <span class="hljs-title">ThreadPool::take</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-comment">// always use a while-loop, due to spurious wakeup</span><br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>() &amp;&amp; running_)<br>    &#123;<br>        notEmpty_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>    Task task;<br>    <span class="hljs-keyword">if</span> (!queue_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        task = queue_.<span class="hljs-built_in">front</span>();<br>        queue_.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (maxQueueSize_ &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            notFull_.<span class="hljs-built_in">notify</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子线程loop">子线程loop</h2><p>主要工作：从工作队列取用户任务，然后执行之。循环往复，直到线程池停止工作。</p><p>实现该工作的runInThread()是在用户调用start()时，自动启动的，不需要用户自行调研。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::runInThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (threadInitCallback_)<br>        &#123;<br>            <span class="hljs-built_in">threadInitCallback_</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (running_)<br>        &#123;<br>            <span class="hljs-function">Task <span class="hljs-title">task</span><span class="hljs-params">(take())</span></span>;<br>            <span class="hljs-keyword">if</span> (task)<br>            &#123;<br>                <span class="hljs-built_in">task</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> Exception&amp; ex)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;exception caught in ThreadPool %s\n&quot;</span>, name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;reason: %s\n&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;stack trace: %s\n&quot;</span>, ex.<span class="hljs-built_in">stackTrace</span>());<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; ex)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;exception caught in TheadPool %s\n&quot;</span>, name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;reason: %s\n&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;unknown exception caught in ThreadPool %s\n&quot;</span>, name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">throw</span> ; <span class="hljs-comment">// rethrow</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，用了try-catch语句块将代码包裹起来，因为不知道用户代码会干些什么，很有可能会产生异常，因此需要捕获异常。对于不确定的异常，可以rethrow（继续上抛）。另外，threadInitCallback_让用户有机会在线程初始化完成后，运行用户任务之前，做一些事情。</p><h2 id="threadpool的使用测试">ThreadPool的使用、测试</h2><p>基本流程:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建线程池对象</span><br><span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-string">&quot;MyThreadPool&quot;</span>)</span></span>;<br><span class="hljs-comment">// 设置工作队列最大尺寸</span><br>pool.<span class="hljs-built_in">setMaxQueueSize</span>(maxSize);<br><span class="hljs-comment">// 启动线程池线程组, 指定线程数量</span><br>pool.<span class="hljs-built_in">start</span>(threadNum);<br><span class="hljs-comment">// 运行用户指定任务</span><br>pool.<span class="hljs-built_in">run</span>(userTask); <span class="hljs-comment">// userTask是用户任务（可调用对象）</span><br>...<br><span class="hljs-comment">// 停止线程池（如有需要）</span><br>pool.<span class="hljs-built_in">stop</span>();<br></code></pre></td></tr></table></figure><p>截取自muduo的部分代码，对ThreadPool进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// from muduo project</span><br><span class="hljs-comment">// muduo/base/tests/ThreadPool_test.cc</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid=%d\n&quot;</span>, muduo::CurrentThread::<span class="hljs-built_in">tid</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_INFO &lt;&lt; str;<br>    <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100</span>*<span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    LOG_WARN &lt;&lt; <span class="hljs-string">&quot;Test ThreadPool with max queue size = &quot;</span> &lt;&lt; maxSize;<br>    <span class="hljs-function">muduo::ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-string">&quot;MainThreadPool&quot;</span>)</span></span>;<br>    pool.<span class="hljs-built_in">setMaxQueueSize</span>(maxSize);<br>    pool.<span class="hljs-built_in">start</span>(<span class="hljs-number">5</span>);<br><br>    LOG_WARN &lt;&lt; <span class="hljs-string">&quot;Adding&quot;</span>;<br>    pool.<span class="hljs-built_in">run</span>(print);<br>    pool.<span class="hljs-built_in">run</span>(print);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;task %d&quot;</span>, i);<br>        pool.<span class="hljs-built_in">run</span>(std::<span class="hljs-built_in">bind</span>(printString, std::<span class="hljs-built_in">string</span>(buf))); <span class="hljs-comment">// 演示了如何向线程池加入含参的可调用对象</span><br>    &#125;<br>    LOG_WARN &lt;&lt; <span class="hljs-string">&quot;Done&quot;</span>;<br>    <br>    <span class="hljs-comment">// 演示了如何等待线程池运行完用户任务</span><br>    <span class="hljs-function">muduo::CountDownLatch <span class="hljs-title">latch</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    pool.<span class="hljs-built_in">run</span>(std::<span class="hljs-built_in">bind</span>(&amp;muduo::CountDownLatch::countDown, &amp;latch));<br>    latch.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">// wait for pool running latch.countDown()</span><br>    pool.<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有2点问题：</p><ol type="1"><li><p>run只接受一个参数，那么调用线程如何向线程池传参？解决方案有很多，一种是使用模板函数，为向工作队列加用户任务的run函数添加不定参数的重载版本；另一种，是使用std::bind配机器，向run传递一个新的可调用对象。muduo采用的是后者。</p></li><li><p>调用线程端的用户，如何获取用户任务执行结果？run()没有任何返回值，用户只能自行设计用户任务函数及参数，通过参数状态取得结果。当然，还有另外的办法就是，让run()返回一个std::future<return_type>，通过future异步获取结果。</p></li></ol><h2 id="线程池大小的选择">线程池大小的选择</h2><p>若池中执行任务时，密集计算所占用的时间比重为<spanclass="math inline">\(P(0&lt;P&lt;=1)1\)</span>,而系统一共有<spanclass="math inline">\(C\)</span>个CPU，为了让<spanclass="math inline">\(C\)</span>个CPU都能得到充分利用而不过载，线程池大小的经验公式为：<spanclass="math inline">\(T=C/P\)</span>,即<spanclass="math inline">\(T*P=C\)</span>(让CPU刚好跑满)</p><h2 id="总结">总结</h2><p>参考：</p><ul><li><ahref="https://www.cnblogs.com/fortunely/p/15979792.html">muduo笔记线程池ThreadPool</a></li><li><ahref="https://blog.csdn.net/xiuxiu__deng/article/details/89073821">muduo/base库学习笔记-ThreadPool类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-线程同步CountDownLatch/Condition</title>
    <link href="/2023/06/26/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5CountDownLatch-Condition/"/>
    <url>/2023/06/26/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5CountDownLatch-Condition/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-线程同步countdownlatchcondition">muduo库-线程同步CountDownLatch/Condition</h1><h2 id="多线程同步中的问题">多线程同步中的问题</h2><p>多线程环境中，常有这样一种同步情况：一个线程等待其他所有线程完成指定工作。比如，在开启一个新线程后，虽然已经启动线程函数，很可能还有一些准备工作需要完成（如更新当前线程id，名称等信息），这样，调用线程（创建线程的线程）并不能马上投入工作，立即向新线程传递数据，可能造成未定义行为，如调用线程的某段代码依赖于子线程id。</p><p>在muduo库中使用<code>CountDownLatch</code>类来解决这个问题。</p><h2 id="condition">Condition</h2><p><code>Condition</code>类图：</p><p><img src="/img/muduo/CountDownLatch/Condition类图.png" /></p><p><code>Condition</code>类是muduo库中对系统线程条件变量类函数进行的封装；往往跟<code>mutexlock</code>配合使用，但也不控制其对象的生存期。</p><p><img src="/img/muduo/CountDownLatch/Condition结构图.png" /></p><p>整个condition类主要为方便用户使用，封装<code>pthread_cond_signal为notify()</code>，封装<code>pthread_cond_broadcast</code>为<code>notifyAll()</code>;封装<code>pthread_cond_wait</code>为<code>wait()</code>；封装<code>pthread_cond_timedwait</code>为<code>waitForSeconds()</code>;</p><h2 id="countdownlatch">CountDownLatch</h2><p><code>CountDownLatch</code> 也被称为门阀 、计数器 或者闭锁。用于多个线程之间的同步，特别是一个线程等待另一个或多个线程。<code>CountDownLatch</code>类图如下：</p><p><img src="/img/muduo/CountDownLatch/CountDownLatch类图.png" /></p><p><code>CountDownLatch</code>内部持有一个向下计数的计数器<code>count_</code>，构造时给定一个初值，代表需要等待的线程数。每个线程完成一个任务，<code>count_</code>减1，当<code>count_</code>值减到0时，代表所有线程已经完成了所有任务，在<code>CountDownLatch</code>上等待的线程就可以继续执行了。</p><p><img src="/img/muduo/CountDownLatch/CountDownLatch结构图.png" /></p><h3 id="countdownlatch的接口">CountDownLatch的接口</h3><p>需要等待其他线程完成任务的线程，调用<code>wait()</code>，等待<code>count_</code>变为0；</p><p>任务线程，如果完成了任务，就调用<code>countDown()</code>，将<code>count_</code>计数值<code>-1</code>，值减到<code>0</code>时，会唤醒所有等待线程继续执行；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Count down from a count user specified to zero.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Thread safe.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Wait until count_ decrease to 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Decrease 1 in count_</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return the value of count_</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> MutexLock mutex_;<br>    <span class="hljs-function">Condition cond_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> count_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="countdownlatch的实现">CountDownLatch的实现</h3><p>通过<code>mutex_</code>，确保所有对<code>count_</code>的操作，都是线程安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CountDownLatch::<span class="hljs-built_in">CountDownLatch</span>(<span class="hljs-type">int</span> count) : <span class="hljs-built_in">mutex_</span>(), <span class="hljs-built_in">cond_</span>(mutex_), <span class="hljs-built_in">count_</span>(count)<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountDownLatch::wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">while</span> (count_ &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cond_.<span class="hljs-built_in">wait</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Count down count_ from init value to 0, then notify thread</span><br><span class="hljs-comment">* waiting on the condition cond_.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountDownLatch::countDown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    --count_;<br>    <span class="hljs-keyword">if</span> (count_ == <span class="hljs-number">0</span>)<br>    &#123;<br>        cond_.<span class="hljs-built_in">notifyAll</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountDownLatch::getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> count_;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://www.cnblogs.com/fortunely/p/15944815.html">muduo笔记线程同步CountDownLatch</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-lambda递归调用的问题</title>
    <link href="/2023/06/26/Cpp-lambda%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/26/Cpp-lambda%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp-lambda递归调用的问题">Cpp-lambda递归调用的问题</h1><p>今天写了一个<code>lambda</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function&lt;<span class="hljs-type">bool</span>(TreeNode*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>)&gt; isBST = [](TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> <span class="hljs-type">long</span> upper)<br>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root-&gt;right, root-&gt;val, upper);<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后发现报错了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Line 23: Char 20: error: variable &#x27;isBST&#x27; cannot be implicitly captured in a lambda with no capture-default specified<br>            return isBST(root-&gt;left, lower, root-&gt;val) &amp;&amp; isBST(root-&gt;right, root-&gt;val, upper);<br>                   ^<br>Line 16: Char 57: note: &#x27;isBST&#x27; declared here<br>        function&lt;bool(TreeNode*, long long, long long)&gt; isBST = [](TreeNode* root, long long lower, long long upper)<br>                                                        ^<br>Line 16: Char 65: note: lambda expression begins here<br>        function&lt;bool(TreeNode*, long long, long long)&gt; isBST = [](TreeNode* root, long long lower, long long upper)<br></code></pre></td></tr></table></figure><p>究其原因是在定义的时候<code>lambda</code>使用了按值捕获，而<code>lambda</code>表达式不能隐式capture，所以需要改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function&lt;<span class="hljs-type">bool</span>(TreeNode*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>)&gt; isBST = [&amp;](TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> <span class="hljs-type">long</span> upper)<br><span class="hljs-comment">//                                                       ^这里一定要使用引用捕获                                                        </span><br>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root-&gt;right, root-&gt;val, upper);<br>&#125;;<br></code></pre></td></tr></table></figure><p>之所以使用引用捕获而不是值捕获，原因是捕获的时候，fact还没有初始化。</p><p>这个问题其实和下面的代码问题是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <span class="hljs-comment">// not initialized</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref_n = n;<br><span class="hljs-type">int</span> val_n = n;<br>n = <span class="hljs-number">10</span>; <span class="hljs-comment">// initialized</span><br>cout &lt;&lt; <span class="hljs-string">&quot;n is &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;, ref_n is &quot;</span> &lt;&lt; ref_n &lt;&lt; <span class="hljs-string">&quot;, val_n is &quot;</span> &lt;&lt; val_n &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n is 10, ref_n is 10, val_n is 4198713<br></code></pre></td></tr></table></figure><p><code>n</code>和<code>ref_n</code>都能获得正确的值，但<code>val_n</code>就不一定能打印出什么来了。这就是因为，在使用<code>operator=</code>的时候，<code>val_n</code>将未初始化的<code>n</code>复制了一份，而之后<code>n</code>的初始化和<code>val_n</code>就无关了，所以<code>val_n</code>虽然初始化了，但和没初始化一样。</p><p>参考<ahref="https://zhuanlan.zhihu.com/p/414509010">C++中的递归lambda，以及携带额外变量</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-线程类Thread，当前线程类CurrentThread</title>
    <link href="/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E7%B1%BBThread%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%B1%BBCurrentThread/"/>
    <url>/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E7%B1%BBThread%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%B1%BBCurrentThread/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-线程类thread当前线程类currentthread">muduo库-线程类Thread，当前线程类CurrentThread</h1><h2 id="线程类thread要解决的问题">线程类Thread要解决的问题</h2><p>从用户角度，一个线程类应该要提供什么给用户？</p><p>线程类最核心的内容显然是为用户提供另一个执行流，让用户程序能以线程方式并发执行（调用线程与新线程“同时”执行），但同时能共享同一个进程的内存空间。同时，作为用户，我们希望能对这个线程设置用户提供的线程函数，还有对线程进行控制，包括启动、停止、回收资源（连接）；获得这个线程在内核或线程库中的线程id，是否已启动、是否已连接（被回收资源）等状态信息。为了方便调试、打印/查看log，我们可能还需要为线程设置标识，如用户指定的线程id和线程名称等信息。</p><p>现有的线程能提供什么？<br />Linux下，C++ 11 std::thread也是用NPTL提供的pthreads实现的，因此，我们主要考虑pthreads。</p><p>pthreads主要接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span></span>;<br><span class="hljs-comment">// 连接线程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span></span>;<br><span class="hljs-comment">// 分离线程, 线程分离后, 调用线程无需其他线程join</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><span class="hljs-comment">// 退出调用线程,</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br><span class="hljs-comment">// 取消(指定)线程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><span class="hljs-comment">// 判断2个线程id是否相同</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_equal</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span></span>;<br></code></pre></td></tr></table></figure><p>注：以上线程函数的使用，都需要用-pthread编译、链接。</p><h2 id="封装线程类thread">封装线程类Thread</h2><p>根据pthreads接口pthread_*，Thread要实现：</p><ul><li>基本线程的原语：线程的创建和等待结束。</li><li>线程控制的状态：是否已经创建（启动），是否已经结束（连接）。</li><li>线程属性：线程id，线程名称。</li><li>线程统计信息：通过Thread class创建的线程数量。</li></ul><p>线程类的拷贝没有实际意义，因为线程会对应内核中的数据结构，运行状态等。</p><h3 id="thread-接口">Thread 接口</h3><p>因此，我们可以为Thread设计如下接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>()&gt; ThreadFunc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadFunc, <span class="hljs-type">const</span> string&amp; nameArg = string())</span></span>;<br>    ~<span class="hljs-built_in">Thread</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> started_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">pthread_t</span> <span class="hljs-title">pthreadId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pthreadId_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> tid_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> string&amp; <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">numCreated</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> numCreated_.<span class="hljs-built_in">get</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDefaultName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">bool</span> started_;    <span class="hljs-comment">// 启动状态</span><br>    <span class="hljs-type">bool</span> joined_;     <span class="hljs-comment">// 连接状态</span><br>    <span class="hljs-type">pthread_t</span> pthreadId_; <span class="hljs-comment">// 用来绑定NPTL线程</span><br>    <span class="hljs-type">pid_t</span> tid_;       <span class="hljs-comment">// 当前线程tid, 通过CurrentThread::tid()获取</span><br>    ThreadFunc func_; <span class="hljs-comment">// 用户设置的线程函数</span><br>    string name_;     <span class="hljs-comment">// 用户自定义名称, 用于debug, log</span><br>    CountDownLatch latch_; <span class="hljs-comment">// 向下计数器, 用于同步调用线程和新线程</span><br><br>    <span class="hljs-type">static</span> AtomicInt32 numCreated_; <span class="hljs-comment">// 原子类型, Thread class已经创建的线程数量</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="thread-实现">Thread 实现</h3><p>Thread对象构造，决定了数据成员的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">AtomicInt32 Thread::numCreated_;<br><br>Thread::<span class="hljs-built_in">Thread</span>(Thread::ThreadFunc func, <span class="hljs-type">const</span> string&amp; nameArg)<br>: <span class="hljs-built_in">started_</span>(<span class="hljs-literal">false</span>),<br>  <span class="hljs-built_in">joined_</span>(<span class="hljs-literal">false</span>),<br>  <span class="hljs-built_in">pthreadId_</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">tid_</span>(<span class="hljs-number">0</span>),<br>  <span class="hljs-built_in">func_</span>(std::<span class="hljs-built_in">move</span>(func)),<br>  <span class="hljs-built_in">name_</span>(nameArg),<br>  <span class="hljs-built_in">latch_</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 计数器初值为1, 只需要等待一个线程任务完成</span><br>&#123;<br>    <span class="hljs-built_in">setDefaultName</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* default Thread name: Thread + id (self-defined increased atomic id starts with 1)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::setDefaultName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = numCreated_.<span class="hljs-built_in">incrementAndGet</span>();<br>    <span class="hljs-keyword">if</span> (name_.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;Thread%d&quot;</span>, num);<br>        name_ = buf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>latch_是用来解决调用线程和新线程的同步问题的。只有新线程准备好了以后，调用线程才能继续正常运行。因此，初值为1；<br /></li><li>setDefaultName()利用类的原子变量numCreated_，来组装构建线程对象的名称（name_）。</li></ol><p>start()中创建线程，并启动线程函数；join()连接线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(!started_); <span class="hljs-comment">//to avoid repeated start()</span><br>    started_ = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> move(func_)</span><br>    detail::ThreadData* data = <span class="hljs-keyword">new</span> detail::<span class="hljs-built_in">ThreadData</span>(func_, name_, &amp;tid_, &amp;latch_);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pthreadId_, <span class="hljs-literal">NULL</span>, &amp;detail::startThread, data))<br>    &#123; <span class="hljs-comment">// non-zero: error</span><br>        started_ = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">delete</span> data; <span class="hljs-comment">// or no delete?</span><br>        LOG_SYSFATAL &lt;&lt; <span class="hljs-string">&quot;Failed in pthread_create&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// zero: success</span><br>        latch_.<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-built_in">assert</span>(tid_ &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(started_);<br>    <span class="hljs-built_in">assert</span>(!joined_);<br>    joined_ = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 置连接状态</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_join</span>(pthreadId_, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 连接线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>1）我们并没有直接启动线程函数，而是先构建一个自定义内部类ThreadData对象，包含了线程相关信息，然后再传递给新线程函数。<br />2）线程创建pthread_create失败时，调用LOG_SYSFATAL，会打印log并直接导致程序终止；成功时，会利用latch_等待新线程函数启动运行到指定位置（已经设置好线程tid）。<br />3）我们将pthread_create线程函数交给detail::startThread来执行，而该函数内部又通过传入的ThreadData参数，将运行ThreadData::runInThread()，再在其中运行用户设置的线程函数。而这个函数，是在Thread构建时，由用户指定的。</p><h3 id="内部类threaddata">内部类ThreadData</h3><p>自定义的线程数据结构ThreadData，作为实现细节，包含在detail命名空间即可。<br />ThreadData主要实现：<br />1）新线程通用数据的封装；<br />2）新线程的启动与调用线程的同步；<br />3）try-catch 捕捉并处理用户传入的线程函数异常；<br />4）调用prctl修改线程在内核中的名称；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadData</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;<br>    ThreadFunc func_;<br>    string name_;<br>    <span class="hljs-type">pid_t</span>* tid_;<br>    CountDownLatch* latch_;<br><br>    <span class="hljs-built_in">ThreadData</span>(ThreadFunc func,<br>               <span class="hljs-type">const</span> string&amp; name,<br>               <span class="hljs-type">pid_t</span>* tid,<br>               CountDownLatch* latch)<br>               : <span class="hljs-built_in">func_</span>(std::<span class="hljs-built_in">move</span>(func)),<br>               <span class="hljs-built_in">name_</span>(name),<br>               <span class="hljs-built_in">tid_</span>(tid),<br>               <span class="hljs-built_in">latch_</span>(latch)<br>    &#123; &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set Thread name, tid</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * run thread func set by ctor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        *tid_ = muduo::CurrentThread::<span class="hljs-built_in">tid</span>(); <span class="hljs-comment">// help to cache current thread tid</span><br>        tid_ = <span class="hljs-literal">NULL</span>;<br>        latch_-&gt;<span class="hljs-built_in">countDown</span>();<br>        latch_ = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// as latch_&#x27;s member count_ init value = 1, abandon it after countDown()</span><br><br>        muduo::CurrentThread::t_threadName = name_.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;muduoThread&quot;</span> : name_.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-comment">// Set the name of the calling thread</span><br>        ::<span class="hljs-built_in">prctl</span>(PR_SET_NAME, muduo::CurrentThread::t_threadName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">func_</span>();<br>            muduo::CurrentThread::t_threadName = <span class="hljs-string">&quot;finished&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">catch</span> (...)<br>        &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="当前线程currentthread">当前线程CurrentThread</h2><p>muduo中有个很特殊的命名空间：muduo::CurrentThread。CurrentThread包含了线程的本地数据（threadlocal），以及对调用线程的若干操作。</p><p>thread local数据主要包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CurrentThread.h</span><br><span class="hljs-comment">// thread local</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">int</span> t_cachedTid;      <span class="hljs-comment">// 缓存线程tid</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">char</span> t_tidString[<span class="hljs-number">32</span>]; <span class="hljs-comment">// 线程tid的字符串形式</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">int</span> t_tidStringLength; <span class="hljs-comment">// t_tidStringLength的实际长度</span><br><span class="hljs-keyword">extern</span> __thread <span class="hljs-type">const</span> <span class="hljs-type">char</span>* t_threadName; <span class="hljs-comment">// 线程名称</span><br><br><span class="hljs-comment">// CurrentThread.cc</span><br>__thread <span class="hljs-type">int</span> t_cachedTid = <span class="hljs-number">0</span>;<br>__thread <span class="hljs-type">char</span> t_tidString[<span class="hljs-number">32</span>];<br>__thread <span class="hljs-type">int</span> t_tidStringLength = <span class="hljs-number">6</span>;<br>__thread <span class="hljs-type">const</span> <span class="hljs-type">char</span>* t_threadName = <span class="hljs-string">&quot;unknown&quot;</span>;<br><span class="hljs-built_in">static_assert</span>(std::is_same&lt;<span class="hljs-type">int</span>, <span class="hljs-type">pid_t</span>&gt;::value, <span class="hljs-string">&quot;pit_t should be int&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：这里有个static_assert，用于编译期断言线程tid的类型pid_t是否与int相同。</p><h3 id="cachetid获取当前线程tid">cacheTid()获取当前线程tid</h3><p>前面https://www.cnblogs.com/fortunely/p/15930558.html，已经提到：因为pthread_self()获得的pthread_t类型的线程id，是glibc维护的一个动态分配的内存指针，而且是反复使用的，容易导致线程id值重复。因此我们用系统调用gettid，来获取Linux线程id。<br />考虑到线程id在线程创建后并不会改变，为了避免频繁系统调用，我们用threadlocal变量t_cachedTid在第一次请求线程id时，通过gettid系统调用缓存线程id，其他时候，直接返回该缓存值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CurrentThread::cacheTid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (t_cachedTid == <span class="hljs-number">0</span>)<br>    &#123;<br>        t_cachedTid = detail::<span class="hljs-built_in">gettid</span>();<br>        t_tidStringLength = <span class="hljs-built_in">snprintf</span>(t_tidString, <span class="hljs-built_in">sizeof</span>(t_tidString), <span class="hljs-string">&quot;%5d &quot;</span>, t_cachedTid);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">detail::gettid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">pid_t</span>&gt;(::<span class="hljs-built_in">syscall</span>(SYS_gettid));<br>&#125;<br></code></pre></td></tr></table></figure><h3id="ismainthread判断调用线程是否为main线程">isMainThread()判断调用线程是否为main线程</h3><p>Linux中，线程本质上是通过进程来实现的，也就是说，新建线程对应tid跟pid的值是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Only main thread&#x27;s tid == ::getpid()</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CurrentThread::isMainThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tid</span>() == ::<span class="hljs-built_in">getpid</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sleepusec-休眠指定微秒数">sleepUsec() 休眠指定微秒数</h3><p>通过系统调用nanosleep实现休眠功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CurrentThread::sleepUsec</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> usec)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> ts = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    ts.tv_sec = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">time_t</span>&gt;(usec / Timestamp::kMicroSecondsPerSecond);<br>    ts.tv_nsec = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span>&gt;(usec % Timestamp::kMicroSecondsPerSecond * <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">//    std::this_thread::sleep_for(std::chrono::microseconds());</span><br>    ::<span class="hljs-built_in">nanosleep</span>(&amp;ts, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么不用usleep？</strong><br />因为usleep在POSIX.1-2001不推荐使用, POSIX.1-2008中已经废除。推荐使用nanosleep。当然，C++中还可以用std::this_thread::sleep_for。</p><h2id="threadnameinitializer类初始化main线程信息">ThreadNameInitializer类初始化main线程信息</h2><p>有没有一种办法，能初始化main线程信息，包括线程名、tid？<br />答案是有的，可以设置一个全局对象，在构造时就初始化调用线程信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadNameInitializer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadNameInitializer</span>() <span class="hljs-comment">// 线程名称初始化</span><br>    &#123;<br>        muduo::CurrentThread::t_threadName = <span class="hljs-string">&quot;main&quot;</span>; <span class="hljs-comment">// 初始化线程名</span><br>        CurrentThread::<span class="hljs-built_in">tid</span>(); <span class="hljs-comment">// 缓存tid</span><br>        <span class="hljs-built_in">pthread_atfork</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;childAfterFork); <span class="hljs-comment">// 清除fork子进程对应线程信息</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> ThreadNameInitializer init; <span class="hljs-comment">// 全局变量，会由mian线程构造对象</span><br></code></pre></td></tr></table></figure><p>由于线程信息在初始化以后，并不会自行改变：tid是缓存一次，线程名是不会变化。如果在main线程中，fork创建子进程，子进程对应线程也会继承父线程（main）的线程信息，显然，这不是我们想要的。我们需要专门为子进程清除从父进程继承而来的线程信息。</p><p>因此，需要通过pthread_atfork，在fork结束前，子进程中注册用于清理子进程的main线程信息的清理函数childAfterFork。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childAfterFork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    muduo::CurrentThread::t_cachedTid = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear child tid</span><br>    muduo::CurrentThread::t_threadName = <span class="hljs-string">&quot;child&quot;</span>;<br>    CurrentThread::<span class="hljs-built_in">tid</span>();<br>    <span class="hljs-comment">// no need to call pthread_atfork(NULL, NULL, &amp;childAfterFork);</span><br>&#125;<br></code></pre></td></tr></table></figure><hr /><h2 id="知识点">知识点</h2><h3id="is_same模板判断两种类型是否相同">is_same模板判断两种类型是否相同</h3><p>如果int和pid_t是同种类型，用is_same::value将返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> sameType = std::is_same&lt;<span class="hljs-type">int</span>, <span class="hljs-type">pid_t</span>&gt;::value;<br></code></pre></td></tr></table></figure><p>本文转载自<ahref="https://www.cnblogs.com/fortunely/p/15947679.html">muduo笔记线程类Thread，当前线程CurrentThread</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-线程安全相关类MutexLock MutexLockGuard</title>
    <link href="/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%B1%BBMutexLock-MutexLockGuard/"/>
    <url>/2023/06/22/muduo%E5%BA%93-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%B1%BBMutexLock-MutexLockGuard/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-线程安全相关类mutexlock-mutexlockguard">muduo库-线程安全相关类MutexLockMutexLockGuard</h1><h2 id="互斥锁mutex的选择">互斥锁mutex的选择</h2><p>互斥锁mutex有2种方案：</p><ul><li>C++11以后，使用<code>std::mutex</code>，当然，特殊应用场景下，也有另外三种：<code>std::recursive_mutex</code>（递归mutex类），<code>std::timed_mutex</code>（定时mutex类），<code>recurisive_timed_mutex</code>（定时递归mutex类）；</li><li>Linux平台下，使用NPTL提供的<code>pthread_mutex</code>。</li></ul><p>muduo采用第2种方案，自定义<code>MutexLock</code>对<code>pthread_mutex</code>进行了轻度包装。</p><h2 id="mutexlock类">MutexLock类</h2><p>MutexLock类，除了基础的lock/unlock，支持Condition（条件变量）外，还支持查询锁的持有线程tid（holder），断言当前线程是否持有锁等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CAPABILITY, RELEASE, ASSERT_CAPABILITY等宏定义适用于clang/SWIG编译器下的线程安全</span><br><span class="hljs-comment">// 其他编译器如GCC可以安全擦除, 这里保留, 可以作为标记提醒程序员</span><br><br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">CAPABILITY</span><span class="hljs-params">(<span class="hljs-string">&quot;mutex&quot;</span>)</span> MutexLock : public noncopyable</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MutexLock</span>()<br>    : <span class="hljs-built_in">holder_</span>(<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="hljs-literal">NULL</span>)); <span class="hljs-comment">// 宏函数MCHECK, 用于检查库函数/系统调用的返回值</span><br>    &#125;<br>    ~<span class="hljs-built_in">MutexLock</span>()<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(holder_ == <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex_));<br>    &#125;<br>    <span class="hljs-comment">// must be called when locked, i.e. for assertion</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLockedByThisThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 断言 当前调用线程持有锁, 失败返回false, 不会导致程序终止</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> holder_ == CurrentThread::<span class="hljs-built_in">tid</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assertLocked</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">ASSERT_CAPABILITY</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> <span class="hljs-comment">// 断言 调用线程持有锁, 会导致程序终止, 用于debug</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isLockedByThisThread</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// internal usage</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * lock mutex_ and check lock status.</span><br><span class="hljs-comment">     * assign current thread&#x27;s tid as the lock&#x27;s holder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-title">ACQUIRE</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex_));<br>        <span class="hljs-built_in">assignHolder</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * unassign the lock&#x27;s holder, then unlock mutex_.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> <span class="hljs-title">RELEASE</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">unassignHolder</span>();<br>        <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex_));<br>    &#125;<br>    <span class="hljs-comment">/* non-const, because return a pointer to class&#x27;s (private) data */</span><br>    <span class="hljs-function"><span class="hljs-type">pthread_mutex_t</span>* <span class="hljs-title">getPthreadMutex</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;mutex_;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Condition</span>;<br><br>    <span class="hljs-comment">/* give up the MutexLock */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnassignGuard</span> : <span class="hljs-keyword">public</span> noncopyable <span class="hljs-comment">// 用于放弃锁, 如条件变量中需要放弃锁时可用到</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">UnassignGuard</span><span class="hljs-params">(MutexLock&amp; owner)</span></span><br><span class="hljs-function">        : owner_(owner)</span><br><span class="hljs-function">        &#123;</span><br>            owner_.<span class="hljs-built_in">unassignHolder</span>(); <span class="hljs-comment">// clear lock owner_ holder</span><br>        &#125;<br>        ~<span class="hljs-built_in">UnassignGuard</span>()<br>        &#123;<br>            owner_.<span class="hljs-built_in">assignHolder</span>();  <span class="hljs-comment">// set current thread as the lock holder</span><br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        MutexLock&amp; owner_; <span class="hljs-comment">// 互斥锁对象引用</span><br>    &#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set current thread as the lock holder</span><br><span class="hljs-comment">     * by assigning current thread&#x27;s tid to holder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assignHolder</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        holder_ = CurrentThread::<span class="hljs-built_in">tid</span>(); <span class="hljs-comment">// 设置锁的持有线程tid为当前线程tid</span><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * clear the lock holder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unassignHolder</span><span class="hljs-params">()</span> <span class="hljs-comment">// 清除锁的持有线程tid</span></span><br><span class="hljs-function">    </span>&#123;<br>        holder_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_mutex_t</span> mutex_;<br>    <span class="hljs-type">pid_t</span> holder_;         <span class="hljs-comment">// 持有锁的线程tid, 初值0表示无效线程</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：MutexLock是引用传递，要操作原来的MutexLock对象，需要传递引用。</p><h2 id="mutexlockguard类">MutexLockGuard类</h2><p>类同std::lock_guard，MutexLockGuard通过RAII方式管理MutexLock资源：构造MutexLockGuard对象时，取得mutex_锁；释放对象时，释放mutex_锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RAII方式管理MutexLock锁资源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SCOPED_CAPABILITY</span> MutexLockGuard : <span class="hljs-keyword">public</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MutexLockGuard</span><span class="hljs-params">(MutexLock&amp; mutex)</span> <span class="hljs-title">ACQUIRE</span><span class="hljs-params">(mutex)</span></span><br><span class="hljs-function">    : mutex_(mutex)</span><br><span class="hljs-function">    &#123;</span><br>        mutex_.<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">MutexLockGuard</span>() <span class="hljs-built_in">RELEASE</span>()<br>    &#123;<br>        mutex_.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    MutexLock&amp; mutex_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="测试">测试</h2><p>思路：利用MutexLockGuard在local作用域内，获取指定MutexLock互斥锁，对全局变量进行递增操作。多个线程同时进行这一操作，最终通过判断全局变量是否为预期值，来判断MutexLock和MutexLockGuard是否正常工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MutexLock g_mutex;<br>vector&lt;<span class="hljs-type">int</span>&gt; g_vec;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kCount = <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>;<br><br><span class="hljs-type">int</span> g_count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> g_threadfunc_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span> <span class="hljs-params">((__noinline__))</span></span>; <span class="hljs-comment">// 阻止foo内联</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kCount; ++i) &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>        g_vec.<span class="hljs-built_in">push_back</span>(i);<br>        g_threadfunc_count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>    <span class="hljs-keyword">if</span> (!g_mutex.<span class="hljs-built_in">isLockedByThisThread</span>())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    ++g_count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof pthread_mutex_t: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_mutex_t</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof Mutex: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(MutexLock));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof pthread_cond_t: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_cond_t</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof Condition: %zd\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(Condition));<br>    <span class="hljs-built_in">MCHECK</span>(<span class="hljs-built_in">foo</span>());<br>    <span class="hljs-keyword">if</span> (g_count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MCHECK calls twice.\n&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxThreads = <span class="hljs-number">8</span>;<br>    g_vec.<span class="hljs-built_in">reserve</span>(kMaxThreads * kCount);<br><br>    <span class="hljs-function">Timestamp <span class="hljs-title">start</span><span class="hljs-params">(Timestamp::now())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kCount; ++i) &#123;<br>        g_vec.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;single thread without lock %f seconds\n&quot;</span>, <span class="hljs-built_in">timeDifference</span>(Timestamp::<span class="hljs-built_in">now</span>(), start));<br><br>    start = Timestamp::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">threadFunc</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signle thread with lock %f seconds\n&quot;</span>, <span class="hljs-built_in">timeDifference</span>(Timestamp::<span class="hljs-built_in">now</span>(), start));<br><br>    <span class="hljs-comment">// 多线程核心测试部分</span><br>    <span class="hljs-comment">// multi-thread invoke threadFunc try to get the same mutex at the same time</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nthreads = <span class="hljs-number">0</span>; nthreads &lt; kMaxThreads; ++nthreads)<br>    &#123;<br>        std::vector&lt;std::unique_ptr&lt;Thread&gt;&gt; threads;<br>        g_vec.<span class="hljs-built_in">clear</span>();<br>        g_threadfunc_count = <span class="hljs-number">0</span>;<br>        start = Timestamp::<span class="hljs-built_in">now</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthreads; ++i) &#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(&amp;threadFunc));<br>            threads.<span class="hljs-built_in">back</span>()-&gt;<span class="hljs-built_in">start</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthreads; ++i) &#123;<br>            threads[i]-&gt;<span class="hljs-built_in">join</span>();<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d thread(s) with lock %f seconds\n&quot;</span>, nthreads, <span class="hljs-built_in">timeDifference</span>(Timestamp::<span class="hljs-built_in">now</span>(), start));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_threadfunc_count = %d\n&quot;</span>, g_threadfunc_count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">sizeof pthread_mutex_t: 40<br>sizeof Mutex: 48<br>sizeof pthread_cond_t: 48<br>sizeof Condition: 56<br>single thread without lock 0.166781 seconds<br>signle thread with lock 0.455777 seconds<br>0 thread(s) with lock 0.000000 seconds<br>g_threadfunc_count = 0<br>1 thread(s) with lock 0.425418 seconds<br>g_threadfunc_count = 10000000<br>2 thread(s) with lock 4.080142 seconds<br>g_threadfunc_count = 20000000<br>3 thread(s) with lock 4.136063 seconds<br>g_threadfunc_count = 30000000<br>4 thread(s) with lock 5.242511 seconds<br>g_threadfunc_count = 40000000<br>5 thread(s) with lock 6.609551 seconds<br>g_threadfunc_count = 50000000<br>6 thread(s) with lock 7.620478 seconds<br>g_threadfunc_count = 60000000<br>7 thread(s) with lock 8.231012 seconds<br>g_threadfunc_count = 70000000<br></code></pre></td></tr></table></figure><p>本文转载自<ahref="https://www.cnblogs.com/fortunely/p/15943954.html">muduo笔记线程安全相关类MutexLock, MutexLockGuard</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAII原理</title>
    <link href="/2023/06/22/RAII%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/22/RAII%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="raii原理">RAII原理</h1><blockquote><p>RAII是什么? RAII（Resource Acquisition IsInitialization）是由C++之父BjarneStroustrup提出的，中文翻译为资源获取即初始化，即使用局部对象来管理资源的技术称为资源获取即初始化；</p></blockquote><blockquote><p>这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p></blockquote><p>资源的使用一般经历三个步骤:</p><ul><li>获取资源；</li><li>使用资源；</li><li>销毁资源；</li></ul><p>但是资源的销毁往往是程序员经常忘记的一个环节；C++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期（正如本文开篇所讲）；</p><p>给一个简单的例子来看下局部对象的自动销毁的特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">person</span><span class="hljs-params">(std::string name = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">int</span> age = <span class="hljs-number">0</span>)</span> :</span><br><span class="hljs-function">            name_(std::move(name)), age_(age) &#123;</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Init a person!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">person</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destroy a person!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::string name_;<br>    <span class="hljs-type">int</span> age_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPerson</span><span class="hljs-params">()</span> </span>&#123;<br>    person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">testPerson</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Init a person!<br>Destroy a person!<br></code></pre></td></tr></table></figure><p>从person类可以看出，当我们在testPerson函数中声明一个局部对象的时候，会自动调用构造函数进行对象的初始化，当整个testPerson函数执行完成后，自动调用析构函数来销毁对象，整个过程无需人工介入，由操作系统自动完成；</p><p>于是，很自然联想到，当我们在使用资源的时候，在构造函数中进行初始化，在析构函数中进行销毁；</p><p>整个RAII过程为四个步骤：</p><ul><li><strong>设计一个类封装资源</strong>；</li><li><strong>在构造函数中初始化</strong>；</li><li><strong>在析构函数中执行销毁操作</strong>；</li><li><strong>使用时声明一个该对象的类</strong>；</li></ul><p>最后，举一个RAII在实际应用中的例子来结束本文；</p><p>Linux下经常会使用多线程技术，而在多线程中经常使用互斥锁保护临界资源一次只被一个线程访问，按照我们前面的分析，我们封装一下POSIX标准的互斥锁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mutex.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CPP_LEARN_MUTEX_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPP_LEARN_MUTEX_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mutex</span>();<br>    ~<span class="hljs-built_in">Mutex</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> mu_&#123;&#125;;<br><br>    <span class="hljs-comment">// No copying</span><br>    <span class="hljs-built_in">Mutex</span>(<span class="hljs-type">const</span> Mutex&amp;);<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Mutex&amp;);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CPP_LEARN_MUTEX_H</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mutex.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CPP_LEARN_TEST_MUTEX_LOCK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPP_LEARN_TEST_MUTEX_LOCK_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mutex.h&quot;</span></span><br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MutexLock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MutexLock</span><span class="hljs-params">(Mutex *mu)</span></span><br><span class="hljs-function">            : mu_(mu)  &#123;</span><br>        <span class="hljs-keyword">this</span>-&gt;mu_-&gt;<span class="hljs-built_in">Lock</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">MutexLock</span>() &#123; <span class="hljs-keyword">this</span>-&gt;mu_-&gt;<span class="hljs-built_in">Unlock</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Mutex *<span class="hljs-type">const</span> mu_;<br><br>    <span class="hljs-comment">// No copying allowed</span><br>    <span class="hljs-built_in">MutexLock</span>(<span class="hljs-type">const</span> MutexLock&amp;);<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MutexLock&amp;);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//CPP_LEARN_TEST_MUTEX_LOCK_H</span></span><br></code></pre></td></tr></table></figure><p>到这里我们就真正封装了互斥锁，下面我们来通过一个简单的例子来使用它，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test_mutex_lock.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_mutex_lock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREADS 10000</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>Mutex mutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">count</span><span class="hljs-params">([[maybe_unused]] <span class="hljs-type">void</span> *args)</span> </span>&#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>    num++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">pthread_t</span> thread[NUM_THREADS];<br><br>    <span class="hljs-keyword">for</span> (t = <span class="hljs-number">0</span>; t &lt; NUM_THREADS; t++) &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;thread[t], <span class="hljs-literal">nullptr</span>, count, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (t = <span class="hljs-number">0</span>; t &lt; NUM_THREADS; t++)<br>        <span class="hljs-built_in">pthread_join</span>(thread[t], <span class="hljs-literal">nullptr</span>);<br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-时间戳类Timestamp</title>
    <link href="/2023/06/21/muduo%E5%BA%93-%E6%97%B6%E9%97%B4%E6%88%B3%E7%B1%BBTimestamp/"/>
    <url>/2023/06/21/muduo%E5%BA%93-%E6%97%B6%E9%97%B4%E6%88%B3%E7%B1%BBTimestamp/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-时间戳类timestamp">muduo库-时间戳类Timestamp</h1><h2id="如何度量程序在某一时刻的时间">如何度量程序在某一时刻的时间？</h2><p>通常，我们用时刻来表示，比如"2023-06-2623:43:00.000000"，这种方式便于人查看，但不便于程序中的比较和计算。比如有2个时刻A和B，计算哪个时刻在前，哪个在后，或者要计算时刻A和B的时间差时，这种字符串表示方式就很麻烦。</p><p>我们想到将字符串形式的时刻，用自纪元时间（Epoch时间，1970-01-0100:00:00 +0000 (UTC)）以来的时间戳来表示，精度为1us（微秒）。</p><h2 id="linux中如何获取这个时间呢">Linux中，如何获取这个时间呢？</h2><p>使用<code>gettimeofday</code>，分辨率1us，其实现也能达到毫秒级（当然分辨率不等于精度），再加上Linux是非实时任务系统，也能满足日常计时功能。前面讲过，<code>time</code>只能精确到1s，<code>ftime</code>已被废弃，<code>clock_gettime</code>精度高，但系统调用开销比<code>gettimeofday</code>大，网络编程中，最适合用<code>gettimeofday</code>来计时。muduo中也是这么做的。</p><p>有没有一种可能，两个线程，或者两段出现在1us内执行？答案是有可能的，对于常规情况，即使时间戳相同，并不影响我们的日常计时功能；对于特殊需求，比如排序、查找，需要区分时间戳大小的，后面遇到具体情况具体分析。</p><h2 id="timestamp类">Timestamp类</h2><p><img src="/img/muduo/Timestamp/Timestamp.png" /></p><p>由于时间戳希望在不同变量之间赋值、拷贝，因此设计成值语义的，继承自copyableclass。</p><p>数据成员：</p><p>成员变量<code>microSecondsSinceEpoch_</code>，用来来表示从Epoch时间到目前为止的微妙数，初值0（也表示无效值）。</p><p><code>microSecondsSinceEpoch_</code>的数据类型为什么是<code>int64_t</code>，而不是<code>int32_t</code>或者<code>uint64_t</code>？因为32位连一年的微妙数都不能表示，而<code>int64_t</code>可以表示290余年的微妙数（一年按<spanclass="math inline">\(365243600 *100000\)</span>计算），未来还能表示一百余年，也就是说，其范围满足目前日常需求。而有符号的<code>int64_t</code>可以用来让2个时间戳进行差值计算，从而表示先后顺序。当然，时间戳本身为负数没有意义。</p><h3 id="构造函数">构造函数</h3><p>可以像这样定义Timstamp及其构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Time stamp in UTC, in microseconds resolution.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timestamp</span> : <span class="hljs-keyword">public</span> copyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs an invalid Timestamp</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">Timestamp</span>() : <span class="hljs-built_in">microSecondsSinceEpoch_</span>(<span class="hljs-number">0</span>)<br>    &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a Timestamp at specific time</span><br><span class="hljs-comment">     * @param microSecondsSinceEpochArg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timestamp</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> microSecondsSinceEpochArg)</span></span><br><span class="hljs-function">            : microSecondsSinceEpoch_(microSecondsSinceEpochArg)</span><br><span class="hljs-function">    &#123;</span><br>    &#125;<br>    ...<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int64_t</span> microSecondsSinceEpoch_;<br>&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li>继承自copyable，表明这是一个值语义的class，其对象能够进行copy操作；</li><li>defaultctor（构造函数），存储时间戳变量<code>microSecondsSinceEpoch_</code>初值0，0和负数都表示无效值。同时，也提供单一参数版本<code>ctor</code>，给调用者构造指定时间戳值的Timestamp对象的机会。</li></ol><h3 id="对象有效性">对象有效性</h3><p>至于<code>microSecondsSinceEpoch_</code>符号，我们可以定义成员函数valid()判断其有效性，通过invalid()构造一个无效的Timestamp对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> microSecondsSinceEpoch_ &gt; <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> Timestamp <span class="hljs-title">invalid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Timestamp</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>gettimeofday()</code>获取当前时刻，转化为微秒，并构造一个<code>Timestamp</code>临时对象。1换算公式：sec= 1e6 usec</p><h3 id="时间换算">时间换算</h3><p>如何将由<code>time()</code>获得的自Epoch时间（1970-01-01 00:00:00+0000 (UTC).）以来的秒数（time_t类型），转化为Timestamp类型对象？</p><p>可以定义<code>fromUnixTime</code>来完成这个工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Timestamp <span class="hljs-title">fromUnixTime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fromUnixTime</span>(t, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Timestamp <span class="hljs-title">fromUnixTime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> t, <span class="hljs-type">int</span> microseconds)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Timestamp</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(t) * kMicroSecondsPerSecond + microseconds);<br>    &#125;<br></code></pre></td></tr></table></figure><p>第一个重载版本，只转换提供的秒数，微秒数默认0；第二个版本，提供了秒数和微秒数的设置</p><h3 id="对象交换">对象交换</h3><p>有时为了避免对象数据成员的拷贝，会利用swap对对象进行交换操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Timestamp&amp; that)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);<br>    &#125;<br></code></pre></td></tr></table></figure><p>就目前的设计来说，完全可以用std::swap来交换2个对象，而不用定义Timestamp::swap()。这里是为了以后方便扩展，自定义swap行为。</p><h3 id="获取时间戳">获取时间戳</h3><p>获取从Epoch时间，到目前为止的时间戳数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">microSecondsSinceEpoch</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> microSecondsSinceEpoch_;&#125;; <span class="hljs-comment">// 微秒数</span><br>    <span class="hljs-function"><span class="hljs-type">time_t</span> <span class="hljs-title">secondsSinceEpoch</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 秒数</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="获取可打印字符串">获取可打印字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp.h</span><br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">toFormattedString</span><span class="hljs-params">(<span class="hljs-type">bool</span> showMicroseconds = <span class="hljs-literal">true</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STDC_FORMAT_MACROS <span class="hljs-comment">// PRId64, for printf data in cross platform</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_FORMAT_MACROS</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-function">string <span class="hljs-title">Timestamp::toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int64_t</span> seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;<br>    <span class="hljs-type">int64_t</span> microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;%&quot;</span> PRId64 <span class="hljs-string">&quot;.%06&quot;</span> PRId64 <span class="hljs-string">&quot;&quot;</span>, seconds, microseconds);<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">Timestamp::toFormattedString</span><span class="hljs-params">(<span class="hljs-type">bool</span> showMicroseconds)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">time_t</span> seconds = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> tm_time;<br>    <span class="hljs-built_in">gmtime_r</span>(&amp;seconds, &amp;tm_time); <span class="hljs-comment">// convert seconds since Epoch to UTC time (struct tm)</span><br><br>    <span class="hljs-keyword">if</span> (showMicroseconds)<br>    &#123;<br>        <span class="hljs-type">int</span> microseconds = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;</span>,<br>                 tm_time.tm_year + <span class="hljs-number">1990</span>, tm_time.tm_mon + <span class="hljs-number">1</span>, tm_time.tm_mday,<br>                 tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,<br>                 microseconds);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,<br>                 tm_time.tm_year + <span class="hljs-number">1990</span>, tm_time.tm_mon + <span class="hljs-number">1</span>, tm_time.tm_mday,<br>                 tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>toString()</code>将秒数、微秒数转换为可打印的std::string类型，用PRId64跨平台输出64bit数据到string缓存；</li><li><code>toFormattedString()</code>将时间戳转换为人类可理解的格式化时间字符串，形如"yyyymmddhh:mm:ss.zzzzzz"。</li></ol><h3 id="辅助函数非class-member函数">辅助函数（非class member函数）</h3><p>常需要比较2个时间先后顺序，计算这2个时刻之间的时间差，一个时刻加上一段时间来得到另外一个时刻，可以通过定义helper函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Timestamp lhs, Timestamp rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">microSecondsSinceEpoch</span>() &lt; rhs.<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Gets time difference of two timestamps, result in seconds.</span><br><span class="hljs-comment">* @param high</span><br><span class="hljs-comment">* @param low</span><br><span class="hljs-comment">* @return (high - low) in seconds.</span><br><span class="hljs-comment">* @c double has 52-bit precision, enough for one-microsecond</span><br><span class="hljs-comment">* resolution for next 100 years.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">timeDifference</span><span class="hljs-params">(Timestamp high, Timestamp low)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int64_t</span> diff = high.<span class="hljs-built_in">microSecondsSinceEpoch</span>() - low.<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(diff) / Timestamp::kMicroSecondsPerSecond;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Add @c seconds to given timestamp.</span><br><span class="hljs-comment">* @param timestamp given basic timestamp</span><br><span class="hljs-comment">* @param seconds given seconds to be added to timestamp</span><br><span class="hljs-comment">* @return timestamp + seconds as Timestamp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> Timestamp <span class="hljs-title">addTime</span><span class="hljs-params">(Timestamp timestamp, <span class="hljs-type">double</span> seconds)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int64_t</span> delta = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(seconds * Timestamp::kMicroSecondsPerSecond);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Timestamp</span>(timestamp.<span class="hljs-built_in">microSecondsSinceEpoch</span>() + delta);<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>operator&lt;()</code>除了比较2个时间戳大小关系（代表的先后顺序），也是实现等价关系判断的重要条件；</li><li><code>timeDifference()</code>计算2个时间戳差值，精确到1usec，用小数表示，而整数部分表示1sec；</li><li><code>addTime()</code> 利用一个基准时间戳timestamp +时间段seconds(秒数)，得到新的Timestamp对象。</li></ol><h3 id="单元测试">单元测试</h3><p>单元测试测什么？muduo是以class为单位，根据提供给用户的功能点进行测试。有些进行的是覆盖测试。</p><p>Timestamp主要功能点：</p><ol type="1"><li>构造对象：默认对象，无效对象；</li><li>值语义，即引用传递、值传递对象；</li><li><code>now()</code>获取当前时间；</li><li><code>microSecondsSinceEpoch()</code>获取微秒数，<code>secondsSinceEpoch()</code>获取秒数；</li><li><code>valid()</code>判断对象是否有效；</li><li><code>fromUnixTime()</code> 将Epoch时间转换为Timestamp对象；</li><li><code>toString()</code> 将时间戳转换为string类型；</li><li><code>toFormattedString()</code>将时间戳转换为格式化字符串string类型；</li></ol><p>辅助函数主要功能点：</p><ol type="1"><li><code>operator&lt;()</code> 比较2个Timestamp对象大小；</li><li><code>timeDifference()</code>计算2个Timestamp对象差值；</li><li><code>ddTime()</code> 将一个Timestamp加上指定时间；</li></ol><p>由于<code>toString()</code>和<code>toFormattedString()</code>可以输出类的信息，因此可以作为测试时判断的依据。</p><!-- Timestamp的单元测试，可以这样设计：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Timestamp_unittest.cc</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Timestamp <span class="hljs-title">now</span><span class="hljs-params">(Timestamp::now())</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, now.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 测试now() + copy ctor</span><br>    <span class="hljs-built_in">passByValue</span>(now); <span class="hljs-comment">// 测试值传递</span><br>    <span class="hljs-built_in">passByConstReference</span>(now); <span class="hljs-comment">// 测试引用传递</span><br>    <span class="hljs-built_in">benchmark</span>(); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">passByValue</span><span class="hljs-params">(Timestamp x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, x.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">passByConstReference</span><span class="hljs-params">(<span class="hljs-type">const</span> Timestamp&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, x.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">benchmark</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNumber = <span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>;<br><br>    std::vector&lt;Timestamp&gt; stamps;<br>    stamps.<span class="hljs-built_in">reserve</span>(kNumber);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kNumber; ++i) &#123;<br>        stamps.<span class="hljs-built_in">push_back</span>(Timestamp::<span class="hljs-built_in">now</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, stamps.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, stamps.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, muduo::<span class="hljs-built_in">timeDifference</span>(stamps.<span class="hljs-built_in">back</span>(), stamps.<span class="hljs-built_in">front</span>()));<br><br>    <span class="hljs-type">int</span> increments[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int64_t</span> start = stamps.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kNumber; ++i) &#123;<br>        <span class="hljs-type">int64_t</span> next = stamps[i].<span class="hljs-built_in">microSecondsSinceEpoch</span>();<br>        <span class="hljs-type">int64_t</span> inc = next - start;<br>        start = next;<br>        <span class="hljs-keyword">if</span> (inc &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;reverse!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inc &lt; <span class="hljs-number">100</span>)<br>        &#123;<br>            ++increments[inc];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;big gap %d\n&quot;</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(inc));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d: %d\n&quot;</span>, i, increments[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs shell">1645946164.776317<br>1645946164.776317<br>1645946164.776317<br>1645946164.777235<br>1645946164.981893<br>0.204658<br>big gap 109<br>big gap 193<br>big gap 162<br>big gap 158<br>big gap 35248<br>big gap 7007<br>big gap 142<br>big gap 6098<br>big gap 2142<br>big gap 12422<br>big gap 262<br>big gap 12291<br>big gap 12078<br>big gap 222<br>big gap 12069<br>big gap 229<br>0: 901839<br>1: 97441<br>2: 83<br>3: 191<br>4: 175<br>5: 13<br>6: 47<br>7: 22<br>8: 10<br>9: 6<br>10: 7<br>11: 10<br>12: 4<br>13: 12<br>14: 4<br>15: 4<br>16: 5<br>17: 10<br>18: 2<br>19: 2<br>20: 1<br>21: 0<br>22: 2<br>...<br>``` --&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 小结</span></span><br><br>1. 有些重要函数功能点，并未测试到，比如`toFormattedString()`；<br>2. 针对特定函数，设计的测试用例并不全面，比如并没有永非法的时间戳数值（如&lt;0），来验证生成的`Timestamp`有效性。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 重要知识点</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 模板boost::less_than_comparable</span></span><br><br>要求实现`&lt;`，可自动实现`&gt;`，`&lt;=`，`&gt;=`。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 编译时断言BOOST_STATIC_ASSERT</span></span><br><br>相当于C++11里面的static_assert，可以在编译时进行断言。<br><br>```C++<br>BOOST_STATIC_ASSERT(sizeof(Timestamp) == sizeof(int64_t)); // 断言Timestamp大小等于int64_t（64位）<br></code></pre></td></tr></table></figure><h3 id="跨平台打印prid64">跨平台打印PRId64</h3><p><code>int64_t</code>表示64位整数，在32位系统总是<code>long long int</code>，在64位系统中是<code>long int</code>，所以打印<code>int64_t</code>的格式化方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, value);  <span class="hljs-comment">// 64bit OS</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, value); <span class="hljs-comment">// 32bit OS</span><br></code></pre></td></tr></table></figure><p>可以看到，转义字符是不一样的，也就是说这种写法不跨平台。</p><p>跨平台的方法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDC_FORMAT_MACROS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __STDC_FORMAT_MACROS</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%&quot;</span> PRId64 <span class="hljs-string">&quot;\n&quot;</span>, value);<br></code></pre></td></tr></table></figure><p>这样，32位系统、64位系统是通用的。</p><p>为什么需要包含<code>__STDC_FORMAT_MACROS</code>？因为开启<code>PRId64</code>宏，默认要开启宏<code>__cplusplus</code>或者<code>__STDC_FORMAT_MACROS</code>。在C语言中，没有定义<code>__cplusplus</code>，就必须定义<code>__STDC_FORMAT_MACROS</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-原子类AtomicIntegerT&lt;T&gt;</title>
    <link href="/2023/06/21/muduo%E5%BA%93-%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicIntegerT-T/"/>
    <url>/2023/06/21/muduo%E5%BA%93-%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicIntegerT-T/</url>
    
    <content type="html"><![CDATA[<h1id="muduo库-原子类atomicintegert">muduo库-原子类AtomicIntegerT<T></h1><p>C++中的原子操作有两种实现方式：</p><ol type="1"><li>C++11以后，提供st::atomic可以实现T类型数据的原子操作，主要包括：初始化、读取值、写值、自增自减（i.e.前置或后置++）等。</li><li>C++11以前的版本，需要用GCC编译器提供的原子操作接口，实现原子操作。</li></ol><h2 id="atomicintegert模板类">AtomicIntegerT模板类</h2><p>muduo产生与C++11流行之前，因此用了第二种方案。实际上，Linux下面，C++11中的原子操作实现，也是用的第一种方案实现的。</p><p>自定义AtomicIntegerT模板：</p><p><imgsrc="/img/muduo/原子类AtomicIntegerT/AtomicIntegerT类图.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/* GCC atomic operation see</span><br><span class="hljs-comment">* https://www.cnblogs.com/the-tops/p/6347584.html</span><br><span class="hljs-comment">* https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerT</span> : noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AtomicIntegerT</span>()<br>    :<span class="hljs-built_in">value_</span>(<span class="hljs-number">0</span>)<br>    &#123; &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// CAS(compare and swap)</span><br>        <span class="hljs-comment">// in gcc &gt;= 4.7: __atomic_load_n(&amp;value, __ATOMIC_SEQ_CST)</span><br>        <span class="hljs-keyword">return</span> __sync_val_compare_and_swap(&amp;value_, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 先fetch获取值（value_），然后再add加x</span><br>    <span class="hljs-function">T <span class="hljs-title">getAndAdd</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST)</span><br>        <span class="hljs-keyword">return</span> __sync_fetch_and_add(&amp;value_, x);<br>    &#125;<br>    <span class="hljs-comment">// getAndAdd()中已经用原子操作改变了value_值，这里是通过值传递方式返回 old value_ + x</span><br>    <span class="hljs-function">T <span class="hljs-title">addAndGet</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getAndAdd</span>(x) + x;<br>    &#125;<br>    <span class="hljs-comment">// 前缀式递增，相当于++value_</span><br>    <span class="hljs-function">T <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 前缀式递减，相当于--value_</span><br>    <span class="hljs-function">T <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 求和，相当于value_ = value_ + x</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">getAndAdd</span>(x);<br>    &#125;<br>    <span class="hljs-comment">// 单纯递增，不关心返回值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">incrementAndGet</span>();<br>    &#125;<br>    <span class="hljs-comment">// 单纯递减，不关心返回值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">decrementAndGet</span>();<br>    &#125;<br>    <span class="hljs-comment">// 先fetch old value_，然后set value_ = newValue</span><br>    <span class="hljs-function">T <span class="hljs-title">getAndSet</span><span class="hljs-params">(T newValue)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST)</span><br>        <span class="hljs-keyword">return</span> __sync_lock_test_and_set(&amp;value_, newValue);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T value_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了使用方便，同时避免重复命名、实例化、甚至编译，使用AtomicIntegerT包装int32_t,int64_t，然后重定义，我们在.h文件中声明这2个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// namespace muduo::detail</span><br><span class="hljs-keyword">typedef</span> detail::AtomicIntegerT&lt;<span class="hljs-type">int32_t</span>&gt; AtomicInt32;<br><span class="hljs-keyword">typedef</span> detail::AtomicIntegerT&lt;<span class="hljs-type">int64_t</span>&gt; AtomicInt64;<br></code></pre></td></tr></table></figure><h2 id="单元测试">单元测试</h2><p>主要针对AtomicInt64、AtomicInt32这2个常用的、具体的类型，进行测试。</p><p><strong>方法</strong>:通过构造实例对象后，调用成员函数get()、getAndAdd()、addAndGet()、incrementAndGet()、decrementAndGet()，对原子对象进行修改，然后根据返回值判断值是否为预期值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// AtomicInt64 的测试</span><br>&#123;<br>    AtomicInt64 a0;<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">getAndAdd</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">incrementAndGet</span>() == <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">4</span>);<br>    a0.<span class="hljs-built_in">increment</span>();<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">addAndGet</span>(<span class="hljs-number">-3</span>) == <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">getAndSet</span>(<span class="hljs-number">100</span>) == <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">assert</span>(a0.<span class="hljs-built_in">get</span>() == <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// AtomicInt32 的测试类同，只需要修改a0的类型为AtomicInt32即可，具体代码略</span><br>... <br></code></pre></td></tr></table></figure><h2 id="相关知识点">相关知识点</h2><h3 id="gcc原子操作">GCC原子操作</h3><p>GCC提供了一套原子操作的接口，可以实现原子操作。这些接口都是以__sync开头的，如__sync_fetch_and_add()，__sync_val_compare_and_swap()等。</p><p><strong>原子自增操作</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">type __sync_fetch_and_add(type *ptr, type value)<br></code></pre></td></tr></table></figure><p><strong>原子赋值操作</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">type __sync_lock_test_and_set(type *ptr, type value)<br></code></pre></td></tr></table></figure><p>使用这些原子操作时，编译时需要加<code>-march=cpu-type</code>（CPU体系结构=CPU类型，可以指定为native）</p><h3 id="volatile关键字">volatile关键字</h3><p>确保本条指令不会因为编译器的优化而省略，而且要求每次从内存直接读值，而不是读高速cache中的备份。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">volatile</span> T value_;<br></code></pre></td></tr></table></figure><p>本文参考自：<ahref="https://www.cnblogs.com/haippy/p/3235560.html">muduo笔记原子类AtomicIntegerT<T></a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>muduo库-标记类copyable noncopyable</title>
    <link href="/2023/06/21/muduo%E5%BA%93-%E6%A0%87%E8%AE%B0%E7%B1%BBcopyable-noncopyable/"/>
    <url>/2023/06/21/muduo%E5%BA%93-%E6%A0%87%E8%AE%B0%E7%B1%BBcopyable-noncopyable/</url>
    
    <content type="html"><![CDATA[<h1 id="muduo库-标记类copyable-noncopyable">muduo库-标记类copyablenoncopyable</h1><h2 id="值语义与引用语义">值语义与引用语义</h2><p><strong>值语义</strong>指的是对象的拷贝与元对象无关，就像拷贝int一样。C++的内置类型（bool/int/double/char）都是值语义，标准库里的<code>complex</code>,<code>pair</code>,<code>vector</code>,<code>map</code>等等也都是值语义，拷贝之后就与原对象脱离关系。</p><p>与值语义对应的对象语义，或者叫做<strong>引用语义</strong>，对象语义指的是面向对象意义下的对象，对象拷贝是禁止的。</p><h2id="如何为一个class实现值语义引用语义">如何为一个class实现值语义，引用语义</h2><p>当构造一个class对象时，会先bit-wise构造其数据成员。而继承的baseclass那部分，会被派生类隐式继承，作为派生类数据成员。</p><p>形如下面的代码，编译器会将base class对象作为deriveclass的数据成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> b;<br>    A a; <span class="hljs-comment">// 编译器自动生成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果A的构造函数是private，编译器就无法在B中构造baseclass，即A那部分。这样，编译器也就无法为B合成构造函数。copy操作、move操作也是如此。</p><p>因此，我们可以为定义2个标记class，其他类继承这2个标记类，用于表示是否支持copy操作。</p><h3 id="copyable-class">copyable class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* A tag class emphasises the objects are copyable.</span><br><span class="hljs-comment">* The empty base class optimization applies.</span><br><span class="hljs-comment">* Any derived class of copyable should be a value type.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">copyable</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">copyable</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">copyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="noncopyable-class">noncopyable class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* A tag class emphasises the objects are non-copyable.</span><br><span class="hljs-comment">* A derived class should be a reference type rather than a value type.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">noncopyable</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">noncopyable</span>(<span class="hljs-type">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br><br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="用法以及使用这两个类的原因">用法以及使用这两个类的原因</h3><p>为什么不直接使用C++11关键字default/delete，指定支持/阻止编译器合成相关ctor、copy操作、move操作？</p><p>答案是当然可以，default/delete能达到同样目的，但不像继承自copyable、noncopyable这种标记类一样作用明显，程序员一眼都能看出其特性：是否允许copy。</p><p>本文转载自<ahref="https://www.cnblogs.com/fortunely/p/15943391.html">muduo笔记标记类copyable, noncopyable</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>muduo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法模板</title>
    <link href="/2023/06/08/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/08/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="kmp算法模板">KMP算法模板</h1><p>KMP算法的原理以及图解见<ahref="https://www.zhihu.com/question/21923021/answer/281346746">如何更好地理解和掌握KMP 算法?</a></p><p>下面给出KMP算法的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// KMP算法</span><br><span class="hljs-comment">// 匹配成功返回匹配的起始位置，失败返回-1</span><br><span class="hljs-comment">// haystack为主串，needle为模式串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(string haystack, string needle)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = haystack.<span class="hljs-built_in">size</span>(), len2 = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(len2 + <span class="hljs-number">1</span>)</span></span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || needle[i] == needle[j])<br>            &#123;<br>                ++i;<br>                ++j;<br>                next[i] = j;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <br>                j = next[j];  <br>                <br>        &#125;<br>        i = <span class="hljs-number">0</span>;<br>        j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || haystack[i] == needle[j])<br>            &#123;<br>                ++i;<br>                ++j;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == len2)<br>            <span class="hljs-keyword">return</span> i - j;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL下添加系统调用</title>
    <link href="/2023/06/05/WSL%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2023/06/05/WSL%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl下添加系统调用">WSL下添加系统调用</h1><p>由于WSL的内核是在原版基础之上有做修改的，所以要先去下载内核的源码。https://github.com/microsoft/WSL2-Linux-Kernel.</p><p>查看当前系统内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>然后去源码中找到对应的版本并下载，下载完成后解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zvxf linux-msft-wsl-5.15.90.1.tar.gz<br><span class="hljs-built_in">cd</span> WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1<br></code></pre></td></tr></table></figure><h2 id="新增系统调用号">新增系统调用号</h2><p>在arch/x86/include/generated/uapi/asm/unistd_64.h中添加系统调用号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_my_func 335</span><br></code></pre></td></tr></table></figure><p>注意这里的系统调用号可以随便取，但一定要是唯一的，不然会报错。<code>my_func</code>是系统调用名。</p><h2 id="修改系统调用向量表">修改系统调用向量表</h2><p>修改arch/x86/entry/syscalls/syscall_64.tbl文件</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">335 </span><span class="hljs-number">64</span> my_oper sys_my_func<br></code></pre></td></tr></table></figure><p>此处的系统调用号必须与之前声明的保持一致，<code>my_func</code>为调用函数名，<code>sys_my_func</code>为实际调用的函数。</p><h2 id="添加系统调用的声明">添加系统调用的声明</h2><p>在include/linux/syscalls.h中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_my_func</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>;<br></code></pre></td></tr></table></figure><p>其中<code>asmlinkage</code>是一个宏，用于声明函数的调用方式，<code>long</code>是返回值类型，<code>sys_my_func</code>为函数名，<code>int count</code>为函数参数。</p><h2 id="添加具体实现">添加具体实现</h2><p>在kernel/sys.c中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-title function_">my_oper</span><span class="hljs-params">(<span class="hljs-type">int</span> *result, <span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">char</span> *op)</span><br>&#123;<br><span class="hljs-keyword">if</span>(op)<br>&#123;<br><span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;+&#x27;</span>)<br>*result = num1 + num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>*result = num1 - num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;*&#x27;</span>)<br>*result = num1 * num2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;\\&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(num2 != <span class="hljs-number">0</span>)<br>*result = num1 / num2;<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;divided number can&#x27;t bere zero.\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;operator is empty.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>SYSCALL_DEFINE1(my_func, <span class="hljs-type">int</span>, count)<br>&#123;<br>printk(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span> <span class="hljs-title">tstart</span>, <span class="hljs-title">tend</span>;</span><br>ktime_get_real_ts64(&amp;tstart);<br><span class="hljs-type">int</span> i, result, times = count / <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_add = <span class="hljs-string">&#x27;+&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, &amp;op_add);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_add is ok. op_add count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_sub = <span class="hljs-string">&#x27;-&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;op_sub);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_sub is ok. op_sub count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_mul = <span class="hljs-string">&#x27;*&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, &amp;op_mul);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_mul is ok. op_mul count is :%d&quot;</span>, i);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; times; ++i)<br>&#123;<br><span class="hljs-type">char</span> op_div = <span class="hljs-string">&#x27;\\&#x27;</span>;<br>my_oper(&amp;result, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, &amp;op_div);<br>&#125;<br>printk(<span class="hljs-string">&quot;my_func op_div is ok. op_div count is :%d&quot;</span>, i);<br>ktime_get_real_ts64(&amp;tend);<br>printk(<span class="hljs-string">&quot;my_func running time is %ld usec/n&quot;</span>, <span class="hljs-number">1000000000</span> * (tend.tv_sec-tstart.tv_sec) + (tend.tv_nsec-tstart.tv_nsec));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>DEFINE后面的数字是传入的参数个数,这里是1个，所以是1。<code>my_func</code>是系统调用名，<code>count</code>是传入的参数。</p><p>注意：函数实现不要写在条件编译的范围内。</p><h2 id="编译内核">编译内核</h2><p>编译内核需要.config配置文件，可以通过<code>make menuconfig</code>生成，也可以直接复制现有的.config文件。这里使用<code>make menuconfig</code>生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><p><img src="/img/Linux/make-menuconfig.png" /></p><p><code>make menuconfig</code>会打开一个配置界面，这里不需要修改别的配置，只需要修改内核版本号，以便与现在的内核区分开，然后保存退出。</p><p>编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make<br></code></pre></td></tr></table></figure><p>编译完成后，生成的内核文件在项目目录arch/x86/boot下面，文件名为bzImage。</p><h2 id="替换内核">替换内核</h2><p>将内核文件bzImage从wsl系统中拷贝出来，放在windows文件系统中任意路径下，例如C:_usr_kernel</p><p>然后进入C:.wslconfig 的文件，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[wsl2]<br>kernel=C:\\wsl_usr_kernel\\bzImage<br></code></pre></td></tr></table></figure><p>注意双反斜杠，否则不生效。然后在powershell中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><p>重启wsl系统，查看内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>可以看到内核版本已经变成了我们刚刚编译的版本。</p><p>如果要恢复原来的内核，只需要删除.wslconfig文件，然后执行<code>wsl --shutdown</code>重启wsl系统即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据期末复习</title>
    <link href="/2023/06/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据期末复习">大数据期末复习</h1><h2 id="ch1-intruction">Ch1 Intruction</h2><h3 id="what-is-big-data">What is big data?</h3><p><strong>Big data</strong> is used to describe a massive volume ofboth structured and unstructured data that is so large that it'sdifficult to process using traditional database and softwaretechniques.</p><p><strong>大数据</strong>用来描述大量的结构化和非结构化的数据，这些数据非常大，难以用传统的数据库和软件技术来处理。</p><h3 id="the-4v-features-of-big-data">The 4V Features of big data</h3><p><img src="/img/大数据/4V-features.png" /></p><ul><li>Volume (Scale of Data)</li><li>Velocity (Data Stream)</li><li>Variety (Different types of data)</li><li>Veracity (Uncertainty, missing value)</li></ul><h3 id="what-is-data-mining">What is data mining?</h3><p><strong>Data mining</strong> consists of <strong>applying dataanalysis</strong> and <strong>discovery algorithms</strong> that, underacceptable computational efficiency limitations, produce a particularenumeration of patterns over the data.</p><p><strong>数据挖掘</strong>包括<strong>应用数据分析</strong>和<strong>发现算法</strong>，在可接受的计算效率限制下，在数据上产生特定的模式列举。</p><h3 id="the-kdd-processcore-part">The KDD Process(core part)</h3><p><img src="/img/大数据/KDD-process.png" /></p><h3 id="the-main-tasks-of-data-mining">The main tasks of Datamining</h3><ul><li>Association Rule Mining(关联规则挖掘)</li><li>Cluster Analysis(聚类分析)</li><li>Classification/Prediction(分类/预测)</li><li>Outlier Detection(异常点检测)</li></ul><h3id="the-relationship-between-data-minning-and-other-subjectse.g.-database">Therelationship between Data minning and other subjects(e.g. Database)</h3><p>Data mining is known as Knowledge Discovery in Database (KDD) in thefield of artificial intelligence, is also considered as a fundamentalstep in the process of knowledge discovery in database.</p><p>数据挖掘在人工智能领域被称为数据库知识发现（KDD），也被认为是数据库知识发现过程中的一个基本步骤。</p><h3 id="the-challenges-of-big-data-mining">The challenges of big datamining</h3><ul><li>Curse of dimensionality(维度灾难)</li><li>Storage cost</li><li>Query speed <!-- - Data Quality- Data Complexity- Data Privacy and Security- Scalability- Ethics(伦理学)- interpretability --></li></ul><h2 id="ch2-foundations-of-data-mining">Ch2 Foundations of DataMining</h2><h3id="supervised-learningunsupervised-learningsemi-supervised-learning">Supervisedlearning/Unsupervised learning/Semi-supervised learning</h3><ul><li><strong>Supervised learning</strong>: targets to learn the mappingfunction or relationship between the features and the labels based onthe labeled data. Namely, <span class="math inline">\(𝑌=𝐹(𝑋|𝜃)\)</span>.(e.g. Classification, Prediction)</li><li><strong>Unsupervised learning</strong>: aims at learning theintrinsic structure from unlabeled data. (e.g. Clustering, Latent FactorLearning and Frequent Items Mining)</li><li><strong>Semi-supervised learning</strong>: can be regarded as theunsupervised learning with some constraints on labels, or the supervisedlearning with additional information on the distribution of data.</li></ul><h3 id="loss-function">LOSS FUNCTION</h3><p><img src="/img/大数据/ch2-lossfunction.png" /></p><p><span class="math inline">\(l_1\)</span> norm:</p><p><span class="math display">\[L(\beta) =\frac{1}{N}\sum\limits_{i =1}^{N}L(Y_i, F(X_i | \beta)) + \frac{\lambda}{2} || \beta||_2\]</span></p><p><span class="math inline">\(l_2\)</span> norm:</p><p><span class="math display">\[L(\beta) =\frac{1}{N}\sum\limits_{i =1}^{N}L(Y_i, F(X_i | \beta)) + \frac{\lambda}{2} || \beta||_1\]</span></p><p><span class="math inline">\(||A||_∗\)</span> nuclear norm:</p><p><span class="math display">\[||A||_∗=∑\limits_i{σ_i}(A).\]</span></p><h3 id="overfittingunderfitting-problem">Overfitting/Underfittingproblem</h3><p><strong>Reason</strong>?</p><p><strong>How to avoid overfitting</strong>?</p><h3 id="classfied-algorithms">Classfied Algorithms</h3><h4 id="decision-tree">Decision Tree</h4><ul><li>How to construct DT?</li><li>Attribute selection Criteria<ul><li>Information Gain</li><li>Information Gain Ratio</li><li>Gini index</li></ul></li></ul><h4 id="knn">KNN</h4><p><strong>Lazy Learning</strong>: Lazy Learning does not extract rulesor generalizations from a specific model. Instead, it searches forhistorical instances that are similar to the testing instance and makesa prediction based on their output results. (LazyLearning并没有从特定的模型中提取基本规则或一般情况，而是在预测时查找与测试实例相似的历史实例，并根据它们的输出结果做出预测)</p><p><strong>advantage</strong>:</p><ul><li>local data distribution（适用本地数据分布）</li><li>Incremental/online learning（渐进式/在线学习）</li><li>large number of classes（可以对很大的类型数量分类）</li></ul><p><strong>disvantage</strong>:</p><ul><li>parameter k(要设置参数k)</li><li>imbalanced data（数据不平衡时分类效果差）</li><li>slow inference（推理慢）</li></ul><h4 id="naive-bayse">Naive bayse</h4><p><strong>basic idea</strong></p><p><strong>advantage</strong></p><h4 id="svm">SVM</h4><ol type="1"><li>basic concept</li><li>Linear seperation problem<ol type="1"><li>Why SVM works well on small size of samples?<ol type="1"><li>可以处理高维空间</li><li>可以控制正则化参数防止过拟合</li><li>对噪声鲁棒性强</li><li>适用非线性分类</li></ol></li><li>Good generalization</li></ol></li><li>NonLinear problem<ol type="1"><li>solution: map data into high dimension space</li><li>Trick: kernel Trick <span class="math inline">\(K(X,Y) = \Phi(X)\Phi(Y)\)</span></li><li>Kernel function: Gaussian kernel, polynormial kernel</li></ol></li></ol><p>损失函数是平方损失加上L1正则化</p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2 + \alpha \sum_{j=1}^n|\theta_j|\]</span></p><p>其中，第一项是平方损失，第二项是L1正则化项，<spanclass="math inline">\(\alpha\)</span>是正则化参数。</p><h3 id="ensemble-learning">Ensemble Learning</h3><p>Rationale for Ensemble Learning: No Free Lunch thm: There is noalgorithm that is always the most accurate</p><p><strong>Two Criteria</strong>:</p><ul><li>Good base learner</li><li>diversity</li></ul><p><strong>Three Strategies</strong>:</p><ul><li>Bagging(Random Forest)</li><li>Boosting(AdaBoost)</li><li>Stacking</li></ul><h3 id="clustering">Clustering</h3><h4 id="k-means-procedure-and-darwbacks">K-means procedure anddarwbacks</h4><p>K-means procedure:</p><ol type="1"><li>从数据中选择k个对象作为初始聚类中心;</li><li>计算每个聚类对象到聚类中心的距离来划分；</li><li>再次计算每个聚类中心;</li><li>计算标准测度函数，之道达到最大迭代次数，则停止，否则，继续操作。</li></ol><p>优点：</p><ul><li>原理简单，实现容易；</li><li>复杂度与样本数量线性相关，对于处理大数据集合，该算法非常高效，且伸缩性较好。</li></ul><p>drawbacks（缺点）:</p><ul><li>K需要事先给定；</li><li>Kmeans需要人为地确定初始聚类中心，不同的初始聚类中心可能导致完全不同的聚类结果；</li><li>结果不一定是全局最优，只能保证局部最优；</li><li>对噪声和离群点敏感；</li><li>该方法不适于发现非凸面形状的簇或大小差别很大的簇；</li><li>需样本存在均值（限定数据种类）。</li></ul><h4 id="dbscan">DBSCAN</h4><p><strong>Advantage</strong>:</p><ul><li>可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</li><li>可以在聚类的同时发现异常点，对数据集中的异常点不敏感;</li><li>聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</li></ul><p><strong>Disadvantage</strong>:</p><ul><li>如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差。If thedensity of the sample set is not uniform and the distance betweenclusters is very different, the clustering quality is poor.</li><li>如果样本集较大时，聚类收敛时间较长。If the sample set is large, theclustering convergence time is long.</li><li>调参相对于传统的K-Means之类的聚类算法稍复杂. Parameter adjustment ismore complex than K-means.</li></ul><h3 id="subspace-learning">Subspace learning</h3><h4 id="dimension-reduction">Dimension Reduction</h4><p><strong>Models</strong>:</p><ul><li>Linear methods<ul><li>PCA(Principal Component Analysis)</li><li>MDS(Multi-Dimensional Scaling)</li></ul></li><li>Nonlinear methods<ul><li>LLE(Locally Linear Embedding)</li><li>LEM(Laplacian eigenmaps)</li><li>Isomap</li></ul></li></ul><h4 id="feature-selectionclassification">Featureselection(Classification)</h4><ul><li>Filter Method(IG, <span class="math inline">\(\mathcal{X}^2\)</span>)</li><li>wrapper Method</li><li>Embedded Methods</li></ul><h3 id="subspace-clustering子空间聚类">SubspaceClustering(子空间聚类)</h3><ul><li>Sparse subspace clustering (SSC)</li><li>Low-rank representation (LRR)</li></ul><h2 id="ch3-hashing">Ch3 Hashing</h2><h3 id="the-role-of-hashing作用">The role of Hashing(作用)</h3><ul><li>After using the hash code to represent the data, <strong>therequired storage space will be greatlyreduced</strong>（使用哈希码表示数据后，所需要的存储空间会被大幅减小）</li><li>Can <strong>reduce data dimensionality</strong>, thereby alleviatingthe <strong>dimensionality curseproblem</strong>(可以降低数据维度，从而减轻维度灾难问题)</li><li>Can realize fast neighbor retrieval at constant or sub-linear level,and provide support for the rapid realization of upper-level learningtasks(可以实现常数或者次线性级别的快速近邻检索，为上层学习任务的快速实现提供支撑)</li></ul><h3 id="find-similar-items">Find similar items</h3><p>Three Essential Techniques for Similar items:</p><ul><li><strong>K-Shingling</strong>：convert documents, emails, etc., tosets.</li><li><strong>Min-hashing</strong>：convert large sets to shortsignatures, while preserving similarity.</li><li><strong>Locality-sensitive hashing</strong> : focus on pairs ofsignatures likely to be similar.</li></ul><p><img src="/img/大数据/ch3-the-big-pic.png" /></p><h4 id="shingles">Shingles</h4><p>A k-shingle (or k-gram) for a document is <strong>a sequence of kcharacters that appears in the document</strong>.一个文件的k-shingle（或k-gram）是一个出现在文件中的k个字符的序列。</p><p>Example: <span class="math inline">\(k=2; doc = abcab\)</span>. Setof 2-shingles = <span class="math inline">\(\{ab, bc, ca\}\)</span>.</p><h4 id="min-hashing">min-hashing</h4><p>definition:min-hash is an algorithm for <strong>text and datasimilarity comparison</strong> that efficiently extracts the signatureof each data from large-scale data, thus supporting fast comparison oftheir similarity.min-hash是一种用于文本和数据相似度比较的算法，它可以高效地从大规模数据中提取每个数据的签名，从而支持快速地比较它们之间的相似程度。</p><h5 id="signature-matrix-rightarrow-how-to-compute-similarity">signaturematrix <span class="math inline">\(\Rightarrow\)</span> how to computesimilarity</h5><p><img src="/img/大数据/ch3-similarity.png" /></p><p>Jaccard similarity：不将<spanclass="math inline">\((0,0)\)</span>计入分母，相同的行占全部行的比率</p><p>matrix similarity：相同的行占全部行的比率</p><p><strong>Signature Matrix的计算方法</strong>：</p><p><img src="/img/大数据/ch3-signature计算方法.png" /></p><p>上图中间矩阵是输入矩阵，左侧的每一列都代表输入矩阵行的一种排列，那么signaturematrix的每一行都对应左侧的一种排列方式，该行的每列数字对应该种排列方式对应列的第一个1的出现行数。</p><h5 id="locality-sensitive-hashinglsh">Locality-SensitiveHashing（LSH）</h5><p>假设我们在主内存中有代表大量对象的数据</p><ul><li>可能是对象本身</li><li>可能是min-hashing中的签名</li></ul><p>我们要逐一进行比较，找到那些足够相似的pair。但是检查所有的pair是很困难的。</p><ul><li>一般的想法：使用一个函数f(x,y)，告诉人们x和y是否是一个候选对：一对元素的相似性必须被评估。</li><li>对于min-hash矩阵：哈希列到许多桶中，并使同一桶中的元素成为候选对。</li></ul><p>基本思想：Generate from the collection of all elements (signatures inour example) a small list of candidate pairs: pairs of elements whosesimilarity must be evaluated.</p><p>简单来说就是从我们Min-hashing得到的标记矩阵生成可能相似的文档对列表。</p><p>候选相似文档对 <span class="math inline">\(\Rightarrow\)</span>这一对的Jaccard相似度必须被准确计算出来</p><p>方法：</p><ul><li>选一个相似度标准 <span class="math inline">\(t\)</span>，并且 <spanclass="math inline">\(t&lt;1\)</span>，如果两个文档的相似度大于 <spanclass="math inline">\(t\)</span>，则认为这两个文档相似。</li><li>如果列<span class="math inline">\(c\)</span>和列<spanclass="math inline">\(d\)</span>被视为候选文档对，那么他们一定要满足<spanclass="math inline">\(M(i,c)=M(i,d)&gt;=t\)</span>，其中M是标记矩阵。</li></ul><h5 id="lsh-for-minhashing-signatures">LSH for MinhashingSignatures</h5><p>总体思想：把标记矩阵里的hash很多遍，只有hash到同一个桶(bucket)里的列才被认为是可能相似的。</p><p><strong>Partion Into Bands</strong></p><p><img src="/img/大数据/Partion-Into-Bands.png" /></p><p>Divide matrix M into b bands of r rows. For each band, hash itsportion of each column to a hash table with k buckets.如图所示，把标记矩阵(signature matrix)的所有行分成 <spanclass="math inline">\(b\)</span> 个带(bands)，每个带有 <spanclass="math inline">\(r\)</span>行。对于每条带，对带里面每列进行hash，分别hash到<spanclass="math inline">\(k\)</span>个桶中，并让<spanclass="math inline">\(k\)</span>尽可能得大。</p><p>只有有<spanclass="math inline">\(&gt;=1\)</span>的band哈希到同一个桶中，就把这两列当作候选相似对。</p><p><img src="/img/大数据/Partion-Into-Bands-例子.png" /></p><h5 id="example---bands">Example - Bands</h5><p>假设有 100,000 列，每列有100个标记，因此存储标记需要40MB;我们希望找到所以相似度大于80%的文档对，用上面的方法，把标记分为20个带，每个带里有5个标记。</p><p>这样的话，如果文档<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>的相似度是<spanclass="math inline">\(80\%\)</span>，那么他们的任意一个带的<spanclass="math inline">\(5\)</span>个标记都相同的概率是: <spanclass="math inline">\((0.8)^5=0.328\)</span>，看起来好像不大，但是只要有任意一个带都相同就被认为是候选对，所以他们不被选上的概率，即20个带都不相同的概率为：<spanclass="math inline">\((1−0.328)^20=0.00035\)</span> ，也就是每<spanclass="math inline">\(3000\)</span>个相似度为<spanclass="math inline">\(80\%\)</span>的文档对里才会有一对漏选。</p><p>我们再考虑文档<span class="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>只有<spanclass="math inline">\(40\%\)</span>的相似度，那么他们任意一个带的<spanclass="math inline">\(5\)</span>个标记都相同的概率为 <spanclass="math inline">\((0.4)^5=0.01\)</span>，则文档<spanclass="math inline">\(C_1\)</span>和<spanclass="math inline">\(C_2\)</span>被选为候选对的概率，即他们中有一个带完全相同的概率为:<span class="math inline">\(C^1_{20}×0.01=0.2\)</span> ，就是说每<spanclass="math inline">\(5\)</span>个<spanclass="math inline">\(40\%\)</span>相似度的文档对里就有一对会被误选为候选对。但是相似度小于<spanclass="math inline">\(40\%\)</span>的文档对里误选的概率就非常小了。</p><h3 id="learn-to-hash">Learn to Hash</h3><ol type="1"><li>Data indenpendent:Random projection</li><li>Data dependent:<ol type="1"><li>PCA hashing</li><li>Spectral Hashing</li></ol></li></ol><h4 id="pca-hashing">PCA hashing</h4><p>分为两个阶段</p><p><strong>Projection Stage（投影阶段）</strong>:</p><p>用一个转换矩阵<span class="math inline">\(W\)</span>,可以将<spanclass="math inline">\(x\)</span>投影到一个新的特征平面。</p><p><span class="math display">\[Y=W^T X\]</span></p><p><strong>Quantization Stage（量化阶段）</strong>:</p><p><span class="math display">\[h(x) = sgn(W^T X)\]</span></p><p>最小化quantization loss（量化损失）</p><p><span class="math display">\[Q(B,Y) = ||B - Y^T R||^2_F\]</span></p><p><span class="math inline">\(R\)</span>是正交矩阵. <spanclass="math inline">\(B = Sgn(Y^T R)\)</span></p><p>基本思想是旋转数据以最小化量化损失。</p><p>实现方法：从<spanclass="math inline">\(R\)</span>的随机初始化开始，采用类似K-means的迭代算法来优化<spanclass="math inline">\(R\)</span>。在每次迭代中，每个数据点首先被分配到最近的聚类中心，然后更新<spanclass="math inline">\(R\)</span>以使量化损失最小化。</p><h4 id="spectral-hashing谱哈希">Spectral Hashing（谱哈希）</h4><p><img src="/img/大数据/Spectral-Hashing公式.png" /></p><h4id="general-approach-to-learning-based-hashinglearning-based哈希的一般方法">GeneralApproach to Learning-Based Hashing(Learning-Based哈希的一般方法)</h4><p>将哈希学习问题分解为两个步骤：</p><ol type="1"><li>hash bit learning. 哈希比特学习</li><li>hash function learning based on the learned bits.基于所学习的哈希比特的哈希函数学习</li></ol><p><img src="/img/大数据/ch3-Learning-Based-Hashing-步骤.png" /></p><h2 id="ch4-sampling">Ch4 Sampling</h2><p>Why sampling?</p><ul><li>Big data issue<ul><li>Store complexity</li><li>Calculate complexity</li></ul></li><li>Posterior estimation<ul><li>Expectation estimation</li></ul></li></ul><h3 id="inverse-transform-sampling逆采样变换">Inverse TransformSampling(逆采样变换)</h3><p>Inverse Transform Sampling based on the inverse of CumulativeDistribution Function (CDF). 逆采样变换（Inverse TransformSampling）是伪随机数采样的一种基本方法。在已知任意概率分布的累积分布函数<spanclass="math inline">\(CDF\)</span>时，可以通过<spanclass="math inline">\(CDF\)</span>的逆函数来实现随机数的采样。</p><p>简单来说，假设<spanclass="math inline">\(X\)</span>为一个连续随机变量，其概率密度函数为<spanclass="math inline">\(PDF(X)\)</span>，累计分布函数为<spanclass="math inline">\(CDF(X)\)</span>。这时候若想生成符合<spanclass="math inline">\(X\)</span>分布的随机变量样本，只需在<spanclass="math inline">\([0, 1]\)</span>范围内生成随机变量<spanclass="math inline">\(x\)</span>,然后放入<spanclass="math inline">\(CDF\)</span>的反函数中，即可得到符合<spanclass="math inline">\(X\)</span>分布的随机变量样本。</p><p>方法：</p><p><img src="/img/大数据/ch4-CDF.png" /></p><p>优点：</p><ul><li>简单</li><li>适用于任意分布</li></ul><p>缺点：</p><ul><li>Hard to get the inverse function. 很难确定逆函数</li></ul><h3 id="rejection-sampling拒绝采样">Rejection Sampling(拒绝采样)</h3><p>Rejection Sampling accept the samples in the region under the graphof its density function and reject others. 拒绝采样（RejectionSampling）是一种基本的随机数采样方法。它的基本思想是：对于一个难以采样的分布，我们可以找到一个容易采样的分布，使得容易采样的分布包含难以采样的分布，然后从容易采样的分布中采样，若采样的点在难以采样的分布中，则接受该点，否则拒绝该点。</p><p>方法：</p><p><img src="/img/大数据/ch4-Rejection-Sampling.png" /></p><p>步骤：</p><p><img src="/img/大数据/ch4-Rejection-Sampling-步骤.png" /></p><p>这就使得Proposal Distribution <spanclass="math inline">\(q(x)\)</span>的支撑集（support）要大于目标分布<spanclass="math inline">\(p(x)\)</span>的支撑集。所以<spanclass="math inline">\(q(x)\)</span>的分布选择很重要。</p><h3 id="importance-sampling重要性采样">ImportanceSampling(重要性采样)</h3><p>Importance Sampling not reject but assign weight to each instance sothat the correct distribution is targeted. 重要性采样（ImportanceSampling）与RejectionSampling(拒绝采样)的区别在于，重要性采样不会拒绝采样的点，而是对采样的点赋予一个权重，使得采样的点更多地来自于目标分布。</p><h3 id="importance-sampling和rejection-sampling的区别">ImportanceSampling和Rejection Sampling的区别</h3><ul><li>RS的实例有一个相同的权重，只有部分的实例会被保留</li><li>IS的实例有不同的权重，所有的实例都会被保留</li><li>IS对对proposal distribution的选择更不敏感</li></ul><h3 id="markov-chain-monte-carlomcmc">Markov Chain MonteCarlo(MCMC)</h3><p>MCMC methods are a class of algorithms for <strong>sampling from aprobability distribution based on constructing a Markov chain</strong>that has the desired distribution as its <strong>equilibriumdistribution</strong>. The state of the chain after a number of steps isthen used as a sample of the desired distribution.</p><p>马尔可夫链蒙特卡洛（Markov Chain MonteCarlo，MCMC）是一种基于马尔可夫链的随机采样方法。它的基本思想是：对于一个难以采样的分布，我们可以构造一个马尔可夫链，使得该马尔可夫链的平稳分布为该难以采样的分布，然后从该马尔可夫链中采样，得到的样本服从该难以采样的分布。</p><p><strong>蒙特卡洛法</strong>：</p><p>蒙特卡洛法（Monte CarloMethod）是一种基于随机数的数值计算方法。它的基本思想是：对于一个难以计算的问题，我们可以构造一个概率分布，使得该概率分布的期望为该问题的解，然后从该概率分布中采样，得到的样本的平均值即为该问题的解。</p><h4 id="detailed-balance-condition细致平衡条件">Detailed BalanceCondition(细致平衡条件)</h4><p>细致平衡条件（Detailed BalanceCondition）是马尔可夫链平稳分布的一个必要条件。它的基本思想是：对于一个马尔可夫链，若该马尔可夫链的平稳分布为<spanclass="math inline">\(\pi(x)\)</span>，则该马尔可夫链的任意两个状态<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>满足：</p><p><span class="math display">\[\pi(x)P(x, y) = \pi(y)P(y,x)\]</span></p><p>其中<span class="math inline">\(P(x, y)\)</span>为从状态<spanclass="math inline">\(x\)</span>转移到状态<spanclass="math inline">\(y\)</span>的概率,<spanclass="math inline">\(\pi(x)\)</span>为状态<spanclass="math inline">\(x\)</span>的概率。那么<spanclass="math inline">\(\pi(x)\)</span>就是该马尔可夫链的平稳分布。</p><h4 id="the-procedure-of-mcmcmcmc的流程">The Procedure ofMCMC(MCMC的流程)</h4><p><img src="/img/大数据/ch4-MCMC流程.png" /></p><h3 id="metropolis-hastings-algorithmmh算法">Metropolis-HastingsAlgorithm(MH算法)</h3><p>由于MCMC采样有收敛太慢的问题,所以在MCMC的基础之上进行改进，引出MH算法。</p><p><img src="/img/大数据/ch4-MH算法流程.png" /></p><p>MH算法的具体流程如下：</p><p><img src="/img/大数据/ch4-MH算法具体流程.png" /></p><p>一般来说M-H采样算法较MCMC算法应用更广泛，然而在大数据时代，M-H算法面临着两个问题：</p><ol type="1"><li>在高维时的计算量很大，算法效率很低，同时存在拒绝转移的问题，也会加大计算量</li><li>由于特征维度大，很多时候我们甚至很难求出目标的各特征维度联合分布，但是可以方便求出各个特征之间的条件概率分布（因此就思考是否能只知道条件概率分布的情况下进行采样）。</li></ol><h3 id="gibbs-sampling">Gibbs Sampling</h3><p>Gibbs Sampling是MH算法的一种特殊情况。它的基本思想是：</p><p><img src="/img/大数据/ch4-Gibbs.png" /> <imgsrc="/img/大数据/ch4-Gibbs-1.png" /></p><p>因此可以得出在二维的情况下Gibbs采样算法的流程如下：</p><p><img src="/img/大数据/ch4-Gibbs-二维流程.png" /></p><p>而在多维的情况下，比如一个n维的概率分布<spanclass="math inline">\(π(x_1, x_2, ...x_n)\)</span>，我们可以通过在<spanclass="math inline">\(n\)</span>个坐标轴上轮换采样，来得到新的样本。对于轮换到的任意一个坐标轴<spanclass="math inline">\(x_i\)</span>上的转移，马尔科夫链的状态转移概率为<spanclass="math inline">\(P(x_i|x_1, x_2, ..., x_{i−1}, x_{i+1}, ...,x_n)\)</span>，即固定<spanclass="math inline">\(n−1\)</span>个坐标轴，在某一个坐标轴上移动。而在多维的情况下Gibbs采样算法的流程如下：</p><p><img src="/img/大数据/ch4-Gibbs-多维流程.png" /></p><h3 id="gibbs-sampling和mh算法的联系与区别">GibbsSampling和MH算法的联系与区别</h3><ul><li>Gibbs Sampling和MH都是MCMC</li><li>Acceptance Ratio:<ul><li>Gibbs Sampling: <span class="math inline">\(1\)</span></li><li>MH: <span class="math inline">\(\frac{\pi(y)q(y, x)}{\pi(x)q(x, y)}&lt; 1\)</span></li></ul></li><li>MH不需要知道条件概率，而Gibbs Sampling需要知道条件概率</li></ul><h3 id="reservoir-sampling">Reservoir sampling</h3><p>Reservoirsampling是一种随机采样算法，它的基本思想是：对于一个数据流，我们希望从中随机采样出<spanclass="math inline">\(k\)</span>个样本，但是我们不知道数据流的长度，也就是说我们不知道<spanclass="math inline">\(k\)</span>的大小。具体流程如下：</p><p><img src="/img/大数据/ch4-Reservoir.png" /></p><h2 id="ch5-data-stream-mining">Ch5 Data Stream Mining</h2><h3 id="data-stream">Data Stream</h3><p><strong>What is Data Stream?</strong></p><p>A data stream is a massive sequence of data objects which have someunique features.</p><h4 id="properity-of-data-stream">Properity of Data Stream</h4><p>数据流（Data Stream）是一种连续不断的数据，它的特点是：</p><ul><li>One by One(逐个到达)</li><li>Potentially Unbounded(无界)</li><li><strong>Concept Drift(概念漂移)</strong></li></ul><h4 id="conncept-drift概念漂移">Conncept Drift(概念漂移)</h4><p>Concept Drift is the probability distribution changes.</p><p>概念漂移（ConceptDrift）是指数据流中的数据分布随着时间的推移而发生变化的现象。概念漂移分为两种类型：</p><ul><li>Real concept drift (真实概念漂移)</li><li>Virtual concept drift (虚假概念漂移)</li></ul><h4 id="concept-drift-detection概念漂移检测">Concept DriftDetection(概念漂移检测)</h4><ol type="1"><li>Distribution-based detector(基于分布的检测器)</li></ol><p>监测两个固定或可变化的数据窗口之间的数据分布变化，如果数据分布发生变化，则认为发生了概念漂移。方法很简单：只要<spanclass="math inline">\(W\)</span>的两个足够大的子窗口<spanclass="math inline">\(W_1\)</span>和<spanclass="math inline">\(W_2\)</span>的数据分布不同，就认为发生了概念漂移，这时较旧的窗口就被放弃。</p><p><strong>draw back(缺点)</strong>：</p><ul><li>Hard to determine window size.</li><li>Learn concept drift slower</li><li>Virtual concept drift</li></ul><p><strong>Adaptive Windowing(ADWIN)</strong>:</p><p>ADWIN 的思想是从时间窗口 <span class="math inline">\(W\)</span>开始，在上下文没有明显变化时动态增大窗口 <spanclass="math inline">\(W\)</span>，并在检测到变化时将其缩小。该算法试图找到显示不同平均值的 <span class="math inline">\(W -w_0\)</span> 和 <span class="math inline">\(w_1\)</span> 的两个子窗口。这意味着窗口的旧部分 <span class="math inline">\(- w_0\)</span>是基于与实际不同的数据分布，因此被删除。</p><ol type="1"><li>Error-rate based detector(基于错误率的检测器)</li></ol><p>根据分类性能的变化来捕捉概念的漂移,如果分类器的错误率超过了某个阈值，则认为发生了概念漂移。</p><p>DDM算法：</p><p>DDM算法的基本思想是：在数据流中，如果某个时间点的错误率比之前的错误率大很多，则认为发生了概念漂移。确定错误率的变化是否显著的方法如下公式：</p><p><span class="math display">\[p_i + s_i \ge p_{min} + 3 \timess_{min}\]</span></p><p>误差率是指观察到错误的概率<spanclass="math inline">\(p_i\)</span>，其标准差为<spanclass="math inline">\(s_i = sqrt(p_i (1 - p_i) / i)\)</span></p><p><strong>draw back(缺点)</strong>：</p><ul><li>Sensitive to noise</li><li>Hard to deal with gradual concept drift</li><li>Depend on learning model itself heavily</li></ul><h4 id="data-stream面临的挑战">Data Stream面临的挑战</h4><ul><li>Infinite Length(无限长度)</li><li>Evolving Nature(不断变化的数据)</li></ul><h3 id="data-stream-clissification数据流分类">Data StreamClissification(数据流分类)</h3><p>流程：</p><ul><li>从数据流中读取下一个可用数据(要求1)</li><li>用读取的数据更新分类器，并且这样做不回超过对它设置的内存限制(要求2)，并尽可能快地完成（要求3）</li><li>算法已经学习了足够的数据，以便在新数据上进行分类(要求4)</li></ul><p><strong>典型算法</strong>：</p><ul><li>VFDT(very fast decision tree, KDD'00)</li><li>CVFDT(Concept-adapting very fast decision tree, KDD'01)</li><li>SyncStream(同步流算法, KDD'14)</li></ul><h4 id="vfdt">VFDT</h4><p>Hoeffding树是一种基于决策树学习的数据流分类算法，在处理数据流时，可以保证挖掘效率的同时，达到对数据流一些必要操作的要求。该算法简单的对数据流中的每个样本检查一次，并逐步生成一颗决策树，而在这些样本更新完决策树之后无需进行存储。在内存中只需维护决策树信息，因为在决策树的叶结点中存储着决策树扩展所必须的统计信息，并且在处理训练数据集时，可以用决策树中的信息进行预测。</p><p>VFDT（very fast decision tree）是基于Hoeffdingtree改进的算法和系统，它和Hoeffdingtree算法相似之处在于都是根据<strong>Hoeffding不等式</strong>来决定决策节点的最佳属性从而建立决策树模型。</p><p>Hoeffding 不等式:</p><p>Hoeffding不等式适用于有界的随机变量。设有两两独立的一系列随机变量<spanclass="math inline">\(X_1, X_2, ..., X_n\)</span>，且<spanclass="math inline">\(X_i\)</span>的取值范围是<spanclass="math inline">\([a_i, b_i]\)</span>，这<spanclass="math inline">\(n\)</span>个随机变量的经验期望<spanclass="math inline">\(\bar{X}=\frac{X_1 + \dots +X_n}{n}\)</span>满足以下不等式：</p><p><span class="math display">\[P(|\bar{X} - E(\bar{X})| \ge \epsilon)\ge \exp(-\frac{2n^2\epsilon^2}{\sum_{i=1}^n(b_i - a_i)^2})\]</span></p><p><span class="math display">\[P(|\bar{X} - E(\bar{X})| \ge \epsilon)\le 2 \exp(-\frac{2n^2\epsilon^2}{\sum_{i=1}^n(b_i -a_i)^2})\]</span></p><p>其中<span class="math inline">\(E(\bar{X})\)</span>是<spanclass="math inline">\(\bar{X}\)</span>的期望，<spanclass="math inline">\(\epsilon\)</span>是一个正数。</p><p>VFDT系统解决了Hoeffdingtree算法没有提到的实际问题，就是当两个属性的信息熵差不多时，这个时候就会发生两个属性之间的权衡。这是系统需要花费大量的时间和空间，利用更多的样本来决定选择哪个属性为最佳的决策节点的属性，而这显然是浪费的。</p><p>VFDT算法相较于Hoeffding Tress算法的改进：</p><ul><li>提供了一个用户定义的阈值<span class="math inline">\(τ\)</span>用来解决“两个属性的信息熵差不多时的博弈”。当信息熵差值小于某个阈值时，即可判定其为决策节点属性。</li><li>允许设定节点的最小样本个数值<spanclass="math inline">\(n_{min}\)</span>，在用户能够承受的置信度下，让用户设定每个节点最小的样本数将有效的减少样本信息熵<spanclass="math inline">\(G\)</span>的计算而消耗的时间复杂度。</li><li>提供重新扫描数据集和二次抽样的功能，并且在数据流中的样本数减少时，决策树的精度也会无限逼近于读取所有样本建立决策树的精度。</li></ul><p><strong>以下是 VFDT 算法的基本流程</strong>：</p><ol type="1"><li><p>构建决策树：对于一个分类问题，首先需要构建一颗决策树。该决策树会被VFDT 算法不断地更新和重新构建。</p></li><li><p>建立示例集：随机选择一些实例作为示例集。</p></li><li><p>计算初始统计信息：对于示例集中的每个实例，计算它们分类结果的概率分布。</p></li><li><p>增量统计每个实例：对于新增加的每个实例，将其加入当前的示例集，并更新分类结果的概率分布。</p></li><li><p>检查增量误差：计算每个分类器的误差，并选择一个误差最小的分类器来更新决策树。</p></li><li><p>执行更新：将当前分类器放到决策树上对应的位置，并更新决策树。</p></li></ol><p>重复步骤 4-6，直到决策树满足一定条件。</p><p>VFDT算法是一种增量式建树算法，它通过不断更新决策树的方法来尽可能地减小误差。这种算法的好处是，可以随时加入新的数据，更新模型，同时不需要重新训练整个模型。但是，VFDT算法也存在一些缺点，比如计算复杂度较高，对异常数据较为敏感等。</p><h5 id="vfdt的优缺点">VFDT的优缺点</h5><p><strong>优点</strong>：</p><ul><li>Scales better than traditional methods(比传统方法更好)<ul><li>Sublinear with sampling(子线性采样)</li><li>Very small memory utilization(非常小的内存使用率)</li></ul></li><li>Incremental(增量学习)<ul><li>Make class predictions in parallel(并行预测分类)</li><li>New examples are added as they come(新的样本随着到来而添加)</li></ul></li></ul><p><strong>缺点</strong>：</p><ul><li>Could spend a lot of time with ties(可能会花费很多时间)</li><li>Memory used with tree expansion(内存使用率随着树的扩展而增加)</li><li>Number of candidate attributes(候选属性的数量大)</li></ul><h4id="cvfdtconcept-adapting-very-fast-decision-tree">CVFDT(Concept-adaptingvery fast decision tree)</h4><p>CVFDT是VFDT的改进版，它保持了VFDT的精度和速度，VFDT算法假设所分析处理的数据流是平稳分布的，所以应对数据流中概念变化时采用的是单一的决策树模型，这就导致VFDT的决策树模型不能及时反映数据流随时间变化的趋势。</p><p>另外VFDT也没有处理连续值属性的问题。因为在CVFDT中滑动窗口的引入，过时的样本都被删除，所以 CVFDT 树比 VFDT 树要小很多。CVFDT根据滑动窗口中的数据流样本来持续检测旧的决策树的有效性从而保证建立模型与概念漂移同步。</p><p>CVFDT算法对VFDT算法的改进如下：</p><ul><li><strong>CVFDT算法解决了VFDT算法不能处理数据流中概念漂移的问题</strong>。通过在VFDT算法基础上添加滑动窗口使得建立决策树模型的数据流能够不断实现更新，保证在概念漂移的数据流中保持模型的准确率。</li><li>对于每个节点包括根节点都有相应的ID。样本遍历每个节点时不仅会在节点处保存其样本的属性信息，同时窗口中的样本也会保存其遍历过的节点信息。当样本滑出窗口时，该样本所经历过的节点统计值将依次减一。</li><li>CVFDT还为每个决策节点设置备选子树，周期性的检测每个决策节点的准确率从而决定替代子树是否替换当前的决策节点，从而也有效的提高了决策树模型的准确率。</li></ul><p>CVFDT算法流程如下：</p><p><img src="/img/大数据/ch5-CVFDT-流程.png" /></p><p>CVFDT算法采用增量的方式训练决策树，解决了VFDT算法不能处理连续属性的问题，并且在处理大规模数据时效率更高。</p><h4 id="syncstream">SyncStream</h4><p>KNN style</p><!-- 待完善 --><h4 id="open-set-problem">Open-set problem</h4><ul><li>Novel class Dection(Extreme Value Theory,EVT)</li></ul><p>EVT 中心思想是概率分布，可给出事件发生概率的数学公式。</p><ul><li>Continued learning(Elastic Weight Consolidation,EWC)</li></ul><p>EWC的基本思想：模型中的一些参数对前面的任务很重要。只改变不重要的参数</p><p>Gradient Episodic Memory(GEM)的基本思想:限制梯度的方向来改善之前的工作</p><ul><li>Class-incremental learning</li></ul><p>问题：</p><ol type="1"><li>怎么平衡新旧类的样本</li><li>怎么平衡新旧类的样本的重要性</li><li>怎么提取榜样样本(exemplars examples)</li></ol><p><strong>Knowledge Distillation(知识蒸馏)</strong>:</p><p><strong>Weight Aligning(权重对齐)</strong>:通过对齐权重来减少模型的参数数量</p><h3 id="data-stream-clustering流聚类">Data StreamClustering(流聚类)</h3><h4 id="framework">Framework</h4><p>有两个阶段</p><ol type="1"><li>online Dataabstraction(数据抽象):将数据归纳为具有内存效率的数据结构</li><li>offline clustering(离线聚类):使用聚类算法来寻找数据类别</li></ol><!-- online阶段首先根据K-mens算法生成p个初始的聚类中心(micro clusters)，并为每一个簇提供一个独一无二的ID，其中P是大于具体的聚类数目但是要远远小于具体数据点的个数。对于每一个到来的数据点，要么被现有的微集群吸收（是否在一个集群的最大边界内-均值根偏差RMS），要么自己成立一个集群。但是数据点不属于现有的集群有两种情况，一种是该点是一个异常点，第二种是该点是一个新集群的起始点。那么如果要新建立一个集群的话，就需要将已有的集群删除一个或者合并两个相似的集群。若要删除一个集群的话，首先判断删除该集群是否会有不良的影响，所以根据该集群的数据点的时间戳信息来判断，如果该簇的时间戳不满足设定的阈值，将其删除。合并集群的话，将两个最近的集群进行合并。 --><p>流聚类算法：</p><p><img src="/img/大数据/ch5-流聚类算法.png" /></p><!-- offline clustering(离线聚类)根据用户输入的需要查看的时间，从特征金字塔中取出两个时间段的汇总信息，相减之后就得到用户所需时间段的近似数据集，在此基础上进行聚类即可。 --><h4 id="online-data-abstraction">online Data abstraction</h4><p><strong>Micro-Cluster</strong>: A Micro-Cluster is a set ofindividual data points that are close to each other and will be treatedas a single unit in further offlineMacro-clustering.(Micro-Cluster是一组彼此接近的单个数据点，将在进一步的离线宏聚类中作为单个单元处理。)</p><p><strong>Cluster Feature</strong>:用来表示一个Micro-Cluster的属性，<span class="math inline">\(CF = (N,LS, SS)\)</span></p><p>其中<span class="math inline">\(LS = \sum\limits_{i=1}^N X_i, SS =\sum\limits_{i=1}^N X_i^2\)</span></p><p>其中<span class="math inline">\(N\)</span>是数据点，<spanclass="math inline">\(LS,SS\)</span>中的<spanclass="math inline">\(X_i\)</span>是一个向量。</p><p><strong>Cluster Feature</strong>的属性：Additivity Property</p><p><img src="/img/大数据/ch5-CF属性-1.png" /> <imgsrc="/img/大数据/ch5-CF属性-2.png" /></p><ol type="1"><li>动态选择short-term和long-term的代表性example，代表性高的保留，代表性低的删除，没有，若代表性没有改变，就进行statisticsummary(摘要统计)</li><li>Cluster Feature的属性：Additivity Property</li></ol><h2 id="ch6-graph-mining">Ch6 Graph Mining</h2><h3 id="key-node-identification">Key Node Identification</h3><h4 id="centrality">Centrality</h4><p><strong>DegreeCentrality</strong>:节点度的大小用来衡量节点的重要性（节点的直接影响）。</p><p><strong>BetweennessCentrality</strong>：每个顶点的间性中心度是通过该顶点的这些最短路径的数量。</p><p><strong>ClosenessCentrality</strong>：计算为节点与图中所有其他节点之间的最短路径长度之和。</p><h3 id="k-shell-decomposition">K-shell Decomposition</h3><p>将图中结点度为1的所有结点和对应的连边去掉后，新的网络中可能会有新的度为1的结点，把这些结点和边也去掉，重复操作，直到不再有度为1的结点为止。这种操作类似于剥去网络最外面一层壳，所以把所有去除的结点以及他们之间的连边称为网络的1-壳(1-shell)。网络中度为0的独立结点称为0-壳(0-shell)。在去除1-壳后的网络中，所有结点度都大于等于2，因此，接着把度为2的结点和对应连边去掉，直到不再有度为2的结点为止，则去除的结点和边称为2-壳(2-shell)。依此类推，直到网络中每个结点都划分到相应k-shell中，就得到网络的k-shell分解。</p><p>每个结点都唯一对应一个k-shell，这个k-shell中的结点的度一定大于等于k。但是注意，度相同的结点不一定属于同一个k-shell。并且，度大的结点既可能属于k值大的k-shell(最内层)，可能能属于k值较小的shell(外层)。所以，度值大的未必就重要。</p><p>优点：</p><ul><li>计算复杂度低</li><li>直观的揭示了网络的层次结构</li></ul><p>缺点：</p><ul><li>不能在很多网络中使用，如星形网络、树形网络等。</li><li>不能很好地反映网络的重要性，有时候甚至不如单纯用节点度值衡量效果好。</li></ul><h3id="eigenvector特征向量e.g.pagerank">Eigenvector（特征向量）e.g.PageRank</h3><p>PageRank是Google最早的搜索引擎核心用的就是这个算法</p><p>PageRank基本思想：如果一个页面被很多其他页面链接到的话说明这个页面比较重要，如果一个页面被一个很重要的页面链接到的话，那么这个页面也很重要。</p><h3 id="community-detection">Community Detection</h3><h4 id="cut-based-methods">Cut-based Methods</h4><h5 id="minimum-cut">Minimum Cut</h5><p>由于大多数节点互动是在组内进行的，而组与组之间的互动则很少。所以我们可以把communitydetection问题转换为一个最小割问题。最小割问题是指在一个无向图中，找到一条边的集合，使得这些边的权重之和最小，且删除这些边之后，图被分成两个部分。</p><h5 id="ratio-cut-normalized-cut">Ratio Cut &amp; Normalized Cut</h5><p>由于最小割往往返回一个不平衡的partation，其中的一个集合是一个单点，所以我们可以用RatioCut和NormalizedCut来解决这个问题。思想是在最小割的基础之上修改目标函数以考虑到partation的平衡性。</p><p><img src="/img/大数据/ch6-ratio-cut.png" /></p><p><img src="/img/大数据/ch6-norm-cut.png" /></p><p>其中<span class="math inline">\(C_i\)</span>是一个子集和，<spanclass="math inline">\(\bar{C_i}\)</span>是<spanclass="math inline">\(C_i\)</span>的补集，<spanclass="math inline">\(|C_i|\)</span>是子集和的大小，<spanclass="math inline">\(vol(C_i)\)</span>是子集和中所有节点的度之和。</p><p>在 RatioCut切图中，不仅要考虑使不同组之间的权重最小化，也考虑了使每个组中的样本点尽量多。</p><p>在 Norm Cut切图中，除了考虑最小化损失函数之外，还考虑了子图之间的权重大小。</p><p>由于子图样本的个数多并不一定权重就大，切图时基于权重也更合目标，因此一般来说Normcut 切图优于 RatioCut 切图。</p><h5 id="modularity-maximization模块度最大化">ModularityMaximization(模块度最大化)</h5><p>模块度通过考虑度分布来衡量Community partition的强度。</p><p>给定一个有<spanclass="math inline">\(m\)</span>条边的网络，学位为<spanclass="math inline">\(d_i\)</span>和<spanclass="math inline">\(d_j\)</span>的两个节点之间的预期边数为<spanclass="math inline">\(d_i d_j / 2 m\)</span></p><p>给定如下例子：</p><p><img src="/img/大数据/ch6-Modularity-Maximization-例子图.png" /></p><p>则节点<span class="math inline">\(1\)</span>和<spanclass="math inline">\(2\)</span>之间的预期边数为<spanclass="math inline">\(3 * 2 / (2 * 14)\)</span></p><p>Strength of a community: <span class="math inline">\(\sum\limits_{i\in C, j \in C} A_{ij} - \frac{d_i d_j}{2m}\)</span></p><p>Modularity(模块度)：<span class="math inline">\(Q =\frac{1}{2m}\sum\limits_{l =1}^k \sum\limits_{i \in C, j \in C} (A_{ij}- \frac{d_i d_j}{2m})\)</span> )</p><p>数值越大，表明community structure越好.</p><h5 id="simulatingdistance-dynamics">Simulating:Distance Dynamics</h5><p>动态距离(Distance Dynamics)是CommunityDetection的一种新视角，它的基本思想是模拟边距离的动态变化。</p><p>它将整个网络视为一个动态系统，根据不同的互动模式模拟距离动态（距离动态与节点动态）.所有边的距离都会收敛，从而直观地识别出社区结构。</p><p>如果两个节点相连，每个节点都会吸引另一个节点，使得另一个节点移动到自己身边.</p><p>边距离:受三种不同类型节点的影响:(a)直接链接节点;(b)共同邻居;(c)独占邻居</p><ul><li>直接链接节点的影响：使u和v更接近。</li><li>共同邻居的影响：使u和v更接近。</li><li>独占邻居的影响：使u和v更接近或更远。</li></ul><p>Distance Dynamics的步骤：</p><ol type="1"><li>Initialization：计算每条边的Jaccard距离</li><li>Dynamics: 研究每条边距离的变化</li><li>Community Detection : 删除距离为1的边</li></ol><p><img src="/img/大数据/ch6-Distance-Dynamics-流程.png" /></p><h3 id="graph-embedding">Graph embedding</h3><h4 id="motivation">Motivation</h4><ul><li>网络包含数十亿的节点和边，对整个网络进行复杂的推理是难以实现的。</li><li>机器学习算法需要向量表示</li><li>如何在Graph embedding的过程中保留Commmunity structure</li><li>如何有效地处理大规模网络</li></ul><p>Graph embedding的目标是将每个节点映射到一个低维空间。</p><p>图是一种非欧几里得结构，图的属性：</p><ul><li>节点的编号是任意的</li><li>图具有任意的大小</li><li>结构复杂</li></ul><p>困难：</p><ul><li>衡量节点之间的相似度</li><li>编码网络信息并生成节点表示</li></ul><h4 id="deepwalk">DeepWalk</h4><!-- DeepWalk的思想类似word2vec，使用图中节点与节点的共现关系来学习节点的向量表示。那么关键的问题就是如何来描述节点与节点的共现关系，DeepWalk给出的方法是使用随机游走(RandomWalk)的方式在图中进行节点采样。RandomWalk是一种可重复访问已访问节点的深度优先遍历算法。给定当前访问起始节点，从其邻居中随机采样节点作为下一个访问节点，重复此过程，直到访问序列长度满足预设条件。![](/img/大数据/ch6-deepwalk-流程.png)#### Node2Vec**优化目标**:设$f(u)$是是将顶点 $u$ 映射为embedding向量的映射函数,对于图中每个顶点$u$,定义$N_{S}(u)$为通过采样策略$S$采样出的顶点$u$的近邻顶点集合。node2vec优化的目标是给定每个顶点条件下，令其近邻顶点（**如何定义近邻顶点很重要**）出现的概率最大。![](/img/大数据/ch6-Node2vec-公式.png) --><p>详见<a href="https://zhuanlan.zhihu.com/p/56380812">【GraphEmbedding】DeepWalk：算法原理，实现和应用</a></p><h4 id="node2vec">Node2vec</h4><p>详见<a href="https://zhuanlan.zhihu.com/p/56542707">【GraphEmbedding】node2vec：算法原理，实现和应用</a></p><h2 id="ch7-hadoopspark">Ch7 Hadoop/Spark</h2><h3 id="hadoop">Hadoop</h3><h4 id="what-is-hadoop">What is Hadoop</h4><p>Hadoop是一个软件框架，用于在大型计算机集群中分布式处理大型数据集。</p><h4 id="design-principles-of-hadoop">Design Principles of Hadoop</h4><ul><li>Need to process big data</li><li>Need to parallelize computation across thousands of nodes</li><li>Commodity hardware<ul><li>Large number of low-end cheap machines working in parallel to solvea computing problem</li></ul></li><li>This is in contrast to Parallel DBs<ul><li>Small number of high-end expensive machines</li></ul></li><li>Automatic parallelization &amp; distribution<ul><li>Hidden from the end-user</li></ul></li><li>Fault tolerance(容错) and automatic recovery<ul><li>Nodes/tasks will fail and will recover automatically</li></ul></li><li>Clean and simple programming abstraction.(干净而简单的编程抽象)<ul><li>Users only provide two functions “map” and “reduce”</li></ul></li></ul><h4 id="hadoop-architecture">Hadoop Architecture</h4><ul><li>Distributed file system (HDFS)</li><li>Execution engine (MapReduce)</li></ul><p><img src="/img/大数据/ch7-Hadoop-Architecture.png" /></p><h3 id="eco-system-of-hadoop">Eco-system of Hadoop</h3><ul><li>HDFS:Storing(存储)</li><li>MapReduce:computation</li><li>HBASE:NoSQL database</li><li>Hive:Data warehouse(数据仓库)</li><li>Pig:Data flow language</li><li>Zookeeper:Coordination service</li><li>Core:Filesystems and I/O</li><li>Avro:Cross-language serialization(跨语言序列化)</li></ul><h3 id="hadoop-distributed-file-systemhdfs分布式文件系统">HadoopDistributed File System(HDFS)：分布式文件系统</h3><p><strong>Main Properties of HDFS</strong>:</p><ul><li><strong>Large</strong>:一个HDFS实例可能由数以千计的服务器机器组成，每个机器都存储着文件系统的部分数据</li><li><strong>Replication</strong>:每个数据块被多次复制（默认为3）。</li><li><strong>Failure</strong>:失败是常态而不是例外</li><li><strong>FaultTolerance</strong>:检测故障和快速自动恢复故障是HDFS的一个核心架构目标</li></ul><h4 id="namenode-datanode"><strong>NameNode + DataNode</strong></h4><ul><li>NameNode(meta-information)<ul><li>Managing FsImage file and EditLog file to manager metainformation</li><li>EditLog is used to update FsImage (Checkpoint).</li></ul></li><li>DataNode(actual data)<ul><li>Store data</li><li>Block operation</li></ul></li></ul><h4 id="fault-tolerance-replication-heartbeat"><strong>FaultTolerance</strong>: Replication + HeartBeat</h4><ul><li>HeartBeat:DataNode</li><li>Replication:Steady NameNode</li></ul><h3 id="mapreduce">MapReduce</h3><p>MapReduce的思想就是“分而治之”</p><h4 id="map">Map</h4><p>Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：</p><ul><li>一是数据或计算的规模相对原任务要大大缩小;</li><li>二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算;</li><li>三是这些小任务可以并行计算，彼此间几乎没有依赖关系。</li></ul><h4 id="reduce">Reduce</h4><p>Reducer负责对map阶段的结果进行汇总。至于需要多少个Reducer，用户可以根据具体问题具体设置。</p><h3 id="spark基于内存的计算框架">Spark(基于内存的计算框架)</h3><p>MapReduce is great at one-pass computation,but inefficient formulti-pass algorithms.</p><h4 id="what-is-spark">What is Spark</h4><p><strong>Apache Spark is a fast and general-purpose cluster computingsystem.</strong>It also supports a rich set of higher-level toolsincluding <strong>Spark SQL</strong> for SQL and structured dataprocessing,<strong> MLlib</strong> for machinelearning,<strong> GraphX</strong> for graph processing,and <strong>Spark Streaming</strong> for streaming processing.</p><h4 id="memory-based-computation">Memory based computation</h4><h5 id="rdd">RDD</h5><p>Spark的主要抽象是resilient distributed dataset(RDD),它表示一个只读的对象集合，在一组机器上进行分区，如果一个分区丢失，可以重建。</p><p>An RDD can be created 2 ways:</p><ul><li>Parallelize a collection</li><li>Read data from an external source</li></ul><h5 id="operations-on-rdd">Operations on RDD</h5><ul><li>transformations：create a new dataset from an existing one</li><li>actions: return a value to the driver program after running acomputation on the dataset</li></ul><h4 id="fault-tolerance">Fault Tolerance</h4><p>暂无待续.</p><h3 id="mapreduce-vs-spark">MapReduce VS Spark</h3><p><strong>MapReduce</strong>:</p><ul><li>Great at <strong>one-pass computation</strong>, but inefficient for<strong>multi-pass algorithms</strong>.</li><li>No efficient primitives for datasharing(没有用于数据共享的有效基元)</li></ul><p><strong>Spark</strong>:</p><ul><li>Extends a programming language with a distributed collectiondata-structure（RDD）.(用分布式集合数据结构（RDD）扩展了一种编程语言)</li><li>Clean APIs in Java, Scala, Python, R.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和数组与差分数组</title>
    <link href="/2023/06/01/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2023/06/01/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和数组与差分数组">前缀和数组与差分数组</h1><h2 id="一维前缀和">一维前缀和</h2><p>对于一维数组<code>nums</code>，其前缀和数组<code>prefix</code>为<span class="math display">\[prefix[i] = \sum\limits^{i}_{1} nums[i]\]</span></p><p>实际中多在前面加一个<code>0</code>，这样<code>prefix[i]</code>就刚好是<code>nums</code>数组的前<code>i</code>项和。</p><h2 id="一维差分数组">一维差分数组</h2><p>一维数组<code>nums</code>的差分数组<code>diff</code>定义：</p><p><span class="math display">\[diff[i] = nums[i] - nums[i - 1]\]</span></p><p>二维差分、二维前缀和与一维差分一维前缀和同理。</p><p>二维前缀和、二维差分定义以及例题详见<ahref="https://juejin.cn/post/7051851325746708511">Hard题学算法(二维前缀和+二维差分）</a></p><h2id="从差分数组前缀和数组求原数组">从差分数组、前缀和数组求原数组</h2><p><strong>差分数组求原数组</strong>：差分数组的前缀和数组就是原数组</p><p><strong>前缀和数组求原数组</strong>（以二维为例,默认在前面添加了一维的<code>0</code>防止越界）：</p><p><span class="math display">\[nums[i][j] = prefix[i + 1][j + 1] -prefix[i][j + 1] - prefix[i + 1][j] + prefix[i][j]\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习期末复习</title>
    <link href="/2023/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习期末复习">机器学习期末复习</h1><h2 id="第一章-机器学习简介">第一章 机器学习简介</h2><h3 id="机器学习的概念">机器学习的概念</h3><p>是一种实现人工智能的方法</p><h3 id="机器学习的要素">机器学习的要素</h3><ul><li>模型：对于监督学习，模型就是要学习的条件概率或者决策函数</li><li>策略<ul><li>目标：选择最优的模型</li><li>损失函数，损失函数越小，模型就越好<ul><li>平方损失函数：<spanclass="math inline">\(L(Y，f(X))=(Y-f(x))^2\)</span>, 其中<spanclass="math inline">\(Y\)</span>是标签（真实值), <spanclass="math inline">\(f(X)\)</span>是预测值。</li></ul></li><li>风险函数（期望损失）：损失函数的期望</li><li>经验风险：训练集的平均损失，训练集的拟合情况 <spanclass="math display">\[结构风险  =  经验风险 + 正则化项 (系数 *模型复杂度)\]</span></li></ul></li><li>算法：用什么样的计算方法求解最优模型。归结为最优化问题</li></ul><h3 id="机器学习的类型">机器学习的类型</h3><ul><li>监督学习：监督学习是指通过让机器学习大量带有标签的样本数据，训练出一个模型，并使该模型可以根据输入预测相应输出的过程</li><li>无监督学习：训练数据不再是（input,output）对的形式，样本数据没有标签</li><li>强化学习：通过感知外界环境的变化来调整学习方式，然后通过奖惩的方式来判别学习方式是否正确，通过一步步调整学习方式，最终找到一个最优的方式。通过一个智能体在与复杂而不确定的环境交互中最大化总回报来学习的一种计算方法</li></ul><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>训练误差：训练集的平均损失</p><p>测试误差：测试集的平均损失</p><h3 id="回归和分类">回归和分类</h3><p>回归：因变量𝑦 ∈ ℝ是连续变量 分类：label是离散变量</p><h3 id="过拟合">过拟合</h3><p>欠拟合：模型在训练集上误差很大，在测试集上误差也大。由于模型能力不足（不灵活）</p><p>过拟合(Over-fitting)：模型在训练集上误差很低，但是在测试数据上误差很高。由于训练数据太少和/或模型能力太强等原因造成</p><p><img src="/img/机器学习/过拟合.jpg" /></p><p>解决过拟合的方法:</p><ul><li>扩大训练集</li><li>正则化Regularization：通过修改目标函数来惩罚模型的复杂度<ul><li>L1正则化：可以使参数稀疏化</li><li>L2正则化：可以防止过拟合</li></ul></li><li>通过验证集来选择模型</li></ul><h3 id="模型选择方法">模型选择方法</h3><p><strong>正则化</strong>:</p><p>结构风险 = 经验风险 + 正则化项</p><p><img src="/img/机器学习/期末复习/结构风险.png" /></p><p>在回归问题中，正则化项可以是L1,L2范数：</p><p><img src="/img/机器学习/期末复习/L1L2范数.png" /></p><p>其中，L1 L2范数分别为</p><p><img src="/img/机器学习/期末复习/L1L2范数定义.png" /></p><p><strong>奥卡姆剃刀原理</strong>：在已知数据的情况下，越简单的模型越好</p><p><strong>贝叶斯估计视角</strong>：正则化项为模型先验概率</p><h3 id="交叉验证">交叉验证</h3><p>数据集划分为三个部分：训练集，测试集，验证集。训练集用于模型训练，测试集用于最终对学习方法评估，验证集用于模型选择。在学习到不同复杂度的模型中，选择验证集最小预测误差的模型。</p><ul><li>简单交叉验证：划分训练集和测试集，用不同的模型对训练集进行训练，最终在测试集评价每一个模型的误差，选出误差最小的模型。</li><li>S折交叉验证：把数据集划分成s份，用其中的s-1份训练模型，用剩下的一份测试模型。其中，一共有s种组合，对s种组合重复对对模型进行训练和评测。最终，选出在这s次训练和评测中，平均误差最小的模型。</li><li>留一交叉验证：s折交叉验证的特殊情况：S=N，N为数据集的个数。即为：只留一个样本用作测试。</li></ul><h3 id="泛化能力">泛化能力</h3><p>对未知数据集的预测能力</p><h3 id="生成模型与判别模型">生成模型与判别模型</h3><ul><li>生成模型：生成方法由数据学习联合概率分布<spanclass="math inline">\(P(X,Y)\)</span>,然后求出条件概率分布 <spanclass="math inline">\(P(Y|X)\)</span>作为预测的模型：<spanclass="math inline">\(P(Y|X) = {P(X,Y)/P(X)}\)</span>。最后模型: <spanclass="math inline">\(P(Y)=P(Y|X)*P(X)\)</span>。</li><li>判别模型：直接学习决策函数或者 P(Y|X)作为预测的模型。</li></ul><h3 id="二分类评价指标">二分类评价指标</h3><p>精确率和召回率：TP, FP, TN, FN（true/false positive/negitive）</p><p>精确率: <span class="math inline">\(P = \frac{TP}{TP +FP}\)</span></p><p>召回率: <span class="math inline">\(R = \frac{TP}{TP+FN}\)</span></p><h3 id="贝叶斯定理">贝叶斯定理</h3><p><span class="math inline">\(P(A|H) =\frac{P(A)P(H|A)}{P(H)}\)</span></p><h4 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h4><p><strong>先验概率</strong>:<spanclass="math inline">\(P(Y=c_k),k=1,2,...,K\)</span></p><p><strong>条件概率（似然概率）</strong>:<spanclass="math inline">\(P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,...,K\)</span></p><p><strong>后验概率</strong>:<spanclass="math inline">\(P(Y=c_k|X=x)=\frac{P(Y=c_k)P(X=x|Y=c_k)}{\sum_{k=1}^KP(Y=c_k)P(X=x|Y=c_k)}\)</span></p><h2 id="第二章-概率论概述">第二章 概率论概述</h2><h3 id="频率论学派和贝叶斯学派">频率论学派和贝叶斯学派</h3><p><strong>频率论学派（Frequentist）</strong>：通过大量独立实验将概率解释为事件发生频率的均值（大数定律）</p><p><strong>贝叶斯学派（Bayesian）</strong>：则将概率解释为信念度（degreeofbelief）。当考虑的试验次数非常少的时候，贝叶斯方法的解释非常有用。此外，贝叶斯理论将我们对于随机过程的先验知识纳入考虑，当我们获得新数据的时候，这个先验的概率分布就会被更新到后验分布中</p><h3 id="高斯分布">高斯分布</h3><p><img src="/img/机器学习/期末复习/高斯分布.jpg" /></p><h3 id="极大似然估计和最大后验估计">极大似然估计和最大后验估计</h3><p><strong>极大似然估计（频率学派模型参数估计常用方法）</strong>：通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！即最大化<spanclass="math inline">\(P(x_0|\theta)\)</span></p><p><img src="/img/机器学习/期末复习/极大似然估计.jpg" /></p><p><strong>最大后验估计（贝叶斯派模型参数估计的常用方法）</strong>：最大化在给定数据样本的情况下模型参数的后验概率。即最大化<span class="math inline">\(P(\theta | x_0) = \frac{P(x_0 |\theta)P(\theta)}{P(x_0)}\)</span>。最大似然估计是求参数 <spanclass="math inline">\(\theta\)</span>使似然函数最大。最大后验概率估计则是想求<spanclass="math inline">\(\theta\)</span>使<spanclass="math inline">\(P(x_0|\theta)\)</span>最大 。求得的<spanclass="math inline">\(\theta\)</span>不单单让似然函数大,<spanclass="math inline">\(\theta\)</span>自己出现的先验概率也得大。</p><p><img src="/img/机器学习/期末复习/最大后验分布.png" /></p><h2 id="第三章-优化方法简介">第三章 优化方法简介</h2><h3 id="梯度下降法">梯度下降法</h3><p>一种求解的最优化算法（无约束），主要解决求最小值问题，基本思想是下山，即不断逼近最优点的思想，通过求梯度的反方向，来确定错误面中的最低点的方向（有可能是局部最低点），从而不断逼近最小值。设损失函数为：<spanclass="math inline">\(J(\theta)=\frac{1}{2}[f(x)-y]^2\)</span>,则梯度下降为：<span class="math inline">\(\theta_{n+1} = \theta_{n} - \alphaJ&#39;(\theta)\)</span> 其中<spanclass="math inline">\(\alpha\)</span>为学习率。</p><h4 id="确定学习率的方法">确定学习率的方法</h4><ul><li>线性搜索法：<span class="math inline">\(\eta_t = argminf(x - \eta\Delta f(x))\)</span>,一般来说在实际中代价太高</li><li>线性回溯搜索算法：<span class="math inline">\(f(x-\eta \Delta f(x))\le f(x) - \alpha \eta ||\Delta f(x)||^2\)</span>,在实际中work well</li></ul><h4 id="应用梯度下降的不同形式">应用梯度下降的不同形式</h4><ul><li>批量梯度下降（BGD）：更新参数时使用所有样本进行更新，梯度更新比较耗时，但是会更准确朝极值方向更新，迭代次数少</li><li>随机梯度下降(SGD)：每步仅选取一个样本求梯度，梯度更新快，但下降时候波动大，更容易从一个局部最优跳到另一个局部最优，准确度下降。迭代次数多，可能不收敛，或陷入局部极值或鞍点。</li><li>小批量梯度下降(MBGD)：上面两个的折衷，每步采用固定一部分的样本计算梯度梯度更新比BGD快，迭代次数比SGD少。学习过程仍会有振荡，为更接近最小值，需要增加学习率衰减项，避免过度振荡。</li></ul><p><strong>使用建议</strong>：当训练集比较小时，批学习，采用拟牛顿或者共轭梯度下降；当训练集大时，随机梯度下降；当训练集介于其间时，小批量学习</p><h3 id="拉格朗日乘子法和kkt条件">拉格朗日乘子法和KKT条件</h3><p>梯度下降只能求解无约束问题，对于有约束问题，使用梯度下降法，很可能最小值点根本不在约束范围内，所以用拉格朗日乘子法。</p><h4 id="拉格朗日乘子法">拉格朗日乘子法</h4><p>求解有约束最小值问题（约束为等式）：</p><p><span class="math display">\[\min{f(x)} \\s.t.g(x) = 0\]</span></p><p>即在 <span class="math inline">\(g(x)=0\)</span>的条件下，求 <spanclass="math inline">\(f(x)\)</span>的最小值，引入一个自由变量 <spanclass="math inline">\(\lambda\)</span>,构造拉格朗日函数：</p><p><span class="math display">\[L(x,\lambda)=f(x) + \lambdag(x)\]</span></p><p>则新的方程又变成了无约束问题，对其中的 <spanclass="math inline">\(x,\lambda\)</span>求偏导，联立方程组使其等于0，则所得解就是原方程的解。</p><h4 id="kkt条件">KKT条件</h4><p>用于求解约束为不等式时候的约束问题，只是判断x是否为最优解的<strong>必要条件</strong>。和拉格朗日乘子法一样，引入自由变量，构造拉格朗日函数，设约束条件：</p><p><span class="math display">\[g(x)=0 \\ t(x)≤0\]</span></p><p>求解 <span class="math inline">\(\min f(x)\)</span>.</p><p>同理构造拉格朗日函数：</p><p><span class="math display">\[L(x,\lambda,\theta)=f(x) + \lambda g(x)+ \theta t(x)\]</span></p><p>则对应kkt条件有：</p><ul><li>L对x的偏导数为0；</li><li>g(x)=0;</li><li><span class="math inline">\(\theta t(x)=0\)</span>;</li><li><span class="math inline">\(\theta \ge 0\)</span>;</li></ul><p><img src="/img/机器学习/期末复习/KKT条件.jpg" /></p><h5 id="拉格朗日乘子法求解">拉格朗日乘子法求解</h5><p><img src="/img/机器学习/期末复习/拉格朗日乘子法求解.jpg" /></p><p><strong>总结：同时包含等式和不等式约束的一般优化问题</strong></p><h3 id="对偶">对偶</h3><p>在机器学习中，对偶（duality）是指将一个优化问题转化为其对偶形式，从而更容易地解决原始问题。具体来说，对于一个原始优化问题，通过构建一个拉格朗日函数，并对其进行最大化或最小化，可以得到对偶问题。通过解决对偶问题，我们可以获得原始问题的解。这种方法在解决某些优化问题时非常有用，因为对偶问题可能比原始问题更容易求解。</p><p>用<spanclass="math inline">\(p^*\)</span>表示原问题（最小化）的最优值；<spanclass="math inline">\(d^*\)</span>表示对偶问题（最大化）的最优值。</p><p><strong>弱对偶性</strong>：<span class="math inline">\(d^* \lep^*\)</span>。即使原问题不是凸优化，不等式也成立</p><p><strong>强对偶性</strong>：<span class="math inline">\(d^* =p^*\)</span></p><h4 id="为什么要研究对偶问题">为什么要研究对偶问题</h4><ul><li>虽然对偶方法并不能保证成功，但是它对于某些类别的函数有效，在这些情况下，它总能带来更简单的优化问题，特别是当原问题中自变量的维度比约束的数量大得多的情况下,</li><li>对偶函数总是凹函数，无论原问题如何。所以对偶函数的优化是个凸优化问题</li></ul><h3 id="牛顿法">牛顿法</h3><p>用目标函数的二阶泰勒展开近似该目标函数，通过求解这个二次函数的极小值来求解凸优化的搜索方向</p><h2 id="第四章-回归的线性模型">第四章 回归的线性模型</h2><h3 id="线性回归最小二乘法">线性回归最小二乘法</h3><p>回归就是一个输入连续输出连续的模型，比如 <spanclass="math inline">\(f(x) = \lambda x + \beta\)</span>,其中： <spanclass="math inline">\(\lambda\)</span>为要学习的参数， <spanclass="math inline">\(\beta\)</span>为偏置，过于简单不多说。</p><p><strong>最小二乘法标准</strong>：平方损失函数达到最小</p><p>对于上述一元线性回归模型来说，损失函数 <spanclass="math inline">\(J(\lambda,\beta)=(f(x_i)-y_i)^2\)</span>,使损失函数最小，便是求偏导=0，所以去算损失函数关于参数和偏置的偏导为0即可求解。</p><h3 id="岭回归">岭回归</h3><p>岭回归是一种特殊的线性回归方法，它在<strong>普通线性回归的基础上增加了一个L2正则化项</strong>。</p><p>普通线性回归的损失函数为：</p><p><span class="math display">\[J(\boldsymbol{\theta}) = \frac{1}{m}\sum_{i=1}^{m}{(\boldsymbol{\theta}^{\top}\boldsymbol{x}^{(i)} -y^{(i)})^2}\]</span></p><p>岭回归损失函数为：</p><p><span class="math display">\[J(\boldsymbol{\theta}) = \frac{1}{m}\sum_{i=1}^{m}{(\boldsymbol{\theta}^{\top}\boldsymbol{x}^{(i)} -y^{(i)})^2} + \alpha \sum_{j=1}^{n}{\theta_j^2}\]</span></p><p>其中， <spanclass="math inline">\(\alpha\)</span>是正则化强度的调节参数， <spanclass="math inline">\(\boldsymbol{\theta}\)</span>是回归系数向量， <spanclass="math inline">\(\boldsymbol{x}^{(i)}\)</span>是第 <spanclass="math inline">\(i\)</span>个样本的特征向量，<spanclass="math inline">\(y^{(i)}\)</span>是第 <spanclass="math inline">\(i\)</span>个样本的目标值(标签)， <spanclass="math inline">\(n\)</span>是特征数。</p><p>岭回归通过增加正则化项，使得回归系数更加稳定，从而防止过拟合。在L2正则化下，回归系数会被压缩到接近于0的数值，但不会变成0。因此，岭回归可以保留所有的特征，而不用像特征选择那样舍弃一些特征。</p><p>岭回归的求解方法与普通线性回归类似，只是在最小化损失函数时需要加上正则化项的贡献。最常用的方法是使用解析解：</p><p><span class="math display">\[\boldsymbol{\theta} =(\boldsymbol{X}^{\top}\boldsymbol{X} +\alpha\boldsymbol{I})^{-1}\boldsymbol{X}^{\top}\boldsymbol{y}\]</span></p><p>其中， <spanclass="math inline">\(\boldsymbol{X}\)</span>是样本特征矩阵， <spanclass="math inline">\(\boldsymbol{y}\)</span>是目标值向量， <spanclass="math inline">\(\boldsymbol{I}\)</span>是单位矩阵。</p><p>岭回归的一个关键问题是如何选择正则化强度参数 <spanclass="math inline">\(\alpha\)</span>。通常可以通过交叉验证来选择最佳的<span class="math inline">\(\alpha\)</span>值。</p><h3 id="lasso回归">Lasso回归</h3><p>Lasso回归是一种用于特征选择的线性回归模型，它的<strong>损失函数是平方损失加上L1正则化</strong>。L1正则化会让一部分特征的系数变为0，从而达到特征选择的目的。</p><p>Lasso回归的损失函数为：</p><p><span class="math display">\[J(\theta) = \frac{1}{2m} \sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2 + \alpha \sum_{j=1}^n|\theta_j|\]</span></p><p>其中，第一项是平方损失，第二项是L1正则化项， <spanclass="math inline">\(\alpha\)</span>是正则化参数。</p><p>Lasso回归的优化算法是坐标轴下降法，也称为坐标下降法。它的基本思想是，每次只更新一个参数的值，将其他参数的值固定住。</p><p>Lasso回归有一个重要的应用场景是特征选择。如果某个特征的系数为0，说明这个特征对目标变量没有太大的影响，可以将其从模型中剔除，从而简化模型并提高泛化性能。</p><h2 id="第五章-分类的线性模型">第五章 分类的线性模型</h2><h3 id="线性分类概念">线性分类概念</h3><p>线性分类是一种常见的机器学习技术，旨在将数据分成两个或多个类别。它的基本思想是在特征空间中找到一条直线、平面或超平面，将不同类别的数据分开。线性分类可以用于二元分类（将数据分成两个类别）和多元分类（将数据分成三个或更多类别）问题。</p><p><img src="/img/机器学习/期末复习/线性分类概念.jpg" /></p><p>在二元分类中，线性分类器会将数据点分为两个类别，通常用“+1”和“-1”表示。对于一个新的数据点，分类器会计算它与这条直线、平面或超平面之间的距离，并根据其距离的符号来预测其所属的类别。如果距离为正，则预测其属于正类；如果距离为负，则预测其属于负类。</p><p>线性分类器可以用很多不同的算法来训练。其中，最常用的算法是支持向量机（SVM）。SVM算法通过寻找最大间隔超平面来分割数据。这条超平面可以最大限度地扩大不同类别数据点之间的距离，从而提高分类器的性能。</p><p>除了SVM之外，还有其他的线性分类器算法，例如感知器（perceptron）和逻辑回归（logisticregression）。这些算法也可以用来解决线性分类问题，但它们的性能和训练速度可能会有所不同。</p><h3id="判别函数概率生成模型概率判别模型">判别函数、概率生成模型、概率判别模型</h3><h4 id="判别函数模型">判别函数模型</h4><p>判别函数模型通过学习一个判别函数来直接将输入映射到输出类别，它<strong>不需要生成训练样本的概率分布</strong>。判别函数模型通常适用于高维稠密数据，并且由于它只关注分类结果，而不是关注如何生成数据，因此在训练数据不太充分或噪声较大的情况下也能够有很好的表现。常见的判别函数模型包括支持向量机（SVM）和神经网络（NeuralNetwork）。</p><h4 id="概率生成模型">概率生成模型</h4><p>概率生成模型先对样本的概率分布进行建模，然后通过贝叶斯公式计算后验概率来进行分类或预测。概率生成模型适用于多类别分类或回归问题，并且能够较好地处理缺失数据和噪声。常见的概率生成模型包括朴素贝叶斯（NaiveBayes）和高斯混合模型（Gaussian Mixture Model）。</p><p>概率生成模型先对类条件密度<spanclass="math inline">\(p(x|C_k)\)</span>和先验类概率分布<spanclass="math inline">\(p(C_k)\)</span>建模然后再使⽤贝叶斯定理计算后验类概率分布<spanclass="math inline">\(p(C_k|x)\)</span>.最后，使⽤决策论来确定每个输⼊<spanclass="math inline">\(x\)</span>的类别等价地，直接对联合概率分布建模，再归一化得到后验概率。</p><p><img src="/img/机器学习/期末复习/概率生成模型.jpg" /></p><h4 id="概率判别模型">概率判别模型</h4><p>概率判别模型是通过直接对条件概率分布进行建模来预测输出。与概率生成模型不同，它不需要显式地建模输入的概率分布，而是直接估计类别条件概率。概率判别模型适用于多分类问题，其预测性能优于概率生成模型。常见的概率判别模型包括逻辑回归（LogisticRegression）和多层感知器（Multilayer Perceptron）。</p><p>概率判别模型直接对后验概率<spanclass="math inline">\(p(C_k|x)\)</span>建模,再使⽤决策论来确定每个新的输⼊<spanclass="math inline">\(x\)</span>的类别。</p><h3 id="逻辑回归">逻辑回归</h3><p>Logistic Regression虽然被称为回归，但其实际上是分类模型，并常用于二分类</p><p>逻辑回归是一种经典的机器学习算法，用于处理分类问题。它基于线性模型，将输入特征与输出标签之间的关系建模为一个sigmoid函数，并通过最大化似然函数来学习模型参数。在预测时，逻辑回归将输入特征传入模型，并通过sigmoid函数计算输出标签的概率值，从而得到最终的分类结果。</p><p>假设我们有一个二分类问题，样本集合为</p><p><spanclass="math display">\[D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}\]</span></p><p>其中 <span class="math inline">\(x_i\in R^m\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的 <spanclass="math inline">\(m\)</span>维输入特征向量, <spanclass="math inline">\(y_i\in\{0,1\}\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的标签。</p><p>逻辑回归的目标是学习一个函数 <spanclass="math inline">\(f(x)\)</span>，将输入特征 <spanclass="math inline">\(x\)</span>映射到一个 <spanclass="math inline">\([0,1]\)</span>之间的概率值，即：</p><p><span class="math display">\[P(Y=1|X=x)=\sigma(w^Tx+b)\]</span></p><p>其中, <spanclass="math inline">\(\sigma\)</span>是sigmoid函数，定义为：</p><p><spanclass="math display">\[\sigma(z)=\frac{1}{1+e^{-z}}\]</span></p><p>逻辑回归使用极大似然估计来学习模型参数 <spanclass="math inline">\(w\)</span>和 <spanclass="math inline">\(b\)</span>。</p><p>假设每个样本独立同分布地采样，根据贝叶斯定理，我们可以将样本的似然函数写为：</p><p><spanclass="math display">\[L(w,b)=\prod_{i=1}^nP(Y=y_i|X=x_i;w,b)\]</span></p><p>对数似然函数为：</p><p><span class="math display">\[\log L(w,b)=\sum_{i=1}^n\logP(Y=y_i|X=x_i;w,b)\]</span></p><p>我们的目标是最大化对数似然函数，可以通过梯度上升法来求解。具体来说，我们可以首先计算对数似然函数关于<span class="math inline">\(w\)</span>和 <spanclass="math inline">\(b\)</span>的梯度，然后更新模型参数，重复这个过程直到收敛。</p><p>在预测时，将输入特征 <spanclass="math inline">\(x\)</span>传入训练好的模型，计算 <spanclass="math inline">\(P(Y=1|X=x)\)</span>的值，若大于0.5则预测为正类，否则预测为负类。</p><h3 id="朴素贝叶斯分类器-1">朴素贝叶斯分类器</h3><p>朴素贝叶斯分类器是一种基于贝叶斯定理和特征条件独立假设的分类算法。它通常用于文本分类、垃圾邮件过滤、情感分析等自然语言处理任务。</p><p>假设我们有一个包含 <spanclass="math inline">\(n\)</span>个训练样本的数据集 <spanclass="math inline">\(D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}\)</span>，其中<spanclass="math inline">\(x_i=(x_{i1},x_{i2},\cdots,x_{im})\)</span>表示第<span class="math inline">\(i\)</span>个样本的 <spanclass="math inline">\(m\)</span>个特征， <spanclass="math inline">\(y_i\in\{c_1,c_2,\cdots,c_k\}\)</span>表示第 <spanclass="math inline">\(i\)</span>个样本的类别。</p><p>朴素贝叶斯分类器基于贝叶斯定理计算<strong>后验概率</strong> <spanclass="math inline">\(P(y|x)\)</span></p><p>即给定特征 <span class="math inline">\(x\)</span>下类别 <spanclass="math inline">\(y\)</span>的条件概率。根据贝叶斯定理，可以将 <spanclass="math inline">\(P(y|x)\)</span>表示为：</p><p><spanclass="math display">\[P(y|x)=\frac{P(x|y)P(y)}{P(x)}\]</span></p><p>其中， <span class="math inline">\(P(y)\)</span>是类别 <spanclass="math inline">\(y\)</span>的先验概率， <spanclass="math inline">\(P(x)\)</span>是特征 <spanclass="math inline">\(x\)</span>的边缘概率， <spanclass="math inline">\(P(x|y)\)</span>是在类别 <spanclass="math inline">\(y\)</span>下特征 <spanclass="math inline">\(x\)</span>的条件概率。在朴素贝叶斯分类器中，我们假设所有特征都是相互独立的，即：</p><p><span class="math display">\[P(x|y)=\prod_{i=1}^mP(x_i|y)\]</span></p><p>根据上述假设，朴素贝叶斯分类器将 <spanclass="math inline">\(P(y|x)\)</span>简化为：</p><p><span class="math display">\[P(y|x)=\frac{P(y)\prod_{i=1}^mP(x_i|y)}{P(x)}\]</span></p><p>由于 <spanclass="math inline">\(P(x)\)</span>是与类别无关的常量，因此可以忽略掉。于是我们只需要计算先验概率<span class="math inline">\(P(y)\)</span>和条件概率 <spanclass="math inline">\(P(x_i|y)\)</span>即可。</p><p>先验概率 <spanclass="math inline">\(P(y)\)</span>可以通过样本中每个类别出现的频率来估计。对于条件概率<spanclass="math inline">\(P(x_i|y)\)</span>，我们可以根据不同类型的特征进行不同的处理。</p><ul><li>对于离散型特征，我们可以直接计算每个取值出现的频率。</li><li>对于连续型特征，通常假设其服从正态分布，然后估计每个类别下的均值和方差。</li></ul><p>在预测时，我们将测试样本的特征代入上述公式，计算每个类别的后验概率，最终预测为概率最大的类别。</p><h2 id="第六章-支持向量机">第六章 支持向量机</h2><p>简单点讲，SVM就是一种二类分类模型，他的基本模型是的定义在特征空间上的<strong>间隔最大</strong>的线性分类器，SVM的学习策略就是间隔最大化。</p><p>对于支持向量机来说，数据点若是<spanclass="math inline">\(p\)</span>维向量，我们用<spanclass="math inline">\(p-1\)</span>维的超平面来分开这些点。但是可能有许多超平面可以把数据分类。最佳超平面的一个合理选择就是以最大间隔把两个类分开的超平面。因此，SVM选择能够使离超平面最近的数据点的到超平面距离最大的超平面。</p><p>以上介绍的SVM只能解决线性可分的问题，为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型:</p><ul><li><p>线性可分SVM</p><p>当训练数据线性可分时，通过硬间隔(hardmargin，什么是硬、软间隔下面会讲)最大化可以学习得到一个线性分类器，即硬间隔SVM</p></li><li><p>线性SVM</p><p>当训练数据不能线性可分但是可以近似线性可分时，通过软间隔(softmargin)最大化也可以学习到一个线性分类器，即软间隔SVM</p></li><li><p>非线性SVM</p></li></ul><p>当训练数据线性不可分时，通过使用核技巧(kerneltrick)和软间隔最大化，可以学习到一个非线性SVM</p><h3 id="个关键想法">3个关键想法</h3><ul><li>通过优化来求解一 个超平面分类器</li><li>寻找最大间隔分类器来提高模型 的 泛化能力（结构风险最小化）</li><li>采用核技巧使得在高维特征空间的计算更有效率</li></ul><h3 id="线性可分svm硬间隔">线性可分SVM——硬间隔</h3><p>考虑如下形式的线性可分的训练数据集:</p><p><span class="math display">\[(X_1, y_1),(X_2,y_2),...,(X_n,y_n)\]</span></p><p>其中<span class="math inline">\(X_i\)</span>是一个含有<spanclass="math inline">\(d\)</span>个元素的列向量, 即<spanclass="math inline">\(X_i \in R^d\)</span>;<spanclass="math inline">\(y_i\)</span>是标量,<span class="math inline">\(y\in +1, -1\)</span>,<spanclass="math inline">\(y+i=+1\)</span>时表示<spanclass="math inline">\(X_i\)</span>属于正类别,<spanclass="math inline">\(y_i=-1\)</span>时表示<spanclass="math inline">\(X_i\)</span>属于负类别。注：这里的<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(X_i\)</span>、<spanclass="math inline">\(W\)</span>都是列向量。</p><p>回忆一下感知机的目标:找到一个超平面使其能正确地将每个样本正确分类。感知机使用误分类最小的方法求得超平面，不过此时解有无穷多个。而线性可分支持向量机利用间隔最大化求最优分离超平面,这时解是唯一的。</p><p>一个超平面由法向量<span class="math inline">\(W\)</span>和截距<spanclass="math inline">\(b\)</span>决定,其方程为<spanclass="math inline">\(X^TW+b = 0\)</span>,可以规定法向量指向的一侧为正类,另一侧为负类。下图画出了三个平行的超平面，法方向取左上方向。</p><p><img src="/img/机器学习/期末复习/SVM硬间隔.png" /></p><p>为了找到最大间隔超平面，我们可以先选择分离两类数据的两个平行超平面，使得它们之间的距离尽可能大。在这两个超平面范围内的区域称为“间隔(margin)”，最大间隔超平面是位于它们正中间的超平面。这个过程如上图所示。</p><h4 id="间隔最大化">间隔最大化</h4><p>将高数里面求两条平行直线的距离公式推广到高维可求得上图中margin的<spanclass="math inline">\(\rho\)</span>:</p><p><span class="math display">\[margin = \rho =\frac{2}{||W||}\]</span></p><p>我们的目标是使<spanclass="math inline">\(\rho\)</span>最大，等价于使<spanclass="math inline">\(p^2\)</span>最大：</p><p><span class="math display">\[\max\limits_{W,b} \rho\Longleftrightarrow \max\limits_{W,b}\rho^2 \Longleftrightarrow\min\limits{W,b}\frac{1}{2}||W||^2 \tag{1}\]</span></p><p>上式的<spanclass="math inline">\(\frac{1}{2}\)</span>是为了后续求导后刚好能消去，没有其他特殊意义。</p><p>同时也不要忘了有一些约束条件:</p><p><span class="math display">\[X_i^tW+b\ge +1,y_i=+1 \\ X_i^tW+b\le-1,y_i=-1\]</span></p><p>总结一下，间隔最大化问题的数学表达就是</p><p><span class="math display">\[\begin{equation}\min\limits_{W,b} J(W)= \min\limits_{W,b}\frac{1}{2}||W||^2 \\s.t. \quad y_i(X_i^T+b) \ge 1, i = 1,2,...,n    \tag{2}\end{equation}\]</span></p><p>通过求解上式即可得到最优超平面<spanclass="math inline">\(\hat{W}\)</span>和<spanclass="math inline">\(\hat{b}\)</span>。</p><h4 id="支持向量">支持向量</h4><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离<strong>最近</strong>的数据点称为支持向量(supportvector)，支持向量是使<spanclass="math inline">\((2)\)</span>中的约束条件取等的点，即满足</p><p><span class="math display">\[y_i(X_i^TW+b)=1\]</span></p><p>的点。也即所有在直线<spanclass="math inline">\(X_i^TW+b=1\)</span>或直线<spanclass="math inline">\(X_i^TW+b=-1\)</span>的点。如下图所示:</p><p><img src="/img/机器学习/期末复习/支持向量.jpg" /></p><p><strong>在决定最佳超平面时只有支持向量起作用，而其他数据点并不起作用</strong>。如果移动非支持向量，甚至删除非支持向量都不会对最优超平面产生任何影响。也即支持向量对模型起着决定性的作用，这也是“支持向量机”名称的由来。</p><h4 id="对偶问题">对偶问题</h4><p>如何求解式<span class="math inline">\((2)\)</span>呢？</p><p>我们称式<spanclass="math inline">\((2)\)</span>所述问题为原始问题(primal problem),可以应用拉格朗日乘子法构造拉格朗日函数(Lagrangefunction)再通过求解其对偶问题(dualproblem)得到原始问题的最优解。转换为对偶问题来求解的原因是:</p><ul><li>对偶问题更易求解，由下文知对偶问题只需优化一个变量<spanclass="math inline">\(\alpha\)</span>且约束条件更简单；</li><li>能更加自然地引入核函数，进而推广到非线性问题。</li></ul><p>首先构建拉格朗日函数。为此需要引进拉格朗日乘子(Lagrangemultiplier),<span class="math inline">\(\alpha_i \ge0,i=1,2,...,n\)</span>。则拉格朗日函数为:</p><p><span class="math display">\[L(W,b,\alpha)=\frac{1}{2}||w||^2 -\sum\limits_{n}^{i=1}\alpha_i [y_i(X_i^TW+b)-1]\]</span></p><p>因此，给定一个<span class="math inline">\(W\)</span>和<spanclass="math inline">\(b\)</span>, 若满足式<spanclass="math inline">\((1)\)</span>的约束条件，那么有</p><p><spanclass="math display">\[\max\limits_{\alpha}L(W,b,\alpha)=J(W)=\frac{1}{2}||W||^2\]</span></p><p>则由上式可知，优化问题</p><p><span class="math display">\[\min\limits_{W,b}\max\limits_{\alpha}L(W,b,\alpha)\]</span></p><p>与式<span class="math inline">\((1)\)</span>所述问题完全等价。</p><p>根据拉格朗日对偶性，式<spanclass="math inline">\((1)\)</span>所述问题即原始问题的对偶问题是:</p><p><span class="math display">\[\max\limits_{\alpha} \min\limits_{W,b}L(W,b,\alpha)\]</span></p><p>为了求得对偶问题的解，需要先求得<spanclass="math inline">\(L(W,b,\alpha)\)</span>对<spanclass="math inline">\(W\)</span>和<spanclass="math inline">\(b\)</span>的极小再求对<spanclass="math inline">\(\alpha\)</span> 的极大。</p><ol type="1"><li>求<span class="math inline">\(\min\limits_{W,b}L(W,b,\alpha)\)</span>:对拉格朗日函数求导并令导数为0，有：</li></ol><p><span class="math display">\[\begin{equation}\nabla_W L(W, b, \alpha)=W-\sum_{i=1}^n \alpha_i y_i X_i=0\Longrightarrow W=\sum_{i=1}^n \alpha_i y_i X_i \tag{3}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation*}    \nabla_b L(W, b, \alpha)=-\sum_{i=1}^n \alpha_i y_i=0\Longrightarrow \sum_{i=1}^n \alpha_i y_i=0\end{equation*}\]</span></p><p>将上面两式代入<span class="math inline">\(L(W,b,\alpha)\)</span>:</p><p><span class="math display">\[\begin{aligned}&amp; L(\mathbf{w}, b,\boldsymbol{\alpha})=\frac{1}{2}\|\mathbf{w}\|^2-\sum_{i=1}^n\alpha_i\left[y_i\left(\mathbf{x}_i^T \mathbf{w}+b\right)-1\right] \\&amp; =\frac{1}{2} \sum_{i=1}^n \alpha_i y_i \mathbf{x}_i^T \sum_{j=1}^n\alpha_j y_j \mathbf{x}_j-\sum_{i=1}^n \alpha_i y_i \mathbf{x}_i^T\sum_{j=1}^n \alpha_j y_j \mathbf{x}_j-b \sum_{i=1}^n \alpha_iy_i+\sum_{i=1}^n \alpha_i \\&amp; =\sum_{i=1}^n \alpha_i-\frac{1}{2} \sum_{i=1}^n \alpha_i y_i\mathbf{x}_i^T \sum_{j=1}^n \alpha_j y_j \mathbf{x}_j=\sum_{i=1}^n\alpha_i-\frac{1}{2} \sum_{i, j=1}^n y_i y_j \alpha_{i} \alpha_j\mathbf{x}_i^T \mathbf{x}_{i=1}\end{aligned}\]</span></p><p>所以</p><p><span class="math display">\[\begin{equation}    \min _{W, b} L(W, b, \alpha)=-\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n\alpha_i \alpha_j y_i y_j X_i^T X_j+\sum_{i=1}^n \alpha_i \tag{4}\end{equation}\]</span></p><ol start="2" type="1"><li>求<spanclass="math inline">\(\min\limits{W,b}L(W,b,\alpha)\)</span>对<spanclass="math inline">\(\alpha\)</span>的极大：</li></ol><p>等价于式<span class="math inline">\((4)\)</span>对<spanclass="math inline">\(\alpha\)</span>求极大，也等价于式<spanclass="math inline">\((4)\)</span>取负数后对<spanclass="math inline">\(\alpha\)</span>求极小，即</p><p><span class="math display">\[\min _\alpha \frac{1}{2} \sum_{i=1}^n\sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j-\sum_{i=1}^n \alpha_i\tag{5}\]</span></p><p>同时满足约束条件：</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{i=1}^n \alpha_i y_i=0 \\&amp; \alpha_i \geq 0, i=1,2, \ldots, n\end{aligned} \tag{6}\]</span></p><p>至此，我们得到了原始最优化问题<spanclass="math inline">\((2)\)</span>和对偶最优化问题<spanclass="math inline">\((5)\)</span>、<spanclass="math inline">\((6)\)</span>。</p><p>因为原始优化问题的目标函数和不等式约束条件都是凸函数，并且该不等式约束是严格可行的(因为数据是线性可分的),所以存在<spanclass="math inline">\(\hat{W},\hat{b},\hat{\alpha}\)</span>，使得<spanclass="math inline">\(\hat{W},\hat{b}\)</span>是原始问题的解，<spanclass="math inline">\(\hat{\alpha}\)</span>是对偶问题的解。这意味着求解原始最优化问题<spanclass="math inline">\((2)\)</span>可以转换为求解对偶最优化问题<spanclass="math inline">\((5),(6)\)</span>。</p><p>那么如何求解优化问题<span class="math inline">\((5)\)</span>、<spanclass="math inline">\((6)\)</span>的最优解<spanclass="math inline">\(\hat{\alpha}\)</span>呢？不难发现这是一个二次规划问题，有现成的通用的算法来求解。</p><p>假设我们现在求得了<span class="math inline">\((4)\)</span>、<spanclass="math inline">\((5)\)</span>的最优解<spanclass="math inline">\(\hat{\alpha}\)</span>，则根据式<spanclass="math inline">\((4)\)</span>可求得最优<spanclass="math inline">\(\hat{W}\)</span>：</p><p><span class="math display">\[\hat{W}=\sum\limits_{i=1}^n\hat{\alpha}_i y_i X_i \tag{5}\]</span></p><p>因为至少存在一个<span class="math inline">\(\hat{\alpha}_j &gt;0\)</span>(若不存在，即<spanclass="math inline">\(\hat{\alpha}\)</span>全为0，则<spanclass="math inline">\(\hat{W}=0\)</span>, 即<spanclass="math inline">\(margin=\frac{2}{||W||} =\infty\)</span>,显然不行), 再根据KKT条件，即</p><p><span class="math display">\[\left\{\begin{array}{l}\text { 乘子非负 }: \alpha_i \geq 0(i=1,2, \ldots n . \text { 下同 }) \\\text { 约束条件 }: y_i\left(X_i^T W+b\right)-1 \geq 0 \\\text { 互补条件 }: \alpha_i\left(y_i\left(X_i^T W+b\right)-1\right)=0\end{array}\right.\]</span></p><p>所以至少存在一个<span class="math inline">\(j\)</span>,使<spanclass="math inline">\(y_j(X_T\hat{W}+\hat{b})-1=0\)</span>,即可求得最优<spanclass="math inline">\(\hat{b}\)</span>:</p><p><span class="math display">\[\begin{aligned}\hat{b} &amp; =\frac{1}{y_j}-X_j^T \hat{W} \\&amp; =y_j-X_j^T \hat{W} \\&amp; =y_j-\sum_{i=1}^n \hat{\alpha}_i y_i X_j^T X_i\end{aligned}   \tag{7}\]</span></p><p>至此，所以我们就求得了整个线性可分SVM的解。求得的分离超平面为:</p><p><span class="math display">\[\sum_{i=1}^n \hat{\alpha}_i y_i X^T X_i+\hat{b}=0\]</span></p><p>则分类的决策函数为</p><p><span class="math display">\[f(X)=\operatorname{sign}\left(\sum_{i=1}^n \hat{\alpha}_i y_i X^TX_i+\hat{b}\right)\]</span></p><p>再来分析KKT条件里的互补条件，对于任意样本<spanclass="math inline">\((X_i,y_i)\)</span>，总会有<spanclass="math inline">\(\alpha_i=0\)</span>或者<spanclass="math inline">\(y_if(X_i)=y_i(X^T_i\hat{W}+b)=1\)</span>。则有若<spanclass="math inline">\(\alpha_i=0\)</span>，此样本点不是支持向量，对模型没有任何作用；若<spanclass="math inline">\(\alpha_i &gt;0\)</span>，此样本点位于最大间隔边界上，是一个支持向量，如下图所示:</p><p><img src="/img/机器学习/期末复习/硬间隔-1.png" /></p><p>此外，当样本点是非支持向量时，因为<spanclass="math inline">\(\alpha_i=0\)</span>，所以SVM的解中的求和项中第<spanclass="math inline">\(i\)</span>项就为0，所以SVM的解<spanclass="math inline">\((6)\)</span>、<spanclass="math inline">\((7)\)</span>可简化为如下形式:</p><p><span class="math display">\[\hat{W}=\sum\limits_{i\in S V}\hat{\alpha}_{i}y_{i}X_{i}\\\hat{b}=y_{j}-\sum\limits_{i\in S V}\hat{\alpha}_{i}y_{i}X_{j}^{T}X_{i}\]</span></p><p>类似的，判别函数也可转换成如下形式:</p><p><span class="math display">\[f(X)=s i g n(\sum\limits_{i\in SV}\hat{\alpha}_{i}y_{i}X^{T}X_{i}+\hat{b})\]</span></p><p>所以，整个SVM的解只与支持向量SV有关，与非支持向量无关。</p><h3 id="线性svm软间隔">线性SVM——软间隔</h3><p>上述<strong>硬间隔</strong>是完全分类准确，其损失函数不存在；其损失值为0；只要找出两个异类正中间的那个平面，而<strong>软间隔</strong>允许一定量的样本分类错误，即允许少量样本不满足约束</p><p><span class="math display">\[y_{i}(X_{i}^{T}W+b)\geq1\]</span></p><p>为了使不满足上述条件的样本点尽可能少，我们需要在优化的目标函数<spanclass="math inline">\((1)\)</span>里面新增一个对这些点的惩罚项。最常用的是hinge损失:</p><p><span class="math display">\[l_{h i n g e}(z)=m ax(\mathsf{0,1-z})\]</span></p><p>即若样本点满足约束条件损失就是0, 否则损失就是,则优化目标<spanclass="math inline">\(（1）\)</span>变成</p><p><span class="math display">\[\begin{equation}\min\limits_{W,b} \frac{1}{2}||W||^2 + C\sum\limits_{i=1}^n \max{(0, 1 -u_i(X_i^TW + b))}  \tag{8}\end{equation}\]</span></p><p>其中<span class="math inline">\(C&gt;0\)</span>称为惩罚参数，<spanclass="math inline">\(C\)</span>越小时对误分类惩罚越小，越大时对误分类惩罚越大，当<spanclass="math inline">\(C\)</span>取正无穷时就变成了硬间隔优化。实际应用时我们要合理选取<spanclass="math inline">\(C\)</span>,<spanclass="math inline">\(C\)</span>越小越容易欠拟合，<spanclass="math inline">\(C\)</span>越大越容易过拟合。</p><p>如果我们引入“松弛变量”<span class="math inline">\(\xi_i \ge0\)</span>, 那么式<span class="math inline">\((8)\)</span>可重写成</p><p><span class="math display">\[\min\limits_{W,b,\xi}{\frac{1}{2}||W||^{2}+C\sum\limits_{i=1}^{n}\xi_{i}} \\ s.t. \quady_i(X_i^TW+b) \ge 1 - \xi_i \\ \xi_i \ge 0, i = 1,2,...,n\]</span></p><p>上式所述问题即软间隔支持向量机。</p><p>而其对偶问题与硬间隔同理。</p><h3 id="非线性svm核技巧">非线性SVM——核技巧</h3><p>首先回顾前面的线性SVM的优化目标</p><p><span class="math display">\[\min _\alpha \frac{1}{2} \sum_{i=1}^n\sum_{j=1}^n \alpha_i \alpha_j y_i y_j X_i^T X_j-\sum_{i=1}^n\alpha_i\]</span></p><p>以及约束条件</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{i=1}^n \alpha_i y_i=0 \\&amp; \alpha_i \geq 0, i=1,2, \ldots, n\end{aligned}\]</span></p><p>前面介绍的都是线性问题，但是我们经常会遇到非线性的问题(例如异或问题)，此时就需要用到核技巧(kerneltrick)将线性支持向量机推广到非线性支持向量机。如果样本在特征空间内线性不可分，则需要利用核函数将其映射到高维空间中，让其在高维空间中线性可分。根据SVM基础形式的求解，我们可能会想到下面的方式：</p><p><span class="math display">\[f(\boldsymbol X)=\sum_{i=1}^{N} w_i\phi_i(\boldsymbol X)+b\]</span></p><p>这里的<spanclass="math inline">\(\phi_i()\)</span>就是从输入的特征空间到某个更高维的特征空间的映射，这就意味着建议了非线性的学习器分为两步：</p><ul><li>使用一个变换将原空间的数据映射到新空间(例如更高维甚至无穷维的空间)；</li><li>然后在新空间里用线性方法从训练数据中学习得到模型。</li></ul><p>这种基本型的求解是非常难的，因为这个映射函数是非常难以寻找和求解的！（据说NP难），而了解了SVM的对偶形式给了另一种求解思路：</p><p><span class="math display">\[f(\boldsymbol X)=\sum_{i=1}^{l} \alpha_iy_i \left \langle \boldsymbol \phi_i(\boldsymbol X_i) \cdot \boldsymbol\phi(\boldsymbol X) \right \rangle + b\]</span></p><p>注意到，我们在求解的时候需要计算<spanclass="math inline">\(ϕi(X_i)⋅ϕ(X)\)</span>，也就是映射后的两个样本的高维特征的内积形式，如果有一种方法可以在特征空间中直接计算这个东西，是不是就很方便了？对的，核函数就是做这个的：</p><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i) =\boldsymbol \phi(\boldsymbol X) \cdot \boldsymbol \phi(\boldsymbolX_i)\]</span></p><p>那么现在的优化目标就变为</p><p><span class="math display">\[\min\limits_{\alpha}\frac{1}{2}\sum_{i=1}^{n}\sum_{j=1}^{n}\alpha_{i}\alpha_{j}y_{i}y_{j}K(X_{i},X_{j})\;-\;\sum_{i=1}^{n}\alpha_{i}\\s.t.\,\,\,\,\sum_{i=1}^{n}\alpha_{i}y_{i}=0 \\0\leq\alpha_{i}\leq C,i=1,2,\cdot\cdot,n.\]</span></p><p>上述的思想就是SVM核函数的核心思想。</p><h4 id="多项式核函数">多项式核函数</h4><p>对于一个多项式核函数</p><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i) = [(X\cdot X_i) + c]^q\]</span></p><p>可以得到q阶多项式分类器</p><h4 id="高斯径向基核rbf">高斯径向基核RBF</h4><p><span class="math display">\[K(\boldsymbol X, \boldsymbol X_i)=  exp(-\frac{|X-X_i|^2}{\sigma^2})\]</span></p><p>每个基函数中心对应一个支持向量，它们及输出权值由算法自动确定。</p><h4 id="sigmod核">Sigmod核</h4><p><span class="math display">\[K(X, X_i)=tanh(\nu(X,X_)+c)\]</span></p><p>包含一个隐层的多层感知器，隐层节点数是由算法自动确定。</p><p>注：上述SVM内容转载于<ahref="https://zhuanlan.zhihu.com/p/49331510">看了这篇文章你还不懂SVM你就来打我</a></p><h2 id="第七章-混合模型与期望最大">第七章 混合模型与期望最大</h2><p><strong>聚类基本思想</strong>：将相似的实例分组在一起。聚类结果在很大程度上取决于待聚类点之间的相似性（或距离）度量</p><p><strong>聚类算法</strong></p><ul><li>原型聚类：如K均值算法、高斯混合模型</li><li>密度聚类：如DBSCAN算法、Mean-Shift 算法</li><li>层次聚类：如Agglomerative 算法、Divisive算法、BIRCH 算法</li><li>谱聚类</li></ul><h3 id="k-means-聚类">K-means 聚类</h3><p>K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p><p>如果用数据表达式表示，假设簇划分为<spanclass="math inline">\((C_1,C_2,...C_k)\)</span>，则我们的目标是最小化平方误差<spanclass="math inline">\(E\)</span>：</p><p><span class="math display">\[E = \sum\limits_{i=1}^k\sum\limits_{x\in C_i} ||x-\mu_i||_2^2\]</span></p><p>其中<span class="math inline">\(μ_i\)</span>是簇<spanclass="math inline">\(C_i\)</span>的均值向量，有时也称为质心，表达式为：</p><p><span class="math display">\[\mu_i = \frac{1}{|C_i|}\sum\limits_{x\in C_i}x\]</span></p><p>如果我们想直接求上式的最小值并不容易，这是一个NP难的问题，因此只能采用启发式的迭代方法。</p><p>K-Means采用的启发式方式很简单，用下面一组图就可以形象的描述。</p><p><img src="/img/机器学习/期末复习/kmeans过程.png" /></p><p>K-Means的算法步骤为:</p><ol type="1"><li>选择初始化的 k 个样本作为初始聚类中心<spanclass="math inline">\(a=a_1,a_2,...,a_k\)</span></li><li>针对数据集中每个样本<span class="math inline">\(x_i\)</span>计算它到<span class="math inline">\(k\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；</li><li>针对每个类别 <spanclass="math inline">\(a_j\)</span>，重新计算它的聚类中心<spanclass="math inline">\(a_{j}=\frac{1}{|c_{i}|}\sum\limits_{x\inc_{i}}x\)</span>（即属于该类的所有样本的质心）;</li><li>重复上面 2 3两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。</li></ol><h3 id="高斯混合模型gmm">高斯混合模型（GMM）</h3><p>高斯混合模型（Gaussian MixedModel）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布）。</p><!-- ![](/img/机器学习/期末复习/GMM.jpg) --><p><span class="math display">\[p(\alpha)=\sum_{k=1}^{K}\pi_{k}\mathcal{N}(x \mid\mu_{k},\Sigma_{k})\]</span></p><p>其中<span class="math inline">\(\mathcal{N}(x\mid\mu_{k},\Sigma_{k})\)</span>称为混合模型中的第<spanclass="math inline">\(k\)</span>个分量（component）。混合系数<spanclass="math inline">\(\pi_k\)</span>满足<spanclass="math inline">\(\sum\limits^{K}_{k=1}\pi_k =1 \quad0\le \pi \le1\)</span>。可以认为<spanclass="math inline">\(\pi_k\)</span>就是每个分量<spanclass="math inline">\(\mathcal{N}(x | \mu_k,\Sigma_k)\)</span>的权重。</p><h3 id="em算法">EM算法</h3><p>EM 算法，全称 Expectation MaximizationAlgorithm。期望最大算法是一种迭代算法，用于含有隐变量（HiddenVariable）的概率参数模型的最大似然估计或极大后验概率估计。</p><h4 id="em算法思想">EM算法思想</h4><p>EM 算法的核心思想非常简单，分为两步：Expection-Step 和Maximization-Step。</p><ul><li>E-Step主要通过观察数据和现有模型来估计参数，然后用这个估计的参数值来计算似然函数的期望值；</li><li>而 M-Step是寻找似然函数最大化时对应的参数。由于算法会保证在每次迭代之后似然函数都会增加，所以函数最终会收敛。</li></ul><p>EM算法例子的执行过程<ahref="https://www.jianshu.com/p/1121509ac1dc">如何感性地理解EM算法？</a></p><p>事实上隐变量估计也可以通过梯度下降等优化方法求解，但由于求和的项数将随着隐变量的数目以指数级别上升，会给梯度计算带来麻烦；而EM算法可以看作一种非梯度优化方法。</p><h2 id="第八章-高斯过程">第八章 高斯过程</h2><p>高斯过程 Gaussian Processes是概率论和数理统计中随机过程的一种，是多元高斯分布的扩展，被应用于机器学习、信号处理等领域。本文对高斯过程进行公式推导、原理阐述、可视化以及代码实现，介绍了以高斯过程为基础的高斯过程回归Gaussian Process Regression 基本原理、超参优化、高维输入等问题。</p><p><a href="https://zhuanlan.zhihu.com/p/75589452">高斯过程 GaussianProcesses 原理、可视化及代码实现</a></p><h2 id="第九章-集成学习">第九章 集成学习</h2><h3 id="bagging">Bagging</h3><p>Bagging（装袋算法）的集成学习方法非常简单，假设我们有一个数据集<spanclass="math inline">\(D\)</span>，使用Bootstrapsample（有放回的随机采样，这里说明一下，有放回抽样是抽一个就放回一个，然后再抽，而不是这个人抽<spanclass="math inline">\(10\)</span>个，再放回，下一个继续抽，它是每一个样本被抽中概率符合均匀分布）的方法取了<spanclass="math inline">\(k\)</span>个数据子集（子集样本数都相等）：<spanclass="math inline">\(D_1，D_2，…，D_k\)</span>，作为新的训练集，我们使用这<spanclass="math inline">\(k\)</span>个子集分别训练一个分类器（使用分类、回归等算法），最后会得到<spanclass="math inline">\(k\)</span>个分类模型。我们将测试数据输入到这<spanclass="math inline">\(k\)</span>个分类器，会得到<spanclass="math inline">\(k\)</span>个分类结果，比如分类结果是<spanclass="math inline">\(0\)</span>和<spanclass="math inline">\(1\)</span>，那么这<spanclass="math inline">\(k\)</span>个结果中谁占比最多，那么预测结果就是谁。</p><p><strong>算法流程</strong>：</p><ul><li>从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</li><li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知机等）</li><li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</li></ul><p><strong>特点</strong>：</p><ul><li>关于bagging所采用的抽样方式为有放回抽样，抽样的样本数量等于总体样本数量；</li><li>由于某些样本在有放回的情况下不止被抽到一次，有些样本一次也不会被抽到；</li><li>可以并行产生所需要的样本子集个数以及并行训练子模型</li><li>对于二分类问题，一般选取样本子集个数为奇数（避免出现两个类别投票数相同）</li></ul><h3 id="adaboost">AdaBoost</h3><p><strong>Boosting</strong>指的是一类集成方法，其主要思想就是将弱的基学习器提升(boost)为强学习器。具体步骤如下:</p><ol type="1"><li>先用每个样本权重相等的训练集训练一个初始的基学习器；</li><li>根据上轮得到的学习器对训练集的预测表现情况调整训练集中的样本权重(例如提高被错分类的样本的权重使之在下轮训练中得到更多的关注),然后据此训练一个新的基学习器；</li><li>重复2直到得到<spanclass="math inline">\(M\)</span>个基学习器，最终的集成结果是<spanclass="math inline">\(M\)</span>个基学习器的组合。</li></ol><p><strong>Boosting算法簇中最著名的就是AdaBoost</strong>。</p><h4 id="基本思想">基本思想</h4><p>对于上述的Boosting算法步骤，需要回答两个问题:</p><ol type="1"><li>如何调整每一轮的训练集中的样本权重？</li><li>如何将得到的[公式]个组合成最终的学习器？</li></ol><p>AdaBoost(Adaptive Boosting, 自适应增强)算法采取的方法是:</p><ol type="1"><li><strong>提高上一轮被错误分类的样本的权值，降低被正确分类的样本的权值</strong>；</li><li><strong>线性加权求和</strong>。误差率小的基学习器拥有较大的权值，误差率大的基学习器拥有较小的权值。</li></ol><p>AdaBoost算法的流程如下：</p><p>输入：训练数据集<spanclass="math inline">\(T={(x1,y1),(x2,y2),(xN,yN)}\)</span>，其中，<spanclass="math inline">\(xi∈X⊆R^n\)</span>，<spanclass="math inline">\(yi∈Y=−1,1\)</span>，迭代次数<spanclass="math inline">\(M\)</span></p><ol type="1"><li><p>初始化训练样本的权值分布: <spanclass="math display">\[D_1=(w_{1,1},w_{1,2},…,w_{1,i}),w_{1,i}=\frac{1}{N},i=1,2,…,N\]</span></p></li><li><p>对于<span class="math inline">\(m=1,2,…,M\)</span></p><ol type="1"><li><p>使用具有权值分布<spanclass="math inline">\(D_m\)</span>的训练数据集进行学习，得到弱分类器<spanclass="math inline">\(Gm(x)\)</span></p></li><li><p>计算<spanclass="math inline">\(Gm(x)\)</span>在训练数据集上的分类误差率: <spanclass="math display">\[e_m=\sum_{i=1}^Nw_{m,i}  I(G_m (x_i )≠y_i)\]</span></p></li><li><p>计算<spanclass="math inline">\(Gm(x)\)</span>在强分类器中所占的权重： <spanclass="math display">\[α_m=\frac{1}{2}log\frac{1-e_m}{e_m}\]</span></p></li><li><p>更新训练数据集的权值分布（这里，<spanclass="math inline">\(z_m\)</span>是归一化因子，为了使样本的概率分布和为<spanclass="math inline">\(1\)</span>）：</p></li></ol><p><span class="math display">\[w_{m+1,i}=\frac{w_{m,i}}{z_m}exp⁡(-α_my_i G_m (x_i ))，i=1,2,…,10\]</span></p><p><span class="math display">\[z_m=\sum_{i=1}^Nw_{m,i}exp⁡(-α_m y_i G_m(x_i ))\]</span></p></li><li><p>得到最终分类器:</p><p><span class="math display">\[F(x)=sign(\sum_{i=1}^Nα_m G_m(x))\]</span></p></li></ol><h3 id="bagging和boosting的区别">Bagging和Boosting的区别</h3><ol type="1"><li>样本选择上</li></ol><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p><ol start="2" type="1"><li>样例权重</li></ol><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p><ol start="3" type="1"><li>预测函数</li></ol><p>Bagging：所有预测函数的权重相等。</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p><ol start="4" type="1"><li>并行计算</li></ol><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p><h2 id="第十章-半监督学习">第十章 半监督学习</h2><h3 id="基于图的半监督学习">基于图的半监督学习</h3><h4 id="图的概念">图的概念</h4><p>我们首先来看看如何从训练数据中构建出图，给定半监督数据集<spanclass="math inline">\(\{(𝑥_𝑖,𝑦_𝑖 )\}_{𝑖=1}^𝑙\)</span>和<spanclass="math inline">\(\{𝑥_𝑗\}_{𝑗=𝑙+1}^{𝑙+𝑢}\)</span>，每个数据样本（有标签&amp;无标签）是图上的一个顶点，显然，图会非常大，因为无标签数据很多，一旦图构建完成，学习的过程就包括给图中的每一个定点设置标签y值。在图中可以通过边将有标签和无标签数据点相连，边通常是无向的，表示的是两个节点（样本）之间的相似性。将边权重记作<spanclass="math inline">\(w_{ij}\)</span>，<spanclass="math inline">\(w_{ij}\)</span>越大，<spanclass="math inline">\(x_i\)</span>和<spanclass="math inline">\(x_j\)</span>越相似，两者的标签越可能相同。所以边权重非常重要，人们常常将边的权值定义为如下形式：</p><ul><li>全连接图：</li></ul><p>每一对定点之间都有边相连，边的权重随欧式距离<spanclass="math inline">\(||x_i-x_j||\)</span>的增加而降低，常用的权重方程如下：</p><p><span class="math display">\[w_{ij}=\exp(-\frac{||x_i-x_j||^2}{2\sigma^2})\]</span></p><p><spanclass="math inline">\(σ\)</span>叫做带宽参数用来控制权重衰减的速度。这个权重方程和高斯方程的形式相同，也叫做高斯核或者径向基函数；</p><ul><li>KNN图：</li></ul><p>每一个定点定义它的欧式距离上的最近邻，注意，如果<spanclass="math inline">\(x_i\)</span>在<spanclass="math inline">\(x_j\)</span>的<spanclass="math inline">\(k\)</span>近邻内，<spanclass="math inline">\(x_j\)</span>不一定在<spanclass="math inline">\(x_i\)</span>的<spanclass="math inline">\(k\)</span>近邻内，如果<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_j\)</span>中有一个在对方的<spanclass="math inline">\(k\)</span>近邻内我们就用边将它们连接，这就意味着一个定点可能会有超过<spanclass="math inline">\(k\)</span>条边，如果<spanclass="math inline">\(x_i,x_j\)</span>有边相连，边的权重<spanclass="math inline">\(w_{ij}\)</span>就是<spanclass="math inline">\(1\)</span>，否则为<spanclass="math inline">\(0\)</span>。KNN图可以自适应地适应样本在特征空间的密度（密集区KNN范围的半径小）；</p><ul><li><span class="math inline">\(ε\)</span>NN图：</li></ul><p>将距离小于<span class="math inline">\(ε\)</span>的顶点连一条边。</p><h4 id="mincut">MINCUT</h4><p>我们将带有正标签的样本作为源点（就好像流从这里出发流经边），相似的，负标签样本作为终点（流消失的点），目标是找到一个最小的边集，使得删除这些边可以阻止所有从源点到终点的流，我们定义这样的一组边集叫做“cut”，割的大小用这些边的权重和来定义。一旦图被“割”开，与源点相连的点都被标记为正，反之为负。也就是说，我们想要找到这样的一个作用在顶点上的函数<spanclass="math inline">\(f(x)\in\{0,1\}\)</span>用来标记x的标签，使得对于有标签样本来说<spanclass="math inline">\(f(x_i)=y_i\)</span>，而且cut最小:</p><p><span class="math display">\[\sum_{i,j\geq f(x_{i})\neq f(x_{j})}w_{ij}\]</span></p><p>我们将最小割问题形式化为正则化风险最小化问题（合适的损失函数和正则化器）。对任何有标签的顶点<spanclass="math inline">\(x_i\)</span>，<spanclass="math inline">\(f(x_i)\)</span>就是<spanclass="math inline">\(x_i\)</span>对应的标签<spanclass="math inline">\(y_i\)</span>，可以用这样一个损失函数来表示：<spanclass="math inline">\(c(\mathbf{x},\mathbf{y},f(\mathbf{x}))=\infty\cdot(\mathbf{y}-f(\mathbf{x}))^{2}\)</span>,而正则化项则对应cut的大小，考虑到所有无标签样本的类别非负即正，cut的大小可以重写为<spanclass="math inline">\(\Omega(f)=\sum\limits_{i,\,i=1}^{i=n}w_{ij}(f(\mathbf{x}_{i})-f(\mathbf{x}_{j}))^{2}/4\)</span>。注意，当前的和是针对所有点对的，如果<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_j\)</span>不相连，<spanclass="math inline">\(w_{ij}=0\)</span>。那么最小割的正则化风险最小化问题可以写作</p><p><span class="math display">\[\min\limits_{f:f(x) \in \{-1,1\}} \infty\sum_{i=1}^{l}(y_{i}-f(\mathbf{x}_{i}))^{2}+\sum_{i,j=1}^{l+u}w_{ij}(f(\mathbf{x}_{i})-f(\mathbf{x}_{j}))^{2}\]</span></p><p>这是一个整数规划问题，因此，最小割问题可以有许多多项式时间算法可以解决。这种形式的最小割问题可能存在多个最优解，比如下图有两个带标签点一正一负，每条边有相同的权重，有6种最小割解决方案（移除任意一条边即可）。</p><h4 id="调和函数harmonic-function">调和函数（HARMONIC FUNCTION）</h4><p>对于有标签数据，调和函数的值为标签值；对于无标签数据，标签值是其邻居顶点标签值的权重平均</p><p><span class="math display">\[\begin{array}{r cl}{f(\mathbf{x}_{i})}&amp;{=}&amp;{y_{i},}&amp;{i=1,\cdot\cdot,l}\end{array}\]</span></p><p><span class="math display">\[f(x_j) = \frac{\sum\limits_{k=1}^{l+u}w_{jk}f(x_k)}{\sum\limits_{k=1}^{l+u} w_{jk}}, j =l+1,\cdots,l+u\]</span></p><p>然后把它代入上面提到过的目标函数，并松弛<spanclass="math inline">\(f\)</span>使它的值域为实数：</p><p><span class="math display">\[\min\limits_{f:f(x)\in\mathbb{R}} \infty\sum\limits_{i=1}^{l}(y_{i}-f({\bfx}_{i}))^{2}+\sum\limits_{i=1}^{l+u}w_{i j}(f({\bf x}_{i})-f({\bfx}_{j}))^{2}\]</span></p><p>相当于求解：</p><p><spanclass="math display">\[\min\limits_{f:f(x)\in\mathbb{R}}\sum\limits_{i=1}^{l+u}w_{ij}(f({\bf x}_{i})-f({\bf x}_{j}))^{2}\]</span></p><p>对<span class="math inline">\(f\)</span>进行松弛使得<spanclass="math inline">\(f\)</span>有一个闭式解，也就是说上述目标方程有全局最优解，缺点是<spanclass="math inline">\(f(x)\)</span>现在是一个<spanclass="math inline">\([0,1]\)</span>的实数，并不能直接作为一个标签。这可以通过设定阈值进行处理（如，若<spanclass="math inline">\(f(x)&gt;=0.5\)</span>，预测标签<spanclass="math inline">\(y=1\)</span>，否则为<spanclass="math inline">\(0\)</span>）.</p><p>调和函数有许多有趣的解释，比如，将图看作一张电网，每一条边的电阻为<spanclass="math inline">\(1/w_{ij}\)</span>，有标签的点连接到<spanclass="math inline">\(1v\)</span>的电池，正标签顶点连接电池正极，零标签顶点连接电池负极，每个节点两端的电压就是调和函数值，如下图所示：</p><p><img src="/img/机器学习/期末复习/调和函数电网解释.png" /></p><p>也可以解释为图上的随机游走，想象一个粒子在顶点<spanclass="math inline">\(i\)</span>上，那么这个粒子会随机走到下一个顶点<spanclass="math inline">\(j\)</span>的概率是，随机游走以这种方式继续，直到粒子到达一个有标记的顶点。那么顶点<spanclass="math inline">\(i\)</span>的调和函数值<spanclass="math inline">\(f(x_i)\)</span>就是粒子从<spanclass="math inline">\(i\)</span>顶点出发最终走到一个正标签的顶点的概率，如下图所示：</p><p><img src="/img/机器学习/期末复习/调和函数随机游走解释.png" /></p><h5 id="调和函数的求解">调和函数的求解</h5><p>求解调和函数的过程是迭代的，初始的，我们设定：对于有标签顶点，<spanclass="math inline">\(f(x_i)=y_i\)</span>，对于无标签顶点，<spanclass="math inline">\(f\)</span>为任意值。每一轮迭代都用无标签顶点邻居的权重平均更新该无标签顶点的标签值：</p><p><spanclass="math display">\[f(\mathbf{x}_{i})={\frac{\sum\limits_{j=1}^{l+u}w_{ij}f(\mathbf{x}_{j})}{\sum\limits_{j=1}^{l+u}w_{i j}}}\]</span></p><h4 id="半监督支持向量机s3vmstsvms">半监督支持向量机(S3VMs/TSVMs)</h4><p>Semi-Supervised Support VectorMachines(S3VMs)最初被称为直推式支持向量机(Transductive Support VectorMachines(TSVMs))，因为它的理论是为了给无标记样本提供性能界限(理论保证)。但是由于学习到的函数<spanclass="math inline">\(f\)</span>应用到了无标记的样本中，所以被称为半监督支持向量机S3VMs。</p><p>对于S3VMs的直观理解是使得有标记和无标记样本处于间隔边界之外。但是，对于无标记样本，我们无法得知其是否处于处于正确的分类。这里给出一种方法将无标记样本用到学习中。</p><p>对于样本<span class="math inline">\(x\)</span>,它的预测值<spanclass="math inline">\(\hat{y} =sign(f(x))\)</span>，将该预测值假定为该样本的真实标签，则<spanclass="math inline">\(x\)</span>的hinge损失函数为</p><p><span class="math display">\[\begin{align}c(x, \hat{y}, f(x)) &amp; = \max(1-\hat{y}(w^Tx+b), 0) \\&amp; = \max(1-sign(w^Tx+b)(w^Tx+b), 0) \\&amp; = \max(1- |w^Tx+b|, 0)\end{align}\]</span></p><p>该损失函数与hinge损失的不同之处在于它不需要样本真实的标签，而是由<spanclass="math inline">\(f(x)\)</span>替代。该损失函数由上图中的右图所示。基于该损失函数的图形的形状，将其命名为hatloss。</p><p>虽然假设预测的分类结果都是正确的，但是基于hatloss，有些样本还是会存在惩罚。对于<span class="math inline">\(f(x) \le-1\)</span>或<span class="math inline">\(f(x) \ge1\)</span>的样本，它们处在间隔边界之外，远离决策边界，是不存在惩罚的。但是对于<spanclass="math inline">\(-1 \le f(x) \le 1\)</span>的样本，尤其是<spanclass="math inline">\(f(x) \approx0\)</span>的样本，它们在决策边界内，对于预测值<spanclass="math inline">\(f(x)\)</span>是存在不确定性的，所以存在惩罚。</p><p>将无标记样本<spanclass="math inline">\(\{x_j\}_{j=l+1}^{l+u}\)</span>的hatloss加到SVM的损失函数中，定义S3VMs的损失函数</p><p><span class="math display">\[\min_{w,b} \sum_{i=1}^{l} \max(1 -y_i(w^Tx_i+b), 0) + \lambda_1 ||w||^2  + \lambda_2\sum_{j=l+1}^{l+u}\max(1 - |w^Tx_i+b|, 0)\]</span></p><p>由上式可以看出，S3VMs更希望无标记数据能够在决策边界的外边，也就是决策边界更希望出现在数据的低密度区域。此时，可以将hatloss看做正则化项</p><p><span class="math display">\[\Omega(f) = \lambda_1 ||w||^2  +\lambda_2\sum_{j=l+1}^{l+u} \max(1 - |w^Tx_i+b|, 0)\]</span></p><p>注意，有些时候，无标记数据的预测值只存在一个类，也就是无标记数据都被预测成了同一个类。为了纠正这种不平衡性，一种直接的想法就是限制预测值中各个类的比例。假设无标记数据的预测值中各个类的比例与有标记数据中各个类的比例相同，即</p><p><span class="math display">\[\frac{1}{u}\sum_{j=l+1}^{l+u} \hat{y}_j= \frac{1}{l}\sum_{i=1}^{l} y_i\]</span></p><p>因为<span class="math inline">\(\hat{y}_j =sign(f(x_j))\)</span>不是一个连续函数，所以很难满足上述约束条件。因此放松该约束条件为</p><p><span class="math display">\[\frac{1}{u}\sum_{j=l+1}^{l+u} f(x_j) =\frac{1}{l}\sum_{i=1}^{l} y_i\]</span></p><p>该约束被称为类别的平衡约束。</p><p>所以，带类别平衡约束的S3VMs可以表示为</p><p><span class="math display">\[\begin{align}\min_{w,b}  &amp;  \sum_{i=1}^{l} \max(1 - y_i(w^Tx_i+b), 0) + \lambda_1||w||^2  + \lambda_2\sum_{j=l+1}^{l+u} \max(1 - |w^Tx_i+b|, 0)    \\s.t. &amp; \frac{1}{u}\sum_{j=l+1}^{l+u} f(x_j) =\frac{1}{l}\sum_{i=1}^{l} y_i  \tag{4}\end{align}\]</span></p><p>S3VMs的解是很难计算的，因为它的目标函数是<strong>非凸</strong>的。</p><p>上述S3VMs部分转载自<ahref="https://blog.csdn.net/extremebingo/article/details/79020907">Semi-SupervisedSupport Vector Machines(S3VMs)</a></p><h2 id="第十二章-强化学习">第十二章 强化学习</h2><p>强化学习（Reinforcement Learning, 简称RL）是机器学习的范式和方法论之一，用于描述和解决智能体（Agent）在与环境（Environment）的交互过程中通过学习策略（Policy）以达成奖励或回报（Reward）最大化或实现特定目标的问题。</p><p>强化学习主要涉及<strong>无模型（Model-Free）</strong>和<strong>有模型（Model-based）</strong>两大类算法。Model-Free算法可分为<strong>Q-Learning</strong>和<strong>基于策略优化（PolicyOptimization）</strong>两大类。Model-based算法可分为<strong>模型学习（Learnthe Model）</strong>和<strong>给定模型（Given theModel）</strong>两大类。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2下linux header的安装</title>
    <link href="/2023/05/09/WSL2%E4%B8%8Blinux_header%E5%AE%89%E8%A3%85/"/>
    <url>/2023/05/09/WSL2%E4%B8%8Blinux_header%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl2下linux-header的安装">WSL2下linux header的安装</h1><p>正常的linux发行版执行<code>linux-headers-$(uname -r)</code>命令就能装上内核头文件，但WSL2作为一个不一般的linux发行版，并没有直接给出安装包，要手动安装才能正常使用。</p><h2 id="安装步骤">安装步骤</h2><h3 id="确认kernel版本">确认Kernel版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -r<br></code></pre></td></tr></table></figure><h3 id="安装相应依赖">安装相应依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libelf-dev build-essential pkg-config<br>sudo apt install bison build-essential flex libssl-dev libelf-dev bc<br></code></pre></td></tr></table></figure><h3 id="下载相应版本源码">下载相应版本源码</h3><p>从<ahref="https://github.com/microsoft/WSL2-Linux-Kernel/releases">https://github.com/microsoft/WSL2-Linux-Kernel/releases</a>下载刚才得到对应版本的源码。</p><h3 id="解压刚下载的包并编译">解压刚下载的包并编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zvxf linux-msft-wsl-5.15.90.1.tar.gz<br>cd WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1<br>zcat /proc/config.gz &gt; .config<br>sudo make -j $(nproc) <br>sudo make -j $(nproc) modules_install<br></code></pre></td></tr></table></figure><p>安装过程中出现一下错误：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">BTF:</span> .tmp_vmlinux.btf: pahole (pahole) <span class="hljs-built_in">is</span> <span class="hljs-built_in">not</span> available<br>Failed <span class="hljs-keyword">to</span> generate BTF <span class="hljs-keyword">for</span> vmlinux<br><span class="hljs-keyword">Try</span> <span class="hljs-keyword">to</span> disable CONFIG_DEBUG_INFO_BTF<br><span class="hljs-symbol">make:</span> *** [Makefile:<span class="hljs-number">1218</span>: vmlinux] <span class="hljs-keyword">Error</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>原因是系统缺少dwarves软件包，故我们需要安装相应的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install dwarves<br></code></pre></td></tr></table></figure><h3 id="软链接">软链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s ~/Kernel/WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1 usr/src/linux-<br>headers-5.15.90.1-microsoft-standard-WSL2<br></code></pre></td></tr></table></figure><p>参考：<ahref="https://blog.csdn.net/qq_53928256/article/details/129737658">WSL2下kernelheader的安装</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pair tuple 作为 unordered_map unordered_set 的键值</title>
    <link href="/2023/05/06/Cpp-pair%E6%88%96tuple%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%94%AE%E5%80%BC/"/>
    <url>/2023/05/06/Cpp-pair%E6%88%96tuple%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%94%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="pair-tuple-作为-unordered_map-unordered_set-的键值">pair tuple作为 unordered_map unordered_set 的键值</h1><p>C++STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。网上的大部分实现的hash函数虽然可以用，但是其效率其实相当糟糕，他会导致碰撞严重，从而性能低下。</p><p>这里贴出一个《C++ 标准库（第二版）》中作者给出的绝佳方案，“7.9.2Creating and Controlling UnorderedContainer”，把任意结构hash化的代码搬出来，模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-comment">// from boost (functional/hash):</span><br><span class="hljs-comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span><br><span class="hljs-function"></span>&#123;<br>    seed ^= std::<span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// auxiliary generic functions to create a hash value using a seed</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;<br>    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tuple版本的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> hash_tuple &#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TT&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(TT <span class="hljs-type">const</span> &amp;tt)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;TT&gt;()(tt); &#125;<br>&#125;;<br><br><span class="hljs-comment">// from boost (functional/hash):</span><br><span class="hljs-comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, T <span class="hljs-type">const</span> &amp;v)</span> </span>&#123;<br>    seed ^= hash_tuple::<span class="hljs-built_in">hash</span>&lt;T&gt;()(v) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// Recursive template code derived from Matthieu M.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>, <span class="hljs-type">size_t</span> Index = std::tuple_size&lt;Tuple&gt;::value - <span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">struct</span> HashValueImpl &#123;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()(<span class="hljs-type">size_t</span> &amp;seed, Tuple <span class="hljs-type">const</span> &amp;tuple) <span class="hljs-type">const</span> &#123;<br>        HashValueImpl&lt;Tuple, Index - <span class="hljs-number">1</span>&gt;&#123;&#125;(seed, tuple);<br>        <span class="hljs-built_in">hash_combine</span>(seed, std::<span class="hljs-built_in">get</span>&lt;Index&gt;(tuple));<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashValueImpl</span>&lt;Tuple, <span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, Tuple <span class="hljs-type">const</span> &amp;tuple)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">hash_combine</span>(seed, std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(tuple));<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... TT&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;std::tuple&lt;TT...&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::tuple&lt;TT...&gt; <span class="hljs-type">const</span> &amp;tt)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>        HashValueImpl&lt;std::tuple&lt;TT...&gt;&gt;&#123;&#125;(seed, tt);<br>        <span class="hljs-keyword">return</span> seed;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// auxiliary generic functions to create a hash value using a seed</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);<br>    &#125;<br>&#125;;<br>&#125; <span class="hljs-comment">// namespace hash_tuple</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-comment">// std::unordered_map&lt;std::pair&lt;ll, ll&gt;, ll, hash_tuple::pair_hash&gt;</span><br>    <span class="hljs-comment">// hashmapPair; std::unordered_set&lt;std::pair&lt;ll, ll&gt;, hash_tuple::pair_hash&gt;</span><br>    <span class="hljs-comment">// hashsetPair;</span><br><br>    std::unordered_map&lt;std::pair&lt;ll, ll&gt;, ll, hash_tuple::pair_hash&gt;<br>        hashmapPair;<br>    hashmapPair[&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;] = <span class="hljs-number">10</span>;<br>    std::unordered_set&lt;std::pair&lt;ll, ll&gt;, hash_tuple::pair_hash&gt; hashsetPair;<br>    hashsetPair.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-keyword">using</span> TI = std::tuple&lt;ll, ll, ll, ll&gt;;<br>    std::unordered_map&lt;TI, ll, hash_tuple::hash&lt;TI&gt;&gt; hashmapTuple;<br>    hashmapTuple[&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;] = <span class="hljs-number">10</span>;<br>    std::unordered_set&lt;TI, hash_tuple::hash&lt;TI&gt;&gt; hashsetTuple;<br>    hashsetTuple.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bellman-Ford单源最短路径算法</title>
    <link href="/2023/04/22/Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/22/Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="bellman-ford单源最短路径算法">Bellman-Ford单源最短路径算法</h1><p>Bellman-Ford算法是一种用于计算带权有向图中单源最短路径（SSSP：Single-Source ShortestPath）的算法。该算法由 Richard Bellman 和 Lester Ford 分别发表于 1958年和 1956 年，而实际上 Edward F. Moore 也在 1957年发布了相同的算法，因此，此算法也常被称为 Bellman-Ford-Moore 算法。</p><p>Bellman-Ford 算法和 Dijkstra算法同为解决单源最短路径的算法。对于带权有向图 <spanclass="math inline">\(G = (V, E)\)</span>，Dijkstra 算法要求图 G中边的权值均为非负，而 Bellman-Ford算法能适应一般的情况（即存在负权边的情况）。一个实现的很好的 Dijkstra算法比 Bellman-Ford 算法的运行时间要低。</p><p>Bellman-Ford 算法采用动态规划（DynamicProgramming）进行设计，实现的时间复杂度为<spanclass="math inline">\(O(V*E)\)</span>，其中 <spanclass="math inline">\(V\)</span> 为顶点数量，<spanclass="math inline">\(E\)</span> 为边的数量。Dijkstra算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为<span class="math inline">\(O(V^2)\)</span>，若基于 Fibonacci heap的最小优先队列实现版本则时间复杂度为 <span class="math inline">\(O(E +VlogV)\)</span>。</p><p>Bellman-Ford 算法描述：</p><ol type="1"><li>创建源顶点 v 到图中所有顶点的距离的集合distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为0；</li><li>计算最短路径，执行 V - 1 次遍历；<ul><li>对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v的距离 d，则更新终点 v 的距离值 d；</li></ul></li><li>检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v的距离，如果对于 v 存在更小的距离，则说明存在环；</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><span class="hljs-comment">//用来存边</span><br>&#123;<br>    <span class="hljs-type">int</span> from;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> cost;<br>&#125;Edge[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">(<span class="hljs-type">int</span> src, <span class="hljs-type">int</span> destination)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// n是节点个数</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>        dist[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i++)          <span class="hljs-comment">// 查找从源点开始，经过k个节点可以</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++)      <span class="hljs-comment">// m 条边</span><br>        &#123;<br>            <span class="hljs-type">int</span> from = Edge[j].from, to = Edge[j].to, cost = Edge[j].cost;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[i][to], dist[i - <span class="hljs-number">1</span>][from]);<br>        &#125;                          <br>    &#125;<br>    <span class="hljs-comment">// dist[k][n]是刚好经过k步到达节点n的最短路径，若为INT_MAX则表示不能到达</span><br>    <span class="hljs-type">int</span> res = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; ++i)<br>    &#123;<br>        res = <span class="hljs-built_in">min</span>(res, dist[k][destination]);       <span class="hljs-comment">// 查找k步内到达destination的最短路径</span><br>    &#125;<br>    <span class="hljs-comment">// 未考虑负环的存在</span><br>    <span class="hljs-keyword">return</span> res == INT_MAX ? <span class="hljs-number">-1</span> : res;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveCpp-41：了解隐式接口和编译期多态</title>
    <link href="/2023/04/20/EffectiveCpp-41/"/>
    <url>/2023/04/20/EffectiveCpp-41/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-item-41-了解隐式接口和编译期多态">Effective C++ Item41 了解隐式接口和编译期多态</h1><h2 id="显式接口和运行时多态">显式接口和运行时多态</h2><p>面向对象编程的世界围绕着显式接口和运行时多态。举个例子，考虑下面的类（无意义的类）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;                          <span class="hljs-comment">// Item 25</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>考虑下面的函数（同样没有意义）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    &#123;<br>        <span class="hljs-function">Widget <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>        temp.<span class="hljs-built_in">normalize</span>();<br>        temp.<span class="hljs-built_in">swap</span>(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>doProcessing</code>中的<code>w</code>，我们可以这样说：</p><ul><li>因为w被声明为<code>Widget</code>类型，<code>w</code>必须支持<code>Widget</code>接口。我们可以在源码中搜寻这个接口（例如，在<code>Widget</code>的头文件中），以便能够确切的知道它长成什么样子，所以我将其叫做一个显式的接口（explicitinterface）——可以显式的在源码中看到的接口。</li><li>因为<code>Widget</code>中的一些成员函数是虚的，<code>w</code>对这些函数的调用会展示出运行时多态：<code>w</code>具体调用哪个函数会根据运行时<code>w</code>的动态类型来决定。</li></ul><h2 id="隐式接口和编译期多态">隐式接口和编译期多态</h2><p>模板（template）和泛型编程（genericprogramming）的世界从根本上发生了变化。在这个世界中，显式接口和运行时多态继续存在，但是它们不再像以前那么重要。相反，隐式接口和编译时多态被挪到了前台。为了了解这是什么样子的，我们将<code>doProcessing</code>从函数转换为一个函数模板，看看会发生什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    &#123;<br>        <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>        temp.<span class="hljs-built_in">normalize</span>();<br>        temp.<span class="hljs-built_in">swap</span>(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们能对<code>doProcessing</code>中的<code>w</code>说些什么呢？</p><ul><li><code>w</code>必须支持的接口由模板中w需要执行的操作所决定。例如，<code>w</code>的类型<code>T</code>必须支持<code>size</code>，<code>normalize</code>和<code>swap</code>成员函数；拷贝构造函数（来创建<code>temp</code>）；和不等比较（同<code>someNastyWidget</code>进行比较）。我们很快就能发现这也不是很精确的，但是对于现在来说足够了。重要的是，这些表达式必须是<code>T</code>所支持的隐式接口，它们对于模板来说必须是有效的以便能够通过编译。</li><li>对于涉及到<code>w</code>的像<code>operator&gt;</code>和<code>operator!=</code>这样的函数调用，可能涉及到模板的实例化来让这些调用成功。这些实例化在编译期发生。因为用不同的模板参数实例化出来的函数模板会导致不同的函数被调用，这叫做“编译期多态”。</li></ul><h2 id="显示接口和隐式接口的区别">显示接口和隐式接口的区别</h2><h3 id="显示接口的特点">显示接口的特点</h3><p>即使你永远不使用模板，你也应该熟悉运行时多态和编译期多态的区别，因为这同编译期决定调用哪个重载函数以及运行期决定绑定哪个虚函数是类似的。隐式和显式接口的区别对于模板来说是新的概念，然而，一个显式的接口由函数签名组成，也即是函数名字，参数类型，返回值类型等等。<code>Widget</code>类的公共接口，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由一个构造函数，一个析构函数，和函数<code>size</code>，<code>normalize</code>和<code>swap</code>以及参数类型，返回值类型和这些函数的常量性组成。（同样包含编译器生成的拷贝构造函数和拷贝赋值运算符——看Item5）。它同样可以包含<code>typedef</code>和数据成员，如果你够大胆违反Item22的建议的话（将数据成员声明为<code>private</code>）。虽然在这个例子中没有这么做。</p><h3 id="隐式接口的特点">隐式接口的特点</h3><p>一个隐式的接口会有很大的不同。它不是基于函数签名。而是由有效表达式组成。再看一下<code>doProcessing</code>模板开始部分的条件表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T &amp;w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget)<br>    &#123;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>T（<code>w</code>的类型）的隐式接口看上去会有如下限制：</p><ul><li>它必须提供一个名字为<code>size</code>的成员函数并且返回一个整型值。</li><li>它必须支持<code>!=</code>操作符函数，能够对两个<code>T</code>类型的对象进行比较。（这里，我们假设<code>someNastWidget</code>的类型为<code>T</code>。）</li></ul><p>多亏了操作符重载，上面的两个限制都不需要满足。<code>T</code>必须支持一个<code>size</code>成员函数，值得提及的是这个函数可能继承自一个基类。但是这个成员函数没有必要返回一个整型值。甚至不需要返回一个数字类型值。如果这么说的话，它甚至不需要返回<code>operator&gt;</code>定义中所需要的值。他需要的是返回一个类型<code>X</code>的对象，于是可以在一个类型<code>X</code>对象和<code>int</code>（因为<code>10</code>是<code>int</code>型的）型对象上调用<code>operator&gt;</code>。但是<code>Operator&gt;</code>没有必要带一个类型<code>X</code>的参数，因为它也可以带一个类型<code>Y</code>的参数，只要<code>Y</code>可以隐式的转成<code>X</code>就可以了。</p><p>类似的，<code>T</code>也没有必要支持<code>operator!=</code>，因为<code>operator!=</code>带一个类型<code>X</code>的参数和一个类型<code>Y</code>的参数也能接受。只要<code>T</code>能转成<code>X</code>并且<code>someNastyWidget</code>的类型可以转换成<code>Y</code>，那么函数调用就是有效的。</p><p>大多数人当第一次开始考虑这种隐式转换就头疼，你不需要吃阿司匹林。隐式接口只是简单的由一些有效表达式组成。表达式本身看起来复杂，但是加在上面的限制一般来说是简单直接的。例如，考虑下面的条件表达式，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) <br>    ...<br></code></pre></td></tr></table></figure><p>很难说要对函数<code>size</code>，<code>operator&gt;</code>,<code>operator&amp;&amp;</code>或者<code>operator!=</code>做什么限制，但是很容易辨认出需要对整个表达式做出的限制。If声明的条件部分必须是一个boolean表达式，所以不管涉及到什么类型，也不管<code>w.size() &gt; 10 &amp;&amp; w != someNastyWidget</code>产生什么，它必须同<code>bool</code>是兼容的。这是模板<code>doProcessing</code>强加在类型参数<code>T</code>上的隐式接口的一部分。剩下的<code>doProcessing</code>所需要的接口就是对拷贝构造函数的调用，还有<code>swap</code>对于类型T来说必须是有效的。</p><p>强加在模板参数上的隐式接口同强加在类对象上的显示接口一样真实，两者都是在编译阶段检查。你不能同一个类提供的显示接口相矛盾的方式使用一个类对象（不会编译通过），你也不能随便在一个模板中尝试使用一个对象，除非这个对象支持模板需要的隐式转换（否则也不能通过编译）</p><h2 id="总结">总结</h2><ul><li>类和模板都支持接口和多态。</li><li>对于类来说，接口是显式的，以函数签名为中心。多态发生在运行时，通过虚函数来实现。</li><li>对于模板参数来说，接口是隐式的，基于有效表达式。模板多态通过模板实例化和函数重载来实现，它发生在编译期。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveCpp-21：必须返回对象时，不要返回reference</title>
    <link href="/2023/04/20/EffectiveCpp-21/"/>
    <url>/2023/04/20/EffectiveCpp-21/</url>
    
    <content type="html"><![CDATA[<h1 id="effective-c-item-21必须返回对象时不要返回reference">EffectiveC++ Item 21：必须返回对象时，不要返回reference</h1><p>众所周知，C++中函数传参<em>pass-by-value</em>的效率是要低于<em>pass-by-reference</em>的，所以函数传参尽量以<strong><em>pass-by-reference-to-const</em>替换<em>pass-by-value</em></strong>,但是在函数返回的时候，返回一个<em>reference</em>并不一定是一件好事，因为这可能会导致我们<strong>传递一些<em>reference</em>并不存在的对象</strong>。</p><p>考虑一个用于表现有理数的class,内含一个函数用来计算两个有理数的乘积：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n, d;   <span class="hljs-comment">// 分子numerator 和 分母denominator</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类的<code>operator*</code>是以<em>by-value</em>返回其计算结果。如果现在你想节省掉该对象的构造和析构函数成本，而改用传递reference，那么请先回想一下，<strong>所谓reference只是一个名称，代表某个既有对象。任何时候看到一个reference对象声明式，都要立刻提醒自己，它的另一个名称是什么？因为它一定是某物的另一个名称</strong>。如果上面<code>operator*</code>返回reference，那么它一定指向一个既有的<code>Rational</code>对象,内含两个<code>Rational</code>对象的乘积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Rational <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;   <span class="hljs-comment">// a = 1/2</span><br><span class="hljs-function">Rational <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;   <span class="hljs-comment">// b = 3/5</span><br>Rational c = a * b; <span class="hljs-comment">// c 应该是 3/10</span><br></code></pre></td></tr></table></figure><p>以上面的代码为例，期望一个值为<code>3/10</code>的Rational对象已经存在并不合理，如果<code>operator*</code>返回一个reference指向如此数值，它必须自己创建那个Rational对象。</p><p>创建新对象的方式有两种：在stack空间或者在heap空间创建。如果要定义一个local变量，就是在stack空间上创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这样做有一个很明显的漏洞：函数返回一个reference指向result，但result是一个local对象，而local对象在函数退出之前就已经销毁了。因此这个版本的<code>operator*</code>并未返回reference指向某个Rational，它返回的额reference指向一个已经被销毁的“从前的”Rational。而任何使用到这个返回值的操作都会引发“无定义行为”的报错。所以，<strong>任何函数都不要返回reference指向一个local对象</strong>。</p><p>那么考虑在heap内构建对象，并返回reference指向它，Heap-based对象由new创建，所以写一个heap-based<code>operator*</code>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational* <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>即便如此，我们还是要付出一个“构造函数”的代价，因为分配所得的内存将以一个适当的构造函数并完成初始化操作。但此外你又有了另一个问题：谁该对着这个new出来的对象实施delete？</p><p>即便调用者诚实诚谨，并出于良好意识，他们还是不太能在这样合情合理的用法下阻止内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Rational w, x, y, z;<br>w = x * y * z;      <span class="hljs-comment">// 与 operator* (operator* (x, y), z)相同</span><br></code></pre></td></tr></table></figure><p>这里同一个语句调用了两次<code>operator*</code>，也就需要使用两次new，对应的就需要两次delete。但是却没有合理的方法让<code>operator*</code>的使用者进行那些delete调用，因为没有合理的方法让他们取得<code>operator*</code>返回的reference背后隐藏的那个指针。这一定会导致内存泄露。</p><p>所以不管是on-the-stack或者是on-the-heap的做法，都会因为<code>operator*</code>的返回结果调用构造函数而出错或付出代价。而我们想返回引用的最初目的是<strong>避免构造函数的调用</strong>。</p><p>或许还有一种避免任何构造函数被调用的方法，那就是“让<code>operator*</code>返回的reference指向一个被定义于函数内部的staticRational对象”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-type">static</span> Rational result;<br><br>    result = ...;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这也是一个非常糟糕的设计，看下面这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs);<br><br>Rational a, b, c, d;<br><br><span class="hljs-keyword">if</span>((a * b) == (c * d))      <span class="hljs-comment">// 这个表达式一定为true</span><br>    ...<br><span class="hljs-keyword">else</span><br>    ...<br></code></pre></td></tr></table></figure><p>不管<code>a</code>,<code>b</code>,<code>c</code>,<code>d</code>的值是什么，表达式<code>(a * b) == (c * d)</code>一定为<code>true</code>。上述的<code>if</code>判别式可以写为下面的等价形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">operator</span>* (a, b), <span class="hljs-keyword">operator</span>* (c, d)))<br></code></pre></td></tr></table></figure><p>在<code>operator==</code>被调用之前，两个<code>operator*</code>已经被调用，每个都返回reference指向<code>operator*</code>内部定义的static对象。因此<code>operator==</code>比较的两个对象都是<code>operator*</code>内定义的static对象，所以判别式一定是<code>true</code>。</p><h2 id="总结">总结</h2><p>绝不要返回pointer或reference指向一个localstack对象，或返回有一个reference指向一个heap-allocated对象，或返回pointer或reference指向一个loaclstaic对象而又可能同时需要多个这样的对象。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划的几种实现方式</title>
    <link href="/2023/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划的几种实现方式">动态规划的几种实现方式</h1><p>动态规划又几种不同的实现方式，以leetcode第<ahref="https://leetcode.cn/problems/longest-common-subsequence/description/">1143</a>题为例：</p><p><img src="/img/算法/动态规划实现方式/leetcode1143.png" /></p><p>很明显这是一道动态规划的题，而动态规划有多种不同的实现方式，比如最常见的两种方式是迭代递推法和记忆化搜索法，这两种方法的主要区别在于，迭代递推法是自底向上递推，而记忆化搜索是自顶向下搜索，在搜索过程中保存计算结果，避免重复计算。</p><h2 id="递归搜索-保存计算结果-记忆化搜索">递归搜索 + 保存计算结果 =记忆化搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(text1, len1 - <span class="hljs-number">1</span>, text2, len2 - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;text1, <span class="hljs-type">int</span> end1, <span class="hljs-type">const</span> string &amp;text2, <span class="hljs-type">int</span> end2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(end1 == <span class="hljs-number">-1</span> || end2 == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(memo[end1][end2] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> memo[end1][end2];<br><br>        <span class="hljs-keyword">if</span>(text1[end1] == text2[end2])<br>            memo[end1][end2] = <span class="hljs-built_in">dp</span>(text1, end1 - <span class="hljs-number">1</span>, text2, end2 - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            memo[end1][end2] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dp</span>(text1, end1 - <span class="hljs-number">1</span>, text2, end2), <span class="hljs-built_in">dp</span>(text1, end1, text2, end2 - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> memo[end1][end2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代递推">迭代递推</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        memo[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = memo[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = memo[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = memo[i][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span>    <br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(memo[i][j + <span class="hljs-number">1</span>], memo[i + <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len1][len2];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="空间优化一个数组">空间优化（一个数组）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; memo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">size</span>(), len2 = text2.<span class="hljs-built_in">size</span>();<br>        memo = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; ++i)<br>        &#123;   <br>            pre = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 每次++i之后j又从0开始，pre = memo[j] = 二维memo[i][0] = 0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; ++j)<br>            &#123;   <br>                <span class="hljs-type">int</span> tmp = memo[j + <span class="hljs-number">1</span>];      <span class="hljs-comment">// temp == 二维memo[i][j + 1]</span><br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    memo[j + <span class="hljs-number">1</span>] = pre + <span class="hljs-number">1</span>;   <span class="hljs-comment">// memo[j + 1] == 二维memo[i + 1][j + 1]</span><br>                <span class="hljs-keyword">else</span>    <br>                    memo[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(tmp, memo[j]);     <span class="hljs-comment">// memo[j + 1] == 二维memo[i + 1][j + 1]</span><br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len2];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树</title>
    <link href="/2023/04/08/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2023/04/08/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树">前缀树</h1><p>前缀树（又称为字典树或者称为字典映射树、查找树），是一种树形结构。前缀树的作用是：对于一组字符串，找到这组字符串的公共前缀，或者判断一个字符串是否是这组字符串中的某一个串的前缀。</p><p>前缀树的主要性质是：根节点不包含字符,每一个节点的所有子节点包含的字符都不相同。另外，从根节点到某一个节点，路径上经过的字符连接起来，即为该节点对应的字符串。</p><p>以下是前缀树的时间复杂度描述：</p><table><thead><tr class="header"><th>空间复杂度</th><th>时间复杂度</th><th>空间复杂度描述</th><th>时间复杂度描述</th></tr></thead><tbody><tr class="odd"><td>O(字符串总长度)</td><td>O(字符串总长度)</td><td>各字符串的字符数之和</td><td>查找、插入、删除的时间复杂度均为O(字符串长度)</td></tr></tbody></table><p>字典树的应用场景非常广泛，比如字符串的匹配 (Trie),排序、树形统计和信息检索 (eg. 索引, 关键词检索, 模糊查询) 等等。</p><p>前缀树的实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> is_end_;<br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>),  <span class="hljs-built_in">is_end_</span>(<span class="hljs-literal">false</span>)<br>    &#123;   <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span>    <span class="hljs-comment">// 输入字符串</span></span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<br>                node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br><br>            node = node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node -&gt; is_end_ = <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span>    <span class="hljs-comment">// 查找word是否在前缀树中插入过</span></span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-built_in">searchPrefix</span>(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nullptr</span> &amp;&amp; node -&gt; is_end_ == <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span>  <span class="hljs-comment">// 判断是否以word为前缀</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchPrefix</span>(prefix);<br>    &#125;<br><br>    <span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        Trie *node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            node = node -&gt; children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2023/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈">单调栈</h1><p>单调栈是一种运用栈数据结构来解决一些特定问题的解题技巧。它主要用于解决需要快速寻找<strong>一个元素左(或右)边第一个比它大(或小)的元素</strong>的问题。</p><p>使用单调栈的基本思路是保持栈内的元素单调递增或单调递减，栈顶元素是当前栈内最大或最小的元素，同时记录下每个元素的相关信息，如坐标、面积、数量等，根据这些信息计算出所需的结果。</p><p>单调栈的实现主要有两种，第一种是从前往后遍历数组，第二种是从后往前遍历数组。</p><h2 id="寻找数组右侧第一个比它大的数">寻找数组右侧第一个比它大的数</h2><p><strong>第一种实现方式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它大的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 当前元素大于栈顶元素时，当前元素就是栈顶元素右侧第一个大于栈顶的元素，并将栈顶出栈</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[s.<span class="hljs-built_in">top</span>()])    <br>        &#123;<br>            res[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种实现方式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它大的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)     <br>    &#123;<br>        <span class="hljs-comment">// 栈顶元素在当前元素右侧，当栈顶元素小于或等于当前元素的时候，将其出栈，继续寻找当前元素右侧第一个比它大的元素</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[s.<span class="hljs-built_in">top</span>()] &lt;= nums[i])  <br>            s.<span class="hljs-built_in">pop</span>();<br>        res[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寻找数组右侧第一个比它小的数">寻找数组右侧第一个比它小的数</h2><p><strong>第一种实现方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSmallerElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它小的数时对应res为-1，所以初始值全部设置为-1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)     <br>    &#123;<br>        <br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt;= nums[s.<span class="hljs-built_in">top</span>()])  <br>        &#123;<br>            right[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种实现方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSmallerElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 右侧没有比它小的数时对应res为-1，所以初始值全部设置为-1</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt;= nums[s.<span class="hljs-built_in">top</span>()])<br>            s.<span class="hljs-built_in">pop</span>();<br>        right[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="寻找数组右侧第一个满足某个条件的数">寻找数组右侧第一个满足某个条件的数</h2><p>观察上面两个算法的实现，可以发现，以<strong>从前往后遍历</strong>为例，他们的框架其实是一样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[i]满足nums[s.<span class="hljs-built_in">top</span>()]的条件`)    <br>        &#123;<br>            res[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>从后往前遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[s.<span class="hljs-built_in">top</span>()]不满足nums[i]的条件`)<br>            s.<span class="hljs-built_in">pop</span>();<br>        right[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="寻找数组左侧第一个满足某个条件的数">寻找数组左侧第一个满足某个条件的数</h2><p><strong>从前往后遍历</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从前往后遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[s.<span class="hljs-built_in">top</span>()]不满足nums[i]的条件`)<br>            s.<span class="hljs-built_in">pop</span>();<br>        left[i] = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>从后往前遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后往前遍历</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextSatisfiedElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; `nums[i]满足nums[s.<span class="hljs-built_in">top</span>()]的条件`)<br>        &#123;<br>            left[s.<span class="hljs-built_in">top</span>()] = i;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        s.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>寻找左边第一个满足某个条件的数和寻找右边第一个满足条件的数，从前往后遍历和从后往前遍历的循环条件刚好是相反的</p></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2023/04/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法">排序算法</h1><h2 id="快速排序">快速排序</h2><p>快速排序是一种常见的排序算法，其核心思想是分治法。下面是快速排序的步骤：</p><ol type="1"><li>选取一个基准数（pivot）</li><li>将序列中比基准数大的元素放在基准数的右边，比基准数小的元素放在基准数的左边。</li><li>递归地对基准数左右两边的序列进行排序，直到序列长度为1或0。</li></ol><p>快速排序中最重要的就是第2步，也就是<code>partation</code>阶段。快速排序有很多不同的实现方式，每次选择最右侧的数作为<code>pivot</code>进行<code>partation</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> pvoit = nums[right];     <span class="hljs-comment">// 选择最右侧的数作为pivot</span><br>   <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>   &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>          <span class="hljs-built_in">swap</span>(nums[++i], nums[j]);<br><br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过上面的代码我们可以看出，每次<code>partation</code>必然会将一个数放到最终的位置，然后再递归处理<code>pivot</code>左右两侧的区间，那么最好的情况就是每次<code>partation</code>都将数组两等分，而最坏的情况是每次<code>partation</code>划分出的区间都在<code>pivot</code>的一侧。</p><p>那么如何避免最坏情况的发生呢？这里可以每次选择一个随机数作为<code>pivot</code>然后进行划分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>   <span class="hljs-built_in">swap</span>(nums[p], nums[right]);      <span class="hljs-comment">// 将随机选出的数与最右侧数交换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">partation</span>(nums, left, right); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pvoit = nums[right];<br>  <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>  &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 快速排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomQuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(left &gt;= right)<br>      <span class="hljs-keyword">return</span> ;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">randomPartation</span>(nums, left, right);<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, left, p - <span class="hljs-number">1</span>);<br>   <span class="hljs-built_in">randomQuickSort</span>(nums, p + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>   <span class="hljs-built_in">swap</span>(nums[p], nums[right]);      <span class="hljs-comment">// 将随机选出的数与最右侧数交换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">partation</span>(nums, left, right); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pvoit = nums[right];<br>  <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right; ++j)<br>  &#123;<br>      <span class="hljs-keyword">if</span>(nums[j] &lt;= pvoit)<br>      &#123;<br>          ++i;<br>          <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 归并操作，将两个有序数组合并为一个有序数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = right - mid;<br><br>    <span class="hljs-comment">// 创建临时数组来存储左右两部分的元素</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n1)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n2)</span></span>;<br><br>    <span class="hljs-comment">// 拷贝数据到临时数组 L 和 R</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; ++i) &#123;<br>        L[i] = arr[left + i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; ++j) &#123;<br>        R[j] = arr[mid + <span class="hljs-number">1</span> + j];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并临时数组到原数组 arr</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = left;<br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) &#123;<br>            arr[k] = L[i];<br>            ++i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[k] = R[j];<br>            ++j;<br>        &#125;<br>        ++k;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝 L 和 R 中剩余的元素（如果有）</span><br>    <span class="hljs-keyword">while</span> (i &lt; n1) &#123;<br>        arr[k] = L[i];<br>        ++i;<br>        ++k;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; n2) &#123;<br>        arr[k] = R[j];<br>        ++j;<br>        ++k;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 归并排序递归函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 分别对左右两部分进行递归排序</span><br>        <span class="hljs-built_in">mergeSort</span>(arr, left, mid);<br>        <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-comment">// 合并已排序的两部分</span><br>        <span class="hljs-built_in">merge</span>(arr, left, mid, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 归并排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">mergeSort</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <br>    <span class="hljs-comment">// 调用归并排序函数</span><br>    <span class="hljs-built_in">mergeSort</span>(arr);<br><br>    <span class="hljs-comment">// 输出排序后的数组</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sorted array is: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2023/04/04/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2023/04/04/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法">二分法</h1><p>二分法作为一种常见的查找算法，其实不单单可以只寻找某一个数。</p><h2 id="最基本的二分查找">最基本的二分查找</h2><p>搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索一个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 定义target在左闭右开的区间里，即：[left, right)</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;   <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>            right = mid;    <span class="hljs-comment">// target 在左区间，在[left, mid)中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在[mid + 1, right)中</span><br>        <span class="hljs-keyword">else</span>                <span class="hljs-comment">// nums[mid] == target</span><br>            <span class="hljs-keyword">return</span> mid;     <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;              <span class="hljs-comment">// 未找到目标值</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="搜索左侧边界">搜索左侧边界</h2><p><img src="/img/算法/二分法/二分法拓展.png" /></p><p>如上图所示，查找数组中最左侧大于或等于3的数也可以使用二分法。首先对整个数组二分，看中间的数是否满足大于或等于3，若满足继续在左侧二分，否则在右半侧二分，一直到结束，得到的所有满足条件的最小下标就是求得的结果。</p><p><strong>这个问题与普通二分法查找的区别在于</strong>：二分法是使用二分找个一个满足条件的数之后就结果查找，但是这里需要一直二分到最后，然后在所有满足条件的数中比较。</p><p><strong>搜索左侧边界</strong>的二分搜索算法的具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索左侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <br>            right = mid;    <span class="hljs-comment">// 当找到 target 时，收缩右侧边界</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) <br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>            right = mid;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == nums.<span class="hljs-built_in">size</span>())     <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;    <span class="hljs-comment">// nums[left] != target说明没有搜索到，返回-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意在搜索左侧边界的时候并不是一旦发现<code>nums[mid] == target</code>就直接返回，因为要寻找最左侧满足条件的下标。</p><p>简化后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 优化版搜索左侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) <br>            right = mid;  <br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == nums.<span class="hljs-built_in">size</span>())     <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;    <span class="hljs-comment">// nums[left] != target说明没有搜索到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索右侧边界">搜索右侧边界</h2><p>搜索右侧边界其实和搜索左侧边界同理，不同的地方在于，搜索左侧边界时出现<code>nums[mid] == target</code>时<code>right</code>需要向左收缩，而在搜索右侧边界的时候出现<code>nums[mid] == target</code>时是<code>left</code>需要向右收缩。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索右侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            left = mid + <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>; <span class="hljs-comment">// nums[left - 1] != target说明没有搜索到，返回-1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>nums[mid] == target</code>和<code>nums[mid] &lt; target</code>的情况合并之后的简化版为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 搜索右侧边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) <br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)<br>            left = mid + <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">else</span><br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 没有搜索到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>; <span class="hljs-comment">// nums[left - 1] != target说明没有搜索到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><p>不管是搜索单个值还是左右侧边界，此模板中<code>left</code>和<code>right</code>收缩的模式是一样的，即<code>left</code>向右收缩时总是<code>left= mid + 1</code>,而<code>right</code>收缩时总是<code>right =mid</code>。为什么 <code>left</code> 的更新必须是 <code>left = mid +1</code>，当然是为了把 <code>nums[mid]</code>排除出搜索区间。记住这一点便很容易记下三种不同的模板。</p><p>另外，搜索左右侧边界时的返回也不一样，搜索左侧边界的时候返回是<code>left</code>，而在搜索右侧边界的时候返回是<code>left- 1</code>，因为我们对 <code>left</code> 的更新必须是 <code>left = mid +1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于<code>target</code> 了，而 <code>nums[left-1]</code> 可能是<code>target</code>。</p></div><h2 id="寻找局部最小值">寻找局部最小值</h2><p>在一个无序数组arr中，相邻的数都不相同，那么如何在这个数组arr中找到一个局部最小值？这里的极小值定义是比左右两侧都小的数，在数组最左侧则只需要满足比它右侧的数小，在数组最右侧的数只需要满足比它左侧的数小即可。</p><p>首先判断<code>arr[0]</code>和<code>arr[n - 1]</code>是否是极小值，若右极小值则直接返回。若都不是极小值那么取最中间的数<code>arr[m]</code>,判断<code>arr[m]</code>是否为局部最小值，若为局部最小值则直接返回。</p><p><img src="/img/算法/二分法/局部最小值-2.png" /></p><p>若不为极小值那么它要么比它左侧的数大，要么比它右侧的数大。假设它比左侧的数大，那么就在左半边进行二分，如此一来，就存在了二分的点，直至找到一个局部最小值为止。</p><p><img src="/img/算法/二分法/局部最小值-1.png" /></p><p><strong>这里可以看出来二分法不只是能用在有序数组，在无序的情况下满足特定条件也可以用二分。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集union-find">并查集（UNION-FIND）</h1><p>并查集（Union-FindSet）是一种用来管理和解决集合分组问题的数据结构，它支持两个操作：</p><ul><li><strong>查找（Find）</strong>：查找一个元素属于哪个集合，即找出其所在的连通块。</li><li><strong>合并（Union）</strong>：将两个不相交的集合合并成一个新的集合。</li></ul><h2 id="并查集模板">并查集模板</h2><p><strong>查找（Find）</strong>：这里用树来表示是否属于同一个数组，使用<strong>查找（Find）</strong>操作返回的是该节点所在树的根节点，如果一个节点<code>x</code>所在树的根节点就是<code>x</code>自己，那么<code>findParent(x)</code>返回的结果就是<code>x</code>。</p><p><strong>合并（Union）</strong>：合并两个节点<code>x</code>和<code>y</code>之前需要先判断<code>x</code>和<code>y</code>是否属于一个集合，如果已经在一个集合里，那么直接返回，否则将<code>x</code>和<code>y</code>的集合合并（在此实现为将<code>x</code>和<code>y</code>的树合并为一个树）。</p><p>合并两个集合最原始的方式就是将一个节点的根节点接到另一个节点的根节点上：</p><p><img src="/img/算法/并查集/原始合并.jpg" /></p><p>其实就是一个树结构，每个节点的祖先节点是其所在的集合，那么就会有一个问题，在最坏的情况下，树会退化为一个链表，这时候的<strong>查找</strong>时间复杂度为<code>O(N)</code>，上面的<code>findParent</code>函数可以在查找过程中将树结构进行压缩，压缩之后的结构如下图所示，每个节点的父亲节点为所在树的根节点：</p><p><img src="/img/算法/并查集/路径压缩.jpg" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x != parent[x])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(parent[x]);<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>其查找过程便是压缩过程，见下面的动图：</p><p><img src="/img/算法/并查集/路径压缩动图.gif" /></p><p>并查集的模板如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UF</span>(<span class="hljs-type">int</span> n)   <span class="hljs-comment">// 构造函数，输入n为节点个数</span><br>    &#123;<br>        parent = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);    <span class="hljs-comment">// n + 1是可以parent[i]为第i个节点的祖先，视情况而定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;      <span class="hljs-comment">// 初始时每个节点都是单独的结合</span><br>        count = n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x != parent[x])      <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = <span class="hljs-built_in">findParent</span>(parent[x]);<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> parent_x = <span class="hljs-built_in">findParent</span>(x);<br>        <span class="hljs-type">int</span> parent_y = <span class="hljs-built_in">findParent</span>(y);<br><br>        <span class="hljs-keyword">if</span>(parent_x == parent_y)  <span class="hljs-comment">// x，y已经属于同一个集合，直接返回     </span><br>            <span class="hljs-keyword">return</span> ;<br>        --count;<br>        parent[parent_y] = parent_x;   <span class="hljs-comment">// 将两个集合合并</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>  <span class="hljs-comment">// 判断两个节点是否属于一个集合</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findParent</span>(x) == <span class="hljs-built_in">findParent</span>(y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;     <span class="hljs-comment">// parent[i]为第i个节点的祖先</span><br>    <span class="hljs-type">int</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考：本文中的图引用自<ahref="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/bing-cha-j-323f3/">labuladong的算法小抄</a>,模板实现是根据其模板修改而来。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法</title>
    <link href="/2023/04/03/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/03/%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图算法">图算法</h1><h2 id="dijkstra算法">Dijkstra算法</h2><p>输入是一个图<code>graph</code>,返回是一个最短路径权重的数组。</p><p>思路：将<code>dis</code>的初始值出<code>start</code>之外设置为<code>INT_MAX</code>，<code>start</code>设置为<code>0</code>，然后将<code>start</code>加入到优先级队列中，依次将优先级队列中到<code>start</code>距离最小的节点<code>cur</code>弹出，看是否可以更新<code>cur</code>相邻节点<code>next_node</code>的dis值，如果出现下面<code>next_cost &lt; dis[edge.first]</code>的情况，那么就表示<code>next_node</code>的值可以被更新，且新的最短距离是经过<code>cur</code>的，同时将<code>next_node</code>加入到优先级队列中。重复这个过程，最终得到的<code>dis</code>数组就是<code>start</code>到其他节点的距离。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph为输入的图，graph[i]为节点i的邻接表，pair.first为相邻的节点编号,pair.second为该边的权重</span><br><span class="hljs-comment">// start为起点</span><br><span class="hljs-comment">// n为图的节点个数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; &amp;graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;   <span class="hljs-comment">// 距离起点的距离数组,初始设置为INT_MAX,方便以后遍历到之后更新</span><br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p2) &#123;<span class="hljs-keyword">return</span> p1.second &lt; p2.second;&#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);  <span class="hljs-comment">// 使用优先级队列，pair.first为节点编号,pair.second到该节点的最小距离</span><br>    dis[start] = <span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(start, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [id, cost] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cost &gt; dis[id])  <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : graph[id])<br>        &#123;<br>            <span class="hljs-type">int</span> next_cost = edge.second + dis[id];<br>            <span class="hljs-keyword">if</span>(next_cost &lt; dis[edge.first])     <span class="hljs-comment">// 如果下一个节点cost小于dis存储的值，更新dis并将其加入到优先级队列中</span><br>            &#123;<br>                dis[edge.first] = next_cost;<br>                pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, next_cost));   <span class="hljs-comment">// 该节点的cost更新之后，其相邻节点的cost可能也会因此更新</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dis;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="floyd算法">Floyd算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 用INF初始化那些无法直接到达的顶点对之间的距离</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-comment">// graph是二维数组, graph[i][j]表示i到j的距离，i到i的距离为0，若i没有到j的通路，则graph[i][j]为INF</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>    <span class="hljs-type">int</span> V = graph.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-comment">// distances数组会存储最终的最短路径结果</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; distances = graph;<br>    <br>    <span class="hljs-comment">// k是中间顶点的编号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; ++k) &#123;<br>        <span class="hljs-comment">// i是起点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) &#123;<br>            <span class="hljs-comment">// j是终点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; ++j) &#123;<br>                <span class="hljs-comment">// 如果i到k和k到j的路径长度之和小于直接i到j的路径长度，则更新i到j的路径长度</span><br>                <span class="hljs-keyword">if</span> (distances[i][k] &lt; INF &amp;&amp; distances[k][j] &lt; INF) &#123;<br>                    distances[i][j] = <span class="hljs-built_in">min</span>(distances[i][j], distances[i][k] + distances[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 打印最短路径的结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (distances[i][j] == INF) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;INF &quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; distances[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图，使用邻接矩阵表示，INF表示两个顶点之间没有直接的路径</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">0</span>,   <span class="hljs-number">5</span>, INF, <span class="hljs-number">10</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">3</span>, INF&#125;,<br>        &#123;INF, <span class="hljs-number">3</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">10</span>, INF, <span class="hljs-number">1</span>,   <span class="hljs-number">0</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">floydWarshall</span>(graph);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kruskal-最小生成树算法">Kruskal 最小生成树算法</h2><p>思想：从图<code>graph</code>中每次选择一条最短的边<code>e</code>，若加入<code>e</code>之后不构成环，将<code>e</code>加入到最小生成树的结果中；重复上述步骤，一直到有<code>n - 1</code>条边为止（<code>n</code>为图的节点个数，因为<code>n</code>个节点不存在环的连通图中必定有<code>n - 1</code>条边）。</p><p><strong>Kruskal算法步骤</strong>：</p><ol type="1"><li>将所有边按照权重从小到大排序</li><li>初始化一个集合，并且把所有节点分别加入集合，每个节点都是单独一个集合。</li><li>遍历排序后的边，将它们加入树中(如果边的两个节点不在同一个集合中)。</li><li>最后得到的tree就是最小生成树。</li></ol><p>这里实现KRUSKAL使用了并查集，并查集的概念与代码见<ahref="https://gstarmin.github.io/2023/04/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph[i] = [x, y, cost]，表示节点x和y之间有一条权值为cost的边</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(graph.<span class="hljs-built_in">begin</span>(), graph.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;v1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; v2) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> v1[<span class="hljs-number">2</span>] &lt; v2[<span class="hljs-number">2</span>];&#125;);<br>    <span class="hljs-function">UF <span class="hljs-title">my_uf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;      <span class="hljs-comment">// 定义并查集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : graph)<br>    &#123;<br>        <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], cost = edge[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(my_uf.<span class="hljs-built_in">isConnected</span>(x, y))    <span class="hljs-comment">// 若x，y已经连通那么不能把这条边加入到结果中</span><br>            <span class="hljs-keyword">continue</span>;<br>        ++count;<br>        my_uf.<span class="hljs-built_in">unionNode</span>(x, y);<br>        res.<span class="hljs-built_in">emplace_back</span>(edge);     <span class="hljs-comment">// 将这条边添加到结果中，可以根据实际情况执行不同操作</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> count == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="prim-最下生成树算法">Prim 最下生成树算法</h2><p><code>Prim</code>算法与<code>Kruskal</code>的区别在于，<code>Kruskal</code>算法是每次选择一条最短的且不构成环的边，而<code>Prim</code>算法是使用<code>BFS</code>算法思想和<code>visited</code>数组避免成环，保证选出来的边一定是一棵树。</p><p><code>Prim</code>算法步骤：</p><ol type="1"><li>从任意一个节点开始，将该节点加入到已访问节点集合中。</li><li>在未访问节点中找到与已访问节点集合中节点权值最小的边（也就是跨越已访问节点集合和未访问节点中某个节点的边），将该边和对应的节点加入到已访问节点集合中。</li><li>重复第二步操作，直到所有节点都被加入到已访问节点集合中为止。</li></ol><p><code>Prim</code>算法也是一种贪心算法,它的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>，其中<code>n</code>为节点个数。在实际应用中，<code>Prim</code>算法通常用于处理<strong>稠密图</strong>中的最小生成树问题。</p><p>这里<code>Prim</code>算法的实现使用了优先级队列<code>priority_queue</code>,实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// graph为邻接表graph[i] = [node, cost]，start为Prim算法起始节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(graph[start].<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    visited[start] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;p2) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> p1.second &gt; p2.second;&#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);      <span class="hljs-comment">// visited数组判断当前节点是否访问过</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;edge : graph[start])<br>    &#123;<br>        pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, edge.second));<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> cur = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(visited[cur.first])<br>            <span class="hljs-keyword">continue</span>;<br>        visited[cur.first] = <span class="hljs-literal">true</span>;<br>        res += cur.second;      <span class="hljs-comment">// 这里是计算最小生成树边的权值之和，可以根据实际情况调整</span><br>        ++count;<br>        <span class="hljs-keyword">if</span>(count == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;edge : graph[cur.first])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[edge.first])        <span class="hljs-comment">// 将当前节点的邻接节点加入优先级队列</span><br>                pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(edge.first, edge.second));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓扑排序算法">拓扑排序算法</h2><p>Leetcode上的 <ahref="https://leetcode.cn/problems/course-schedule-ii/description/">210.课程表 II</a> 便是一道典型的拓扑排序题，问题如下：</p><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code>到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code>，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程<code>ai</code> 前 必须 先选修 <code>bi</code> 。</p><p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code>，我们用一个匹配来表示：<code>[0,1]</code> 。返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回<strong>任意一种</strong>就可以了。如果不可能完成所有课程，返回<strong>一个空数组</strong>。</p><p>拓扑排序分为<code>DFS</code>版本和<code>BFS</code>版本。</p><h3 id="dfs版本">DFS版本</h3><p><strong>步骤</strong>：</p><ol type="1"><li>首先，需要先建立一个 DAG（有向无环图），包含顶点和边。</li><li>初始化入度为 0 的顶点队列，将初始顶点加入队列中。</li><li>从队列头部开始处理。</li><li>遍历该顶点的出边，将出边对应的顶点的入度减 1。</li><li>如果入度为 0，则将该顶点加入队列末尾。</li><li>重复步骤 <code>3-5</code> 直到队列为空。</li></ol><p><code>DFS</code>版本实现类似二叉树的前序遍历或者树的<code>DFS</code>遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; visited;    <span class="hljs-comment">// 用于判断节点是否已经访问</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inedges;    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// DFS</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        inedges = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">buildGraph</span>(numCourses, prerequisites, graph, inedges);  <span class="hljs-comment">// 建图</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i)     <span class="hljs-comment">// 确保在图不是连通的情况下也能正确得到拓扑排序</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(graph, path, i, numCourses);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses ? path : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> numCourses)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited[s])<br>            <span class="hljs-keyword">return</span> ;<br>        <br>        visited[s] = <span class="hljs-number">1</span>;<br>        path.<span class="hljs-built_in">emplace_back</span>(s);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses)<br>        &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;i : graph[s])<br>        &#123;<br>            --inedges[i];<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(graph, path, i, numCourses);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;prerequisites, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inedges)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : prerequisites)<br>        &#123;<br>            <span class="hljs-type">int</span> from = p[<span class="hljs-number">1</span>], to = p[<span class="hljs-number">0</span>];<br>            graph[from].<span class="hljs-built_in">emplace_back</span>(to);<br>            ++inedges[to];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="bfs版本">BFS版本</h3><p><code>BFS</code>版本和<code>DFS</code>版本的思路其实是一样的，<code>BFS</code>和<code>DFS</code>的区别类似树的遍历，无非是在遍历节点的时候以不同的顺序访问其邻接节点。<code>DFS</code>的实现用到了递归而<code>BFS</code>的实现用到了队列，类似二叉树的层序遍历或树的<code>BFS</code>遍历。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// BFS</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 判断节点是否已经访问</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inedges</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 入度数组</span><br>        <span class="hljs-built_in">buildGraph</span>(numCourses, prerequisites, graph, inedges);      <span class="hljs-comment">// 建图</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">emplace</span>(i);<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            visited[cur] = <span class="hljs-number">1</span>;<br>            path.<span class="hljs-built_in">emplace_back</span>(cur);     <span class="hljs-comment">// 将当前节点加入到拓扑排序结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[cur])<br>            &#123;<br>                --inedges[i];<br>                <span class="hljs-keyword">if</span>(inedges[i] == <span class="hljs-number">0</span>)     <span class="hljs-comment">// 若相邻节点的入度为0，加入到队列中</span><br>                    q.<span class="hljs-built_in">emplace</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)path.<span class="hljs-built_in">size</span>() == numCourses? path : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;prerequisites, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inedges)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : prerequisites)<br>        &#123;<br>            <span class="hljs-type">int</span> from = p[<span class="hljs-number">1</span>], to = p[<span class="hljs-number">0</span>];<br>            graph[from].<span class="hljs-built_in">emplace_back</span>(to);<br>            ++inedges[to];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 右值引用</title>
    <link href="/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="c-右值引用">C++ 右值引用</h1><p>C++11中一个最主要的特性是可以移动而非拷贝对象的能力。我们很多情况下都会发生对象拷贝，而在其中某些情况下，对象拷贝之后就立即背销毁了。这种情况下，移动而非拷贝对象会大幅度提升性能。</p><p>在C++11之前，没有直接的方法移动对象。因此，计时不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如string），进行不必要的拷贝代价非常高。</p><p>为了支持移动操作，C++11中引入了一种新的引用类型————<strong>右值引用(rvaluereference)</strong>。所谓右值引用是就是必须绑定到右值的引用。<strong>我们通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用</strong>。比如我们将要看到的，右值引用有一个重要的性质————<strong>只能绑定到一个将要销毁的对象上</strong>。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。</p><p>如我们所知，对于常规引用（为了与右值引用区分开，我们可以称之为<strong>左值引用</strong>），我们不能将其绑定到要求转换的表达式、字面常量、或者是返回右值的表达式。右值引用有完全相反的特性：我们可以将一个右值绑定到一个左值上，但不能将一个右值引用直接绑定到一个左值上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;         <span class="hljs-comment">// 正确：r引用i</span><br><span class="hljs-type">int</span> &amp;&amp;rr = i;       <span class="hljs-comment">// 错误:不能将一个右值引用绑定到一个左值上</span><br><span class="hljs-type">int</span> &amp;r2 = i * <span class="hljs-number">42</span>;   <span class="hljs-comment">// 错误：i * 42是一个右值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i * <span class="hljs-number">42</span>;     <span class="hljs-comment">// 正确:我们可以将一个const的引用绑定到一个右值上</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = i * <span class="hljs-number">42</span>;         <span class="hljs-comment">// 正确:将rr2绑定到乘法结果上</span><br></code></pre></td></tr></table></figure><p>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。</p><p>返回非引用类型的函数，连同算数、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个右值引用绑定到这类表达式上，但我们可以将一个const的左值引用或一个右值引用绑定到这类表达式上。</p><h2 id="左值持久右值短暂">左值持久；右值短暂</h2><p>考察左值和右值表达式的列表，两者相互区别之处就很明显了：<strong>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong>。</p><p>由于右值引用只能绑定到临时对象，我们得知</p><ul><li>所引用的对象将要别销毁</li><li>该对象没有其他用户</li></ul><p>这两个特性意味着：使用右值引用的diamagnetic可以自由地接管所引用对象的资源.</p><h2 id="变量是左值">变量是左值</h2><p>变量可以看作只有一个变量没有运算符的表达式,虽然我们很少这样看待变量.类似其他任何表达式,变量表达式也有左值/右值属性.变量表达式都是左值,带来的结果就是,<strong>我们不能将一个右值引用绑定一个右值引用类型的变量上</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 正确:字面常量是右值</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = rr1;    <span class="hljs-comment">// 错误:表达式rr1是左值!</span><br></code></pre></td></tr></table></figure><p>其实有了右值表示临时对象这一观察结果,变量是左值这一特性并不令人惊讶.毕竟,变量是持久的,直至离开作用域的时候才被销毁.</p><h2 id="stdmove函数">std::move函数</h2><p>虽然不能将一个右值引用直接绑定到一个左值上,但是我们可以显式地将一个左值转换为对应的右值引用.我们还可以通过调用一个名为<code>move</code>的函数来获得绑定到左值上的右值引用.<strong><code>move</code>函数可以返回给定对象的右值引用</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1);     <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p><code>move</code>调用告诉编译器:我们有一个左值,但我们希望像一个右值一样处理它.调用<code>move</code>就意味着承诺:除了对<code>rr1</code>赋值或销毁它外,我们将不再使用它.在调用<code>move</code>之后,我们不能对移后源对象的值做任何假设.(我们可以销毁一个移后源对象,也可以赋予它新值,但不能使用一个移后源对象的值)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ explicit用法</title>
    <link href="/2023/03/13/Cpp-explicit%E7%94%A8%E6%B3%95/"/>
    <url>/2023/03/13/Cpp-explicit%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="explicit关键字">explicit关键字</h1><h2 id="explicit-作用">explicit 作用</h2><p>在 C++中, explicit 关键字用来修饰类的构造函数, 被修饰的构造函数的类,不能发生相应的隐式类型转换, 只能以显式的方式进行类型转换.</p><p>explicit 使用注意事项:</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上；</li><li>explicit 关键字作用于单个参数的构造函数 (多个参数也适用,但必须只有一个参数需要赋值, 其他的参数要有默认值).</li><li>在 C++ 中, explicit 关键字用来修饰类的构造函数,被修饰的构造函数的类, 不能发生相应的隐式类型转换.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();    <span class="hljs-comment">// default构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>)</span></span>;   <span class="hljs-comment">// default构造函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;  <span class="hljs-comment">// 不是default构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述的classesB和C的构造函数都被声明为explicit，这可以组织它们被用来执行隐式类型转换，但它们仍然可以被用来进行显式类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(B bObject)</span></span>;    <span class="hljs-comment">// 函数，接受一个为B的对象</span><br><br>B bObj1；         <span class="hljs-comment">//一个类型为B的对象</span><br><span class="hljs-built_in">doSomething</span>(bObj1);     <span class="hljs-comment">// 没问题，传递一个B给doSomething对象</span><br><span class="hljs-function">B <span class="hljs-title">bOBj2</span><span class="hljs-params">(<span class="hljs-number">28</span>)</span></span>;            <span class="hljs-comment">// 没问题，根据int 28建立一个B</span><br><br><span class="hljs-built_in">doSomething</span>(<span class="hljs-number">28</span>);        <span class="hljs-comment">// 错误！doSomething应该接受一个B，不是一个int，而int至B没有隐式转化</span><br><br><span class="hljs-built_in">doSomething</span>(<span class="hljs-built_in">B</span>(<span class="hljs-number">28</span>));     <span class="hljs-comment">// 没问题，使用B构造函数将int显式转换为一个B以促成此调用</span><br></code></pre></td></tr></table></figure><p>被声明为explicit二点构造函数通常比其non-explicit兄弟更受欢迎，因为它们禁止编译器执行非预期（往往不被预期）的类型转换。除非我有一个好的理由允许构造函数被用于隐式转换，否则我会把它声明为explicit。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL优先级队列</title>
    <link href="/2023/03/09/CppSTL%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/09/CppSTL%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="cstl优先级队列">C++STL优先级队列</h1><p>优先级队列是特殊的队列，它与queue的区别在于它可以定义队列中数据的优先级，让优先级高的排在队列前面，可以优先出队，它本质上是由堆实现的。</p><h2 id="定义">定义</h2><p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><ul><li>Type:数据类型</li><li>Container：容器类型(Container必须是用数组实现的容器，比如vector,deque等等，但不能用list。STL里面默认用的是vector)</li><li>Functional:比较的方式，当需要用自定义的数据类型时才需要传入第三个参数，使用基本数据类型时，只需要传入数据类型，其默认是<strong>大根堆</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//升序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<br></code></pre></td></tr></table></figure><p><code>greater</code>和<code>less</code>是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）。</p><h2 id="基本操作">基本操作</h2><p><code>priority_queue</code>的基本操作：</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// pair 先比较first，first相等然后再比较second</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; a;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)</span></span>;<br>    a.<span class="hljs-built_in">push</span>(d);<br>    a.<span class="hljs-built_in">push</span>(c);<br>    a.<span class="hljs-built_in">push</span>(b);<br>    <span class="hljs-keyword">while</span> (!a.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; a.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        a.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="自定义类型">自定义类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp1</span> <span class="hljs-comment">//运算符重载&lt;</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">tmp1</span>(<span class="hljs-type">int</span> a) &#123;x = a;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> tmp1&amp; a) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x &lt; a.x;     <span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-comment">// return x &gt; a.x   // 小根堆</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp2</span> <span class="hljs-comment">//重写仿函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(tmp1 a, tmp1 b)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.x &lt; b.x;    <span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-comment">// return a.x &gt; b.x  // 小根堆</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">tmp1 <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    priority_queue&lt;tmp1&gt; d;<br>    d.<span class="hljs-built_in">push</span>(b);<br>    d.<span class="hljs-built_in">push</span>(c);<br>    d.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span> (!d.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; d.<span class="hljs-built_in">top</span>().x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        d.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----&quot;</span>&lt;&lt; endl;<br>    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;<br>    f.<span class="hljs-built_in">push</span>(c);<br>    f.<span class="hljs-built_in">push</span>(b);<br>    f.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span> (!f.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        cout &lt;&lt; f.<span class="hljs-built_in">top</span>().x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        f.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">3<br>2<br><span class="hljs-section">1</span><br><span class="hljs-section">----</span><br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p>参考:<ahref="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列(priority_queue)用法详解</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算的妙用</title>
    <link href="/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2023/03/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算的妙用">位运算的妙用</h1><h2 id="异或运算实现变量交换">异或运算实现变量交换</h2><p>异或运算可以理解为<strong>无进位相加</strong>，异或运算的性质如下：</p><ul><li>0 ^ N = N</li><li>N ^ N = N</li><li>a ^ b = b ^ a (交换律)</li><li>a ^ b ^ c = a ^ (b ^ c) （结合律）</li></ul><p>异或运算的妙用：交换两个数的值不使用额外变量： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">17</span>, b = <span class="hljs-number">23</span>;<br><span class="hljs-comment">// 交换a，b的值</span><br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure></p><p>但是<strong>需要注意的是，可以这样使用的前提是a和b指向的内存是不同的，但是两个数的值可以相同。</strong>比如在一个数组中对nums[i]和nums[j]进行交换，要使用这种方法，必须要保证i和j相同，否则nums[i]位置上的数会被抹成0。所以一般情况下不推荐这种用法。</p><h2 id="异或运算查找出现奇数次的数">异或运算查找出现奇数次的数</h2><h3 id="只有一种数出现奇数次">只有一种数出现奇数次</h3><p>一个数组中只有一种数出现奇数次，其余的数都出现偶数次，那么如果寻找这个出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>就是出现奇数次的数。因为异或运算满足交换律，出现偶数次的数相互异或的结果为<spanclass="math inline">\(0\)</span>，出现奇数次的数相互异或的结果为这个数的值，所以总的结果就是这个出现奇数次的数。</p><h3 id="有两种数出现奇数次">有两种数出现奇数次</h3><p>一个数组中有两种数出现奇数次，其余的数都出现偶数次，那么如果寻找出现奇数次的数？</p><p>设置一个<span class="math inline">\(eor = 0\)</span>,然后让<spanclass="math inline">\(eor\)</span>与数组中的每个数都异或一遍，最后得到的<spanclass="math inline">\(eor\)</span>为a ^b。因为a和b是不同的数，所以必然有a ^ b <spanclass="math inline">\(\ne\)</span> 0,也就是a ^b的二进制至少有一位是1，那么假设a ^ b的二进制第8位为1，让<spanclass="math inline">\(eor\)</span>与数组中第8位为1的数异或，得到的<spanclass="math inline">\(eor^{&#39;}\)</span>就是a或b，再用<spanclass="math inline">\(eor^{&#39;}\)</span>与<spanclass="math inline">\(eor\)</span>异或得到的就是另外一个数。</p><p><img src="/img/算法/异或/查找数组中出现奇数次个数的数图解.png" /></p><p>因为a和b在第8为上的值一定是不一样的，所以肯定在不同的区域里，这样去用<spanclass="math inline">\(eor\)</span>异或第8位为1的数得到的就是a，b其中之一，出现偶数次的数不影响异或的结果。</p><p>那么就有一个问题，<strong>选哪一位的1？如何提取出这一位上的1？</strong>这里选择提取出a^ b最右边一位的1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>) <span class="hljs-comment">// 提取出eor最右侧的1</span><br></code></pre></td></tr></table></figure><p>将<spanclass="math inline">\(eor\)</span>用二进制表示就可以更直观的看出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">             eor = <span class="hljs-number">11001110</span>    <br>        ~eor + <span class="hljs-number">1</span> = <span class="hljs-number">00110010</span><br>eor &amp; (~eor + <span class="hljs-number">1</span>) = <span class="hljs-number">00000010</span> <span class="hljs-comment">// 提取出来最右侧的1</span><br></code></pre></td></tr></table></figure><h2 id="运算消去二进制最低位的1">&amp;运算消去二进制最低位的1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &amp; (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>因为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">    n = <span class="hljs-number">11001110</span><br>n - <span class="hljs-number">1</span> = <span class="hljs-number">11001101</span><br></code></pre></td></tr></table></figure><p>可以看到<code>n</code>的二进制中的高位的<spanclass="math inline">\(1\)</span>其实是不受<strong>减一</strong>操作的影响的，所以<code>n &amp; (n - 1)</code>就可以在不影响其他二进制位的情况下消去其最低位的<spanclass="math inline">\(1\)</span>。</p><p>那么就可以根据这个特性<strong>计算k的二进制1的个数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br>    n &amp;= n - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 每次消去二进制中最低位的1</span><br>    count++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求两个数的均值">求两个数的均值</h2><p>一般的写法是 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>但是这样并不是无懈可击的，可能会出现一个问题，当<code>low</code>和<code>high</code>都很大的时候<code>low + high</code>可能会溢出，这样结果就变成一个负数。更加好的写法是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><code>low</code>和<code>high</code>都没有溢出，那么<code>high - low</code>也不会溢出，这样结果就不会溢出。</p><p>更加简化的写法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++deque和queue</title>
    <link href="/2023/03/07/Cpp-deque%E5%92%8Cqueue/"/>
    <url>/2023/03/07/Cpp-deque%E5%92%8Cqueue/</url>
    
    <content type="html"><![CDATA[<h1 id="c-deque和queue">C++ deque和queue</h1><p>deque是双端队列，queue可以访问两端但是只能修改队头，而deque可以访问两端并且可以在队首和队尾删除和插入元素。</p><p>queue操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q； <span class="hljs-comment">//创建一个int型空队列q</span><br><br>q.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 将变量s从队尾入队</span><br>q.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">// 将队头元素弹出</span><br>q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 只返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();   <span class="hljs-comment">// 只返回队尾元素</span><br>q.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 返回队列中元素个数</span><br></code></pre></td></tr></table></figure><p>deque操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; dq； <span class="hljs-comment">// 创建一个数双端队列dq</span><br><br>dq.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判断队列是否为空，为空返回true</span><br>dq.<span class="hljs-built_in">push_front</span>(s); <span class="hljs-comment">//  将s从队头入队</span><br>dq.<span class="hljs-built_in">push_back</span>(s);    <span class="hljs-comment">// 将s从队尾入队，和普通队列方式一样</span><br>dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 只返回队头元素</span><br>dq.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 只返回队尾元素</span><br>dq.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 将队头元素弹出</span><br>dq.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 将队尾元素弹出</span><br>dq.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 将队列清空</span><br></code></pre></td></tr></table></figure><p>由于deque两端都可以压入，只用个push的话到底是用哪端压入呢？所以有了<code>push_back()</code>和<code>push_front()</code>,同样，<code>pop()</code>是弹出，所以有<code>pop_back()</code>和<code>pop_front()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++函数后冒号的含义</title>
    <link href="/2023/03/06/Cpp-%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2023/03/06/Cpp-%E5%87%BD%E6%95%B0%E5%90%8E%E5%86%92%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="c函数后冒号的含义">C++函数后冒号的含义</h1><h2 id="c-函数后面加一个冒号的含义">c++ 函数后面加一个冒号的含义</h2><p>冒号后面跟的是赋值，这种写法是C++的特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb ):<span class="hljs-built_in">a</span>(aa),<span class="hljs-built_in">b</span>(bb)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>( <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb )<br>&#123;<br>    a=aa;<br>    b=bb;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c构造函数后面的冒号">C++构造函数后面的冒号</h2><p>在C++类的构造函数中经常会看到如下格式的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><p>上述语句中单冒号(:)的作用是表示后面是初始化列表，一般有三种使用场景。</p><h3 id="对父类进行初始化">对父类进行初始化</h3><p>调用格式为“子类构造函数 :父类构造函数”，如下，其中QMainWindow是MyWindow的父类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyWindow::<span class="hljs-built_in">MyWindow</span>(QWidget* parent , Qt::WindowFlags flag) : <span class="hljs-built_in">QMainWindow</span>(parent,flag)<br></code></pre></td></tr></table></figure><h3 id="对类成员进行初始化">对类成员进行初始化</h3><p>调用格式为“构造函数 :A(初始值),B(初始值),C(初始值)……”，如下，其中A、B、C分别是类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">rectangle</span> <span class="hljs-comment">//头文件中类定义</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">rectangle</span>( <span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length);<br><span class="hljs-keyword">private</span>:<br>    CPoint m_point;<br>    <span class="hljs-type">int</span> m_Width;<br>    <span class="hljs-type">int</span> m_Length;<br>&#125;;<br> <br>rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length) : <span class="hljs-built_in">m_point</span>(pointX,pointY),<span class="hljs-built_in">m_Width</span>(Width),<span class="hljs-built_in">m_Length</span>(Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，上面构造函数的实现与下面的写法等价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">rectangle::<span class="hljs-built_in">rectangle</span>(<span class="hljs-type">int</span> pointX, <span class="hljs-type">int</span> pointY, <span class="hljs-type">int</span> Width, <span class="hljs-type">int</span> Length)<span class="hljs-comment">//源文件中构造函数实现</span><br>&#123;<br>    m_point.X = pointX;<br>    m_point.Y = pointY;<br>    m_Width   = Width;<br>    m_Length  = Length;<br>    todo......<br>&#125;<br></code></pre></td></tr></table></figure><h3id="对类的const成员变量进行初始化">对类的const成员变量进行初始化</h3><p>由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值。</p><h3 id="总结">总结</h3><p>对于第2、3种方式的应用场景，有以下两点说明：</p><ol type="1"><li><p>构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关。</p></li><li><p>相对于在构造函数中赋值，初始化列表执行效率更高。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常量、#define、const和constexpr</title>
    <link href="/2023/03/06/Cpp%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/"/>
    <url>/2023/03/06/Cpp%E4%B8%ADdefine%E3%80%81const%E5%92%8Cconstexpr/</url>
    
    <content type="html"><![CDATA[<h1id="c常量defineconst和constexpr">C++常量、#define、const和constexpr</h1><h2 id="常量">常量</h2><p>常量是固定值，在程序执行期间不会改变，可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值，常量的值在定义后不能进行修改；</p><p>可以使用枚举、#define、const和constexpr等方法定义常量.</p><h2 id="define">#define</h2><p>#define是预处理阶段进行处理，是一种宏定义，所以定义常量的宏是没有类型的，是在编译前即预编译阶段进行字符替换，并且由于是在预处理阶段替换所以不会有类型安全检查，系统也不会为它分配内存，存储在程序的代码段空间，实际就是给出了立即数，在运行过程中，常量在内存中会有若干个拷贝；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br></code></pre></td></tr></table></figure><p>如果只想常量宏只在某段代码起作用，则使用#undef这个常量宏，如果再用到了这个常量宏，编译器就会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Pi 3.1415926</span><br>S = Pi * r * r; <span class="hljs-comment">//这里Pi会替换成3.1415926</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span></span><br><br>S = Pi + <span class="hljs-number">1</span>; <span class="hljs-comment">//编译器报错</span><br></code></pre></td></tr></table></figure><h2 id="const">const</h2><p>const是一种Runtime，const常量会在内存中分配，可以是堆中也可以是栈中。以后在定义的常量调用时，只是使用对应的内存地址，不再开辟新的空间，在内存中只有一个拷贝，因此const相比#define，可以避免反复分配内存，节省空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> doulbe Pi=<span class="hljs-number">3.14159</span>;<br>S = Pi * r * r;<br></code></pre></td></tr></table></figure><h3 id="const修饰指针">const修饰指针</h3><p>const位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* test_ptr = &amp;test;<span class="hljs-comment">//禁止修改test_ptr指向的值, 可以修改test_ptr的值</span><br><span class="hljs-type">int</span> test2 = <span class="hljs-number">2</span>;<br>test_ptr = &amp;test2;<span class="hljs-comment">//指向另一个变量</span><br></code></pre></td></tr></table></figure><p>const位于<code>*</code>的右侧，const就是修饰指针本身，即指针本身是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> test = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> test_ptr = &amp;test;<br><br>*test_ptr = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 可以修改test_ptr指向的值, 禁止修改test_ptr的值</span><br></code></pre></td></tr></table></figure><h3 id="const修饰函数">const修饰函数</h3><p>在类中将成员函数修饰为const表明在该函数体内，不能修改对象的数据成员而且不能调用非const函数，由于非const函数可能修改数据成员，const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//fun1函数需要设置i的值，所以不能声明为const</span></span><br><span class="hljs-function">    </span>&#123;<br>i = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-comment">//fun2函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。</span></span><br><span class="hljs-function">    </span>&#123; <br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数参数">const修饰函数参数</h3><p>const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用;const指针可以接收非const和const指针，而非const指针只能接收非const指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> param)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰函数返回值">const修饰函数返回值</h3><p>const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员变量">const修饰成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> Test:: <span class="hljs-built_in">fun1</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">//i++; i不能修改</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="constexpr">constexpr</h2><p>constexpr与const一样，它可以应用于变量，不同的是可以应用于函数和类构造函数,constexpr指示值或返回值是常量，并且在可能的情况下，在编译时计算</p><h3 id="修饰变量">修饰变量</h3><p>const和constexpr之间的主要区别在于，const的初始化可以在到运行时，而constexpr编译时必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> :<br>        n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-built_in">exp</span>(x * x, n / <span class="hljs-number">2</span>) :<br>        <span class="hljs-built_in">exp</span>(x * x, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰构造函数">修饰构造函数</h3><p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy,<span class="hljs-type">int</span> zz)</span></span><br><span class="hljs-function">        :x(xx),y(yy),z(zz)&#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        :Base(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">constexpr</span> Base pt = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure><p>转载自<a href="https://zhuanlan.zhihu.com/p/473260243">C/C++常量、#define、const和constexpr</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛法:埃氏筛和欧拉筛</title>
    <link href="/2023/03/06/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
    <url>/2023/03/06/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%E4%B9%8B%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="质数数筛法">质数数筛法</h1><p>本文主要介绍埃氏筛法和欧拉筛法。</p><h2 id="判断单个数是不是质数">判断单个数是不是质数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(num==<span class="hljs-number">2</span> || num==<span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(num%<span class="hljs-number">6</span> != <span class="hljs-number">1</span> &amp;&amp; num%<span class="hljs-number">6</span> != <span class="hljs-number">5</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp = <span class="hljs-built_in">sqrt</span>(num);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">5</span>; i &lt;= tmp; i+=<span class="hljs-number">6</span>)<br><span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span> || num%(i+<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是当有很多个数需要判断的时候，每次都输入num判断是否是质数就很耗时了，这样提前将一个范围的质数算出来可以更节省时间，所以就用到了质数筛法。</p><h2 id="暴力筛法">暴力筛法</h2><p>学习埃氏筛之前，我们先看一下暴力筛法，即对每个数都用试除法判断其是不是质数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> st[N]; <span class="hljs-comment">// 初始化为0， 0表示质数，1表示合数</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i / j; j++)&#123;<span class="hljs-comment">//试除法</span><br><span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<br>st[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 合数，标记为1 </span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="埃式筛">埃式筛</h2><p>暴力筛法无疑是最慢的，我们看一下如何加快，换一种思路：一个质数的倍数一定是合数，所以，假设<spanclass="math inline">\(P\)</span>是质数，我们可以筛掉区间<spanclass="math inline">\([1,1e7]\)</span>中所有<spanclass="math inline">\(P\)</span>的倍数。 先看个例子，对于数列1~11：</p><p><img src="/img/算法/素数筛法/数1-11.png" /></p><p>先筛去2的倍数：</p><p><img src="/img/算法/素数筛法/筛去2倍数.png" /></p><p>再筛去3倍数：</p><p><img src="/img/算法/素数筛法/筛去3倍数.png" /></p><p>再筛去5倍数：</p><p><img src="/img/算法/素数筛法/筛去5倍数.png" /></p><p>至此，1~11内的所有合数都被筛完了， 2 3 5 7 11是数列中的质数。</p><p>为什么这样能筛去所有的合数呢，因为<strong>一个合数一定能被分解为几个质数的幂的乘积</strong>，并且这个数的质因子一定是小于它本身的，所以当我们从小到大将每个质数的倍数都筛去的话，当遍历到一个合数时，它一定已经被它的质因子给筛去了。</p><p>埃氏筛代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的时间复杂度为<span class="math inline">\(O(n\log{\log_2 n})\)</span></p><p>我们还可以对其进行优化：</p><ul><li>我们会先筛<spanclass="math inline">\(2\)</span>的所有倍数，然后筛<spanclass="math inline">\(3\)</span>的所有倍数，但筛除<spanclass="math inline">\(3\)</span>的倍数时，我们还是从<spanclass="math inline">\(3\)</span>的<spanclass="math inline">\(2\)</span>倍开始筛，其实<spanclass="math inline">\(3 * 2\)</span> ，已经被<spanclass="math inline">\(2 * 3\)</span>时筛过了。又比如说筛5的倍数时，我们从5的2倍开始筛，但是<spanclass="math inline">\(5 * 2\)</span>会先被<span class="math inline">\(2* 5\)</span>筛去， <span class="math inline">\(5 * 3\)</span>会先被<spanclass="math inline">\(3 * 5\)</span>会筛去，<spanclass="math inline">\(5 * 4\)</span>会先被<span class="math inline">\(2* 10\)</span>筛去，所以我们每一次只需要从<spanclass="math inline">\(i*i\)</span>开始筛，因为<spanclass="math inline">\((2，3,…,i - 1)\)</span>倍已经被筛过了。</li><li>另外，判断一个数 <spanclass="math inline">\(n\)</span>是不是质数，我们只判断<spanclass="math inline">\([2, \sqrt{n}]\)</span>内有没有它的因子。在筛合数的时候，我们也可以这样做，因为一个合数的最小质因子一定小于等于<span class="math inline">\(\sqrt{n}\)</span>。所以对于区间<spanclass="math inline">\([1, 1e7]\)</span>，最大的合数是 <spanclass="math inline">\(1e7\)</span>, 它的最小质因子一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>，区间内其他的合数的最小质因子也一定是小于等于 <spanclass="math inline">\(\sqrt{1e7}\)</span>的，所以只需要用<spanclass="math inline">\([1, \sqrt{1e7}]\)</span>中的质数就可以筛去 <spanclass="math inline">\([1, 1e7]\)</span>中所有的合数。</li></ul><p>优化后的埃式筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">E_sieve</span><span class="hljs-params">(<span class="hljs-type">int</span>  n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 注意循环条件i &lt;= n / i，为什么不直接成sqrt(n)?</span><br>    <span class="hljs-comment">// 写成这样的形式当i &gt;= sqrt(n) 时候依然可以停止循环，而且加减法需要几个时钟周期，乘法需要10几个时钟周期，除法需要2、3十个时钟周期，开根号需要8000个时钟周期，这样可以节省时间</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i)<br>    st[j] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// j是i的一个倍数，j是合数，筛掉。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的时间复杂度可以近似看成<spanclass="math inline">\(O(n)\)</span>了。</p><h2 id="欧拉筛">欧拉筛</h2><p>优化后的埃式筛时间复杂度可以<strong>近似</strong>看成<spanclass="math inline">\(O(n)\)</span>，但是欧拉筛可以比它更快，欧拉筛的时间复杂度是<spanclass="math inline">\(O(n)\)</span>，又被称为线性筛。</p><p>埃氏筛是筛去每个质数的倍数，但难免，会有合数会被其不同的质因子多次重复筛去。这就造成了时间浪费。</p><p>比如说： <span class="math inline">\(120 = 2^3 * 3 * 5\)</span>,<spanclass="math inline">\(120\)</span> 会被<spanclass="math inline">\(2\)</span>筛去一次， <spanclass="math inline">\(3\)</span>筛去一次， <spanclass="math inline">\(5\)</span>筛去一次。 多做了两次不必要的操作。</p><p>那么我们如何确保120只被2筛掉呢？在埃氏筛中我们用了一个循环来筛除一个质数的所有倍数，即对于p来说，筛除数列：<span class="math inline">\(2 * p , 3 * p, ... ,k*p\)</span>。另外，我们是从小到大枚举区间中的每个数的，数列是：<spanclass="math inline">\(2,3,4,...,n\)</span>。</p><p>对比两个数列：</p><p><span class="math display">\[\begin{align}    &amp;2 * p , 3 * p, ... , k*p \\    &amp;2,3,4,...,n\end{align}\]</span></p><p>会发现，第二个数列是第一个数列的系数,所以，我们不需要用一个for循环去筛除一个质数的所有倍数，我们将所有质数存储到<code>primes[]</code>中，然后枚举到第i个数时，就筛去所有的<code>primes[j] * i</code>。这样就在每一次遍历中，正好筛除了所有已知素数的<code>i</code>倍。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>;<br><span class="hljs-comment">//isPrime[i] == 1表示：i是素数</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-comment">//Prime存质数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//筛到n</span></span><br><span class="hljs-function"></span>&#123;<br>    Prime.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    isPrime.<span class="hljs-built_in">resize</span>(N, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//以“每个数都是素数”为初始状态，逐个删去</span><br>    isPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//1不是素数</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(isPrime[i])<span class="hljs-comment">//没筛掉 </span><br>        &#123;<br>            Prime.<span class="hljs-built_in">push_back</span>(i);<br>            ++cnt;<br>        &#125;<br>            <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n<span class="hljs-comment">/*不超上限*/</span>; j++) <br>        &#123;<br>            <span class="hljs-comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span><br>            <span class="hljs-comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span><br>            isPrime[i * Prime[j]] = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">if</span>(i % Prime[j] == <span class="hljs-number">0</span>)<span class="hljs-comment">//i中也含有Prime[j]这个因子</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//重要步骤。见原理</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意内层循环有一个<code>break</code>的条件<code>i % primes[j] == 0</code>,为什么呢？</p><p><strong>因为</strong>:</p><p>由</p><p><span class="math display">\[i \quad \% \quad primes[j] ==0\]</span></p><p>可得</p><p><span class="math display">\[primes[j] * k = i \tag{1}\]</span></p><p>设</p><p><span class="math display">\[primes[j] * k = X\tag{2}\]</span></p><p>将<span class="math inline">\((1)\)</span>代入到<spanclass="math inline">\((2)\)</span>中可得</p><p><span class="math display">\[primes[j+1] * primes[j] * k =X\]</span></p><p>因为<span class="math inline">\(primes[j+1] &gt;primes[j]\)</span>,所以<span class="math inline">\(primes[j+1] * k &gt;i\)</span>。</p><p>设</p><p><span class="math display">\[primes[j] * k = i^\prime\]</span></p><p>则</p><p><span class="math display">\[primes[j] * i^\prime =X\tag{3}\]</span></p><p>所以如果用<span class="math inline">\((2)\)</span>式筛去<spanclass="math inline">\(X\)</span>的话，当<spanclass="math inline">\(i\)</span>等于<spanclass="math inline">\(i&#39;\)</span>时，<spanclass="math inline">\(X\)</span>又会被<spanclass="math inline">\((3)\)</span>式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的<spanclass="math inline">\(i\)</span>, 所以不能提前筛。</p><p>比如说 <span class="math inline">\(1，2，3，4，5，6，7，8，9，10，11， 12\)</span>,当<code>i == 4</code> 时,<code>primes = &#123;2, 3&#125;</code>,此时 <code>i % 2 == 0</code>,如果不结束内层循环的话， <spanclass="math inline">\(12\)</span>会被<spanclass="math inline">\(3*4\)</span>筛掉， 当<code>i == 6</code>时，<spanclass="math inline">\(12\)</span>又会被<spanclass="math inline">\(2*6\)</span>筛掉。</p><p><strong>欧拉筛的核心思想就是确保每个合数只被最小质因数筛掉。或者说是被合数的最大因子筛掉。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++左值和右值</title>
    <link href="/2023/03/04/Cpp-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2023/03/04/Cpp-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="理解-cc-中的左值和右值">理解 C/C++ 中的左值和右值</h1><p>我们在 C/C++ 编程中并不会经常用到 <em>左值 (lvalue)</em> 和 <em>右值(rvalue)</em>两个术语。然而一旦遇见，又常常不清楚它们的含义。最可能出现两这个术语的地方是在编译错误或警告的信息中。例如，使用<code>gcc</code> 编译以下代码时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会得到：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">test</span>.c: <span class="hljs-keyword">In</span> function &#x27;main&#x27;:<br><span class="hljs-keyword">test</span>.c:8:5: <span class="hljs-keyword">error</span>: lvalue required <span class="hljs-keyword">as</span> left operand of assignment<br></code></pre></td></tr></table></figure><p>没错，这个例子有点夸张，不像是你能写出来的代码。不过错误信息中提到了左值(lvalue)。另一个例子是当你用 <code>g++</code> 编译以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在错误信息是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">testcpp.cpp: <span class="hljs-keyword">In</span> <span class="hljs-keyword">function</span> &#x27;<span class="hljs-title function_">int</span>&amp; <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#x27;:<br>testcpp.cpp:<span class="hljs-number">5</span>:<span class="hljs-number">12</span>: error: invalid initialization <span class="hljs-keyword">of</span> non-<span class="hljs-keyword">const</span> <span class="hljs-keyword">reference</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&amp;&#x27;</span> <span class="hljs-keyword">from</span> an rvalue <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的，错误信息中提到了术语右值 (rvalue)。那么，在 C 和 C++ 中，左值和 右值 到底是什么意思呢？我这篇文章将会详细解释。</p><h2 id="简单的定义">简单的定义</h2><p>这里我故意给出了一个 <strong>左值</strong> 和 <strong>右值</strong>的简化版定义。文章剩下的部分还会进行详细解释。</p><p><strong>左值 (lvalue, locator value)</strong>表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是左值 就是 右值 。那么，右值是一个<strong>不</strong>表示内存中某个可识别位置的对象的表达式。</p><h2 id="举例">举例</h2><p>上面的术语定义显得有些模糊，这时候我们就需要马上看一些例子。我们假设定义并赋值了一个整形变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var;<br>var = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>赋值操作需要左操作数是一个左值。<code>var</code>是一个有内存位置的对象，因此它是左值。然而，下面的写法则是错的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">4</span> = var;       <span class="hljs-comment">// 错误！</span><br>(var + <span class="hljs-number">1</span>) = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误！</span><br></code></pre></td></tr></table></figure><p>常量 <code>4</code> 和表达式 <code>var + 1</code>都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p><p>那么，我们就能理解第一个代码片段中的错误信息的含义了。<code>foo</code>返回的是一个临时的值。它是一个右值，赋值给它是错误的。因此当编译器看到<code>foo() = 2</code> 时，会报错——赋值语句的左边应当是一个左值。</p><p>然而，给函数返回的结果赋值，不一定总是错误的操作。例如，C++的引用让我们可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> globalvar = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> globalvar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>foo</code>返回一个引用。<strong>引用一个左值</strong>，因此可以赋值给它。实际上，C++中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符<code>[]</code>，来实现一些查找访问的操作，如 <code>std::map</code>中的方括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; mymap;<br>mymap[<span class="hljs-number">10</span>] = <span class="hljs-number">5.6</span>;<br></code></pre></td></tr></table></figure><p>之所以能赋值给 <code>mymap[10]</code>，是因为<code>std::map::operator[]</code> 的重载返回的是一个可赋值的引用。</p><h2 id="可修改的左值">可修改的左值</h2><p>左值一开始在 C 中定义为“可以出现在赋值操作左边的值”。然而，当 ISO C加入 <code>const</code> 关键字后，这个定义便不再成立。毕竟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// &#x27;a&#x27; 是左值</span><br>a = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 但不可以赋值给它！</span><br></code></pre></td></tr></table></figure><p>于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为<strong>可修改左值 (modifiable lvalues)</strong>。C99标准定义可修改左值为：</p><blockquote><p>可修改左值是特殊的左值，不含有数组类型、不完整类型、const修饰的类型。如果它是 <code>struct</code> 或<code>union</code>，它的成员都（递归地）不应含有 const 修饰的类型。</p></blockquote><h2 id="左值与右值间的转换">左值与右值间的转换</h2><p>通常来说，计算对象的值的语言成分，都使用右值作为参数。例如，两元加法操作符<code>'+'</code> 就需要两个右值参数，并返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;     <span class="hljs-comment">// a 是左值</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;     <span class="hljs-comment">// b 是左值</span><br><span class="hljs-type">int</span> c = a + b; <span class="hljs-comment">// + 需要右值，所以 a 和 b 被转换成右值</span><br>               <span class="hljs-comment">// + 返回右值</span><br></code></pre></td></tr></table></figure><p>在例子中，<code>a</code> 和 <code>b</code>都是左值。因此，在第三行中，它们经历了隐式的<strong>左值到右值转换</strong>。除了数组、函数、不完整类型的所有左值都可以转换为右值。</p><p>那右值能否转换为左值呢？当然不能！根据左值的定义，这违反了左值的本质。【注1：右值可以显式地赋值给左值。之所以没有隐式的转换，是因为右值不能使用在左值应当出现的位置。】</p><p>不过，右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符<code>'*'</code>需要一个右值参数，但返回一个左值结果。考虑这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;arr[<span class="hljs-number">0</span>];<br>*(p + <span class="hljs-number">1</span>) = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span><br></code></pre></td></tr></table></figure><p>相反地，一元取地址操作符 <code>'&amp;'</code>需要一个左值参数，返回一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* bad_addr = &amp;(var + <span class="hljs-number">1</span>); <span class="hljs-comment">// 错误: 一元 &#x27;&amp;&#x27; 操作符需要左值参数</span><br><span class="hljs-type">int</span>* addr = &amp;var;           <span class="hljs-comment">// 正确: var 是左值</span><br>&amp;var = <span class="hljs-number">40</span>;                  <span class="hljs-comment">// 错误: 赋值操作的左操作数需要是左值</span><br></code></pre></td></tr></table></figure><p>在 C++ 中 <code>'&amp;'</code>符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string&amp; sref = std::<span class="hljs-built_in">string</span>();  <span class="hljs-comment">// 错误: 非常量的引用 &#x27;std::string&amp;&#x27; 错误地使用右值 &#x27;std::string` 初始化</span><br></code></pre></td></tr></table></figure><p><strong>常量的</strong>左值引用可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得C++中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。</p><h2 id="cv-限定的右值">CV 限定的右值</h2><p>如果我们仔细阅读 C++ 标准中关于左值到右值的转换的部分【注2：在新的C++11 标准草稿的第 4.1 节】，我们会发现：</p><blockquote><p>一个非函数、非数组的类型 T 的左值可以转换为右值。 […] 如果 T不是类类型【译注：类类型即 C++中使用类定义的类型，区别与内置类型】，转换后的右值的类型是 T 的 未限定CV 的版本 (cv-unqualified version ofT)。其他情况下，转换后的右值类型就是 T 本身。</p></blockquote><p>什么叫做 “未限定 CV” (cv-unqualified) 呢？ <strong>CV 限定符</strong>这个术语指的是 <em>const</em> 和 <em>volatile</em> 两个类型限定符。C++标准的 3.9.3 节写到：</p><blockquote><p>每个类型都有三个对应的 CV-限定类型版本： <em>const 限定</em> 、<em>volatile 限定</em> 和 <em>const-volatile 限定</em> 版本。有或无 CV限定的不同版本的类型是不同的类型，但写法和赋值需求都是相同的。</p></blockquote><p>那么，这些又和右值有什么关系呢？在 C 中，只有左值有 CV限定的类型，而右值从来没有。而在 C++ 中，类右值可以有 CV限定的类型，但内置类型 (如 <code>int</code>)则没有。考虑下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo() const\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::foo()\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">cbar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(); &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bar</span>().<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// calls foo</span><br>    <span class="hljs-built_in">cbar</span>().<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// calls foo const</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code> 中的第二个函数调用实际上调用的是 <code>A</code>中的 <code>foo() const</code> 函数，因为 <code>cbar</code> 返回的类型是<code>const A</code>，这和 <code>A</code>是两个不同的类型。这就是上面的引用中最后一句话所表达的意思。另外注意到，<code>cbar</code>的返回值是一个右值，所以这是一个实际的 CV 限定的右值的例子。</p><h2 id="c11-的右值引用">C++11 的右值引用</h2><p>C++11 标准中引入的最强有力的特性就是右值引用，以及相关的 <em>移动语义(move semantics)</em>概念。这篇简短的文章没法完全讨论这个特性【注3：搜索 “rvalue references”可以找到很多相关的资料，几个个人认为有用的资料：<ahref="http://www.artima.com/cppsource/rvalue.html">这一篇</a>， <ahref="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x">这一篇</a>，特别是<ahref="http://thbecker.net/articles/rvalue_references/section_01.html">这一篇</a>】，但我想给出一个简单的例子。实际上，对左值和右值的理解可以帮助我们理解一些非平凡的语言概念。</p><p>这篇文章的大部分内容都在解释：左值和右值的主要区别是，左值可以被修改，而右值不能。不过，C++11改变了这一区别。在一些特殊的情况下，我们可以使用右值的引用，并对右值进行修改。</p><p>假设我们要实现一个“整数的vector”，一些相关的函数可能是这样定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Intvec</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Intvec</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        : m_size(num), m_data(new int[m_size])</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;constructor&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">Intvec</span>()<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;destructor&quot;</span>);<br>        <span class="hljs-keyword">if</span> (m_data) &#123;<br>            <span class="hljs-keyword">delete</span>[] m_data;<br>            m_data = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">Intvec</span>(<span class="hljs-type">const</span> Intvec&amp; other)<br>        : <span class="hljs-built_in">m_size</span>(other.m_size), <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size])<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy constructor&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_size; ++i)<br>            m_data[i] = other.m_data[i];<br>    &#125;<br><br>    Intvec&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Intvec&amp; other)<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy assignment operator&quot;</span>);<br>        <span class="hljs-function">Intvec <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>        std::<span class="hljs-built_in">swap</span>(m_size, tmp.m_size);<br>        std::<span class="hljs-built_in">swap</span>(m_data, tmp.m_data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> m_size;<br>    <span class="hljs-type">int</span>* m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样，我们定义了基本的构造器、析构器、拷贝构造器 (copy constructor)和拷贝赋值操作符 (copy assignment operator)【注4：拷贝赋值操作符的实现是在考虑异常安全角度的规范写法。结合使用拷贝构造器和不会抛出异常的<code>std::swap</code>，可以保证在异常发生时不会出现未初始化的内存】。它们都有一个logging 函数，让我们能知道是否调用了它们。</p><p>运行一个将 <code>v1</code> 的内容拷贝到 <code>v2</code> 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Intvec <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>Intvec v2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;assigning lvalue...\n&quot;</span>;<br>v2 = v1;<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning lvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>运行输出的结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">assigning lvalue...<br>[<span class="hljs-number">0</span>x28fef8] <span class="hljs-keyword">copy</span> assignment <span class="hljs-keyword">operator</span><br>[<span class="hljs-number">0</span>x28fec8] <span class="hljs-keyword">copy</span> <span class="hljs-keyword">constructor</span><br>[0<span class="hljs-title function_">x28fec8</span>] <span class="hljs-title function_">destructor</span><br><span class="hljs-title function_">ended</span> <span class="hljs-title function_">assigning</span> <span class="hljs-title function_">lvalue</span>...<br></code></pre></td></tr></table></figure><p>这是正常的结果，准确展示了 <code>operator=</code>的内部过程。但假设我们要将一个右值赋值给 <code>v2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;assigning rvalue...\n&quot;</span>;<br>v2 = <span class="hljs-built_in">Intvec</span>(<span class="hljs-number">33</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning rvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>虽然这里的例子中是赋值一个新创建的vector，但它可以代表更一般的情况——创建了一个临时的右值，然后赋值给<code>v2</code> （例如当一个函数返回 vector的情况）。我们会得到这样的输入：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fec8</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>这看起来就要很多步骤了。特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。然而，在拷贝赋值操作符中，也创建和销毁了<em>另一个</em> 临时的对象。这完全是多余的没有意义的工作。</p><p>不过现在你不需要多一个临时对象了。C++11引入了右值引用，让我们可以实现“移动语义” (movesemantics)，特别是可以实现“移动赋值操作符” (move assignment operator)【注5：文章中一直将 <code>operator=</code> 叫做 “拷贝赋值操作符” (copyassignment operator)。在 C++11中，区分这两个概念是很重要的】。我们可以为 <code>Intvec</code>加上另一个 <code>operator=</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">Intvec&amp; <span class="hljs-keyword">operator</span>=(Intvec&amp;&amp; other)<br>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;move assignment operator&quot;</span>);<br>    std::<span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>    std::<span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>符号 <code>&amp;&amp;</code> 代表了新的 <strong>右值引用 (rvaluereference)</strong>。顾名思义，右值引用可以让我们创建对右值的引用。而且在调用结束后，右值引用就会被销毁。我们可以利用这个特性将右值的内部内容“偷”过来——因为我们不再需要使用这个右值对象了！这样得到的输出是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">assigning rvalue...<br>[<span class="hljs-number">0</span>x28ff08] <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28fef8</span>] <span class="hljs-title">move</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function">[0<span class="hljs-title">x28ff08</span>] <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">ended</span> <span class="hljs-title">assigning</span> <span class="hljs-title">rvalue</span>...</span><br></code></pre></td></tr></table></figure><p>由于将一个右值赋值给了 <code>v2</code>，移动赋值操作符被调用。虽然<code>Intvec(33)</code>仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。优雅。</p><p>再提醒一遍，这个例子只展示了移动语义和右值引用的冰山一角。你可以猜到，这实际上是一个复杂的话题，要考虑很多特殊情况和陷阱。我是想展示一个C++中左值右值区别的一个很有趣的应用。编译器显然知道哪里是个右值，会在编译时选择调用合适的构造器。</p><h2 id="总结">总结</h2><p>即使不考虑左值和右值的问题，你也可以写很多 C++代码，然后把这些问题看作编译器某些错误警告中奇怪的行话。然而，这篇文章想表明，对这个问题有一些领悟的话，会使你能更深入地理解一些C++ 代码，也更能弄懂一些 C++ 规范和语言专家的讨论。</p><p>另外，在新的 C++ 规范中，因为 C++11引入了右值引用和移动语义，这个话题变得更重要了。要想真正理解这个语言的一些新特性，透彻地理解左值和右值就变得重要了。</p><p>转载自<ahref="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C">理解C/C++ 中的左值和右值</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ auto与decltype:类型推导</title>
    <link href="/2023/03/04/Cpp-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/03/04/Cpp-auto%E4%B8%8Edecltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="modern-c-之-auto-与-decltype-类型推导">Modern C++ 之 auto 与decltype : 类型推导</h1><h2 id="auto-与-decltype-类型推导"><code>auto</code> 与<code>decltype</code> : 类型推导</h2><p>变量类型推导其实在 C++ 中一直存在,例如我们在使用泛型函数时编译器将帮助我们隐式地推导参数类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(_Type value)</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">114514</span>);  <span class="hljs-comment">// func&lt;int&gt;(114514);</span><br></code></pre></td></tr></table></figure><p>但直到 C++11 起才允许用户主动要求编译器进行类型推导. 现代 C++中提供的主动类型推导功能主要是通过 <code>auto</code> 的<code>decltype</code> 两个关键字实现.</p><h2 id="使用-auto-进行变量类型推导">使用 <code>auto</code>进行变量类型推导</h2><p>当你声明一个变量为 <code>auto</code> 类型时,编译器将自动帮助你推导出合适的数据类型. 这个变量可以是 :</p><ol type="1"><li>声明后立即赋值的普通变量;</li><li>函数的返回值;</li><li>函数的形参 (C++14 起)</li></ol><p>需要注意的是, 使用 <code>auto</code> 进行类型推导时, 将忽略顶层的<code>const</code> , <code>&amp;</code> , <code>*</code> 等修饰符,以便用户更细化的控制推导, 示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">auto</span> var_1 = number;       <span class="hljs-comment">// int var_1 = number;</span><br><span class="hljs-keyword">auto</span> var_2 = <span class="hljs-number">8.0f</span>;         <span class="hljs-comment">// float var_2 = 8.0f;</span><br><span class="hljs-keyword">auto</span> var_3 = var_1;        <span class="hljs-comment">// int var_3 = var_1;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> var_4 = var_2;  <span class="hljs-comment">// const float var_4 = var_2;</span><br><span class="hljs-keyword">auto</span>&amp; var_5 = number;      <span class="hljs-comment">// int&amp; var_5 = number;</span><br></code></pre></td></tr></table></figure><p>这种基础的用法主要是用于省略一些很长的类型名,一定程度上增加代码可读性. 一种经典用法是简写迭代器类型以遍历容器, 传统C++ 中, 我们需要完整写出迭代器的类型或是使用局部的 <code>typedef</code>进行简写, 如下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::unordered_map&lt;std::string, std::string&gt; key_value_map;<br><span class="hljs-comment">// C++98/03, 迭代器遍历容器完整写法</span><br><span class="hljs-keyword">for</span> (std::unordered_map&lt;std::string, std::string&gt;::const_iterator itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++98/03, 使用迭代器别名进行缩写</span><br><span class="hljs-keyword">typedef</span> std::unordered_map&lt;std::string, std::string&gt;::const_iterator unordered_map_const_itor;<br><span class="hljs-keyword">for</span> (unordered_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>而现代 C++ 中, 一方面我们通常使用 <code>using</code> 代替<code>typedef</code>, 但更方便的方式是使用 <code>auto</code>简写迭代器类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, 使用 using 代替 typedef</span><br><span class="hljs-keyword">using</span> hash_map_const_itor = std::unordered_map&lt;std::string, std::string&gt;::const_iterator;<br><span class="hljs-keyword">for</span> (hash_map_const_itor itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++11 起, 使用 auto 自动推导迭代器类型</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itor = key_value_map.<span class="hljs-built_in">begin</span>(); itor != key_value_map.<span class="hljs-built_in">end</span>(); itor++) <br>&#123;<br>  std::cout &lt;&lt; itor-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itor-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们稍微引申一下, 在现代 C++ 中迭代一个容器的方式还有很多,具体可见下面的例子 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++11 起, auto + 范围 for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++17 起, auto + 范围 for 循环 + 结构化绑定</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map) <br>&#123;<br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// C++20 起, auto + 范围 for 循环 + 结构化绑定 + range 机制, 细化控制方式 (MSVC /std:c++laest)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::all) <span class="hljs-comment">// 全部遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::reverse) <span class="hljs-comment">// 全部倒序遍历</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [first, second] : key_value_map | std::views::<span class="hljs-built_in">drop</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 顺序遍历忽略前两个</span><br>&#123;  <br>  std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了普通的变量外, 我们还可以使用 <code>auto</code> 设置函数的返回值,此时需要我们在参数列表后使用 <code>-&gt;</code>符号标注具体的返回值类型. 这种写法被称作"返回类型后置语法",在一些脚本语言中比较常见 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>-&gt;<span class="hljs-type">int</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br><br><span class="hljs-comment">// 引申 : lambda 表达式的书写格式借鉴了返回值后置语法</span><br><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>到了 C++14, 我们甚至可以使用 <code>auto</code> 进行参数类型推导,在传统 C++ 中我们想进行参数类型的推导需要用到泛型机制, 但有了<code>auto</code> 进行推导参数类型后, 我们可以简化一些工作 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(_Type value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br><span class="hljs-comment">// C++20</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_value</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p><code>auto</code> 关键字在单独使用时, 大部分是用于简化书写当它与其它机制结合使用时可以衍生出更多的功能, 同样在下文里细说.</p><h2 id="使用-decltype-进行表达式类型推导">使用 <code>decltype</code>进行表达式类型推导</h2><p><code>auto</code> 关键字用于推导变量类型, 与之相对的<code>decltype</code> 则是用来推导表达式结果的类型. 熟悉 GCC的用户可能对这个关键字不陌生, <code>decltype</code> 的标准化提案就是源自GCC 的扩展关键字 <code>__decltype</code>, 而后者又是源自于 GCC一个很古老的扩展关键字 <code>__typeof__</code> .例如你可能需要推导某两个变量相加的结果类型 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> number_a = <span class="hljs-number">16LL</span>;                                          <span class="hljs-comment">// long long number_a = 16LL;</span><br><span class="hljs-keyword">auto</span> number_b = <span class="hljs-number">16.0F</span>;                                         <span class="hljs-comment">// float number_b = 16.0F;</span><br><span class="hljs-keyword">decltype</span>(number_a + number_b) number_c = number_a + number_b;  <span class="hljs-comment">// float number_c = number_a + number_b;</span><br></code></pre></td></tr></table></figure><p><code>decltype</code> 的推导规则遵循如下几点 :</p><ol type="1"><li>若表达式是一个 <strong>不带括号的标记符表达式</strong> 或<strong>类/结构体成员访问表达式</strong>,那么推导的结果是所代表实体的类型;</li><li>若表达式是一个<strong>函数调用(包括操作符重载)</strong>,那么推导的结果是函数的返回类型, 若返回值是基础类型则抛弃<code>const</code> 限定符;</li><li>若表达式是一个<strong>字符串字面量</strong>, 则推到为<code>const</code> 左值引用;</li><li>上述情况以外, 若表达式结果为左值则推导为左值引用,否则推导为本类型;</li></ol><p>示例见下 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> number = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> const_number = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> number_array[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span>* number_array_ptr = number_array;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123; <span class="hljs-type">double</span> member; &#125; my_struct;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">bool</span> <span class="hljs-title">func_1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;;<br><span class="hljs-function"><span class="hljs-type">const</span> MyStruct <span class="hljs-title">func_2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyStruct</span>(); &#125;;<br><br><span class="hljs-comment">// 规则 1 : 不带括号的标记符表达式 或 类/结构体成员访问表达式</span><br><span class="hljs-keyword">decltype</span>(number_array) var_1;      <span class="hljs-comment">// int[2] var_1; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number_array_ptr) var_2;  <span class="hljs-comment">// int*   var_2; 标记符表达式 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(my_struct.member) var_3;  <span class="hljs-comment">// double var_3; 成员访问表达式 =&gt; 本类型</span><br><br><span class="hljs-comment">// 规则 2 : 函数调用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_1</span>(<span class="hljs-number">1</span>)) var_5 = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// bool var_5; 基础类型返回值, 丢弃 const 限定符</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>)) var_7 = <span class="hljs-built_in">func_2</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// const MyStruct var_7; 类类型返回值, 保留 const 限定符</span><br><br><span class="hljs-comment">// 规则 3 : 字符串字面量</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-string">&quot;hello&quot;</span>) var_8 = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">//const char&amp; var_8[6]; const 左值引用</span><br><br><span class="hljs-comment">// 规则 4 : 其他情况下表达式结果</span><br><span class="hljs-keyword">decltype</span>((number)) var_9 = number;                 <span class="hljs-comment">// int&amp; var_9; 带括号的标记符表达式 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? number : number) var_10 = number;  <span class="hljs-comment">// int&amp; var_10; 条件表达式返回左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(++number) var_11 = number;                <span class="hljs-comment">// int&amp; var_11; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(number_array[<span class="hljs-number">5</span>]) var_12 = number;         <span class="hljs-comment">// int&amp; var_12; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(*number_array_ptr) var_13 = number;       <span class="hljs-comment">// int&amp; var_13; 表达式结果为左值 =&gt; 左值引用</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>) var_14 = <span class="hljs-number">10</span>;                           <span class="hljs-comment">// int var_14; 纯右值字面量 =&gt; 本类型</span><br><span class="hljs-keyword">decltype</span>(number++) var_15 = number;                <span class="hljs-comment">// int var_15; 表达式结果为右值 =&gt; 本类型</span><br></code></pre></td></tr></table></figure><p>你可能在部分平台上使用过关键字 <code>typeof</code> ,<code>__typeof__</code> 或 <code>__decltype</code> ,它们同样可用于推导表达式结果类型, 并且可以视作 <code>decltype</code>功能的子集. 但这些关键字从来都不是标准 C++ 的一部分,只是部分编译器支持的功能, 并且它们的推导规则也有很强的平台差异性.相比之下 <code>decltype</code> 的标准化程度和适用面更广. 除此之外<code>typeof</code> 进行类型推导时 <code>&amp;</code>引用符号很可能将不做保留, 至少 GCC 上是这样的, 参考以下示例 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>           var = <span class="hljs-number">1</span>; <br><span class="hljs-type">int</span>&amp;          ref = var; <br><span class="hljs-built_in">typeof</span>(var)   var_1 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-built_in">typeof</span>(ref)   var_2 = <span class="hljs-number">1</span>;  <span class="hljs-comment">// int GCC 4.3.x</span><br><span class="hljs-keyword">decltype</span>(var) var_3;      <span class="hljs-comment">// int </span><br><span class="hljs-keyword">decltype</span>(ref) var_4 = a;  <span class="hljs-comment">// int&amp; </span><br></code></pre></td></tr></table></figure><p>总之, 当你的工程所使用的 C++ 版本若是等于或高于 C++11 ,我推荐全盘使用 <code>decltype</code> 代替 <code>typeof</code> .</p><h2 id="结合-auto-与-decltype-进行自动推导返回值类型">结合<code>auto</code> 与 <code>decltype</code> 进行自动推导返回值类型</h2><p><code>auto</code> 与 <code>decltype</code> 单独使用的时候,在功能上的突破本质还是向用户开放了主动要求类型推导的权限.但如果二者结合使用的话, 就可以突破传统 C++ 中一些限制了.在这里我们思考一个问题 : <strong>如何实现一个满足所有类型之间进行<code>+</code> 运算的函数?</strong></p><p>在传统 C++ 中的最优解是这样的 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++98/03</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function">_TypeResult <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法的确可以满足所有类型的 <code>+</code> 运算,但很明显使用上有着很大的局限性. 因为我们必须预知返回值的类型,而题目的隐藏含义是一定要做到通用性的. 那么我们现在已经知道如何使用<code>decltype</code> 可以进行表达式结果的类型推导,那何不直接用其直接推导函数体的结果呢 ?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span> <span class="hljs-comment">// 未定义的标识符</span></span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>很遗憾这种行为是无效的, 因为形式参的定义在参数列表里,而处于参数列表左侧的返回值类型是无法获取形参名的.除非我们能将返回值类型放在参数列表的右侧, 实现这个目标的方式就是使用<code>auto</code> 书写返回类型后置语法 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// auto 返回类型后置语法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight, <span class="hljs-keyword">typename</span> _TypeResult&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;_TypeResult </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br><span class="hljs-comment">// auto 返回类型后置语法 结合 decltype 表达式结果类型推导</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _TypeLeft, <span class="hljs-keyword">typename</span> _TypeRight&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(_TypeLeft left, _TypeRight right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><p>若只是单纯的只用 <code>auto</code> 进行返回类型后置,则只是换了种语法. 但如果将 <code>auto</code> 与 <code>decltype</code>相结合, 就可以突破传统 C++ 的限制了. 到此,我们已经完全实现了题目里的需求. 但还有继续优化的空间,首先是上文中提到的, 自 C++14 起, 我们可以利用 <code>auto</code>进行参数类型的推导 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(left + right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p>其次是由于这种二者结合的模式被大量的使用, 自 C++14 起, 我们在使用<code>auto</code> 描述返回类型时无需在参数列表后写上返回类型,编译器将自动通过函数体进行推导, 因此这个方法最终将演化成这种形式 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> left, <span class="hljs-keyword">auto</span> right)</span> </span>&#123; <span class="hljs-keyword">return</span> left + right; &#125;<br></code></pre></td></tr></table></figure><p><strong>引申 : 上例中的 "最终版本" 真的完美吗?</strong></p><blockquote><p>返回类型后置这种语法看似只是语法上的一些取巧手法,但实则通过这种方式可以突破编译器的桎梏,因为编译器始终是由上至下由左至右理解代码的.</p></blockquote><p>正如上文中所说, <code>auto</code> 与 <code>decltype</code>的功能并不是现代 C++ 才出现的,而且在它们单独使用时更多的时候是一种简化代码书写的方式.但当二者结合起来时, 将可以做出一些语言功能上的突破.</p><h2 id="auto-与-decltype-的演化"><code>auto</code> 与<code>decltype</code> 的演化</h2><p>传统 C++ 里, 类型推导一般是在模板传参时进行隐式类型推导, 而<code>auto</code> 的出现是将类型推导的控制权开放给用户进行显示类型推导;而传统 C++ 里表达式结果类型的推导通常由不同平台上各种<code>typeof</code> 非标准扩展关键字实现, 而 <code>decltype</code>的出现则是这个功能的标准化. 当 <code>auto</code> 与<code>decltype</code> 相结合后, 由衍生出许多新的功能, 它们二者构成了现代C++ 类型推导功能的核心. 以下的 <code>auto</code> 与<code>decltype</code> 的发展历程简述 :</p><ol type="1"><li>C++11 :<ul><li>允许使用 <code>auto</code> 进行普通变量的主动类型推导;</li><li>允许使用 <code>auto</code> 书写返回值后置语法;</li><li>使用标准 <code>decltype</code> 进行表达式结果类型推导以替代各平台的<code>typeof</code> 扩展关键字;</li></ul></li><li>C++14 :<ul><li>允许使用 <code>auto</code> 进行形参类型推导;</li><li>允许使用 <code>auto</code> 进行返回值类型推导(书写返回值后置语法时不适用类型标识符表面返回类型);</li></ul></li></ol><p>内容转载自 <ahref="http://brabbit.xyz/blog/NoteModernCpp/p3_auto_deltype.html">ModernC++ 之 auto 与 decltype : 类型推导</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="详解-c-11-中的智能指针">详解 C++ 11 中的智能指针</h2><p>C/C++语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在C/C++语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如boost，智能指针技术应运而生。</p><h4 id="c-9803-的尝试stdauto_ptr">C++ 98/03 的尝试——std::auto_ptr</h4><p>在 2022 年讨论 <strong>std::auto_ptr</strong>不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11标准的出现（最新标准是 C++20），<strong>std::auto_ptr</strong>已经被彻底废弃了，取而代之是<strong>std::unique_ptr</strong>。然而，我之所以还向你介绍一下<strong>std::auto_ptr</strong> 的用法以及它的设计不足之处是想让你了解C++语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它，不是吗？</p><p><strong>std::auto_ptr</strong> 的基本用法如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化方式1</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-comment">//初始化方式2</span><br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">8</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针对象 <strong>sp1</strong> 和 <strong>sp2</strong>均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在<strong>sp1</strong> 和 <strong>sp2</strong> 释放时得到释放。这是<strong>std::auto_ptr</strong> 的基本用法。</p><div class="admonition info"><p class="admonition-title">info</p><p>sp 是 smart pointer（智能指针）的简写。</p></div><p><strong>std::auto_ptr</strong>真正让人容易误用的地方是其不常用的复制语义，即当复制一个<strong>std::auto_ptr</strong> 对象时（拷贝复制或 operator =复制），原对象所持有的堆内存对象也会转移给复制出来的对象。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试拷贝构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    <span class="hljs-keyword">if</span> (sp1.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp2.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">//测试赋值构造</span><br>    <span class="hljs-function">std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">8</span>))</span></span>;<br>    std::auto_ptr&lt;<span class="hljs-type">int</span>&gt; sp4;<br>    sp4 = sp3;<br>    <span class="hljs-keyword">if</span> (sp3.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sp4.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is not empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp4 is empty.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中分别利用拷贝构造（sp1 =&gt; sp2）和 赋值构造（sp3 =&gt;sp4）来创建新的 std::auto_ptr 对象，因此 sp1 持有的堆对象被转移给sp2，sp3 持有的堆对象被转移给 sp4。我们得到程序执行结果如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[root@iZ238vnojlyZ testx]<span class="hljs-comment"># g++ -g -o test_auto_ptr test_auto_ptr.cpp</span><br>[root@iZ238vnojlyZ testx]<span class="hljs-comment"># ./test_auto_ptr </span><br>sp1 <span class="hljs-keyword">is</span> empty.<br>sp2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br>sp3 <span class="hljs-keyword">is</span> empty.<br>sp4 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty.<br></code></pre></td></tr></table></figure><p>由于 <strong>std::auto_ptr</strong>这种不常用的复制语义，我们应该避免在 stl 容器中使用<strong>std::auto_ptr</strong>，例如我们绝不应该写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; myvectors;<br></code></pre></td></tr></table></figure><p>当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误。</p><p>以史为鉴，作为 <strong>std::auto_ptr</strong> 的替代者<strong>std::unique_ptr</strong>吸取了这个经验教训。下文会来详细介绍。</p><p>正因为 <strong>std::auto_ptr</strong> 的设计存在如此重大缺陷，C++11标准在充分借鉴和吸收了 boost库中智能指针的设计思想，引入了三种类型的智能指针，即<strong>std::unique_ptr</strong>、<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong>。</p><div class="admonition info"><p class="admonition-title">info</p><p>boost 还有 scoped_ptr，C++11并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。</p></div><p>所有的智能指针类（包括 std::unique_ptr）均包含于头文件<strong>memery</strong> 中。</p><div class="admonition info"><p class="admonition-title">info</p><p>正因为存在上述设计上的缺陷，在 C++11及后续语言规范中 std::auto_ptr已经被废弃，你的代码不应该再使用它。</p></div><h4 id="stdunique_ptr">std::unique_ptr</h4><p><strong>std::unique_ptr</strong>对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是1，<strong>std::unique_ptr</strong>对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个<strong>std::unique_ptr</strong> 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>你应该尽量使用初始化方式 3 的方式去创建一个<strong>std::unique_ptr</strong> 而不是方式 1 和 2，因为形式 3更安全，原因 Scott Meyers 在其《Effective ModernC++》中已经解释过了，有兴趣的读者可以阅读此书相关章节。</p><div class="admonition info"><p class="admonition-title">info</p><p>令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared()方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique()方法创建一个 std::unique_ptr 对象，这个方法直到 C++14才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp; ...params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></td></tr></table></figure><p>鉴于 <strong>std::auto_ptr</strong>的前车之鉴，<strong>std::unique_ptr</strong>禁止复制语义，为了达到这个效果，<strong>std::unique_ptr</strong>类的拷贝构造函数和赋值运算符（operator =）被标记为<strong>delete</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//省略其他代码...</span><br><br>    <span class="hljs-comment">//拷贝构造函数和赋值运算符被标记为delete</span><br>    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，下列代码是无法通过编译的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;;<br><br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//std::unique_ptr&lt;int&gt; sp2(sp1);</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><span class="hljs-comment">//以下代码无法通过编译</span><br><span class="hljs-comment">//sp3 = sp1;</span><br></code></pre></td></tr></table></figure><p>禁止复制语义也存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(val))</span></span>;<br>    <span class="hljs-keyword">return</span> up;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp1 = <span class="hljs-built_in">func</span>(<span class="hljs-number">123</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码从 func 函数中得到一个 <strong>std::unique_ptr</strong>对象，然后返回给 sp1。</p><p>既然 <strong>std::unique_ptr</strong> 不能复制，那么如何将一个<strong>std::unique_ptr</strong>对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>))</span></span>;<br><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(std::move(sp1))</span></span>;<br><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>    sp3 = std::<span class="hljs-built_in">move</span>(sp2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码利用 std::move 将 sp1 持有的堆内存（值为 123）转移给sp2，再把 sp2 转移给 sp3。最后，sp1 和 sp2不再持有堆内存的引用，变成一个空的智能指针对象。并不是所有的对象的std::move 操作都有意义，只有实现了移动构造函数（MoveConstructor）或移动赋值运算符（operator =）的类才行，而<strong>std::unique_ptr</strong> 正好实现了这二者，以下是实现伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Deletor&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>&#123;<br>    <span class="hljs-comment">//其他函数省略...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_pT = rhs.m_pT;<br>        <span class="hljs-comment">//源对象释放</span><br>        rhs.m_pT = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T*    m_pT;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是 <strong>std::unique_ptr</strong>具有移动语义的原因，希望读者可以理解之。关于移动构造和<strong>std::move</strong>，我们将在后面章节详细介绍。</p><p><strong>std::unique_ptr</strong>不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建10个int类型的堆对象</span><br>    <span class="hljs-comment">//形式1</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br>    <span class="hljs-comment">//形式2</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; sp2;<br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]);<br>    <span class="hljs-comment">//形式3</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(std::make_unique&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">10</span>))</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        sp1[i] = i;<br>        sp2[i] = i;<br>        sp3[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        std::cout &lt;&lt; sp1[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp2[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; sp3[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># g++ -g -o test_unique_ptr_with_array test_unique_ptr_with_array.cpp -std=c++17</span><br>[root<span class="hljs-symbol">@myaliyun</span> testmybook]<span class="hljs-meta"># ./test_unique_ptr_with_array </span><br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span><br><span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span><br><span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span><br><span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span><br><span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span><br><span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span><br><span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>也可以持有一组堆对象，用法与 <strong>std::unique_ptr</strong>相同，下文不再赘述。</p><p><strong>自定义智能指针对象持有的资源的释放函数</strong></p><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete或者delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个Socket类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以<strong>std::unique_ptr</strong> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    ~<span class="hljs-built_in">Socket</span>()<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//关闭资源句柄</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> deletor = [](Socket* pSocket) &#123;<br>        <span class="hljs-comment">//关闭句柄</span><br>        pSocket-&gt;<span class="hljs-built_in">close</span>();<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span><br>        <span class="hljs-keyword">delete</span> pSocket;<br>    &#125;;<br><br>    <span class="hljs-function">std::unique_ptr&lt;Socket, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(Socket * pSocket)</span>&gt; <span class="hljs-title">spSocket</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Socket(), deletor)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义 <strong>std::unique_ptr</strong> 的资源释放函数其规则是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;T, DeletorFuncPtr&gt;<br></code></pre></td></tr></table></figure><p>其中 T 是你要释放的对象类型，DeletorPtr是一个自定义函数指针。上述代码 <strong>33</strong> 行表示 DeletorPtr有点复杂，我们可以使用 <strong>decltype(deletor)</strong>让编译器自己推导 deletor 的类型，因此可以将 <strong>33</strong>行代码修改为：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">std</span>::unique_ptr&lt;<span class="hljs-type">Socket</span>, decl<span class="hljs-keyword">type</span>(deletor)&gt; spSocket(new <span class="hljs-type">Socket</span>(), deletor);<br></code></pre></td></tr></table></figure><h4 id="stdshared_ptr">std::shared_ptr</h4><p><strong>std::unique_ptr</strong> 对其持有的资源具有独占性，而<strong>std::shared_ptr</strong> 持有的资源可以在多个<strong>std::shared_ptr</strong> 之间共享，每多一个<strong>std::shared_ptr</strong> 对资源的引用，资源引用计数将增加1，每一个指向该资源的 <strong>std::shared_ptr</strong>对象析构时，资源引用计数减 1，最后一个 <strong>std::shared_ptr</strong>对象析构时，发现资源计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作<strong>std::shared_ptr</strong>引用的对象是安全的）。<strong>std::shared_ptr</strong> 提供了一个<strong>use_count()</strong>方法来获取当前持有资源的引用计数。除了上面描述的，<strong>std::shared_ptr</strong>用法和 <strong>std::unique_ptr</strong> 基本相同。</p><p>下面是一个初始化 <strong>std::shared_ptr</strong> 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化方式1</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br><br><span class="hljs-comment">//初始化方式2</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">123</span>));<br><br><span class="hljs-comment">//初始化方式3</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br>sp3 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>和 <strong>std::unique_ptr</strong> 一样，你应该优先使用<strong>std::make_shared</strong> 去初始化一个<strong>std::shared_ptr</strong> 对象。</p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//初始化方式1</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//初始化方式2</span><br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        sp2.<span class="hljs-built_in">reset</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        &#123;<br>            std::shared_ptr&lt;A&gt; sp3 = sp1;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码 <strong>22</strong> 行 sp1 构造时，同时触发对象 A的构造，因此 A 的构造函数会执行；</li><li>此时只有一个 sp1 对象引用 <strong>22</strong> 行 new 出来的 A对象（为了叙述方便，下文统一称之为<strong>资源对象A</strong>），因此代码 <strong>24</strong> 行打印出来的引用计数值为<strong>1</strong>；</li><li>代码 <strong>27</strong> 行，利用 sp1 拷贝一份 sp2，导致代码<strong>28</strong> 行打印出来的引用计数为 <strong>2</strong>；</li><li>代码 <strong>30</strong> 行调用 sp2 的 reset() 方法，sp2释放对资源对象 A 的引用，因此代码 <strong>31</strong>行打印的引用计数值再次变为 <strong>1</strong>；</li><li>代码 <strong>34</strong> 行 利用 sp1 再次 创建 sp3，因此代码<strong>35</strong> 行打印的引用计数变为 <strong>2</strong>；</li><li>程序执行到 <strong>36</strong> 行以后，sp3 出了其作用域被析构，资源A 的引用计数递减 1，因此 代码 <strong>38</strong> 行打印的引用计数为<strong>1</strong>；</li><li>程序执行到 <strong>39</strong> 行以后，sp1出了其作用域被析构，在其析构时递减资源 A 的引用计数至<strong>0</strong>，并析构资源 A 对象，因此类 A 的析构函数被调用。</li></ul><p>所以整个程序的执行结果如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# ./test_shared_ptr_use_count <br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">use</span> <span class="hljs-title">count</span>:</span> <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>use count: <span class="hljs-number">2</span><br>use count: <span class="hljs-number">1</span><br>A <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure><p><strong>std::enable_shared_from_this</strong></p><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个<strong>std::shared_ptr</strong> 对象给外部使用，C++新标准也为我们考虑到了这一点，有如此需求的类只要继承自<strong>std::enable_shared_from_this</strong>模板对象即可。用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">getSelf</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，类 A 的继承 <strong>std::enable_shared_from_this</strong>并提供一个 <strong>getSelf()</strong> 方法返回自身的<strong>std::shared_ptr</strong> 对象，在 <strong>getSelf()</strong>中调用 <strong>shared_from_this()</strong> 即可。</p><p><strong>std::enable_shared_from_this</strong>用起来比较方便，但是也存在很多不易察觉的陷阱。</p><p><strong>陷阱一：不应该共享栈对象的 this 给智能指针对象</strong></p><p>假设我们将上面代码 main 函数 <strong>25</strong> 行生成 A对象的方式改成一个栈变量，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//其他相同代码省略...</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br><br>    std::shared_ptr&lt;A&gt; sp2 = a.<span class="hljs-built_in">getSelf</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行修改后的代码会发现程序在<code>std::shared_ptr sp2 = a.getSelf();</code>产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过<strong>shared_from_this()</strong>将该对象交由智能指针对象管理。切记：<strong>智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</strong>。</p><p><strong>陷阱二：避免 std::enable_shared_from_this的循环引用问题</strong></p><p>再来看另外一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// test_std_enable_shared_from_this.cpp : This file contains the &#x27;main&#x27; function. Program execution begins and ends there.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;A&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">9</span>;<br>        <span class="hljs-comment">//注意:</span><br>        <span class="hljs-comment">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span><br>        <span class="hljs-comment">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        m_i = <span class="hljs-number">0</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_SelfPtr = <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>                 m_i;<br>    std::shared_ptr&lt;A&gt;  m_SelfPtr;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">spa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        spa-&gt;<span class="hljs-built_in">func</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[root@myaliyun testmybook]# g++ -g -o test_std_enable_shared_from_this_problem test_std_enable_shared_from_this_problem.cpp<br>[root@myaliyun testmybook]# ./test_std_enable_shared_from_this_problem<br>A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br></code></pre></td></tr></table></figure><p>我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏了！</p><p>我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到<strong>42</strong> 行后，spa出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁A。这就是所谓的 std::enable_shared_from_this的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。也就是说一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理。</p><h4 id="stdweak_ptr">std::weak_ptr</h4><p><strong>std::weak_ptr</strong>是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助<strong>std::shared_ptr</strong> 工作。</p><p><strong>std::weak_ptr</strong> 可以从一个<strong>std::shared_ptr</strong> 或另一个 <strong>std::weak_ptr</strong>对象构造，<strong>std::shared_ptr</strong> 可以直接赋值给<strong>std::weak_ptr</strong> ，也可以通过<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 函数来获得<strong>std::shared_ptr</strong>。它的构造和析构不会引起引用计数的增加或减少。<strong>std::weak_ptr</strong>可用来解决 <strong>std::shared_ptr</strong>相互引用时的死锁问题（即两个<strong>std::shared_ptr</strong>相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放）。</p><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个std::shared_ptr对象</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">123</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过构造函数得到一个std::weak_ptr对象</span><br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过赋值运算符得到一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3 = sp1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span><br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp4 = sp2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># g++ -g -o test_weak_ptr test_weak_ptr.cpp </span><br>[root<span class="hljs-variable">@myaliyun</span> testmybook]<span class="hljs-comment"># ./test_weak_ptr</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">use</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>无论通过何种方式创建 <strong>std::weak_ptr</strong>都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。</p><p>既然，<strong>std::weak_ptr</strong>不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？<strong>std::weak_ptr</strong>提供了一个 <strong>expired()</strong> 方法来做这一项检测，返回true，说明其引用的资源已经不存在了；返回false，说明该资源仍然存在，这个时候可以使用<strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 方法得到一个<strong>std::shared_ptr</strong>对象然后继续操作资源，以下代码演示了该用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span><br><span class="hljs-comment">//tmpConn_引用的TcpConnection已经销毁，直接返回</span><br><span class="hljs-keyword">if</span> (tmpConn_.<span class="hljs-built_in">expired</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (conn)<br>&#123;<br>    <span class="hljs-comment">//对conn进行操作，省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有读者可能对上述代码产生疑问，既然使用了<strong>std::weak_ptr</strong> 的 <strong>expired()</strong>方法判断了对象是否存在，为什么不直接使用 <strong>std::weak_ptr</strong>对象对引用资源进行操作呢？实际上这是行不通的，<strong>std::weak_ptr</strong>类没有重写 <strong>operator-&gt;</strong> 和 <strong>operator</strong>*方法，因此不能像 <strong>std::shared_ptr</strong> 或<strong>std::unique_ptr</strong> 一样直接操作对象，同时<strong>std::weak_ptr</strong> 类也没有重写 <strong>operator!</strong>操作，因此也不能通过 <strong>std::weak_ptr</strong>对象直接判断其引用的资源是否存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><br>    <span class="hljs-function">std::weak_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (sp1)<br>    &#123;<br>        <span class="hljs-comment">//正确代码</span><br>        sp1 -&gt; <span class="hljs-built_in">doSomething</span>();<br>        (*sp1).<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//正确代码</span><br>    <span class="hljs-keyword">if</span> (!sp1)<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    //错误代码，无法编译通过</span><br>    <span class="hljs-comment">//    sp2-&gt;doSomething();</span><br>    <span class="hljs-comment">//    (*sp2).doSomething();</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//错误代码，无法编译通过</span><br>    <span class="hljs-comment">//if (!sp2)</span><br>    <span class="hljs-comment">//&#123;</span><br><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以 <strong>std::weak_ptr</strong>不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦。</p><p>因此，<strong>std::weak_ptr</strong>的正确使用场景是那些资源如果可用就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时Session 对象如果强行持有 Connection 对象与事实矛盾。</p><p><strong>std::weak_ptr</strong>的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubscribeManager</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publish</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; iter : m_subscribers)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!iter.<span class="hljs-built_in">expired</span>())<br>            &#123;<br>                <span class="hljs-comment">//TODO：给订阅者发送消息</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt;   m_subscribers;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="智能指针对象的大小">智能指针对象的大小</h4><p>一个 <strong>std::unique_ptr</strong> 对象大小与裸指针大小相同（即sizeof(std::unique_ptr<T>) == sizeof(void*)），而<strong>std::shared_ptr</strong> 的大小是<strong>std::unique_ptr</strong> 的两倍。以下是我分别在 Visual Studio2019 和 gcc/g++ 4.8 上（二者都编译成 x64 程序）的测试结果：</p><p><strong>测试代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp0;<br>    std::shared_ptr&lt;std::string&gt; sp1;<br>    sp1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>());<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; sp2;<br>    std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; sp3;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp0 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp0) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp1) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp2 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sp3 size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(sp3) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Visual Studio 2019 运行结果：</p><p><img src="/img/C++/智能指针/sp1.webp" /></p><p>gcc/g++ 运行结果：</p><p><img src="/img/C++/智能指针/sp2.webp" /></p><p>在 32 位机器上，<strong>std_unique_ptr</strong> 占 4字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 8 字节；在 64 位机器上，<strong>std_unique_ptr</strong> 占 8字节，<strong>std::shared_ptr</strong> 和 <strong>std::weak_ptr</strong>占 16 字节。也就是说，<strong>std_unique_ptr</strong>的大小总是和原始指针大小一样，<strong>std::shared_ptr</strong> 和<strong>std::weak_ptr</strong> 大小是原始指针的两倍。</p><h4 id="智能指针使用注意事项">智能指针使用注意事项</h4><p>C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++新标准中的各种智能指针是如此的实用与强大，在现代 C++项目开发中，读者应该尽量去使用它们。智能指针虽然好用，但稍不注意，也可能存在许多难以发现的bug，这里我根据经验总结了几条：</p><ul><li><p>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</p><p>看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subscriber</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-keyword">delete</span> pSubscriber;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针spSubscriber去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象<strong>spSubscriber</strong> 情何以堪啊？</p><p>记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。当然，除了<strong>std::weak_ptr</strong>，<strong>std::unique_ptr</strong> 和<strong>std::shared_ptr</strong>都提供了获取原始指针的方法——<strong>get()</strong> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  Subscriber* pSubscriber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Subscriber</span>();<br><br>  <span class="hljs-function">std::unique_ptr&lt;Subscriber&gt; <span class="hljs-title">spSubscriber</span><span class="hljs-params">(pSubscriber)</span></span>;<br><br>  <span class="hljs-comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span><br>  Subscriber* pTheSameSubscriber= spSubscriber.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分清楚场合应该使用哪种类型的智能指针；</p><p>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用<strong>std::unique_ptr</strong>，反之使用<strong>std::shared_ptr</strong>，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用<strong>std::weak_ptr</strong>。</p></li><li><p>认真考虑，避免操作某个引用资源已经释放的智能指针；</p><p>前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;T do something...&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> m_i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; sp2 = sp1;<br><br>  sp1.<span class="hljs-built_in">reset</span>();<br><br>  <span class="hljs-comment">//由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为</span><br>  sp2-&gt;<span class="hljs-built_in">doSomething</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即<strong>operator-&gt;</strong>）在内部会调用 <strong>get()</strong>方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用doSomething() 导致程序崩溃。</p><p>你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//连接断开</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MonitorServer::OnClose</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;TcpConnection&gt;&amp; conn)</span></span><br><span class="hljs-function"></span>&#123;    <br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(m_sessionMutex)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = m_sessions.<span class="hljs-built_in">begin</span>(); iter != m_sessions.<span class="hljs-built_in">end</span>(); ++iter)<br>  &#123;<br>      <span class="hljs-comment">//通过比对connection对象找到对应的session</span><br>      <span class="hljs-keyword">if</span> ((*iter)-&gt;<span class="hljs-built_in">GetConnectionPtr</span>() == conn)<br>      &#123;<br>          m_sessions.<span class="hljs-built_in">erase</span>(iter);<br>          <span class="hljs-comment">//注意这里：程序在此处崩溃</span><br>          <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;monitor client disconnected: %s&quot;</span>, conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码不是我杜撰的，而是来自于我实际的一个商业项目中。注意代码中我提醒注意的地方，该段程序会在代码<strong>12</strong> 行处崩溃，崩溃原因是调用了<code>conn-&gt;peerAddress()</code>方法。为什么这个方法的调用可能会引起崩溃？现在可以一目了然地看出了吗？</p><p>崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个<strong>std::shared_ptr</strong> 的引用，当连接断开时，对应的TcpConnection 对象可能早已被销毁，而 conn引用就会变成空指针（严格来说是不再拥有一个 TcpConnection对象），此时调用 TcpConnection 的 peerAddress()方法就会产生和上一个示例一样的错误。</p></li><li><p>作为类成员变量时，应该优先使用前置声明（forwarddeclarations）</p><p>我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C/C++项目中一般在 *.h文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:<br>  A*      m_pA;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>();<br>  ~<span class="hljs-built_in">Test</span>();<br><br><span class="hljs-keyword">private</span>:  <br>  std::unique_ptr&lt;A&gt;  m_spA;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>C++ 新标准中的智能指针我想介绍的就这么多了，Modern C/C++ 已经变为C/C++开发的趋势，希望读者能善用和熟练使用本节介绍的后三种智能指针对象。</p><p>转载自 <ahref="https://github.com/balloonwj/CppGuide/blob/master/articles/C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AF%A6%E8%A7%A3C++11%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md">详解C++11中的智能指针</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL 容器以及常用操作</title>
    <link href="/2023/03/02/CppSTL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/03/02/CppSTL%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="vector容器">vector容器</h2><p>C++ STL vector是一个动态数组容器，它可以在运行时调整大小，并且支持随机访问。以下是vector 常用的基本操作：</p><h3 id="创建vector">创建vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;             <span class="hljs-comment">// 创建一个空 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size)</span></span>;       <span class="hljs-comment">// 创建一个大小为 size 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size, value)</span></span>;<span class="hljs-comment">// 创建一个大小为 size，并且所有元素都初始化为 value 的 vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;        <span class="hljs-comment">// 创建一个副本 vector，v2 和 v1 中的元素相同</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v3 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 创建一个初始元素分别为1 2 3的vector</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3.begin() + <span class="hljs-number">1</span>, ilist.end() - <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 用v3的某个范围元素初始化v4</span><br></code></pre></td></tr></table></figure><h3 id="访问-vector-元素">访问 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index];                 <span class="hljs-comment">// 访问第 index 个元素</span><br>v.<span class="hljs-built_in">at</span>(index);              <span class="hljs-comment">// 访问第 index 个元素，并且进行边界检查</span><br>v.<span class="hljs-built_in">front</span>();                <span class="hljs-comment">// 访问第一个元素</span><br>v.<span class="hljs-built_in">back</span>();                 <span class="hljs-comment">// 访问最后一个元素</span><br>v.<span class="hljs-built_in">data</span>();                 <span class="hljs-comment">// 返回指向 vector 数据的指针</span><br></code></pre></td></tr></table></figure><h3 id="修改-vector-元素">修改 vector 元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">v[index] = value;         <span class="hljs-comment">// 修改第 index 个元素为 value</span><br>v.<span class="hljs-built_in">at</span>(index) = value;      <span class="hljs-comment">// 修改第 index 个元素为 value，并且进行边界检查</span><br>v.<span class="hljs-built_in">emplace_back</span>(value);       <span class="hljs-comment">// 在 vector 的末尾插入一个元素</span><br>v.<span class="hljs-built_in">pop_back</span>();             <span class="hljs-comment">// 删除 vector 的末尾元素</span><br>v.<span class="hljs-built_in">insert</span>(iterator, value);<span class="hljs-comment">// 在 iterator 指定的位置插入 value</span><br>v.<span class="hljs-built_in">erase</span>(iterator);        <span class="hljs-comment">// 删除 iterator 指定的元素</span><br>v.<span class="hljs-built_in">clear</span>();                <span class="hljs-comment">// 删除 vector 中所有的元素</span><br>v.<span class="hljs-built_in">resize</span>(size);           <span class="hljs-comment">// 修改 vector 的大小为 size，如果原来的大小比 size 大，则删除后面的元素，否则增加默认值的元素</span><br>v.<span class="hljs-built_in">resize</span>(size, value);    <span class="hljs-comment">// 修改 vector 的大小为 size，并且用 value 进行初始化，如果原来的大小比 size 大，则删除后面的元素，否则增加 value 的元素</span><br></code></pre></td></tr></table></figure><h3 id="vector-容量操作">vector 容量操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">v.<span class="hljs-built_in">size</span>();                 <span class="hljs-comment">// 返回 vector 中元素的个数</span><br>v.<span class="hljs-built_in">capacity</span>();             <span class="hljs-comment">// 返回 vector 可以存储的元素的数量，也就是预留的空间</span><br>v.<span class="hljs-built_in">empty</span>();                <span class="hljs-comment">// 如果 vector 为空，返回 true，否则返回 false</span><br>v.<span class="hljs-built_in">reserve</span>(capacity);      <span class="hljs-comment">// 预留 capacity 的存储空间</span><br>v.<span class="hljs-built_in">shrink_to_fit</span>();        <span class="hljs-comment">// 释放 vector 多余的存储空间</span><br></code></pre></td></tr></table></figure><h3 id="vector-遍历操作">vector 遍历操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="两个元素之间的范围">两个元素之间的范围</h3><p>我们知道，作用于同一容器的 2个同类型迭代器可以有效指定一个区间范围。在此基础上，如果想获取该指定范围内包含元素的个数，就可以借助distance() 函数。</p><p>distance()函数用于计算两个迭代器表示的范围内包含元素的个数，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>&gt;<br>  <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="hljs-function">difference_type <span class="hljs-title">distance</span> <span class="hljs-params">(InputIterator first, InputIterator last)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，first 和 last都为<strong>迭代器</strong>，其类型可以是输入迭代器、前向迭代器、双向迭代器以及随机访问迭代器；该函数会返回[first,last)范围内包含的元素的个数。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// distance</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span>         <span class="hljs-comment">// list</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">//创建一个空 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist;<br><span class="hljs-comment">//向空 list 容器中添加元素 0~9</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>mylist.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//指定 2 个双向迭代器，用于执行某个区间</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator first = mylist.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//指向元素 0</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator last = mylist.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//指向元素 9 之后的位置</span><br><span class="hljs-comment">//获取 [first,last) 范围内包含元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;distance() = &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(first, last);<br></code></pre></td></tr></table></figure><h3 id="查找某个值所在位置">查找某个值所在位置</h3><p>使用 std::find()方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-type">int</span> key = <span class="hljs-number">6</span>;<br> <br>    std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator itr = std::<span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), key);<br> <br>    <span class="hljs-keyword">if</span> (itr != v.<span class="hljs-built_in">cend</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element present at index &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(v.<span class="hljs-built_in">begin</span>(), itr);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找最大元素和最小元素">查找最大元素和最小元素</h3><p><code>max_element()</code>函数是算法标头的库函数，用于查找范围中的最大元素，它接受容器范围[start，end]，并返回一个迭代器，该迭代器指向给定范围中具有最大值的元素。</p><p><strong>参数</strong>：</p><ul><li>iterator start, iterator end,容器开始和结束位置;</li><li>[compare comp]，可选参数，可以与给定范围内的元素进行比较。</li></ul><p><strong>返回值</strong>:</p><p>iterator -返回一个迭代器，该迭代器指向给定范围内具有最大值的元素。</p><p><code>min_element()</code>同理，参数用法也相同，不同的是它返回的是最小元素的迭代器。</p><h2 id="stack容器">stack容器</h2><p>C++ STL 标准库中的 stack是一个后进先出（LIFO）的容器适配器，它可以使用不同的底层容器（默认使用deque）实现。以下是 stack 常用的基本操作：</p><h3 id="创建-stack">创建 stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>std::stack&lt;<span class="hljs-type">int</span>&gt; s;       <span class="hljs-comment">// 创建一个空 stack</span><br><span class="hljs-function">std::stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;   <span class="hljs-comment">// 创建一个副本 stack，s1 和 s 中的元素相同</span><br>std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; s2; <span class="hljs-comment">// 创建一个底层容器为 vector 的 stack</span><br></code></pre></td></tr></table></figure><h3 id="stack-元素操作">stack 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">s.<span class="hljs-built_in">emplace</span>(value);       <span class="hljs-comment">// 将 value 压入 stack 顶部</span><br>s.<span class="hljs-built_in">pop</span>();                <span class="hljs-comment">// 弹出 stack 顶部的元素</span><br>s.<span class="hljs-built_in">top</span>();                <span class="hljs-comment">// 返回 stack 顶部的元素</span><br>s.<span class="hljs-built_in">empty</span>();              <span class="hljs-comment">// 如果 stack 为空，返回 true，否则返回 false</span><br>s.<span class="hljs-built_in">size</span>();               <span class="hljs-comment">// 返回 stack 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-stack">遍历 stack</h3><p>stack 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历stack。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = s.<span class="hljs-built_in">top</span>();<br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 stack 时，一定要判断 stack 是否为空，否则会发生undefined behavior。</p><h2 id="queue容器">queue容器</h2><p>C++ STL 标准库中的 queue是一个先进先出（FIFO）的容器适配器，它也可以使用不同的底层容器（默认使用deque）实现。以下是 queue 常用的基本操作：</p><h3 id="创建-queue">创建 queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;           <span class="hljs-comment">// 创建一个空 queue</span><br><span class="hljs-function">std::queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q1</span><span class="hljs-params">(q)</span></span>;       <span class="hljs-comment">// 创建一个副本 queue，q1 和 q 中的元素相同</span><br>std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q2;  <span class="hljs-comment">// 创建一个底层容器为 list 的 queue</span><br></code></pre></td></tr></table></figure><h3 id="queue-元素操作">queue 元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">q.<span class="hljs-built_in">emplace</span>(value);           <span class="hljs-comment">// 将 value 插入 queue 尾部</span><br>q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-comment">// 弹出 queue 头部的元素</span><br>q.<span class="hljs-built_in">front</span>();                  <span class="hljs-comment">// 返回 queue 头部的元素</span><br>q.<span class="hljs-built_in">back</span>();                   <span class="hljs-comment">// 返回 queue 尾部的元素</span><br>q.<span class="hljs-built_in">empty</span>();                  <span class="hljs-comment">// 如果 queue 为空，返回 true，否则返回 false</span><br>q.<span class="hljs-built_in">size</span>();                   <span class="hljs-comment">// 返回 queue 中元素的个数</span><br></code></pre></td></tr></table></figure><h3 id="遍历-queue">遍历 queue</h3><p>queue 是不支持迭代器的容器，因此我们只能通过弹出元素的方式遍历queue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：在遍历 queue 时，一定要判断 queue 是否为空，否则会发生undefined behavior。</p><h2 id="unordered_map容器">unordered_map容器</h2><p>unordered_map定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = std::hash&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Pred = std::equal_to&lt;Key&gt;,<br>    <span class="hljs-keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> Key, Ty&gt; &gt; &gt;<br>    <span class="hljs-keyword">class</span> unordered_map;<br>    &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">unordered_map</span><br></code></pre></td></tr></table></figure><ul><li><strong>第1个参数</strong>:存储key值。</li><li><strong>第2个参数</strong>:存储mapped value。</li><li><strong>第3个参数</strong>:为哈希函数的函数对象。它将key作为参数，并利用函数对象中的哈希函数返回类型为size_t的唯一哈希值。默认值为std::hash&lt;key &gt;。</li><li><strong>第4个参数</strong>:为等比函数的函数对象。它内部通过等比操作符’=='来判断两个key是否相等，返回值为bool类型。默认值是std::equal_to&lt;key &gt;。</li></ul><p>基本操作</p><h3 id="插入元素">插入元素</h3><p>一种插入的特殊情况是，unordered_map插入的<strong>值</strong>是int类型(key的类型无所谓)，这时候可以用第二种方式插入:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="删除元素">删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-comment">// 删除</span><br>    mymap.<span class="hljs-built_in">erase</span>(mymap.<span class="hljs-built_in">begin</span>());    <br>    mymap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>    mymap.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找元素">查找元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> </span><br><span class="hljs-function"></span>&#123;<br>    <br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    hash_map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">//数组插入</span><br>    hash_map[<span class="hljs-number">0</span>]++;                <span class="hljs-comment">//键值插入</span><br><br>    <span class="hljs-keyword">if</span>(hash_map.<span class="hljs-built_in">find</span>(key) != hash_map.<span class="hljs-built_in">end</span>())       <span class="hljs-comment">// 查找</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;True&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;False&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="unordered_set容器">unordered_set容器</h2><p>C++ STL 中的 unordered_set是一个关联容器，它提供了一种存储唯一元素的无序集合。与 set不同，unordered_set内部的元素是无序的，因此在插入和查找时，它的性能通常比有序的关联容器 set更快。</p><p>以下是一些 unordered_set 的基本用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个 unordered_set 对象</span><br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 使用 find() 方法查找元素</span><br>    <span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (it != mySet.<span class="hljs-built_in">end</span>())<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;<br>    <span class="hljs-keyword">else</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 count() 方法检查元素是否在 unordered_set 中</span><br>    <span class="hljs-keyword">if</span> (mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">4</span>) &gt; <span class="hljs-number">0</span>) <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;4 is in the set&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历 unordered_set 中的所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; element : mySet)<br>        std::cout &lt;&lt; element &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Found <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the <span class="hljs-built_in">set</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在 unordered_set中，元素的顺序是不确定的，因此输出的结果可能与上面的示例不完全一致。</p><h2 id="stl中emplace和push的区别">STL中emplace和push的区别</h2><p>在 C++ STL 标准库中，容器中的 <code>emplace()</code> 和<code>push()</code>都可以用来向容器中添加新元素。但是它们的底层实现和作用不同。</p><h3 id="push">push()</h3><p><code>push()</code>是一个成员函数，用于将一个已经构造好的元素加入到容器的尾部，即将元素的副本或引用添加到容器中。因此，需要将元素先构造出来，再将其加入容器中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这里的 <code>push_back()</code> 函数首先构造了一个 int类型的元素，然后将其加入到了 vector 的尾部。</p><h3 id="emplace">emplace()</h3><p><code>emplace()</code>是一个可变参数模板函数，它在容器的尾部直接构造一个新的元素，而不需要将元素构造出来再加入容器。因此，它比<code>push()</code> 更加高效。</p><p>例如，对于 vector 容器来说，下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt; v;<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure><p>将直接在 vector 的尾部构造一个 <code>pair&lt;int, double&gt;</code>类型的元素，而不需要先构造一个 <code>pair&lt;int, double&gt;</code>对象，然后再将其加入到 vector 中。</p><h3 id="总结">总结</h3><ul><li><code>emplace()</code> 可以直接在容器中构造新的元素，而<code>push()</code> 需要先将元素构造出来，再加入到容器中。</li><li><code>emplace()</code> 更加高效，因为它省去了元素构造的过程，而<code>push()</code> 则需要先构造元素，再将其加入容器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉树">什么是二叉树</h2><p>二叉树是一种常见的数据结构，它是每个节点至多有两棵子树的树。</p><p>二叉树有两种特殊的形式，满二叉树和完全二叉树。</p><p><strong>满⼆叉树</strong>：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆叉树为满⼆叉树。一棵深度为k的满二叉树节点个数为<spanclass="math inline">\(2^k -1\)</span>。</p><p><strong>完全⼆叉树</strong>：至多只有最下面的两层结点的度数可以小于2,并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。</p><p><img src="/img/算法/二叉树/完全二叉树和满二叉树.png" /></p><p>我们可以看出满二叉树是完全二叉树， 但完全二叉树不一定是满二叉树。</p><h2 id="二叉搜索树二叉排序树">二叉搜索树（二叉排序树）</h2><p>二叉排序树虽然名叫排序树，但是它其实是用来搜索的，是一种有序的二叉树。它遵循着左小右大的规则：</p><ul><li>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；</li><li>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；</li><li>它的左、右⼦树也分别为⼆叉搜索树。</li></ul><p><img src="/img/算法/二叉树/二叉排序树.jpg" /></p><h2 id="平衡二叉树">平衡二叉树</h2><p>二叉搜索树有一个缺点，在插入数据是有序的序列（包括升序和降序），会导致二叉树退化成链表，从而导致在查找，删除，添加时的性能均从O（logN）降低为O（N），这是不能接受的。</p><p>究其原因，是因为二叉搜索树退化成链表的时候，树的高度与节点的个数相等，也就是成正比，所以为了优化这种情况，就出现了具有平衡能力的二叉搜索树，其中AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O（logN）。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G.M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm forthe organization of information》中公开了这一数据结构。</p><p><strong>平衡二叉树的性质</strong></p><p>平衡二叉树本质上是特殊的二叉搜索树（二叉排序树），它具有二叉搜索树所有的特点，此外它有自己的特别的性质，如下：</p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>平衡二叉树的左右两个子树都是一棵平衡二叉树。</li></ul><p>平衡因子指的是，平衡二叉树在保持平衡的时候，是通过平衡因子来判断的</p><p><span class="math display">\[节点的平衡因子 = 该节点的左子树的高度 -该节点右子树的高度\]</span></p><p>只有当值等于-1（右子树的高度大），0（左右子树的高度相等），1（左子树的高度大）的时候，能够代表该子树是平衡的除此之外，就认为该节点已经失衡了，需要旋转来维持平衡。</p><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的遍历是对于理解二叉树以及应对二叉树问题必不可少的因素，甚至有很多算法问题都是基于二叉树的不同遍历算法来做的。</p><p>二叉树的遍历有多种实现方式，不同的方式这里都要熟练掌握，只有熟练掌握不同的遍历方式才能以不变应万变来应对不同的问题。</p><h3 id="递归法">递归法</h3><p>很简单，不需要多说，二叉树的前序、中序、后序遍历其实都是一个模板，区别在于它们将当前节点值添加到结果数组<code>res</code>的时间不一样，而这种区别是由不同遍历方式下父节点与子节点的遍历次序导致的。</p><h4 id="前序遍历">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">oreOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    res.<span class="hljs-built_in">emplace_back</span>(res -&gt; val, res);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; left);<br>    <span class="hljs-built_in">preOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">inOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; left, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>    <span class="hljs-built_in">inOrder</span>(root -&gt; right, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历">后序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-built_in">postOrder</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; left, res);<br>    <span class="hljs-built_in">postOrder</span>(root -&gt; right, res);<br>    res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="迭代法">迭代法</h3><h4 id="前序遍历-1">前序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="中序遍历-1">中序遍历</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h4 id="后序遍历-1">后序遍历</h4><p>迭代法的后序遍历相比较前序遍历和中序遍历是要麻烦一些的。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    stack&lt;TreeNode*&gt; stk;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// stk.emplace(cur);</span><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur -&gt; left;<br>        &#125;<br>        cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; cur -&gt; right != pre)<br>        &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);   <span class="hljs-comment">// 若右孩子存在且没有遍历过那么将cur重新压栈，访问右子树</span><br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            pre = cur;<br>            cur = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>,其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，为迭代过程中显式栈的开销，平均情况下为<span class="math inline">\(O(\log n)\)</span>，最坏情况下树呈现链状，为<span class="math inline">\(O(n)\)</span>。</li></ul><h3 id="morris法">Morris法</h3><p>Morris法只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979年的论文「Traversing Binary Trees Simply andCheaply」中首次提出，因此被称为 Morris 遍历。</p><h4 id="前序遍历-2">前序遍历</h4><p>Morris遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下（假设当前遍历到的节点为<code>cur</code>）:</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>,然后将<code>cur</code>加入答案。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树。<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>这样我们利用 Morris遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)      <span class="hljs-comment">// 左子节点为空直接将val加入res中</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;  <br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h4 id="中序遍历-2">中序遍历</h4><p>Morris法的中序遍历与前序遍历的思想是相同的，不同的是在当前节点的左孩子存在时的处理方式不同，思路如下（假设当前遍历到的节点为<code>cur</code>）：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，将<code>cur</code>加入答案，并遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空，然后将当<code>cur</code>加入答案。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li><li>重复步骤 1 和步骤 2，直到遍历结束。</li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root,* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左子节点为空直接遍历右子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左子节点不为空寻找cur的前驱节点</span><br>        &#123;<br>            pre = cur -&gt; left;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 前驱节点右指针为空说明还没有遍历过cur的左子树</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>            &#125;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明已经遍历过cur的左子树，将前驱节点右指针重新设置为空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>其中 <span class="math inline">\(n\)</span>为二叉搜索树的节点个数。Morris遍历中每个节点会被访问两次，因此总时间复杂度为 <spanclass="math inline">\(O(2n)=O(n)\)</span>。</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>。</li></ul><h4 id="后序遍历-2">后序遍历</h4><p>后续遍历思路依然同上，不同的仍然是把<code>cur</code>加入答案的时机，思路如下：</p><ol type="1"><li>如果<code>cur</code>的左子节点为空，遍历<code>cur</code>的右子节点；</li><li>如果<code>cur</code>的左子节点不为空，在<code>cur</code>的左子树中找到<code>cur</code>在中序遍历下的前驱节点：<ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为<code>cur</code>。<code>cur</code>更新为<code>cur</code>的左子节点。</li><li>如果前驱节点的右子节点不空，也就是前驱节点的右子节点为<code>cur</code>，说明我们已经遍历完<code>cur</code>的左子树，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。然后将<code>cur</code>更新为<code>cur</code>的右子节点。</li></ul></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, TreeNode* root)</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(root -&gt; val);<br>        root = root -&gt; right;<br>        count++;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">end</span>() - count, res.<span class="hljs-built_in">end</span>());<br> &#125;<br><br> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br><br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        pre = cur -&gt; left;<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 左孩子不空寻找cur左子树的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; right != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; right != cur)<br>                pre = pre -&gt; right;<br>            <span class="hljs-keyword">if</span>(pre -&gt; right == <span class="hljs-literal">nullptr</span>)     <span class="hljs-comment">// 为空说明左子树尚未遍历，将pre的右孩子更新为cur</span><br>            &#123;<br>                pre -&gt; right = cur;<br>                cur = cur -&gt; left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 否则说明左子树已经遍历，将pre右孩子重新置空</span><br>            &#123;<br>                pre -&gt; right = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-built_in">addPath</span>(res, cur -&gt; left);<br>                cur = cur -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 左孩子为空直接访问右子树</span><br>            cur = cur -&gt; right;<br>    &#125;<br>    <span class="hljs-built_in">addPath</span>(res, root); <span class="hljs-comment">// root节点没有parent，所以root需要单独addPath</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，所以由于root节点没有parent，最后要再单独对root节点调用<code>addPath</code>。</strong></p><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><p>上面这种解法是leetcode的官方解法，这里我还有另外一种思路，如上面所说，<strong>Morris的后续遍历其实就是不断把cur节点左孩子到其前驱节点倒序输出的过程，那么是否可以采用Morris的方法将输出顺序改为<code>cur</code>、<code>cur</code>的右孩子、<code>cur</code>的左孩子，在输出完之后再统一对<code>res</code>进行翻转？</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    TreeNode* cur = root, * pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) <br>    &#123;<br>        <br>        pre = cur -&gt; right;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// cur右孩子为空，直接将cur加入答案并访问左子树</span><br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>            cur = cur -&gt; left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则寻找 `父右左` 遍历模式下的前驱节点</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(pre -&gt; left != <span class="hljs-literal">nullptr</span> &amp;&amp; pre -&gt; left != cur)<br>                pre = pre -&gt; left;<br>            <span class="hljs-keyword">if</span>(pre -&gt; left == <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">// 为空说明右子树尚未遍历</span><br>            &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(cur -&gt; val);<br>                pre -&gt; left = cur;<br>                cur = cur -&gt; right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;       <br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明右子树已经遍历</span><br>            &#123;<br>                pre -&gt; left = <span class="hljs-literal">nullptr</span>;<br>                cur = cur -&gt; left;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">// 翻转数组</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>是二叉树的节点数。没有右子树的节点只被访问一次，有右子树的节点被访问两次，最后翻转数组。</li><li>空间复杂度：<spanclass="math inline">\(O(1)\)</span>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h2 id="二叉树问题的小trick">二叉树问题的小trick</h2><p>二叉树中有一类问题其实套路是固定的，虽然不同问题要求的东西不一样，但是仔细分析会发现，其实它们用到的套路是一样的。<strong>当一个问题的结果需要树的左右子树也满足条件，且每层子树需要返回的参数一样时，便可以用到递归套路。</strong></p><h3id="一棵子树上的点在深度优先搜索序列即先序遍历中是连续的">一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的</h3><p>可以采用这个套路来求解一个树是否是另一个树的子树，但是但从一个树<code>s</code>的dfs遍历是否是另一个树<code>t</code>的dfs遍历的字串并不能判断出是否是子树，所以想要通过dfs的序列判断s是否是t的子树，还需要做一些额外的处理。</p><p>可以通过引入两个空值 <code>lNull</code> 和<code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<code>s</code>的深度优先搜索序列包含<code>t</code>的深度优先搜索序列」来判断<code>s</code>是否是<code>t</code>的子树。</p><p>这里判断<code>s</code>的遍历序列是否是<code>t</code>遍历序列的子串可以用KMP算法或Rabin-Karp算法</p><h3 id="后序遍历迭代法">后序遍历迭代法</h3><p>采用迭代法的后序遍历，即上边用栈的方法，当遍历到节点 <spanclass="math inline">\(p\)</span> 时，栈中的节点刚好是 <spanclass="math inline">\(p\)</span>的祖先节点，所以此时将栈中节点依次弹出便得到 <spanclass="math inline">\(p\)</span> 的祖先节点的倒序。</p><h3 id="验证二叉搜索树">验证二叉搜索树</h3><p><strong>问题</strong>：给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>分析</strong>：如何判断一个二叉树是否是二叉搜索树？它需要满足两个条件：</p><ol type="1"><li>它的左子树和右子树都是二叉搜索树；</li><li>它的节点值大于左子树的最大值且小于右子树的最小值。</li></ol><p>那么从以上两点出发，就可以构造一个递归套路，每层需要向上层返回自己这颗树是否是二叉搜索树，如果不是那么整个树一定不是二叉搜索树；同时还要向上层返回自己这颗子树的最大值和最小值。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root, LONG_MIN, LONG_MAX);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBST</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= upper || root -&gt; val &lt;= lower)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBST</span>(root -&gt; left, lower, root -&gt; val) &amp;&amp; <span class="hljs-built_in">isBST</span>(root -&gt; right, root -&gt; val, upper);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是反向思维，若<code>cur</code>的值需要大于左子树最大值并且小于右子树最小值，那么就等价于让它的左子树判断其最大值是否小于<code>cur</code>值以及<code>cur</code>右子树判断其最小值是否大于<code>cur</code>值.</p><h3 id="验证平衡二叉树">验证平衡二叉树</h3><p><strong>问题</strong>:给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p><strong>分析</strong>:一个二叉树是平衡二叉树,那么它必然满足它的左右子树都是平衡二叉树,且左右子树的高度差的绝对值不大于1.那么就又可以以相似的方式构造递归,每次需要向上层返回的参数有:</p><ul><li>当前子树是否是平衡二叉树</li><li>当前子树的深度</li></ul><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> is_balance;<br>    <span class="hljs-built_in">isBalancedTree</span>(root, is_balance, height);<br>    <span class="hljs-keyword">return</span> is_balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isBalancedTree</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">bool</span> &amp;is_balance, <span class="hljs-type">int</span> &amp;height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        is_balance = <span class="hljs-literal">true</span>;<br>        height = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">bool</span> left_balance, right_balance;<br>    <span class="hljs-type">int</span> left_height, right_height;<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; left, left_balance, left_height);<br>    <span class="hljs-built_in">isBalancedTree</span>(root -&gt; right, right_balance, right_height);<br>    <span class="hljs-keyword">if</span>(!left_balance || !right_balance || <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)<br>        is_balance = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        is_balance = <span class="hljs-literal">true</span>;<br>    height = <span class="hljs-built_in">max</span>(left_height, right_height) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全二叉树的第k个节点">完全二叉树的第k个节点</h3><p>规定根节点位于第 <span class="math inline">\(0\)</span>层，完全二叉树的最大层数为 <spanclass="math inline">\(h\)</span>。根据完全二叉树的特性可知，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数<span class="math inline">\(h\)</span>。</p><p>当 <span class="math inline">\(0 \le i &lt; h\)</span> 时，第 <spanclass="math inline">\(i\)</span> 层包含 <spanclass="math inline">\(2^i\)</span> 个节点，最底层包含的节点数最少为<span class="math inline">\(1\)</span>，最多为 <spanclass="math inline">\(2^h\)</span>。</p><p>因此对于最大层数为 hhh 的完全二叉树，节点个数一定在 <spanclass="math inline">\([2^h,2^{h+1}-1]\)</span>的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。</p><p>如何判断第 <span class="math inline">\(k\)</span>个节点是否存在呢？如果第 <span class="math inline">\(k\)</span>个节点位于第 <span class="math inline">\(h\)</span> 层，则 <spanclass="math inline">\(k\)</span> 的二进制表示包含 <spanclass="math inline">\(h+1\)</span> 位，其中最高位是 <spanclass="math inline">\(1\)</span>，其余各位从高到低表示从根节点到第 <spanclass="math inline">\(k\)</span> 个节点的路径，<spanclass="math inline">\(0\)</span> 表示移动到左子节点，<spanclass="math inline">\(1\)</span> 表示移动到右子节点。通过位运算得到第<span class="math inline">\(k\)</span>个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 <spanclass="math inline">\(k\)</span> 个节点是否存在。</p><p><img src="/img/算法/二叉树/完全二叉树第k个节点.png" /></p><p>那么如何依次判断k的各个二进制位是否为1呢？这里需要一个<spanclass="math inline">\(bits = 2^{h-1}\)</span>，<spanclass="math inline">\(h\)</span>为要查找节点所在层数(注意根节点是0层),比如现在要查找<spanclass="math inline">\(8\)</span>这个节点，那么<spanclass="math inline">\(bits = 2^{3 - 1} = 0100\)</span>,而<spanclass="math inline">\(8\)</span>的二进制表示是<spanclass="math inline">\(1000\)</span>,用<spanclass="math inline">\(bits\)</span> &amp; <spanclass="math inline">\(1000 = 0\)</span>，所以向左子树走，然后将<spanclass="math inline">\(bits\)</span>左移一位，再与<spanclass="math inline">\(8\)</span>（也就是<spanclass="math inline">\(1000\)</span>）相与得到<spanclass="math inline">\(0010 \&amp; 1000 =0\)</span>,继续向左子树移动，重复上面操作，一直到<spanclass="math inline">\(bits\)</span>为<spanclass="math inline">\(0\)</span>为止，此时节点若不为空，那么就是第<spanclass="math inline">\(8\)</span>个节点。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL-unordered_map中自定义哈希函数</title>
    <link href="/2023/02/24/Cpp-STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2023/02/24/Cpp-STL-unordered_map%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2id="unordered_map中自定义哈希函数">unordered_map中自定义哈希函数</h2><p>内容转载自<ahref="https://blog.csdn.net/qq_34525916/article/details/115896842">c++unordered_set，unordered_map中自定义哈希函数</a></p><p>如果想用哈希的时候，但是哈希的目标又不再STL标准的类型内，比如一个自定义的class，就不太方便使用STL默认的哈希函数，比较函数，那么就需要重写了。</p><p><strong>将自定义类型作为unordered_map的键值，需如下两个步骤</strong>：</p><ol type="1"><li>定义自定义key的哈希函数的函数对象，告知此容器如何生成hash的值；</li><li>定义等比函数的函数对象或者在自定义类里重载operator==()，告知容器当出现hash冲突的时候，如何区分hash值相同的不同对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">Line</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2)&#123;<br>       k = d1;<br>       b = d2;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Line&amp; other)<span class="hljs-type">const</span>&#123;<span class="hljs-comment">//重载operator==(),若没有重载==则定义 unordered_map 时需要isEqual</span><br>        <span class="hljs-keyword">return</span> other.k ==k &amp;&amp; other.b == b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">createhash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span>  Line l)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// size_t</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//return size_t(l.k ^ l.b);//自定义哈希</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.k) ^  <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(l.b);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">isEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span> Line l1, <span class="hljs-type">const</span> Line l2)</span> <span class="hljs-type">const</span><span class="hljs-comment">//最后的const不能少</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//unordered_map&lt;Line ,int , createhash, isEqual&gt; mm;//若使用这种方式,Line类中不需要重载==</span><br>    unordered_map&lt;Line ,<span class="hljs-type">int</span> , createhash&gt; mm; <br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">1</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">auto</span> success = mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">2</span>&#125;);<br>    <span class="hljs-keyword">if</span>(success.second == <span class="hljs-literal">false</span>)<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;mm insert failed &quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : mm)<br>    &#123;<br>        std::cout&lt;&lt; ele.first.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.first.b&lt;&lt;std::endl; <br><br>    &#125;<br><br>    <span class="hljs-comment">//unordered_set&lt;Line, createhash&gt; ms;</span><br>    unordered_set&lt;Line, createhash, isEqual&gt; ms;<span class="hljs-comment">//若使用这种方式,Line类中不需要重载==</span><br>    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">auto</span> it = ms.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Line</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">if</span>(it.second == <span class="hljs-literal">false</span>)<br>       std::cout&lt;&lt;<span class="hljs-string">&quot;ms insert failed &quot;</span>&lt;&lt;std::endl; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ele : ms)<br>    &#123;<br>        std::cout&lt;&lt; ele.k&lt;&lt;<span class="hljs-string">&quot;  &quot;</span> &lt;&lt;ele.b&lt;&lt;std::endl; <br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表内部传递方式和内存占用">哈希表内部传递方式和内存占用</h3><ol type="1"><li>放入哈希表的key，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。</li><li>放入哈希表的key，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ lambda函数用法</title>
    <link href="/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Lambda表达式（也叫lambda函数，或简称lambda），是从C++11开始引入并不断完善的，是能够捕获作用域中变量的匿名函数对象。因为C++是不能嵌套定义函数的，所以lambda就成了我们构造闭包的主要手段，不过在对象的生命周期上还是有点不同。</p><h2 id="lambda基本语法">Lambda基本语法</h2><figure><img src="/img/C++/lambda/lambda基本语法.png" alt="lambda基本语法" /><figcaption aria-hidden="true">lambda基本语法</figcaption></figure><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。下面对重要的组成部分进行说明：</p><h3 id="捕获列表">捕获列表</h3><p><strong>值捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=100,因为i是创建时拷贝的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-comment">//将i拷贝到明位f的可调用对象</span><br><span class="hljs-keyword">auto</span> f = [&amp;i] &#123; <span class="hljs-keyword">return</span> i; &#125;;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j=0, 因为传递的是引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（隐式捕获），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p><p><strong>lambda捕获列表：</strong></p><ul><li>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</li><li>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>[this]。函数体内可以使用Lambda所在类中的成员变量。</li><li>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>[&amp;a]。将a按引用进行传递。</li><li>[=，&amp;a,&amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul><p><strong>悬垂引用：</strong></p><p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p><h3 id="形参列表">形参列表</h3><p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C++14前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C++14起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> &amp;b) &#123;<br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//输出：10  20</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(i,j);<br><span class="hljs-comment">//输出：1 20</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>) &#123;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">f</span>(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明符">说明符</h3><ul><li>mutable：允许函数体修改各个复制捕获的对象，以及调用其非 const成员函数;</li><li>constexpr：显式指定函数调用运算符为 constexpr函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr函数的所有要求，则它也会是 constexpr； (C++17 起)</li><li>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和constexpr。(C++20 起)</li></ul><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//代码在VS2019中测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span><br><span class="hljs-keyword">auto</span> f = [i, &amp;j]() <span class="hljs-keyword">mutable</span> &#123;<br>i = <span class="hljs-number">100</span>, j = <span class="hljs-number">100</span>;<br>&#125;;<br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//输出:0 100</span><br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回类型--">返回类型 -&gt;</h3><p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的return语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> f = []() -&gt; <span class="hljs-type">double</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p><h3 id="函数体">函数体 <span class="math inline">\(\{ \}\)</span></h3><p>略，同普通函数的函数体。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::accumulate函数用法</title>
    <link href="/2023/02/24/Cpp-accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/24/Cpp-accumulate%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>accumulate定义在#include<numeric>中，有两种用法，一个是累加求和，另一个是自定义类型数据的处理</p><h2 id="默认累加求和">默认累加求和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="自定义对数据的处理">自定义对数据的处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> BinaryOperation &gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">accumulate</span><span class="hljs-params">( InputIt first, InputIt last, T init,</span></span><br><span class="hljs-params"><span class="hljs-function">                        BinaryOperation op )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><p><strong>first, last</strong>: 要求和的元素范围</p><p><strong>init</strong>：和的初值</p><p><strong>op</strong>:被使用的二元函数对象。接收当前积累值 a （初始化为init ）和当前元素 b 的二元运算符。</p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// accumulate example</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">// std::minus</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>      <span class="hljs-comment">// std::accumulate</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">2</span>*y;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myclass</span> &#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>*y;&#125;<br>&#125; myobject;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> init = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> numbers[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using default accumulate: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers,numbers+<span class="hljs-number">3</span>,init);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using functional minus: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom function: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span>(numbers, numbers + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, [](<span class="hljs-type">int</span> a, Grade b)&#123;<span class="hljs-keyword">return</span> a + b * <span class="hljs-number">2</span>; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;using custom object: &quot;</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">accumulate</span> (numbers, numbers+<span class="hljs-number">3</span>, init, myobject);<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">using</span> <span class="hljs-keyword">default</span> accumulate: <span class="hljs-number">160</span><br><span class="hljs-keyword">using</span> functional minus: <span class="hljs-number">40</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-keyword">function</span>: <span class="hljs-number">120</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">custom</span> <span class="hljs-type">object</span>: <span class="hljs-number">280</span><br></code></pre></td></tr></table></figure><p>转载自<ahref="https://blog.csdn.net/gongjianbo1992/article/details/105128849">C++Lambda表达式的基本使用</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中数学公式换行问题</title>
    <link href="/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/19/hexo%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-书写-latex-公式时的一些问题及解决方法">Hexo 书写 LaTeX公式时的一些问题及解决方法</h2><p>使用hexo撰写博客的时候难免会用到数学公式，，如果公式过长，我们通常希望把方程分成多行显示，这时候就需要用到换行符号<code>\\</code>，但是写出来的Markdown 经过 Hexo 的处理以后显示不正确，这与 Hexo的渲染引擎有关系。</p><p>Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax支持，因此首先要启用 MathJax 才能渲染 LaTeX公式.但是它并不支持MathJax换行，这是因为我们的markdown文件首先会被hexo-theme-marked的marked.js解析，这就会使得使用Latex语法所写的MathJax公式中的_和，最后轮到MathJax来对公式进行解析就出错了。</p><h3 id="安装hexo-renderer-pandoc">安装hexo-renderer-pandoc</h3><p>为了使用pandoc作为Hexo的渲染引擎，我们需要安装插件hexo-renderer-pandoc，步骤如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载默认渲染插件</span><br><span class="hljs-built_in">npm</span> install hexo-renderer-pandoc --svae <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p>但是在安装pandoc之后发现，公式中使用<code>\\</code>仍然不能换行，经过一番折腾之后发现了一个曲线救国的方法：在需要换行的公式加上align对齐：</p><p>例如</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>在显示的时候会发现并没有换行</p><p><img src="/img/latex/错误用法.png" /></p><p>而加上aligin之后就可以正常换行</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br><span class="hljs-built_in">&amp;</span>A = [<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\alpha</span><span class="hljs-built_in">_</span>n]<span class="hljs-keyword">\\</span> <span class="hljs-built_in">&amp;</span>B = [<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>1,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>2,...,<span class="hljs-keyword">\beta</span><span class="hljs-built_in">_</span>r]  <br><span class="hljs-keyword">\end</span>&#123;align&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p><img src="/img/latex/正确用法.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的随机过程</title>
    <link href="/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/02/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="正态过程">正态过程</h2><h3id="多维正态分布的概率密度和特征函数">多维正态分布的概率密度和特征函数</h3><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数.png" /></p><p>记 <imgsrc="/img/随机过程/常见随机过程/正态概率密度符号替换.png" /></p><p>则<span class="math inline">\((X,Y)\)</span>的联合概率密度为</p><p><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-新.png" /><imgsrc="/img/随机过程/常见随机过程/多维正态分布的概率密度函数-注.png" /></p><h3 id="证明随机过程xt是正态过程">证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程</h3><p>要证明随机过程<spanclass="math inline">\(X(t)\)</span>是正态过程，即证对<spanclass="math inline">\(\forall t_1,t_2,\dots\)</span> , <spanclass="math inline">\(t_n，(X(t_1),X(t_2),\dots,X(t_n))\)</span>是<spanclass="math inline">\(n\)</span>维正态分布。</p><h4 id="方法1用特征函数">方法1：用特征函数</h4><h4 id="方法2正态分布的线性不变性">方法2：正态分布的线性不变性</h4><p><strong>正态分布的线性不变性</strong>:</p><p><img src="/img/随机过程/常见随机过程/正态分布线性不变性.png" /></p><p><strong>正态分布的线性变换不变性</strong>:</p><p><imgsrc="/img/随机过程/常见随机过程/正态分布的线性变换不变性.png" /></p><h2 id="维纳过程">维纳过程</h2><p><img src="/img/随机过程/常见随机过程/维纳过程条件.png" /> <imgsrc="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><h3 id="维纳过程的分布">维纳过程的分布</h3><p><img src="/img/随机过程/常见随机过程/维纳过程定义.png" /></p><p>设<span class="math inline">\(t&gt;s\)</span>，因<spanclass="math inline">\(W(0)=0\)</span>,且<spanclass="math inline">\(W(t)\)</span>是平稳独立增量过程，故</p><p><span class="math display">\[W(t) - W(s) = W(t-s+s)-W(s)\]</span></p><p>与</p><p><span class="math display">\[W(t-s) - W(0) = W(t-s)\]</span>有相同分布<span class="math inline">\(N(0,\sigma^2 (t-s))\)</span>。</p><p><strong>维纳过程是正态过程</strong>。</p><h3 id="维纳过程的数字特征">维纳过程的数字特征</h3><p><strong>维纳过程是平稳独立增量过程</strong>，其数字特征如下。</p><p><img src="/img/随机过程/常见随机过程/维纳过程的数字特征.png" /></p><h2 id="计数过程和泊松过程">计数过程和泊松过程</h2><h3 id="定义">定义</h3><p><strong>计数过程</strong>：</p><p><img src="/img/随机过程/常见随机过程/计数过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/计数过程定义2.png" /></p><p><strong>Poisson过程是一类很重要的计数过程</strong>。</p><p><strong>Poisson过程数学模型</strong>：</p><p><img src="/img/随机过程/常见随机过程/泊松过程定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程定义2.png" /></p><h3 id="齐次泊松过程">齐次泊松过程</h3><p><img src="/img/随机过程/常见随机过程/齐次泊松过程定义.png" /></p><h3 id="泊松过程的等价定义">泊松过程的等价定义</h3><p><img src="/img/随机过程/常见随机过程/泊松过程等价定义1.png" /> <imgsrc="/img/随机过程/常见随机过程/泊松过程等价定义2.png" /></p><h3 id="齐次泊松过程的有关结论">齐次泊松过程的有关结论</h3><h4 id="数字特征">数字特征</h4><p><strong>均值函数</strong>： <spanclass="math inline">\(m(t)=E\{N(t)\}=\lambda t\)</span></p><p><strong>方差函数</strong>: <span class="math inline">\(D(t)=\lambdat\)</span></p><p><strong>协方差函数</strong>: <spanclass="math inline">\(C(s,t)=\lambda min(s,t)\)</span></p><p><strong>相关函数</strong>： <spanclass="math inline">\(R(s,t)=\lambda min(s,t)+\lambda^2 st\)</span></p><p>故有<spanclass="math inline">\(\lambda=\frac{E\{N(t)\}}{t}\)</span>,称<spanclass="math inline">\(\lambda\)</span>为<strong>事件的到达率</strong>或<strong>单位时间内事件出现的平均次数</strong>。</p><h3 id="时间间隔与等待时间的分布">时间间隔与等待时间的分布</h3><p>如下图所示，<spanclass="math inline">\(N(t)\)</span>是轨道是跃度为<spanclass="math inline">\(1\)</span>的阶梯函数。</p><p><img src="/img/随机过程/常见随机过程/N（t）的分布函数.png" /></p><p>用<span class="math inline">\(T_n\)</span>表示事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n-1\)</span>次出现与第<spanclass="math inline">\(n\)</span>次出现的时间间隔。<spanclass="math inline">\(W_n\)</span>为事件<spanclass="math inline">\(A\)</span>第<spanclass="math inline">\(n\)</span>次出现的<strong>等待时间(到达时间)</strong>，则有：</p><p><span class="math display">\[W_n=\sum\limits_{i=1}^nT_i\]</span></p><p>和</p><p><span class="math display">\[T_n=W_n - W_{n-1}\]</span></p><p><img src="/img/随机过程/常见随机过程/时间间隔序列分布定理.png" /></p><h3 id="到达时间的条件分布">到达时间的条件分布</h3><p><img src="/img/随机过程/常见随机过程/引理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理1.png" /> <imgsrc="/img/随机过程/常见随机过程/到达时间分布定理2.png" /> <imgsrc="/img/随机过程/常见随机过程/注1.png" /> <imgsrc="/img/随机过程/常见随机过程/注2.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性空间</title>
    <link href="/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/02/18/%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="线性空间">线性空间</h2><p><strong>线性空间定义</strong>： <imgsrc="/img/矩阵论/线性空间/线性空间定义.jpg" /></p><p><strong>线性子空间定义</strong>：</p><p><img src="/img/矩阵论/线性空间/线性子空间定义.png" /></p><p><strong>平凡子空间</strong>：<spanclass="math inline">\(V\)</span>空间的平凡子空间指<spanclass="math inline">\(0\)</span>空间和<spanclass="math inline">\(V\)</span>空间本身，其他维数的空间都是非平凡子空间。</p><p><strong>线性空间的和</strong>：</p><p><img src="/img/矩阵论/线性空间/线性空间的和.jpg" /></p><h3 id="维数定理">维数定理</h3><p><img src="/img/矩阵论/线性空间/维数定理.png" /></p><h3 id="直和">直和</h3><p><img src="/img/矩阵论/线性空间/直和定义.png" /></p><h4id="判断线性空间v的两个子空间v_1和v_2是否是直和的方法">判断线性空间V的两个子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>是否是直和的方法</h4><p>判断<span class="math inline">\(V_1 \cap V_2 =\{0\}\)</span>是否成立，若成立，就是直和；否则不是直和。</p><p>将子空间的概念推广到多个子空间，于是在多个子空间中就可以定义这样的直和关系：</p><p><img src="/img/矩阵论/线性空间/多个子空间的直和.jpg" /></p><h3 id="酉空间">酉空间</h3><p>欧几里得空间：定义了内积的实线性空间。</p><p>欧几里得空间的定义推广到复线性空间就是酉空间。</p><h3 id="正交补子空间">正交补子空间</h3><p><img src="/img/矩阵论/线性空间/正交补子空间定义.png" /></p><p>这里的<spanclass="math inline">\(V_n(C)\)</span>指的是酉空间。这里的<spanclass="math inline">\(n\)</span>表示维数，<spanclass="math inline">\(C\)</span>表示复数空间。这个定义指的是复数域内的<spanclass="math inline">\(n\)</span>维空间，即是酉空间。</p><p>也就是说，一个空间V的子空间<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>不仅要满足直和的关系，还要相互正交。<strong>这样的空间我们称<spanclass="math inline">\(V_2\)</span>为<spanclass="math inline">\(V_1\)</span>的正交补子空间（或简称正交补）</strong>。显然，二者是互为正交补的。<strong>正交补分解实际上就是在分正交基。直和分解实际上就是在分解基向量</strong>。</p><p><strong>定理</strong>：<spanclass="math inline">\(V_n(C)\)</span>的任意子空间<spanclass="math inline">\(V_1\)</span>都有唯一的正交补。</p><h3 id="kronecker积">Kronecker积</h3><h4 id="kronecker积-1">Kronecker积</h4><p><img src="/img/矩阵论/线性空间/Kronecker积.png" /></p><p>其中<span class="math inline">\(a_{ij}\)</span>为矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列的元素，对于<spanclass="math inline">\(A \in \mathbb{R^{m × n}}\)</span> 和 <spanclass="math inline">\(B \in \mathbb{R^{p × q}}\)</span>,<spanclass="math inline">\(A \otimes B \in \mathbb{R^{(mp) ×(nq)}}\)</span>。</p><p><strong>Kronecker积的性质如下</strong>：</p><p><img src="/img/矩阵论/线性空间/Kronecker积性质1.png" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质2.jpg" /> <imgsrc="/img/矩阵论/线性空间/Kronecker积性质3.png" /></p><p>这些性质中前4条与矩阵运算完全相同，从第5条开始是Kronecker积独有的性质。</p><p>给出一些定义和定理：</p><p><img src="/img/矩阵论/线性空间/Kronecker积定理.jpg" /></p><p>Kronecker积的特征值：</p><p><img src="/img/矩阵论/线性空间/Kronecker积的特征值.jpg" /></p><h4 id="kronecker和">Kronecker和</h4><p><img src="/img/矩阵论/线性空间/Kronecker和.jpg" /></p><p>由定义2我们可以看到，对于Kronecker积而言，m阶矩阵和n阶矩阵之间是无法直接求和的，所以，我们通过对单位阵的Kronecker积运算，同时把他们化为<spanclass="math inline">\((m ×n)\)</span>阶方阵，这样就可以对矩阵进行求和运算了。</p><h4 id="向量化算符">向量化算符</h4><p><img src="/img/矩阵论/线性空间/向量化算符.png" /></p><p>性质：</p><p><img src="/img/矩阵论/线性空间/向量化算符性质.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题的一些心得</title>
    <link href="/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/17/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录一下在刷题的时候的一些小trick以及踩的一些坑。</p><!-- ### string.size()`string.size()`返回的是一个无符号数，所以在循环中如果需要对使用`s.size()`的话，需要使用`(int)s.size()`。 --><h2 id="滑动窗口">滑动窗口</h2><p>滑动窗口就是<strong>不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。它通常用于字符串或者数组特定长度下内容是否相同，也可以查找在内容相同情况下的最短长度(一般来说需要查找的数组或者字符串是连续的)。</p><h2 id="next_permutation-全排列">next_permutation 全排列</h2><p><code>next_permutation</code>是 C++ 标准库中的一个函数，它用于生成给定范围内的下一个字典序排列。如果可以生成这样的排列，函数返回<code>true</code>；如果这个排列已经是最大的字典序排列，则函数将范围内的元素重排为最小的字典序排列（通常是升序排列）并返回<code>false</code>。</p><p>这个函数非常适合于生成一个序列的<strong>全排列</strong>，或者在不需要考虑所有排列的情况下，寻找满足特定条件的下一个排列。</p><p>使用 <code>next_permutation</code> 的基本步骤如下：</p><ol type="1"><li>包含头文件：首先需要包含算法头文件<code>#include &lt;algorithm&gt;</code>。</li><li>初始化序列：你需要有一个序列（如数组或向量）。</li><li>调用函数：使用 <code>std::next_permutation</code>对序列进行操作。通常在一个循环中调用，直到函数返回<code>false</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 输出初始排列</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>            std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">next_permutation</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例会打印出数组 <code>&#123;1, 2, 3&#125;</code> 的所有排列。</p><p>需要注意的是，为了让 <code>next_permutation</code>正确工作，<strong>初始序列应该是按照字典序最小排列的</strong>，也就是说，最好是升序排列。如果序列是降序排列，第一次调用<code>next_permutation</code> 将直接将其重排为最小字典序排列。</p><h2 id="时间复杂度master公式">时间复杂度（Master公式）</h2><p>若有<span class="math inline">\(T(N)=a * T(\frac{N}{b})+O(N^d)\)</span>，则说明这个算法满足<strong>Master公式</strong>。也就是说只要是<strong>满足子问题等规模的递归都可以用Master公式</strong>。a，b，d的值可能会有三种情况。</p><ol type="1"><li><span class="math inline">\(\log_b a &lt;d\)</span>,则算法时间复杂度为<spanclass="math inline">\(O(N^d)\)</span>。</li><li><span class="math inline">\(\log_b a &gt;d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^{\log_ba})\)</span>。</li><li><span class="math inline">\(\log_b a =d\)</span>,则算法时间复杂度为<span class="math inline">\(O(N^d * \logn)\)</span>。</li></ol><h2 id="链表">链表</h2><h3 id="重要技巧">重要技巧</h3><h4 id="额外数据结构记录哈希表等">额外数据结构记录（哈希表等）</h4><p>此技巧一般只适用于笔试做题，面试一般不适用。</p><p>设置额外的数据结构，比如数组、哈希表或者栈等来辅助做题。</p><h4 id="快慢指针">快慢指针</h4><p>有一些问题诸如寻找链表的中点，最简单暴力的方法是遍历一遍链表然后得到链表长度，然后根据长度得到其最中间的节点。这样做有一个问题，就是需要遍历一遍半的链表。而使用快慢指针就可以少遍历一遍链表。</p><p>它的思想是设置一个<code>fast</code>节点和一个<code>slow</code>节点，每次<code>fast</code>节点往后走两步，而<code>slow</code>节点往后走一步。这样当<code>fast</code>节点走完整个链表的时候，<code>slow</code>节点就在链表的中间。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点。偶数长度返回上中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            fast = fast -&gt; next;<br>      <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>&#125;<br></code></pre></td></tr></table></figure><p>需要特别注意的是，<strong>不要死记这代码，实际上在做题或者应用中的不同情况是是有很多细微的差别的，比如若链表长度是偶数，有的时候需要中间靠前的节点，有的时候需要中间靠后的节点，还有的时候需要中间靠前节点的前驱节点，不同情况要做对应的调整，同时还要注意边界条件，比如节点为空或者只有一个节点的情况。</strong></p><p>链表长度为偶数情况下，寻找中间靠后的那个节点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 奇数长度返回中点，偶数长度返回下中点</span><br>ListNode *fast = head, slow = head;<br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>      fast = fast -&gt; next;<br>      <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">break</span>;<br>      slow = slow -&gt; next;   <br>      fast = fast -&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><!-- - 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点后一个 --><h2 id="同余">同余</h2><p>两个数 <code>x</code> 和<code>y</code>,如果<code>(x - y) mod m = 0</code>,则称<code>x</code>和<code>y</code>模<code>m</code>同余，记作<code>x ≡ y (mod m)</code>。</p><p>例如 <code>42 ≡ 12 (mod 10)</code>,<code>-17 ≡ 3 (mod 10)</code>。</p><p>如果<code>x</code>和<code>y</code>均非负，则<code>x ≡ y (mod m)</code>相当于<code>x mod m = y mod m</code>。</p><p>如果<code>x &lt; 0</code>,<code>y &gt; 0</code>，则<code>x ≡ y (mod m)</code>相当于<code>x mod m + m = y mod m</code>。</p><p>这样无论 <code>x</code> 是否为负数，运算结果都会落在区间<code>[0,m)</code> 中。</p><h3 id="性质">性质</h3><p>若<code>x ≡ y (mod m)</code>，则<code>x</code>必然可以通过加/减若干次<code>m</code>得到<code>y</code>。</p><h2 id="面试时链表解题方法论">面试时链表解题方法论</h2><ol type="1"><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。比如可以直接把链表copy到数组。</li><li>对于面试，时间复杂度仍然放在第一位，但是要找到空间复杂度最省的方法。</li></ol><h2 id="builtin_popcount函数">__builtin_popcount函数</h2><p>在C++中，<code>__builtin_popcount</code>函数是GCC编译器提供的内建函数，用于计算一个无符号整数中置位（值为1的位）的数量。这通常被称为"populationcount"。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x = <span class="hljs-number">23</span>; <span class="hljs-comment">// 二进制表示为 10111，有4个置位</span><br>    std::cout &lt;&lt; __builtin_popcount(x) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码会输出 <code>4</code>，因为数字 <code>23</code>的二进制表示中有四个 <code>1</code>。</p><p>使用这个内建函数通常比手动计算一个数的置位要快，因为它被优化为使用CPU指令来计算置位的数量。但是，需要注意的是，<code>__builtin_popcount</code>函数是GCC特有的，不是标准C++库的一部分，因此在非GCC编译器中可能不可用或者有不同的函数名。在写可移植代码时要特别注意这一点。</p><h2 id="打表法">打表法</h2><p>在刷题过程中经常会遇到一类题，这类题的特点是：<strong>输入简单，可能是一个或几个数或数组，输出也简单，可能只让你返回一个整形的结果。</strong>当然，一般的方法是根据题目的要求编写对应的算法求解。但是有时候这种方法并不那么容易实现或者并不那么容易想，这个时候可以考虑一种比较取巧的方法：打表法。</p><p>打表法就是用暴力方法先求出前面几十个或一百个解，从中找出其规律，然后根据规律直接编写对应方法求解。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平稳过程</title>
    <link href="/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/06/%E5%B9%B3%E7%A8%B3%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="严平稳过程">严平稳过程</h2><p><img src="/img/随机过程/平稳过程/严平稳过程定义.png" /> <imgsrc="/img/随机过程/平稳过程/严平稳过程定义-2.png"alt="严平稳过程定义" /></p><p>严平稳过程有限维分布不随时间的推移而改变，，它的当前变化情况与过去的情况有不可忽视的联系。</p><p>严平稳过程的一维分布与时间无关，而二维分布仅与<spanclass="math inline">\(t_1\)</span>和<spanclass="math inline">\(t_2\)</span>的时间间隔有关，与时间起点无关。</p><h2 id="宽平稳过程">宽平稳过程</h2><p>由于</p><ul><li>工程中确定一个过程的有限维分布函数族,进而判定过程的严平稳性十分困难；</li><li>部分随机过程(如正态过程)的概率特征主要由一阶和二阶矩函数确定；</li><li>工程实际中,通常仅需在相关理论范畴内考虑平稳过程,即只限于研究一、二阶矩（均值、相关函数等）理论.</li></ul><p>所以有了宽平稳过程。</p><p>定义： <img src="/img/随机过程/平稳过程/宽平稳过程定义.png"alt="宽平稳过程定义" /></p><p>其中<span class="math inline">\(R_x(\tau)\)</span>为<spanclass="math inline">\(\{X(t),t \inT\}\)</span>的自相关函数。其协方差函数为 <spanclass="math display">\[C_X(s,t)=R_X(s,t)-|m_X|^2=R_X(\tau)-|m_X|^2\]</span></p><p>自协方差函数与自相关函数都仅依赖于<spanclass="math inline">\(t－s\)</span></p><p><strong>维纳过程不是宽平稳过程，但是维纳过程是增量宽平稳过程，即</strong><span class="math display">\[X(t)=W(t+a)-W(t), t \ge 0, \quad(a&gt;0)\]</span></p><p>是宽平稳过程</p><h2 id="两种平稳性的关系">两种平稳性的关系</h2><ul><li>严平稳过程不一定是宽平稳的;</li></ul><p>因宽平稳过程一定是二阶矩过程, 而严平稳过程未必是二阶矩过程.</p><ul><li>宽平稳不一定 严平稳;</li><li>严平稳过程是宽平稳过程的充要条件是其二阶矩存在.</li><li>对于正态过程, 宽平稳性与严平稳性等价.</li></ul><h2 id="平稳过程的自相关函数">平稳过程的自相关函数</h2><p><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-1.png" /><img src="/img/随机过程/平稳过程/平稳过程自相关函数性质-2.png" /></p><p>证明:</p><ol type="1"><li><img src="/img/随机过程/平稳过程/自相关证明1.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明2.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明3.png" /></li><li><img src="/img/随机过程/平稳过程/自相关证明4.png" /></li></ol><p>推论： <img src="/img/随机过程/平稳过程/自相关函数推论.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.2.png" /></p><p>证明： <img src="/img/随机过程/平稳过程/5.2.2证明.png" /></p><p>定理: <img src="/img/随机过程/平稳过程/定理5.2.3.png" /></p><p>定理： <img src="/img/随机过程/平稳过程/定理5.2.4.png" /></p><p>推论： <img src="/img/随机过程/平稳过程/定理5.2.4推论1.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随机过程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广义逆矩阵</title>
    <link href="/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/12/05/%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="单边逆">单边逆</h2><p>所谓矩阵的单边逆就是指矩阵的左逆和右逆。</p><figure><img src="/img/矩阵论/单边逆定义.png" alt="矩阵的单边逆" /><figcaption aria-hidden="true">矩阵的单边逆</figcaption></figure><p><strong>定理1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(A\)</span>为列满秩矩阵</li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(A\)</span>为行满秩矩阵</li></ul><p><strong>推论1</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则</p><ul><li><span class="math inline">\(A\)</span>左可逆的充要条件是<spanclass="math inline">\(N(A)=\{0\}\)</span></li><li><span class="math inline">\(A\)</span>右可逆的充要条件是<spanclass="math inline">\(R(A)=\mathbb{C}^m\)</span></li></ul><h3 id="单边逆的求法">单边逆的求法</h3><p><strong>例1</strong>: <img src="/img/矩阵论/例1-1.png" /> <imgsrc="/img/矩阵论/例1-2.png" /></p><p><strong>例2</strong>: <img src="/img/矩阵论/例2-1.png" /> <imgsrc="/img/矩阵论/例2-2.png" /></p><p>需要注意的是例1求左逆矩阵进行的是初等行变换,例2求右逆矩阵是进行的初等列变换，初等行变换我们在线性代数中常用，比较熟悉，但是要求右逆矩阵一定要进行初等列变换。</p><h2 id="广义逆矩阵">广义逆矩阵</h2><p><strong>定义</strong>: <img src="/img/矩阵论/广义逆定义.png" /></p><p><strong>性质</strong>: <img src="/img/矩阵论/广义逆定理1.png" /></p><p>推论: <img src="/img/矩阵论/广义逆推论1.png" /></p><p>需要注意的是，同线性代数中的矩阵的逆不同的是，这里求的广义逆一般不唯一。既然不唯一，有许多解的话，我们就考虑是否有一个通解可以将所有的广义逆全部表示呢？的确有，下面我们就介绍定理2，该定理表示的就是全部的广义逆：</p><p><img src="/img/矩阵论/全部广义逆集合定义.png" /></p><p><strong>定理2</strong>(不常考): <imgsrc="/img/矩阵论/广义逆定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆定理2-2.png" /></p><p><strong>定理3</strong>: <img src="/img/矩阵论/广义逆定理3-1.png" /><img src="/img/矩阵论/广义逆定理3-2.png" /></p><ul><li>(i)是逆矩阵性质在广义逆的推广</li><li>(ii)说的是一个矩阵乘以他的广义矩阵是幂等矩阵，且他们矩阵的秩相等</li><li>(iii)可以看出0矩阵的广义逆矩阵可以是任何矩阵（包括0矩阵）</li><li>(v)说的是<span class="math inline">\(AA^{-1}\)</span>与<spanclass="math inline">\(A\)</span>的值域相同,<spanclass="math inline">\(A^{-1}A\)</span>与<spanclass="math inline">\(A\)</span>的零空间相同,证明如下:</li></ul><p><img src="/img/矩阵论/定理3(v)证明.png" /></p><h2 id="自反广义逆矩阵">自反广义逆矩阵</h2><p>自反广义逆矩阵是广义逆矩阵里的一类特殊矩阵,其定义如下: <imgsrc="/img/矩阵论/自反广义逆矩阵定义.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/自反广义逆矩阵定理1.png" /></p><p>需要注意的是，自反广义逆矩阵并不唯一。事实上，对于 <imgsrc="/img/矩阵论/广义逆矩阵/图1.png" /></p><p>构造这样的矩阵 <img src="/img/矩阵论/广义逆矩阵/图2.png" /></p><p>所有满足这样条件的矩阵G，就是A的自反广义逆。所以自反广义逆并不唯一.</p><p><strong>定理2</strong>(考试不要求): <imgsrc="/img/矩阵论/广义逆矩阵/定理2.png" /></p><p>定理2给出了自反广义逆矩阵的一种具体的构造方法,</p><p><strong>定理3</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/定理3.png" /></p><p>定理3给出了在广义逆矩阵中，区分自反广义逆的一种有效方法。当广义逆矩阵的秩等于矩阵A的秩的时候是自反广义逆。当广义逆的秩大于矩阵A的秩的时候是广义逆矩阵而不是自反广义逆矩阵。</p><h2 id="m-p广义逆矩阵">M-P广义逆矩阵</h2><p>M-P广义逆矩阵（Moore-Penrose）矩阵是在自反广义逆矩阵之上又加了两个条件形成的矩阵，要求更加苛刻。我们一般用<span class="math inline">\(A^+\)</span> 来表示M-P广义逆矩阵。 <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定义.png" /></p><p>这四个条件，共同保证了 <span class="math inline">\(A^+\)</span>的<strong>唯一性</strong>。</p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理1.png" /></p><p>该定理给出了<span class="math inline">\(A^+\)</span>的具体计算方法。定理的证明直接用该式子验证定义中的四个式子即可.</p><p><strong>定理2</strong>:设 <span class="math inline">\(A \in\mathbb{C}^{m × n}\)</span>,则 <spanclass="math inline">\(A^+\)</span>是唯一的.</p><p>这一点已经在上面提到过了,定义中的四个式子保证了<spanclass="math inline">\(A^+\)</span>的唯一.</p><h3 id="m-p广义逆的性质">M-P广义逆的性质</h3><p><img src="/img/矩阵论/广义逆矩阵/M-P广义逆定理3.png" /></p><p><strong>定理5</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆定理5.png" /></p><h3 id="m-p广义逆的计算">M-P广义逆的计算</h3><h4 id="最大秩分解">最大秩分解</h4><p><img src="/img/矩阵论/广义逆矩阵/引理1.png" /></p><p><strong>定理1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆的计算定理1.png" /></p><p><strong>例1</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-2.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/最大秩分解法例1-3.png" /></p><h4 id="奇异值分解法">奇异值分解法</h4><p><strong>定理2</strong>: <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-1.png" /> <imgsrc="/img/矩阵论/广义逆矩阵/M-P广义逆计算定理2-2.png" /></p><h3 id="m-p广义逆的应用">M-P广义逆的应用</h3><h4 id="判断方程有没有解">判断方程有没有解</h4><p>求出<span class="math inline">\(A^+\)</span>,判断<spanclass="math inline">\(AA^+b\)</span>是否等于<spanclass="math inline">\(b\)</span>,若不等于则没有解，否则有解。</p><h4id="求方程的最佳逼近解最小范数解最小二乘解">求方程的最佳逼近解/最小范数解/最小二乘解</h4><p>当方程有解的时候，可以求得最小范数解为<spanclass="math inline">\(A^+b\)</span>；当方程没有解的时候，可以求出最佳逼近解为<spanclass="math inline">\(A^+b\)</span>，最小二乘通解为<spanclass="math inline">\(A^+ b+(I-A^+ A)u, \forall u \in\mathbb{C}^n\)</span>,其中<span class="math inline">\(A\)</span>为<spanclass="math inline">\(n\)</span>阶矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    <url>/2022/12/05/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"> --><h2id="三角分解qr分解需要是非奇异矩阵">三角分解(QR分解)(需要是非奇异矩阵)</h2><h3id="正交三角分解通过schmidt正交化">正交三角分解(通过Schmidt正交化)</h3><p>若 <span class="math inline">\(n\)</span> 阶实矩阵 <spanclass="math inline">\(A\in \mathbb {C}^{n\times n}\)</span> 满秩，且<span class="math display">\[A = [\alpha_1,...,\alpha_n]\]</span></p><p>其中 <span class="math inline">\(\alpha_1,...,\alpha_n\)</span> 是<span class="math inline">\(\mathbb {C}^{n\times n}\)</span>中线性无关向量组</p><p><strong>正交化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned} \beta_1&amp;=\alpha_1\\\beta_2&amp;=\alpha_2 -\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1\\ \vdots \\ \beta_n &amp;= \alpha_n -\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}\end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \alpha_1 &amp;=\beta_1\\ \alpha_2 &amp;=\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1+ \beta_2\\ \vdots \\ \alpha_n &amp;=\frac{\left&lt;\beta_n,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\beta_1-\cdots-\frac{\left&lt;\beta_{n-1},\alpha_n\right&gt;}{\left&lt;\beta_{n-1},\alpha_{n-1}\right&gt;}\beta_{n-1}+ \beta_n \end{aligned} \]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\alpha_1,\alpha_2,...,\alpha_n\end{bmatrix} &amp;=\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;\triangleqB\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix} \end{aligned}\]</span></p><p><strong>单位化</strong></p><p>令</p><p><span class="math display">\[ \begin{aligned}q_1=&amp;\frac{\beta_1}{||\beta_1||} \\ &amp;\vdots \\ q_n =&amp; \frac{\beta_n}{||\beta_n||} \end{aligned} \]</span></p><p>变形得</p><p><span class="math display">\[ \begin{aligned} \beta_1 =&amp;q_1||\beta_1|| \\ &amp;\vdots \\ \beta_n =&amp; q_n ||\beta_n||\end{aligned}\]</span></p><p>写成矩阵形式</p><p><span class="math display">\[ \begin{aligned}\begin{bmatrix}\beta_1,\beta_2,...,\beta_n\end{bmatrix} &amp;=\begin{bmatrix}q_1,q_2,...,q_n\end{bmatrix}\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\end{aligned} \]</span></p><p>综上，结合正交化和单位化可得</p><p><span class="math display">\[ \begin{aligned} A &amp;=B\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;0&amp;\cdots&amp;0\\0&amp;||\beta_2||&amp;\cdots&amp;0\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp;||\beta_n||\end{bmatrix}\begin{bmatrix}1&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;1&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; 1\end{bmatrix}\\&amp;=Q\begin{bmatrix}||\beta_1||&amp;\frac{\left&lt;\beta_1,\alpha_1\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}&amp;\cdots&amp;\frac{\left&lt;\beta_1,\alpha_n\right&gt;}{\left&lt;\beta_1,\beta_1\right&gt;}\\0&amp;||\beta_2||&amp;\cdots&amp;\frac{\left&lt;\beta_2,\alpha_n\right&gt;}{\left&lt;\beta_2,\beta_2\right&gt;}\\&amp;&amp;\ddots\\0&amp;&amp;\cdots&amp; ||\beta_n||\end{bmatrix}\\&amp;\triangleq QR \end{aligned} \]</span></p><p><strong>QR 分解定理</strong> : <span class="math inline">\(A\in\mathbb {C}^{n\times n}\)</span> ,则存在酉矩阵 <spanclass="math inline">\(Q\)</span> 和正线上三角阵 <spanclass="math inline">\(R\)</span> ，使 <spanclass="math display">\[A=QR\]</span></p><p>且分解唯一</p><p><strong>正交三角分解的求法</strong> 1. 取矩阵 <spanclass="math inline">\(A=(A_1,A_2,...,A_n)\)</span> 的列向量，进行<strong>Schmidt 标准正交化</strong>,得 <spanclass="math inline">\(v_1,v_2,...,v_n\)</span> ，有 <spanclass="math display">\[Q=(v_1,v_2,...,v_n)\]</span> 2. 再由 <spanclass="math inline">\(R=Q^HA\)</span> 得到 <spanclass="math inline">\(R\)</span> , 于是 <spanclass="math inline">\(A=QR\)</span></p><h3 id="householder变换分解">HouseHolder变换分解</h3><p>将矩阵A按列划分为 <spanclass="math inline">\((\alpha_1,\alpha_2,\dots,\alpha_n)\)</span>,以4阶方阵为例，</p><p>第一步 令 <spanclass="math display">\[\omega_1=\frac{\alpha_1-a_1*e_1}{||\alpha_1-a_1*e_1||_2}，a_1=||\alpha_1||_2\]</span></p><p>于是 <spanclass="math display">\[H_1A=(H_1\alpha_1,H_1\alpha_2，...，H_1\alpha_n)=\left\{\begin{matrix} a_1 &amp; * &amp; \cdots &amp; * \\                   0      &amp; \\                   \vdots &amp; &amp;B_1 \\0\end{matrix}\right\}\]</span></p><p>第二步</p><p>从第一步中得到 <spanclass="math inline">\(B_1=(\beta_2,\beta_2,\cdots,\beta_n)\inR^{n-1}\)</span></p><p>取 <spanclass="math display">\[\omega_2=\frac{\beta_2-b_2*e_1}{||\beta_2-b_2*e_1||_2}，b_1=||\beta_2||_2\]</span></p><p>则 <spanclass="math display">\[\widehat{H_2}=I-2*\omega_2*\omega_2^T,H_2=\left\{\begin{matrix}1 &amp; 0^T \\                                                              0 &amp;\widehat{H_2}，                                              \end{matrix}\right\}\]</span></p><p>得到 <span class="math display">\[H_2(H_1*A) = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp;* \\                                       0 &amp; a_2 &amp; * &amp; \cdots&amp;* \\                                       0 &amp; 0 &amp;  &amp;\\                                       \vdots &amp; \vdots&amp;  &amp;C_2&amp; \\                                       0 &amp; 0\end{bmatrix} , C_2\in R^{n-2}\]</span></p><p>依次类推，进行第n步时，得到第n-1个 <spanclass="math inline">\(H_{n-1}\)</span>阵,使得 <spanclass="math display">\[H_{n-1} \cdots H_2H_1*A = \begin{bmatrix}   a_1&amp; * &amp; * &amp; \cdots &amp; * \\                                                   0 &amp; a_2 &amp; *&amp; \cdots &amp; * \\                                                   0 &amp; 0 &amp; a_3&amp; \cdots &amp; *\\                                                  \vdots &amp; \vdots&amp; &amp;\ddots \\                                                    0 &amp; 0 &amp; 0&amp; \cdots &amp;a_n\end{bmatrix}=R\]</span></p><p>其中 <span class="math inline">\(H_{n-1} \cdotsH_2H_1*A=H\)</span>也称为HouseHolder矩阵，也为自逆矩阵 <spanclass="math inline">\(H=H^{-1}\)</span></p><p><span class="math display">\[H_{n-1} \cdots H_2H_1*A=R\]</span> <spanclass="math display">\[\Rightarrow (H_{n-1} \cdots H_2*H_1)^{-1}*H_{n-1}\cdots H_2H_1*A=(H_{n-1} \cdots H_2*H_1)^{-1}*R\]</span> <spanclass="math display">\[\Rightarrow A=H_1^{-1} \cdotsH_{n-1}^{-1}*R\]</span> <span class="math display">\[\RightarrowA=H_1\cdots H_{n-1}*R\]</span></p><p>得到 <span class="math inline">\(A=QR\)</span>,其中 <spanclass="math inline">\(Q\)</span>为正交矩阵， <spanclass="math inline">\(R\)</span>为上三角矩阵 <spanclass="math display">\[\begin{cases}Q = H_1\cdots H_{n-1}\\R = Q^{-1}A=QA\end{cases}\]</span></p><h3 id="三角分解的性质">三角分解的性质</h3><p><strong>定理1</strong>:设 <span class="math inline">\(A\in \mathbb{C}_r^{m\times n}\)</span>，则 <span class="math inline">\(A\)</span>可以唯一地分解为 <span class="math display">\[A=U_1 R\]</span></p><p>其中 <span class="math inline">\(U_1\)</span>是酉矩阵， <spanclass="math inline">\(R\)</span> 是正线上三角复矩阵，或 <spanclass="math inline">\(A\)</span> 可以唯一地分解为 <spanclass="math display">\[A=L U_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角复矩阵， <spanclass="math inline">\(U_2\)</span>是酉矩阵</p><p><strong>推论1</strong>：设 <span class="math inline">\(A \in \mathbb{R}^{n × n}_n\)</span>,则 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=Q_1 R\]</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是则正交矩阵，<spanclass="math inline">\(R\)</span>是正线上三角实矩阵，或 <spanclass="math inline">\(A\)</span>可以唯一地分解为 <spanclass="math display">\[A=L Q_2\]</span></p><p>其中 <span class="math inline">\(L\)</span>是正线下三角实矩阵， <spanclass="math inline">\(Q_2\)</span>是正交矩阵。</p><p><strong>推论2</strong>：设A是实对称正定矩阵，则存在唯一正线上三角实矩阵<span class="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^T R\]</span></p><p><strong>推论3</strong>：设 <spanclass="math inline">\(A\)</span>是正定Hermite矩阵，则存在唯一正线上三角复矩阵<spanclass="math inline">\(R\)</span>，使得 <spanclass="math display">\[A=R^H R\]</span></p><h2 id="矩阵的满秩分解">矩阵的满秩分解</h2><p>设 <span class="math inline">\(A\in \mathbb {C}_r^{m\timesn}\)</span>，则存在 <span class="math inline">\(B\in \mathbb{C}_r^{m\times r}, C\in \mathbb {C}_r^{r\times n}\)</span>，满足 <spanclass="math display">\[ A = BC \]</span></p><p><span class="math inline">\(\mathbb {C}_r\)</span> 表示矩阵的秩为<span class="math inline">\(r\)</span></p><p>实际上上述定理用文字描述就是，一个亏秩的矩阵可以分解成一个列满秩与行满秩矩阵的乘积</p><p>证明：因为 <span class="math inline">\(rank(A)=r\)</span>，所以一定可以找到与 <spanclass="math inline">\(A\)</span> 相似的一个矩阵</p><p><span class="math display">\[ A \simeq\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\\0_{(m-r)\timesr}&amp;0_{(m-r)\times(n-r)}\end{bmatrix}=\begin{bmatrix}E_r\\0_{(m-r)\timesr}\end{bmatrix}\begin{bmatrix}E_r&amp;0_{r\times (n-r)}\end{bmatrix}\]</span></p><p>因此存在两个可逆矩阵 <span class="math inline">\(P,Q\)</span>，使<span class="math inline">\(PAQ=\begin {bmatrix} E_r&amp;0\\0&amp;0\end{bmatrix}\)</span>，则</p><p><span class="math display">\[ \begin{aligned} A &amp;=P^{-1}\begin{bmatrix}E_r\\0\end{bmatrix}\begin{bmatrix}E_r&amp;0\end{bmatrix}Q^{-1}\\&amp;\triangleq BC \end{aligned} \]</span></p><p>因为 <span class="math inline">\(P^{-1}\)</span> 是可逆矩阵，<spanclass="math inline">\(\begin {bmatrix} E_r\\0\end {bmatrix}\)</span>是一个列满秩矩阵，所以 <span class="math inline">\(B=P^{-1}\begin{bmatrix} E_r\\0\end {bmatrix}\)</span> 仍是一个列满秩矩阵；同理，<spanclass="math inline">\(C=\begin {bmatrix} E_r&amp;0\end {bmatrix}Q^{-1}\)</span> 是一个行满秩矩阵</p><h3 id="矩阵满秩分解的计算">矩阵满秩分解的计算</h3><p>如何在给定矩阵 <span class="math inline">\(A\)</span>的情况下，求出矩阵 <span class="math inline">\(B,C\)</span> 呢？</p><p>设</p><p><span class="math display">\[\begin{align}&amp;A = [\alpha_1,\alpha_2,...,\alpha_n]\\ &amp;B =[\beta_1,\beta_2,...,\beta_r]  \end{align}\]</span></p><p>其中 <span class="math inline">\(\beta_1,...,\beta_r\)</span>线性无关</p><p>所以 <span class="math display">\[ \begin{aligned} &amp;A=BC\\&amp;\Rightarrow[\alpha_1,\alpha_2,...,\alpha_n]=[\beta_1,...,\beta_r]\begin{bmatrix}c_{11}&amp;\cdots&amp;c_{1n}\\\vdots &amp;\ddots&amp;\vdots\\c_{r1}&amp;\cdots&amp;c_{rn}\end{bmatrix} \end{aligned} \]</span></p><p>实际上我们可以取 <spanclass="math inline">\(\beta_1,...,\beta_r\)</span> 为 <spanclass="math inline">\(\alpha_1,...,\alpha_n\)</span>的一个极大线性无关组，因此 <span class="math inline">\(B\)</span>就是矩阵 <span class="math inline">\(A\)</span>列向量组的一个极大线性无关组，<span class="math inline">\(C\)</span>就是用该线性无关组去表示 <span class="math inline">\(A\)</span>时的系数</p><h4 id="例-1">例 1</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换 <span class="math display">\[A=\begin{bmatrix}1&amp;4&amp;-1&amp;5&amp;6\\2&amp;0&amp;0&amp;0&amp;-14\\-1&amp;2&amp;-4&amp;0&amp;1\\2&amp;6&amp;-5&amp;5&amp;-7\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\\0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}1&amp;4&amp;-1\\2&amp;0&amp;0\\-1&amp;2&amp;-4\\2&amp;6&amp;-5\end{bmatrix}，C=\begin{bmatrix}1&amp;0&amp;0&amp;0&amp;-7\\0&amp;1&amp;0&amp;\frac{10}{7}&amp;\frac{29}{7}\\0&amp;0&amp;1&amp;\frac{5}{7}&amp;\frac{25}{7}\end{bmatrix}\]</span></p><h4 id="例-2">例 2</h4><p>求矩阵 <span class="math inline">\(A=\begin {bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\)</span> 的满秩分解</p><p><strong>解</strong>：对矩阵 <span class="math inline">\(A\)</span>只作初等行变换</p><p><span class="math display">\[A=\begin{bmatrix}2&amp;1&amp;-2&amp;3&amp;1\\2&amp;5&amp;-1&amp;4&amp;1\\1&amp;3&amp;-1&amp;2&amp;1\end{bmatrix}\to···\to\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><p><span class="math inline">\(A\)</span> 的秩为3，且前三个列向量线性无关，故 <span class="math display">\[ B =\begin{bmatrix}2&amp;1&amp;-2\\2&amp;5&amp;-1\\1&amp;3&amp;-1\end{bmatrix},C=\begin{bmatrix}1&amp;0&amp;0&amp;\frac{8}{5}&amp;-\frac{2}{5}\\0&amp;1&amp;0&amp;\frac{1}{5}&amp;\frac{1}{5}\\0&amp;0&amp;1&amp;\frac{1}{5}&amp;-\frac{4}{5}\end{bmatrix}\]</span></p><h2 id="矩阵的lu分解">矩阵的LU分解</h2><p>LU 分解（LUDecomposition）是矩阵分解的一种，可以将一个矩阵分解为一个单位下三角矩阵和一个上三角矩阵的乘积，以四阶矩阵为例<span class="math display">\[ L = \begin{bmatrix}1&amp;0&amp;0&amp;0 \\*&amp;1&amp;0&amp;0\\ *&amp;*&amp;1&amp;0\\*&amp;*&amp;*&amp;1\end{bmatrix},U=\begin{bmatrix}*&amp;*&amp;*&amp;*\\0&amp;*&amp;*&amp;*\\0&amp;0&amp;*&amp;*\\0&amp;0&amp;0&amp;*\end{bmatrix}\]</span></p><p>LU 矩阵是否一定存在？答案是否，具体看下面的例子</p><p>设 <span class="math inline">\(\begin {bmatrix} 0&amp;1 \\1&amp;0\end{bmatrix}=\begin {bmatrix} a&amp;0\\b&amp;c\end {bmatrix}\begin{bmatrix} l&amp;m\\0&amp;n\end {bmatrix}\)</span>，则应该满足如下 4个式子</p><p><span class="math display">\[ \begin{cases} al=0\\ am=1\\ bl=1\\bm+cn=0 \end{cases} \]</span></p><p>由 <span class="math inline">\(al=0\)</span> 得 <spanclass="math inline">\(a=0\)</span> 或 <spanclass="math inline">\(l=0\)</span>，但实际上这两种情况带入上面的式子都会推出矛盾，因此不是所有情况LU 分解都存在</p><p><strong>LU 分解定理</strong> ：设 <span class="math inline">\(A\in\mathbb {C}_n^{n\times n}\)</span>，<spanclass="math inline">\(A\)</span> 有唯一的 LU 分解 <spanclass="math inline">\(\Leftrightarrow A\)</span> 的各阶顺序主子式 <spanclass="math inline">\(\Delta k \neq 0,\ k=1,2...,n\)</span></p><p><span class="math inline">\(k\)</span> 阶顺序主子式指的是矩阵左上角<span class="math inline">\(k\times k\)</span> 个元素组成的行列式</p><p>将矩阵 <span class="math inline">\(A\)</span> 分解为 <spanclass="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span> 之后，解方程组 <spanclass="math inline">\(Ax=b\)</span> 就变得简单了，因为 <spanclass="math inline">\(A=LU\)</span>，所以 <spanclass="math inline">\((LU) x=b\Rightarrow L (Ux)=b\Rightarrow \begin{cases} Ly=b\\Ux=y\end {cases}\)</span></p><p>所以 <span class="math inline">\(x=U^{-1} y=U^{-1} L^{-1}b\)</span></p><h3 id="lu-矩阵的求法">LU 矩阵的求法</h3><p>实际上 LU 矩阵有非常多的求法，这里列举一种比较简单的待定系数法</p><p>设 <span class="math inline">\(A = \begin {bmatrix}2&amp;3&amp;4\\1&amp;1&amp;9\\1&amp;2&amp;-6\end{bmatrix}\)</span>，求矩阵 <span class="math inline">\(A\)</span> 的 LU分解矩阵 <span class="math inline">\(L\)</span> 和 <spanclass="math inline">\(U\)</span></p><p><strong>解</strong>：令 <span class="math display">\[L=\begin{bmatrix}1&amp;0&amp;0\\l_1&amp;1&amp;0\\l_2&amp;l_3&amp;1\end{bmatrix},U=\begin{bmatrix}u_1&amp;u_2&amp;u_3\\0&amp;u_4&amp;u_5\\0&amp;0&amp;u_6\end{bmatrix}\]</span></p><p>由于 <span class="math inline">\(A=LU\)</span>，所以有</p><p><span class="math display">\[ \begin{cases} u_1=2\\ u_2=3\\ u_3=4\\l_1u_1=1\\ l_1u_2+u_4=1\\ l_1u_3+u_5=9\\ l_2u_1=1\\ l_2u_2+l_3u_4=2\\l_2u_3+l_3u_5+u_6=-6 \end{cases} \]</span></p><p>上面的方程组非常容易解，最后求出</p><p><span class="math display">\[ L =\begin{bmatrix}1&amp;0&amp;0\\\frac{1}{2}&amp;1&amp;0\\\frac{1}{2}&amp;-1&amp;1\end{bmatrix},U=\begin{bmatrix}2&amp;3&amp;4\\0&amp;-\frac{1}{2}&amp;7\\0&amp;0&amp;-1\end{bmatrix}\]</span></p><h2 id="奇异值分解">奇异值分解</h2><p><strong>奇异值</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{m × n}_r,AA^H\)</span> 的特征值为 <spanclass="math display">\[\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_n =0\]</span></p><p>则称 <span class="math inline">\(\sigma_i=\sqrt{\lambda_i}\)</span>为矩阵A的正奇异值。<strong><span class="math inline">\(A\)</span>和<span class="math inline">\(A^H\)</span>相同的奇异值</strong>。</p><p><strong>奇异值分解</strong>：当给定一个大小为<spanclass="math inline">\(m × n\)</span>的矩阵<spanclass="math inline">\(A\)</span>,虽然矩阵<spanclass="math inline">\(A\)</span>不一定是方阵，但大小为<spanclass="math inline">\(m × m\)</span>的<spanclass="math inline">\(AA^T\)</span>和<span class="math inline">\(n ×n\)</span>的<span class="math inline">\(AA^T\)</span>是对称矩阵,若<spanclass="math inline">\(AA^T=P \Lambda_1 Q^T\)</span>,<spanclass="math inline">\(A^T A=Q\Lambda_2Q^T\)</span>,则矩阵A的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T\]</span></p><p>其中，矩阵<span class="math inline">\(P=(\overrightarrow{p_1},\overrightarrow{p_2}, \dots, \overrightarrow{p_m})\)</span>的大小为<span class="math inline">\(m × m\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{p_1}, \overrightarrow{p_2}, \dots,\overrightarrow{p_m}\)</span>是 <spanclass="math inline">\(AA^T\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的左奇异向量（left singularvector）；矩阵<span class="math inline">\(Q=(\overrightarrow{q_1},\overrightarrow{q_2}, \dots, \overrightarrow{q_m})\)</span>的大小为<span class="math inline">\(n × n\)</span>，列向量 <spanclass="math inline">\(\overrightarrow{q_1}, \overrightarrow{q_2}, \dots,\overrightarrow{q_m}\)</span>是 <spanclass="math inline">\(A^TA\)</span>的特征向量，也被称为矩阵<spanclass="math inline">\(A\)</span>的右奇异向量（left singularvector）；矩阵<spanclass="math inline">\(\Lambda_1\)</span>的大小为<spanclass="math inline">\(m × m\)</span>，矩阵<spanclass="math inline">\(\Lambda_2\)</span>的大小为<spanclass="math inline">\(n ×n\)</span>，两个矩阵对角线上的非零元素相同（即矩阵<spanclass="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的非零特征值相同）；矩阵<spanclass="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(m ×n\)</span>，位于对角线上的元素被称为<strong>奇异值</strong>（singularvalue）。</p><p>设<span class="math inline">\(A\)</span>的秩为r，当 <spanclass="math inline">\(m \ne n\)</span>时，矩阵<spanclass="math inline">\(\Lambda_1\)</span>和<spanclass="math inline">\(\Lambda_2\)</span>的大小显然是不同的，但是他们对角线上的非零元素是相同的，记矩阵<spanclass="math inline">\(\Lambda_1\)</span>(或<spanclass="math inline">\(\Lambda_2\)</span>)对角线上的非零元素为<spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_r\)</span>，这些数皆为非负数，又记矩阵<spanclass="math inline">\(\Sigma\)</span>对角线上的非零元素分别为<spanclass="math inline">\(\sigma_1,\sigma_2,\dots,\sigma_r\)</span>，则<spanclass="math display">\[\sigma_1=\sqrt{\lambda_1},\sigma_2=\sqrt{\lambda_2},\dots,\sigma_r=\sqrt{\lambda_r}\]</span></p><p>即非零奇异值的平方对应着矩阵<spanclass="math inline">\(\Lambda_1\)</span>（或矩阵<spanclass="math inline">\(\Lambda_2\)</span>）的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。</p><p><strong>例1</strong>：一个<spanclass="math inline">\(3×2\)</span>的矩阵<spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\)</span>，求其奇异值分解。</p><p>由 <span class="math display">\[AA^T=\begin{bmatrix}    5&amp;0&amp;0 \\ 0&amp;0&amp;0 \\ 0&amp;0&amp;0\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=\lambda_3=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{p_1}=(1,0,0)^T,\overrightarrow{p_2}=(0,1,0)^T,\overrightarrow{p_3}=(0,0,1)^T\)</span></p><p>由 <span class="math display">\[A^TA=\begin{bmatrix}    1&amp;2 \\ 2&amp;4\end{bmatrix}\]</span></p><p>得到其特征值<spanclass="math inline">\(\lambda_1=5,\lambda_2=0\)</span>，特征向量为<spanclass="math inline">\(\overrightarrow{q_1}=(\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T,\overrightarrow{q_2}=(-\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})^T\)</span></p><p>令 <span class="math display">\[\Sigma=\begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p>注意矩阵<span class="math inline">\(\Sigma\)</span>的大小为<spanclass="math inline">\(3 × 2\)</span>，此时，矩阵<spanclass="math inline">\(A\)</span>的奇异值分解为 <spanclass="math display">\[A=P\Sigma Q^T=(\overrightarrow{p_1},\overrightarrow{p_2}, \overrightarrow{p_3})\Sigma (\overrightarrow{q_1},\overrightarrow{q_2})^T \\ =\begin{bmatrix}    1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}    \sqrt{5}&amp;0 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix} \begin{bmatrix}    \frac{\sqrt{5}}{5}&amp;\frac{2\sqrt{5}}{5} \\\frac{-2\sqrt{5}}{5}&amp;\frac{\sqrt{5}}{5}\end{bmatrix} = \begin{bmatrix}    1&amp;2 \\ 0&amp;0 \\ 0&amp;0\end{bmatrix}\]</span></p><p><strong>例2</strong>：求对称矩阵<spanclass="math inline">\(A=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}\)</span>的奇异值分解。</p><p>经计算可以发现<spanclass="math inline">\(A^TA=AA^T=\begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix} \begin{bmatrix}  2&amp;1 \\ 1&amp;2\end{bmatrix}=\begin{bmatrix}  5&amp;4 \\ 4&amp;5\end{bmatrix}\)</span>，左奇异向量和右奇异向量构成的矩阵也是相等的，即<span class="math display">\[P=Q=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p>则其奇异值分解为 <span class="math display">\[A=P\SigmaQ^T=\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2}&amp; \frac{\sqrt{2}}{2}\end{bmatrix}\begin{bmatrix}    3&amp;0 \\ 0&amp;1\end{bmatrix}\begin{bmatrix}    \frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2} \\-\frac{\sqrt{2}}{2}&amp;\frac{\sqrt{2}}{2}\end{bmatrix}\]</span></p><p><strong>注</strong>：这是由于当矩阵<spanclass="math inline">\(A\)</span>为对称矩阵时，其可以被正交对角化，这时奇异值分解等于正交对角化分解。</p><h2 id="谱分解">谱分解</h2><p><strong>谱分解</strong>：设 <span class="math inline">\(A \in\mathbb{C}^{n × n}\)</span>是单纯矩阵，则 <spanclass="math inline">\(A\)</span>可以分解为一系列幂等矩阵 <spanclass="math inline">\(A_i(i=1,2, \dots,n)\)</span>的加权和 <spanclass="math display">\[A=\sum_{i=1}^n \lambda_i A_i\]</span></p><p>其中 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span>是A的特征值。</p><p><strong>单纯矩阵</strong>：若矩阵 <spanclass="math inline">\(A\)</span>的<strong>代数重数</strong>等于<strong>几何重数</strong>，则称<spanclass="math inline">\(A\)</span>为单纯矩阵。<strong>代数重数</strong>为矩阵<spanclass="math inline">\(A\)</span>特征值的重数，<strong>几何重数</strong>为齐次方程组<spanclass="math inline">\(Ax=\lambda_ix(i=1,2,\dots,k)\)</span>的解空间<spanclass="math inline">\(V_{\lambda_i}\)</span>的维数，也即特征值对应的最多无关特征向量数。</p><p><strong>幂等矩阵</strong>：若 <spanclass="math inline">\(A\)</span>为方阵，且 <spanclass="math inline">\(A^2=A\)</span>，则称<spanclass="math inline">\(A\)</span>为幂等矩阵。所有幂等矩阵都相似与对角元全为0或1的对角阵。</p><p><strong>更一般的单纯矩阵谱分解定理</strong>：设 <spanclass="math inline">\(A \in \mathbb{C}^{n × n}\)</span>，他有 <spanclass="math inline">\(k\)</span>个相异特征值 <spanclass="math inline">\(\lambda_i(i=1,2,\dots,k)\)</span>，则 <spanclass="math inline">\(A\)</span>是单纯矩阵的充要条件是存在<spanclass="math inline">\(k\)</span>个矩阵<spanclass="math inline">\(A_i(i=1,2,\dots,k)\)</span>满足</p><ol type="1"><li><span class="math inline">\(A_i A_j = \begin{cases}  A_i, i=j \\ 0,i\ne j \end{cases}\)</span></li><li><span class="math inline">\(\sum_{i=1}^k A_i = E_n\)</span></li><li><span class="math inline">\(A=\sum_{i=1}^k \lambda_iA_i\)</span></li></ol><p>该定理比定理3要求放宽了，不再要求必须要有n个特征值了，这里的k可以小于等于n。</p><p><strong>例1</strong>：求正规矩阵 <span class="math inline">\(A =\begin{bmatrix}  0&amp;1&amp;1&amp;1 \\ 1&amp;0&amp;-1&amp;1 \\1&amp;-1&amp;0&amp;1 \\ -1&amp;1&amp;1&amp;0\end{bmatrix}\)</span>的谱分解表达式。</p><p><strong>解</strong>：首先计算 <spanclass="math inline">\(A\)</span>的特征值和特征向量 <spanclass="math display">\[|\lambda_ I - A |=(\lambda - 1)^3 (\lambda +3)\]</span></p><p>从而 <span class="math inline">\(A\)</span>的特征值为 <spanclass="math display">\[\lambda_1=\lambda_2=\lambda_3=1,\lambda_4=-3\]</span></p><p>当<spanclass="math inline">\(\lambda=1\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_1=(1,1,0,0)^T \\ \alpha_2=(1,0,1,0)^T \\\alpha_3=(-1,0,0,1)^T\]</span></p><p>当<spanclass="math inline">\(\lambda=-3\)</span>时，求得无关的特征向量为 <spanclass="math display">\[\alpha_4=(1,-1,-1,1)^T\]</span></p><p>将 <spanclass="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交化并单位化得<spanclass="math display">\[\eta_1=(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0,0)^T\\\eta_2=(\frac{1}{\sqrt{6}},\frac{1}{\sqrt{6}},\frac{2}{\sqrt{6}},0)^T \\\eta_3=(-\frac{1}{2\sqrt{3}},\frac{1}{2\sqrt{3}},\frac{1}{\sqrt{3}},\frac{3}{2\sqrt{3}})^T\]</span></p><p>将<span class="math inline">\(\alpha_4\)</span>单位话得 <spanclass="math display">\[\eta_4=(\frac{1}{2},-\frac{1}{2},-\frac{1}{2},\frac{1}{2})\]</span></p><p>故有 <span class="math display">\[G_1=\eta_1 \eta_1^H+\eta_2 \eta_2^H+\eta_3 \eta_3^H \\= \begin{bmatrix}    \frac{3}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;\frac{3}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{3}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{3}{4}    \end{bmatrix}\]</span></p><p><span class="math display">\[G_2=\eta_4 \eta_4^H \\=\begin{bmatrix}    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    -\frac{1}{4}&amp;\frac{1}{4}&amp;\frac{1}{4}&amp;-\frac{1}{4} \\    \frac{1}{4}&amp;-\frac{1}{4}&amp;-\frac{1}{4}&amp;\frac{1}{4}\end{bmatrix}\]</span></p><p>这样其谱分解表达式为 <span class="math display">\[A=G_1 -3G_2\]</span></p><p>注意<span class="math inline">\(G_1\)</span>和<spanclass="math inline">\(G_2\)</span>的系数<spanclass="math inline">\(\lambda_i\)</span>为其对应的特征值。<!-- https://www.cnblogs.com/blairgrowing/p/15800825.html --></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>范数</title>
    <link href="/2022/12/05/%E8%8C%83%E6%95%B0/"/>
    <url>/2022/12/05/%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>不管向量范数、矩阵范数还是算子范数，都需要满足三个特性:</p><ul><li>正定性</li><li>齐次性</li><li>三角不等式</li></ul><h2 id="向量范数">向量范数</h2><p><strong>1 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_1=\sum\limits_{i=1}^N|x_i|\)</span>，即向量元素绝对值之和</p><p><strong>2 - 范数</strong>：<span class="math inline">\(\Vert\boldsymbol {x}\Vert_2=(\sum\limits_{i=1}^N (x_i)^2)^{\frac{1}{2}}\)</span>，也叫欧几里得范数，常用于计算向量长度，即向量元素的平方和再开方</p><p><strong><span class="math inline">\(\infty\)</span>-范数</strong>:<span class="math inline">\(\Vert \boldsymbol{x}\Vert_{\infty}=\max\limits_{i}|x_i|\)</span>，即所有向量元素中绝对值的最大值</p><!-- **-$\infty$- 范数**:$\Vert \boldsymbol {x}\Vert_{-\infty}=\min\limits_{i} |x_i|$，即所有向量元素绝对值中的最小值 --><p><strong>P - 范数</strong>:<span class="math inline">\(\Vert\boldsymbol {x}\Vert_p=(\sum\limits_{i=1}^N (x_i)^p)^{\frac{1}{p}}\)</span>，即向量元素的 p 次方和再开 p 次方</p><h2 id="矩阵范数">矩阵范数</h2><p>设<span class="math inline">\(A \in \mathbb{C}^{m ×n}\)</span>，则</p><p><span class="math inline">\({||A||}_{m_1} = \sum\limits^{n}_{j=1}\sum\limits^{m}_{i=1} |a_{ij}|\)</span></p><p><span class="math inline">\(||A||_{m_2} = {||A||}_{F}=\sqrt{\sum\limits^{n}_{j=1} \sum\limits^{m}_{i=1} |a_{ij}^2|} =\sqrt{tr(A^HA)} = \sqrt{tr(AA^H)}\)</span></p><p><spanclass="math inline">\(||A||_{m_\infty}=\max\limits_{i,j}\{|a_{ij}|\},1\le i \le m, 1 \le j \le n\)</span></p><h3 id="矩阵范数的性质">矩阵范数的性质</h3><p><img src="/img/矩阵论/矩阵范数性质-定理1.png" /> <imgsrc="/img/矩阵论/矩阵范数性质-定理1-2.png" /></p><ul><li><span class="math inline">\({||A||}_{m_1}\)</span>范数与向量范数<span class="math inline">\(||x||_1\)</span>相容</li><li><span class="math inline">\({||A||}_{m_2}\)</span>范数与向量范数<span class="math inline">\(||x||_2\)</span>相容</li><li><spanclass="math inline">\({||A||}_{m_{\infty}}\)</span>范数与向量范数 <spanclass="math inline">\(||x||_\infty\)</span> 不相容</li></ul><h3 id="证明一个范数是矩阵范数流程">证明一个范数是矩阵范数流程</h3><ul><li>证明非负性、齐次性、三角不等式</li><li>看他定义是哪种类型的范数，若是相容的需要证明相容性</li></ul><h2 id="算子范数">算子范数</h2><p>算子范数定义1： <img src="/img/矩阵论/算子范数定义1.png" /></p><p>注意：并不是所以的矩阵范数都与向量范数相容。只有满足该条件的矩阵范数才与向量范数是相容的。</p><p>算子范数定义2： <img src="/img/矩阵论/算子范数定义2.png" /></p><p><strong>则称此矩阵范数为从属于向量范数 <spanclass="math inline">\(||x||\)</span>的算子范数</strong>。这里的x可是n维空间的任意取向。</p><p><strong>算子范数表示</strong>：</p><p><span class="math inline">\({||A||}_1=\max\limits_{1 \le j \len}\{\sum\limits^{s}_{j=1}|a_{ij}|\}\)</span>,列模和范数，即所有矩阵列向量绝对值之和的最大值</p><p><span class="math inline">\(||A||_2=\sqrt{\rho(A^HA)}\)</span>，谱范数</p><p><span class="math inline">\(||A||_\infty=\max\limits_{1 \le i \les}\{\sum^n_{j=1}|a_{ij}|\}\)</span>,行模和范数,即所有矩阵行向量绝对值之和的最大值</p><h3 id="算子范数性质">算子范数性质</h3><ul><li><span class="math inline">\({||A||}_{1}\)</span> 范数与向量范数<span class="math inline">\(||x||_1\)</span> 相容</li><li><span class="math inline">\({||A||}_{2}\)</span> 范数与向量范数<span class="math inline">\(||x||_2\)</span> 相容</li><li><span class="math inline">\(||·||_a\)</span>是算子范数 <spanclass="math inline">\(\Rightarrow ||E||_a = 1\)</span></li><li>设<span class="math inline">\(A \in \mathbb{C}^{n × n}，||A||_a\)</span>是从属向量范数<spanclass="math inline">\(||x||\)</span>的算子范数，若<spanclass="math inline">\(||A||_a &lt; 1\)</span>,则 <spanclass="math inline">\(E \pm A\)</span> 可逆，且<spanclass="math inline">\(||(E \pm A)^{-1}||_a \le (1 -||A||_a)^{-1}\)</span></li></ul><p><img src="/img/矩阵论/算子范数性质-定理3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jordan标准型</title>
    <link href="/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <url>/2022/12/04/Jardon%E6%A0%87%E5%87%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="jordan标准型">Jordan标准型</h2><figure><img src="/img/矩阵论/Jordan标准型定义.png" alt="Jordan标准型定义" /><figcaption aria-hidden="true">Jordan标准型定义</figcaption></figure><p>其中 <spanclass="math inline">\(J_1(\lambda_1),J_2(\lambda_2)\)</span>分别构成Jardon块。</p><p>即对任意矩阵 <spanclass="math inline">\(A\)</span>，比存在n阶可逆矩阵<spanclass="math inline">\(P\)</span>，使 <spanclass="math display">\[P^{-1}AP=\begin{bmatrix}    J_1 &amp; &amp; &amp; \\ &amp; J_2 &amp; &amp; \\ &amp; &amp; \ddots&amp; \\ &amp; &amp; &amp; J_n\end{bmatrix} = J\]</span></p><p>每一个 <span class="math inline">\(J\)</span> 都是Jardon块 <spanclass="math display">\[J_i=\begin{bmatrix}    \lambda_i &amp; 1 &amp; &amp; \\ &amp; \lambda_i &amp; \ddots &amp;&amp; \\ &amp; &amp; \ddots &amp;1 \\ &amp; &amp; &amp; \lambda_i\end{bmatrix}\]</span></p><h3 id="jordan标准型的结构与结论">Jordan标准型的结构与结论</h3><ul><li>Jordan标准型的个数<spanclass="math inline">\(k\)</span>是线性无关特征向量的个数</li><li>矩阵可对角化当且仅当<span class="math inline">\(k=n\)</span></li><li>相应于一个已知特征值的Jordan块的个数是该特征值的几何重数，它是相应的特征子空间的维数，相应于一个已知特征值的所有Jordan的阶数之和，是该特征值的代数重数</li><li>特征值的几何重数 &lt; 代数重数</li><li>矩阵不同特征值对应的特征向量线性无关</li></ul><figure><img src="/img/矩阵论/Jordan标准型定理2.png" alt="定理2" /><figcaption aria-hidden="true">定理2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征值估计</title>
    <link href="/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/12/04/%E7%89%B9%E5%BE%81%E5%80%BC%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>shur不等式</strong> <imgsrc="/img/矩阵论/特征值估计-shur不等式.png" /></p><p>证明如下： <img src="/img/矩阵论/shur不等式证明.png" /></p><p><strong>行盖尔圆盘和列盖尔圆盘</strong>： <imgsrc="/img/矩阵论/盖尔圆盘.png" /></p><p><strong>圆盘定理</strong>： <img src="/img/矩阵论/圆盘定理1.png" /><img src="/img/矩阵论/圆盘定理2.png" /></p><p>推论1：设<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>相似于对角阵.</p><p>推论2： 设<span class="math inline">\(n\)</span>阶实阵<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>个盖尔圆盘两两互不相交，则<spanclass="math inline">\(A\)</span>特征值全为实数.</p><p><strong>对角占优矩阵</strong>：</p><p><img src="/img/矩阵论/对角占优矩阵.png" /></p><p><strong>Rayleigh商</strong>：设<span class="math inline">\(A \in\mathbb{C}^{n \times n}\)</span>为Hermite矩阵，<spanclass="math inline">\(x \in \mathbb{C}\)</span>，称 <spanclass="math display">\[R(x)=\frac{x^HAx}{x^Hx}, x \ne 0\]</span></p><p>为<span class="math inline">\(A\)</span>的Rayleigh商。</p><p><strong>定理（Rayleigh-Ritz）</strong>: <imgsrc="/img/矩阵论/Rayleigh-Ritz定理.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵函数</title>
    <link href="/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/04/%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数">矩阵函数</h2><p><strong>定义</strong>： 设幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty} c_kz^k\)</span>收敛半径为<span class="math inline">\(r\)</span>，且当<spanclass="math inline">\(|z|&lt;r\)</span>的时候，幂级数收敛于<spanclass="math inline">\(f(z)\)</span>，即</p><p><span class="math display">\[f(z)=\sum\limits_{k=0}^{\infty} c_kz^k,|z|&lt;r\]</span></p><p>如果<span class="math inline">\(A \in\mathbb{C}^{n×n}\)</span>满足<spanclass="math inline">\(r(A)&lt;r\)</span>,则收敛的矩阵幂级数<spanclass="math inline">\(\sum\limits_{k=0}^{\infty}a_kA^k\)</span>的和为矩阵函数，记为<spanclass="math inline">\(f(A)\)</span>，即</p><p><span class="math display">\[f(A)=\sum\limits_{k=0}^{\infty} c_kA^k\]</span></p><p>把<span class="math inline">\(f(A)\)</span>的方阵换为<spanclass="math inline">\(At\)</span>,<spanclass="math inline">\(t\)</span>为参数，得到</p><p><span class="math display">\[f(At)=\sum\limits_{k=0}^{\infty}c_k(At)^k\]</span></p><p>常见的矩阵级数有：</p><p><img src="/img/矩阵论/矩阵函数/常见矩阵函数1.png" /> <imgsrc="/img/矩阵论/矩阵函数/常见矩阵函数2.png" alt="常见矩阵函数" /></p><h3 id="矩阵函数的计算方法">矩阵函数的计算方法</h3><h4 id="利用相似对角化">利用相似对角化</h4><p>设<span class="math inline">\(P^{-1}AP= diag(\lambda_1,\lambda_2,\dots, \lambda_3) = D\)</span></p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算2.png" /></p><p><strong>例1</strong>：</p><p><img src="/img/矩阵论/矩阵函数/相似对角化计算-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/相似对角化计算-例1-3.png" /></p><h4 id="jordan标准型法">Jordan标准型法</h4><p><img src="/img/矩阵论/矩阵函数/Jordan法-例1-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-2.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例1-4.png" /></p><p><strong>例2</strong>：</p><p><img src="/img/矩阵论/矩阵函数/Jordan法-例2-1.png" /> <imgsrc="/img/矩阵论/矩阵函数/Jordan法-例2-2.png" /></p><h4 id="数项级数求和法">数项级数求和法</h4><p><img src="/img/矩阵论/矩阵函数/数项级数求和法.png" /></p><p>由哈密尔顿-凯莱定理于是我们有：</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-2.png" /></p><p>由该定理，我们可以实现降次的目的。</p><p><img src="/img/矩阵论/矩阵函数/数项级数求和法-3.png" /> <imgsrc="/img/矩阵论/矩阵函数/数项级数求和法-4.png" /></p><h3 id="矩阵函数的性质">矩阵函数的性质</h3><p><img src="/img/矩阵论/矩阵函数/矩阵函数性质.png" /></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近似算法</title>
    <link href="/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/03/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="近似算法">近似算法</h2><p>假设现在需要解决一个NP-Hard问题，但是又不太可能在多项式时间内求解，但是我们可以退而求其次，那么就必须要牺牲下面的其中一项：</p><ul><li>求得最优解</li><li>在多项式时间内完成</li><li>覆盖问题的所有例子</li></ul><p>而牺牲第二条是不能接受的，当我们选择满足后两者（也就是牺牲第一项），即对解的优越性放宽要求时，设计出的算法被称为<strong>近似算法</strong>。</p><h2 id="load-balancing问题">Load Balancing问题</h2><p>给定<span class="math inline">\(m\)</span>台相同的机器，<spanclass="math inline">\(n\)</span>个任务，任务<spanclass="math inline">\(j\)</span>需要的处理时间为<spanclass="math inline">\(t_j\)</span>,且每个任务<spanclass="math inline">\(j\)</span>必须在一台机器上连续完成。</p><p>令<span class="math inline">\(J(i)\)</span>为分配给机器<spanclass="math inline">\(i\)</span>的任务子集，机器<spanclass="math inline">\(i\)</span>的负载为<spanclass="math inline">\(L_i=\sum\limits_{j \inJ(i)}t_j\)</span>,该问题的时间跨度(makespan)为所有机器上的结束时间最大值<spanclass="math inline">\(L=\max\limits_i L_i\)</span>。</p><p><strong>LoadBalancing</strong>：求上述问题中的任务分配使得时间跨度最小。</p><h3 id="贪心算法">贪心算法</h3><p>每次将任务<spanclass="math inline">\(j\)</span>分配在当前负载最小的机器上： <imgsrc="/img/近似算法/LoadBalancing贪心算法.png" /></p><p><strong>引理1</strong>：最优解makespan<span class="math inline">\(L^*\ge \max\limits_j t_j\)</span>。</p><p>用时最长的这个任务总需要分配到一个机器上完成.</p><p><strong>引理2</strong>:最优解makespan <span class="math inline">\(L^*\ge \frac{1}{m} \sum\limits_j t_j\)</span></p><p>所有任务的总运行时间为<span class="math inline">\(\sum\limits_jt_j\)</span>,那么<spanclass="math inline">\(L^*\)</span>的时间跨度必然选自<spanclass="math inline">\(m\)</span>个机器中最大的一个,而<spanclass="math inline">\(m\)</span>个机器中的最大时间跨度一定不小于<spanclass="math inline">\(\frac{1}{m}\)</span>的总运行时间.</p><p><strong>定理:贪心算法是LoadBalancing问题的二倍近似算法。</strong></p><p>证明:</p><p>假设负载<span class="math inline">\(L_i\)</span>为问题的平静,令<spanclass="math inline">\(j\)</span>为最后一个分配到该机器的任务,由贪心算法,在任务<spanclass="math inline">\(j\)</span>分配之前,机器<spanclass="math inline">\(i\)</span>的负载是最小的.<spanclass="math inline">\(j\)</span>分配之前机器<spanclass="math inline">\(i\)</span>的负载为<span class="math inline">\(L_i- t_j\)</span>,也就是说在准备分配<spanclass="math inline">\(j\)</span>的时候有<span class="math inline">\(L_i- t_j\)</span>小于或等于所有机器上的负载<span class="math inline">\(L_k,1 \le k \le m\)</span></p><p><img src="/img/近似算法/LoadBalancing贪心算法证明-1.png" /></p><p>分配任务<span class="math inline">\(j\)</span>之前,由引理1: <spanclass="math display">\[  \begin{aligned}    L_i - t_j &amp;\le \frac{1}{m}\sum\limits_k L_k \\        &amp;=  \frac{1}{m} \sum\limits_k t_k \\        &amp;\le L^*    \end{aligned}\]</span></p><p>分配任务<span class="math inline">\(j\)</span>后,由上式以及引理2:<span class="math display">\[L_i = (L_i -t_i) + t_j \le L^* +\max\limits_j t_j \le L^* + L^* = 2L^*\]</span></p><p>那么贪心算法是Load Balancing的紧2倍近似算法吗?判断<spanclass="math inline">\(\rho\)</span>-近似算法是否紧的要看该算法相比于最优解有比<spanclass="math inline">\(\rho\)</span>更低的近似率吗?若有则说明其并不是紧的。</p><p>答:大致是的,考虑下面的一个Load Balancing的实例,有<spanclass="math inline">\(m\)</span>个机器,<spanclass="math inline">\(m^2\)</span>个任务,其中有<spanclass="math inline">\(m(m-1)\)</span>个任务运行时间为1,一个任务的运行时间为<spanclass="math inline">\(m\)</span>.贪心算法的结果如下图所示:</p><p><img src="/img/近似算法/LoadBalancing实例-贪心算法.png" /></p><p>而最优解的结果为:</p><p><img src="/img/近似算法/LoadBalancing实例-最优解.png" /></p><p>这个实例里贪心算法的时间跨度为19,而最优解的时间跨度为10.</p><h3 id="lptlongest-processing-time算法">LPT(longest ProcessingTime)算法</h3><p>LPT算法是在上面的贪心算法基础之上,先对<spanclass="math inline">\(n\)</span>个任务按时间降序排序,然后再按照上面的贪心算法执行.</p><p><img src="/img/近似算法/LoadBalancingLPT算法.png" /></p><p>通过观察可以得出,当任务数小于或等于机器数的时候,LRT算法就是最优解.这时候只需要把任务<spanclass="math inline">\(i\)</span>分配给机器<spanclass="math inline">\(i\)</span>.</p><p><strong>引理3</strong>:如果任务数多于机器数<spanclass="math inline">\(m\)</span>,有<span class="math inline">\(L^* \ge2t_{m+1}\)</span>.</p><p>设前<spanclass="math inline">\(m+1\)</span>个任务的运行时间分别为<spanclass="math inline">\(t_1,\dots,t_{m+1}\)</span>,由于运行时间<spanclass="math inline">\(t_i\)</span>是按照降序排列,所以前<spanclass="math inline">\(m+1\)</span>个任务的运行时间都不小于<spanclass="math inline">\(t_{m+1}\)</span>,且由于鸽笼原则,至少有一个机器会被分配两个任务.</p><p><strong>定理:LPT算法是Load Balancing的一个<spanclass="math inline">\(\frac{3}{2}\)</span>近似算法.</strong></p><p>证明:与证明贪心算法相同的方法 <span class="math display">\[L_i=(L_i -t_j) + t_j \le L^* + \frac{1}{2}L^* = \frac{3}{2}L\]</span></p><p>那么LPT算法是Load Balancing的紧<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似算法吗?不是;LPT算法是LoadBalancing的紧<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似算法吗?很可能是.</p><h2 id="centrer-selection-problem中心选址问题">Centrer SelectionProblem(中心选址问题)</h2><p>定义:给定一个大小为<spanclass="math inline">\(n\)</span>个地址集合<spanclass="math inline">\(s_1,s_2,\dots,s_n\)</span>以及一个整数<spanclass="math inline">\(k&gt;0\)</span>,选择<spanclass="math inline">\(k\)</span>个中心使所有地址到离它最近的中心距离的最大值最短.</p><p><img src="/img/近似算法/CentrerSelectionProblem.png" /></p><p>几个概念:</p><ul><li><span class="math inline">\(dist(x, y)\)</span>:<spanclass="math inline">\(x,y\)</span>的距离.</li><li><span class="math inline">\(dist(s_i, C)=\min\limits_{c \inC}\)</span>:<spanclass="math inline">\(s_i\)</span>到离它最近的中心的距离,这里采用欧式距离.</li><li><span class="math inline">\(r(C)=\max\limits_{i}dist(s_i,C)\)</span>:最小的覆盖半径.</li></ul><p>中心选址问题的目标便是找到一个中心集合<spanclass="math inline">\(C\)</span>使覆盖半径<spanclass="math inline">\(r(C)\)</span>最小,其中中心的数量等于<spanclass="math inline">\(k\)</span>.</p><p>距离的一些性质: <span class="math display">\[dist(x,x)=0\tag{同一性}\]</span> <span class="math display">\[dist(x,y)=dist(y,x)\tag{对称性}\]</span> <span class="math display">\[dist(x,y) \ledist(x,z) + dist(z,y) \tag{三角不等式}\]</span></p><h3 id="贪心算法-1">贪心算法</h3><p>开始时我们任意选取一个地址作为中心，接着选择离第一个中心最远的那个地址作为第二个中心，如此的重复进行,直到选了<spanclass="math inline">\(k\)</span>个中心为止。</p><p><img src="/img/近似算法/CentrerSelectionProblem贪心算法.png" /></p><p><strong>定理：贪心算法是中心选址问题的2倍近似解</strong></p><p>证明(反证法)：</p><p>假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span></p><ul><li>对近似解集合<span class="math inline">\(C\)</span>的中心<spanclass="math inline">\(c_i\)</span>，总有一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>在<spanclass="math inline">\(c_i\)</span>的圆中(任意一个最优解的中心<spanclass="math inline">\(c_i^*\)</span>的圆里最少有一个地址<spanclass="math inline">\(s\)</span>,而贪心算法选址都是在地址集合中选的，并且<spanclass="math inline">\(c_i\)</span>的半径 <spanclass="math inline">\(&gt;\)</span> <spanclass="math inline">\(c_i^*\)</span>的半径，所以<spanclass="math inline">\(c_i^*\)</span>必然在某一个中心<spanclass="math inline">\(c_i\)</span>的圆里)</li><li>令<span class="math inline">\(c_i\)</span>是与<spanclass="math inline">\(c_i^*\)</span>对应的中心</li><li>对于任意一个离最优解<spanclass="math inline">\(c_i^*\)</span>最近的地址<spanclass="math inline">\(s\)</span>,有</li></ul><p><span class="math display">\[dist(s,C) \le dist(s, c_i) \le dist(s,c_i^*) + dist(c_i^*, c_i) \le r(C^*) + r(C^*) = 2r(C^*)\]</span></p><p>上式与假设<spanclass="math inline">\(r(C^*)&lt;\frac{1}{2}r(C)\)</span>相违背，故有<spanclass="math inline">\(r(C^*) \ge\frac{1}{2}r(C)\)</span>,即贪心算法是中心选址问题的2倍近似解。</p><p>中心选址问题有没有<spanclass="math inline">\(\frac{3}{2}\)</span>倍近似解或者<spanclass="math inline">\(\frac{4}{3}\)</span>倍近似解？</p><p>答：没有，除非P＝NP，否则中心选址问题没有倍率比2小的近似算法。</p><h2 id="weighted-vertex-cover">Weighted Vertex Cover</h2><p>带权值的顶点覆盖：对于给出的一个顶点带权值的图<spanclass="math inline">\(G\)</span>，找到一个顶点覆盖，使它们的权值之和最小。（这里我们主要解决的是：求图<spanclass="math inline">\(G=(V,E)\)</span>的顶点覆盖<spanclass="math inline">\(S\)</span>，要使顶点集合<spanclass="math inline">\(S\)</span>中所有顶点的权值之和最小。</p><p><img src="/img/近似算法/WeightedVertexCover.png" /></p><h3 id="pricing-method">Pricing Method</h3><p><strong>定价法</strong>：因为顶点覆盖要求每条边至少有一个顶点在集合<spanclass="math inline">\(S\)</span>里,每条边必须被一些顶点所覆盖，根据顶点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>，给边<span class="math inline">\(e =(i, j)\)</span> 标上价格<span class="math inline">\(P_e\)</span>。</p><p>公平性：与顶点<spanclass="math inline">\(i\)</span>所连接的所有边的价格（权值）之和必须小于顶点<spanclass="math inline">\(i\)</span>的权值。</p><p>引理：：图<spanclass="math inline">\(G\)</span>的所有边的价格（权值）之和 <spanclass="math inline">\(\le\)</span> 顶点覆盖<spanclass="math inline">\(S\)</span>中所有顶点的权值之和（两个简单的缩放）。</p><p><img src="/img/近似算法/WeightedVertexCover-不等式放缩.png" /></p><p>上面第一个<spanclass="math inline">\(\le\)</span>不能写成等号，等号只在每条边都恰好只有一个顶点在<spanclass="math inline">\(S\)</span>中时才成立，若有边的两个顶点都在<spanclass="math inline">\(S\)</span>中，那么这条边就会被计算两次。</p><p>求解过程：边的价格设置与找寻顶点覆盖同时进行</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-求解过程.png" /></p><p>例子：</p><p><imgsrc="/img/近似算法/WeightedVertexCover-PricingMethod-例子.png" /></p><p><strong>Pricing Method是Weighted VertexCover</strong>的一个2倍近似算法。</p><p>证明：</p><p>首先证明<span class="math inline">\(S\)</span>是一个点覆盖：</p><p>算法结束条件：在while循环的每次迭代结束之后，至少有一个顶点会是紧致的（除非图没有边），所以在算法结束的时候每条边的两个顶点中至少有一个是紧的，即每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，而VertexCover要求每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中，所以<spanclass="math inline">\(S\)</span>必然是一个点覆盖，否则循环就不会停止。</p><p>然后再证明<spanclass="math inline">\(S\)</span>是最优解的一个2倍近似解：</p><p><img src="/img/近似算法/证明PricingMethod2倍近似解.png" /></p><p>第一处放缩很容易得出，<spanclass="math inline">\(S\)</span>肯定为顶点集<spanclass="math inline">\(V\)</span>的一个子集；<spanclass="math inline">\(\sum\limits_{i \in V} \sum\limits_{e=(i,j)} p_e =2 \sum\limits_{e \in E} p_e\)</span>是因为计算与<spanclass="math inline">\(V\)</span>中所有顶点相连的边时，每条边会被计算两次；最右边一个放缩为引理的结论。</p><h2id="线性规划解决最小带权点覆盖问题">线性规划解决最小带权点覆盖问题</h2><h3 id="整数规划">整数规划</h3><p>对于图<spanclass="math inline">\(G=(V,E)\)</span>,对图中的每个点<spanclass="math inline">\(v \in V\)</span>，定义函数<spanclass="math inline">\(x(v) \in {0, 1}\)</span>,且 <spanclass="math inline">\(x(v)=0\)</span>，表示顶点 <spanclass="math inline">\(v\)</span>不在点覆盖集合里。</p><p>对图中任意一条边 <span class="math inline">\((u,v) \inE\)</span>,由点覆盖定义，顶点<spanclass="math inline">\(u\)</span>、顶点<spanclass="math inline">\(v\)</span> 至少有一个必须在点覆盖中 ，因此：<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>.</p><p>因而得到最小权值点覆盖的规划模型：其中<spanclass="math inline">\(w(v)\)</span> 表示顶点<spanclass="math inline">\(v\)</span>的权值。</p><p><img src="/img/近似算法/整数规划.png" /></p><h3 id="线性规划">线性规划</h3><p>线性规划在整数规划的基础之上不再限定<spanclass="math inline">\(x(v)\)</span>只为0或1，而是有一个范围 <spanclass="math inline">\(x(v) \in [0, 1]\)</span> 这样在整数规划中的<spanclass="math inline">\(x(u) + x(v) \ge 1\)</span>仍然成立.这是可以的。因为：前者是后者的一个特例。前者称为0-1整数规划，后者为普通的线性规划。因此，线性规划中的最优解是0-1整数规划最优解的一个下界（因为线性规划最优解包含了0-1整数规划最优解）。</p><p><img src="/img/近似算法/点覆盖-LP规划.png" /></p><p><strong>用线性规划的解来构造最小权值点覆盖问题的近似解算法</strong>:</p><p>对于每一个顶点<spanclass="math inline">\(v\)</span>，都会求得一个<spanclass="math inline">\(x(v)\)</span>的值。若，<spanclass="math inline">\(x(v) \ge 1/2\)</span>,则将该顶点加入到点覆盖集合中，否则舍去顶点<spanclass="math inline">\(v\)</span>，直至图G中所有的顶点都处理完毕。此时得到的顶点集合<spanclass="math inline">\(C\)</span>即为最小权值点覆盖问题的近似解的点覆盖集合。</p><p><strong>线性规划求得的顶点集合C是最小权值点覆盖问题的二倍近似解</strong>:</p><p>设 <span class="math inline">\(C^*\)</span>是最小权值点覆盖问题的一个最优解，<span class="math inline">\(Z\)</span>是线性规划的一个最优解， <spanclass="math inline">\(C\)</span>是最小权值点覆盖问题的近似解.</p><ol type="1"><li>由于最小权值点覆盖问题的一个最优解是线性规划的一个可行解，故：<spanclass="math inline">\(Z \le W(C^*)\)</span>(<spanclass="math inline">\(W\)</span>为求权值的函数)</li><li>为什么求得的集合<spanclass="math inline">\(C\)</span>就是一个点覆盖呢？因为对任意边<spanclass="math inline">\((u,v) \in E\)</span>,有<spanclass="math inline">\(x(u)+x(v)\ge 1\)</span>，即在<spanclass="math inline">\(x(u)\)</span>和<spanclass="math inline">\(x(v)\)</span>中至少有一个的值大于1/2。因此，顶点<spanclass="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>至少有一个会被加入到集合<spanclass="math inline">\(C\)</span>中，从而使得图<spanclass="math inline">\(G\)</span>中的每一条边都会被覆盖。</li><li>由下式</li></ol><p><img src="/img/近似算法/证明线性规划是2倍近似解.png" /></p><p>以及<span class="math inline">\(Z \le W(C^*)\)</span>,知:<spanclass="math inline">\(W(C) \le 2Z &lt;=2W(C^*)\)</span>,即近似解<spanclass="math inline">\(C\)</span>的权值<span class="math inline">\(W(C)\le\)</span> 二倍最优解<spanclass="math inline">\(C^*\)</span>的权值.</p><p>那么是否有比2倍近似解更小的近似解?最小的近似解倍率是多少?</p><p>答:有.</p><p><strong>定理</strong>: 若 P <span class="math inline">\(\ne\)</span>NP,那么没有比<span class="math inline">\(\rho = 1.3607(10\sqrt{5} -21)\)</span>更小的<span class="math inline">\(\rho\)</span>-近似解.</p><h2id="多项式时间逼近算法polynomial-time-approximation-scheme">多项式时间逼近算法(PolynomialTime Approximation Scheme)</h2><p>上面的<spanclass="math inline">\(\rho\)</span>-近似算法是通过牺牲最优解来换取时间和例子,多项式时间逼近算法可以产生任意高质量的解决方案，但以精度换取时间。</p><p>以背包问题为例:物品<spanclass="math inline">\(i\)</span>的价值为<spanclass="math inline">\(v_i\)</span> ,重量为<spanclass="math inline">\(w_i\)</span>;背包最多可以拿的物品重量为<spanclass="math inline">\(W\)</span>.现在求最大可以拿取的物品价值。</p><p><img src="/img/近似算法/背包问题-例子.png" /></p><h3 id="方法1动态规划-1">方法1：动态规划-1</h3><p>定义<spanclass="math inline">\(OPT(i,w)=\)</span>所有物品中可以拿到的<strong>最大价值</strong>。</p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>新的容量为<span class="math inline">\(w-w_i\)</span></li><li><span class="math inline">\(OPT\)</span>在容量为<spanclass="math inline">\(w-w_i\)</span>的情况下在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到最优解</li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划1.png" /></p><p>运行时间：<span class="math inline">\(O(n W)\)</span></p><ul><li><span class="math inline">\(W=\)</span>重量限制</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="方法2动态规划2">方法2：动态规划2</h3><p>定义<span class="math inline">\(OPT(i,v)=\)</span>物品<spanclass="math inline">\(1,2,\dots,i\)</span>中拿取且得到的物品价值为<spanclass="math inline">\(v\)</span>所消耗的<strong>最小重量</strong></p><ul><li>若<span class="math inline">\(OPT\)</span>没有选择物品<spanclass="math inline">\(i\)</span><ul><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li><li>若<span class="math inline">\(OPT\)</span>选择物品<spanclass="math inline">\(i\)</span><ul><li>消耗重量<span class="math inline">\(w_i\)</span>,且新的价值为<spanclass="math inline">\(v-v_i\)</span></li><li><span class="math inline">\(OPT\)</span>在物品<spanclass="math inline">\(1,2,\dots,i-1\)</span>中选取得到的物品价值为<spanclass="math inline">\(v\)</span></li></ul></li></ul><p><img src="/img/近似算法/背包问题-动态规划2.png" /></p><p>运行时间：<span class="math inline">\(O(n V^*)=O(n^2v_{max})\)</span></p><ul><li><span class="math inline">\(V^*\)</span>为在<spanclass="math inline">\(OPT(n, v) \leW\)</span>的情况下可以选取的最大价值</li><li>输入<strong>不是</strong>多项式的</li></ul><h3 id="多项式时间逼近算法">多项式时间逼近算法</h3><p>以上的动态规划都可以得到最优解，但是考虑一个问题：若所有物品的价值远大于重量的时候，上面的动态规划还可行吗？</p><p>这时候问题的输入不是多项式的（物品的价值，因为在计算机内数据都要转化为2进制再处理），这时候为了使求解时间更快，引入了新的算法<strong>多项式时间逼近算法（PolynomialTime Approximation Scheme）</strong>。它的大致思想是：</p><ul><li>将所有的价值向上舍入到一个较小的范围里</li><li>在向上舍入后的实力上运行动态规划算法</li><li>得到向上舍入实例的最优解</li></ul><p>注：这里一定要是向上舍入而不能是四舍五入，虽然全部向上舍入可能会在原来的问题中丢失一些较为优质的解，但是若四舍五入的时候，若有向下舍去的价值，可能在新的实例中找到的解在原问题中是不可行解。</p><p><img src="/img/近似算法/背包问题-四舍五入.png" /></p><p>首先对所有价值向上舍入：</p><p><img src="/img/近似算法/向上舍入.png" /></p><ul><li><spanclass="math inline">\(v_{max}\)</span>为原始例子里的最大价值</li><li><span class="math inline">\(\varepsilon\)</span>为精确参数</li><li><span class="math inline">\(\theta\)</span>为放缩因子</li></ul><p>对于放缩之后的例子，复杂度<span class="math inline">\(O(n^3 /\varepsilon)\)</span>,使用上面的动态规划-2方法的运行时间为<spanclass="math inline">\(0(n^2 \hat{v}_{max})\)</span>.</p><p>其中</p><p><img src="/img/近似算法/公式1.png" /></p><p><strong>定理</strong>：若<spanclass="math inline">\(S\)</span>为多项式时间逼近算法找到的一个解，同时<spanclass="math inline">\(S^*\)</span>为另一个可行解，那么有 <spanclass="math inline">\((1+\varepsilon) \sum\limits_{i \in S}v_i \ge\sum\limits_{i \in S^*}v_i\)</span></p><p>证明：</p><p><img src="/img/近似算法/多项式时间逼近算法-证明.png" /></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NP问题以及常见多项式规约</title>
    <link href="/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/NP%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="pnpnpcnph问题">P、NP、NPC、NPH问题</h2><p><strong>P问题</strong>：存在多项式时间算法的决策问题。</p><p><strong>NP问题</strong>：能在多项式时间内验证某个猜想答案的正确性，但问题求解可能在无法在多项式时间内完成。比如Composite问题、3-Satisfiability、HamiltonianCycle，很容易就确定一个答案是否正确，但确找不到一个公式来描述其规律。</p><p><strong>结论1</strong>：P <spanclass="math inline">\(\subseteq\)</span> NP</p><p><strong>结论2</strong>：NP <spanclass="math inline">\(\subseteq\)</span> EXP</p><p><strong>EXP问题</strong>：存在指数时间算法的决策问题。</p><p><strong>NPC问题</strong>: 需要满足两个条件</p><ul><li>它是一个NP问题</li><li>所有的NP问题都可以规约到NP-complete</li></ul><p><strong>定理</strong>：若Y是一个NPC问题，那么Y可以在多项式时间内求解<strong>当且仅当</strong>P<spanclass="math inline">\(=\)</span>NP</p><p>证明：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若P <span class="math inline">\(=\)</span>NP，那么Y可以在多项式时间求解，因为Y是NP（NPC的第一个条件：它要先是一个NP）</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若Y可以在多项式时间求解： - 令X为任意一个NP问题，因为X <spanclass="math inline">\(\le_p\)</span>Y，而Y可以在多项式时间求解，故X也可以在多项式时间求解。NP <spanclass="math inline">\(\subseteq\)</span> P - 又已知P <spanclass="math inline">\(\subseteq\)</span> NP,所以 P <spanclass="math inline">\(=\)</span> NP</p><p><strong>如果</strong>我们给NPC问题找到了一个多项式时间复杂度的算法，那么也就意味着我们给所有的NP问题找到了多项式时间复杂度的算法，从而NP=P，因为P=NP，所以“P对NP问题”就可以被解决。但给NPC问题找一个多项式时间复杂度的算法太难了，所以现在人们普遍相信P≠NP。</p><p><strong>NPH问题</strong>：满足上面NPC问题的第二个条件，但不一定要满足第一个条件，所以NPH的范围比HPC更大。</p><h3 id="证明一个问题是npc问题的步骤">证明一个问题是NPC问题的步骤</h3><ul><li>证明这个问题Y属于NP</li><li>选择一个NPC问题X</li><li>证明X可以多项式规约到Y</li></ul><h3 id="证明一个问题是nph问题的步骤">证明一个问题是NPH问题的步骤</h3><p>要证明一个问题是NP-hard，通常是找到一个已被证明了的NPC问题，并把这个NPC问题归约到该问题上去（即NPC<span class="math inline">\(\le\)</span> NP-hard）,简单来说就是：</p><ul><li>对问题A给定限制条件得到一个特例B问题</li><li>证明问题B是NPC问题</li></ul><h2 id="npc之间规约的例子">NPC之间规约的例子</h2><h3 id="sat-le_p-independent-set">3-SAT <spanclass="math inline">\(\le_p\)</span> Independent Set</h3><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造:</p><ul><li>3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点</li><li>连接句子里的点连接形成三角形</li><li>连接不同Clause里每个Literal和它对应的非</li></ul><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h3 id="hamiltonian-cycle-problem">Hamiltonian Cycle problem</h3><p><strong>Hamiltonian Cycle</strong>:给定一个无向图 <spanclass="math inline">\(G=(V,E)\)</span>，是否存在一个简单的环 <spanclass="math inline">\(\Gamma\)</span> 包含 <spanclass="math inline">\(V\)</span> 中所有的点。</p><figure><img src="/img/多项式规约/HamiltonianCycle定义.png"alt="有奇数个节点的Hamiltonian Cycle" /><figcaption aria-hidden="true">有奇数个节点的HamiltonianCycle</figcaption></figure><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p><strong>DIR-HAM-CYCL <span class="math inline">\(\le_p\)</span>Ham-Cycle</strong>: 证明：给定一个有向图<spanclass="math inline">\(G=(V,E)\)</span>,构造一个有<spanclass="math inline">\(3n\)</span>个节点的无向图<spanclass="math inline">\(G&#39;\)</span>，则<spanclass="math inline">\(G\)</span>有Hamiltonian Cycle当且仅当<spanclass="math inline">\(G&#39;\)</span>有Hamiltonian Cycle。</p><p><img src="/img/多项式规约/DIR-HAM-CYC2Ham-Cycle.png" /></p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若<span class="math inline">\(G\)</span>中有一个有向的HamiltonianCycle，则<spanclass="math inline">\(G&#39;\)</span>中肯定也有一个HamiltonianCycle，且顺序与有向图的节点顺序相同。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>若<spanclass="math inline">\(G&#39;\)</span>中有一个无向的HamiltonianCycle，则从蓝色节点出发，节点的颜色出现顺序必然是两种中的一种 -B,G,R,B,G,R,<span class="math inline">\(\dots\)</span> -B,R,G,B,R,G,<span class="math inline">\(\dots\)</span></p><p>若<span class="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第一种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相同；若<spanclass="math inline">\(G&#39;\)</span>的HamiltonianCycle顺序是第二种，那么对应<spanclass="math inline">\(G\)</span>中的HamiltonianCycle的节点顺序与其蓝色节点顺序相反。</p><h3 id="sat-le_p-hamiltonian-cycle-problem">3SAT <spanclass="math inline">\(\le_p\)</span> Hamiltonian Cycle problem</h3><!-- **Vertex Cover**：一组顶点的集合，使得图的每条边至少与集合中的一个顶点相连接。在这里Vertex Cover问题是给定图$G$和点集的个数$k$，要找到图$G$的一个大小为$k$的点覆盖。（也就是常说的最小点覆盖） --><p><strong>构造思路:有<spanclass="math inline">\(n\)</span>个变量的3-SAT有<spanclass="math inline">\(2^n\)</span>种可能的分配，要将其规约到HamiltonianCycle，其对应的Hamiltonian Cycle应该也有<spanclass="math inline">\(2^n\)</span>种可能的分配方式。</strong></p><p>构造方法：对一个有<span class="math inline">\(n\)</span>个变量和<spanclass="math inline">\(k\)</span>个句子的3-SAT,构造<spanclass="math inline">\(3k+3\)</span>个节点的HamiltonianCycle，其中每个变量<span class="math inline">\(x_i\)</span>对应<spanclass="math inline">\(3k+3\)</span>个节点，令外再增加一个源点<spanclass="math inline">\(s\)</span>、一个汇点<spanclass="math inline">\(t\)</span>。</p><p><img src="/img/多项式规约/3-SAT2Ham-Cycle构造.png" /></p><p>如果 <spanclass="math inline">\(x_i=1\)</span>，则形成从左向右的一个路径；如果<spanclass="math inline">\(x_i=0\)</span>，则形成从右向左的一个路径。</p><p>对于每一个clause <span class="math inline">\(c_j=z_1 z_2z_3\)</span>，若<span class="math inline">\(z=x_i\)</span>,则添加有向边<spanclass="math inline">\((v_{i,3j},c_j)和(c_j,v_{i,3j+1})\)</span>;若<spanclass="math inline">\(z=\bar{x}_i\)</span>,则添加有向边<spanclass="math inline">\((c_j,v_{i,3j})和(v_{i,3j+1},c_j)\)</span>，这里<spanclass="math inline">\(1\le j\le m, 1\le i\len\)</span>。如上图所示（即若<spanclass="math inline">\(z=x_i\)</span>,该节点与<spanclass="math inline">\(c\)</span>节点的连接顺序是从左边进入<spanclass="math inline">\(c\)</span>节点，然后从右边出<spanclass="math inline">\(c\)</span>节点；反之顺序相反）。</p><p>如果选择子句<span class="math inline">\(C_1\)</span>中<spanclass="math inline">\(x_1=1\)</span>,则<spanclass="math inline">\(x_1\)</span>对应的路径为从左向右;同理<spanclass="math inline">\(x_2=0\)</span>,则<spanclass="math inline">\(x_2\)</span>对应的路径为从右向左；<spanclass="math inline">\(x_3=1\)</span>,则<spanclass="math inline">\(x_3\)</span>对应的路径为从左向右。其余句子同理，这样就得到了最终的图<spanclass="math inline">\(G\)</span>。</p><p><strong>证明</strong>:</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>假设3-SAT有一个可满足的分配<spanclass="math inline">\(x^*\)</span>：</p><ul><li>对于<span class="math inline">\(x_i\)</span>,若其为1，则第<spanclass="math inline">\(i\)</span>行从左往右遍历；反之，若其为0，则第<spanclass="math inline">\(i\)</span>行从右往左遍历</li><li>且对于每个句子节点<spanclass="math inline">\(c_i\)</span>，至少会有一行便利的时候会经过<spanclass="math inline">\(c_i\)</span>，否则便不满足每个句子都为真的条件，也就是该分配并不是可满足的。</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>假设构造的图<spanclass="math inline">\(G\)</span>有一个Ham-Cycle，那么</p><ul><li>若Ham-Cycle进入句子节点<spanclass="math inline">\(c_i\)</span>，那么它一定会返回相同的行，否则便不存在简单环。</li><li>这样Ham-Cycle里的句子节点<spanclass="math inline">\(c_i\)</span>与同一行的两个相邻节点相连，记这两个相邻节点之间的边为<spanclass="math inline">\(e_i\)</span></li><li>去掉句子节点<span class="math inline">\(c_i\)</span>，同时用<spanclass="math inline">\(e_i\)</span>替换与<spanclass="math inline">\(c_i\)</span>相连的两条边。</li><li>按上面的方法去掉所有的句子节点得到图也必然存在Ham-Cycle，且节点的顺序是相同的。</li><li>若Ham-Cycle的第<spanclass="math inline">\(i\)</span>行是从左往右遍历的，便令<spanclass="math inline">\(x_i=1\)</span>;反之则令<spanclass="math inline">\(x_i=0\)</span>，这样便得到一个分配方案，且其是可满足的。</li></ul><p>这样便得到一个分配方式，且每个句子都是可满足的。</p><h3 id="ham-cycle-le_p-tsptraveling-saleperson-problem">HAM-CYCLE <spanclass="math inline">\(\le_p\)</span> TSP(Traveling SalepersonProblem)</h3><p><strong>TSP(Traveling Saleperson Problem)</strong>：给定一个<spanclass="math inline">\(n\)</span>个城市的集合以及城市之间的距离<spanclass="math inline">\(d(u,v)\)</span>,是否存在一个旅行的路线使行走的距离<spanclass="math inline">\(\le n\)</span>?</p><p>旅行者问题与HAM-CYCLE的区别在于：旅行者问题并不限定简单路径，也就是说一个节点可以通过多次，只需要考虑最后的路径长度。</p><p><strong>DIR-HAM-CYCLE</strong>：给定一个有向图 <spanclass="math inline">\(G=(V,E)\)</span>,是否存在一个简单环 <spanclass="math inline">\(\Gamma\)</span> 包含<spanclass="math inline">\(V\)</span>中所有顶点？</p><p>$HAM-CYCLE <span class="math inline">\(\le_p\)</span> TSP(TravelingSaleperson Problem)$</p><p><strong>构造</strong>：给定一个HAM-CYCLE的实例<spanclass="math inline">\(G=(V,E)\)</span>,<spanclass="math inline">\(V\)</span>中的每个节点构造一个城市节点，城市之间的距离根据<spanclass="math inline">\(E\)</span>进行赋值: <spanclass="math display">\[d(u,v)= \begin{cases}    1, (u,v) \in E  \\    2, (u,v) \notin E\end{cases}\]</span></p><p>则TSP中有一个旅行路径<span class="math inline">\(\len\)</span>当且仅当<spanclass="math inline">\(G\)</span>中存在HAM-CYCLE</p><h3 id="sat-le_p-3-colorable">3-SAT <spanclass="math inline">\(\le_p\)</span> 3-Colorable</h3><p><strong>3-Colorable</strong>:给定一个无向图<spanclass="math inline">\(G\)</span>，并给图中的每个节点染上红、蓝、绿的其中一种颜色，那么是否存在一种染色方式使相邻的节点都有不同的颜色？</p><p>3-SAT <span class="math inline">\(\le_p\)</span> 3-Colorable</p><p><strong>构造</strong>：</p><ul><li>对每个Literal，构造一个节点</li><li>同时添加三个节点<spanclass="math inline">\(T、F、B\)</span>，连接这三个节点形成一个三角形</li><li>对每个literal节点，创建一个它的"非"并与它相连</li><li>所有的Literal节点都与<span class="math inline">\(B\)</span>相连</li></ul><p>如下图所示： <imgsrc="/img/多项式规约/3-SAT23-COLOLABLE-1.png" /></p><p>这样构造保证了下面的每个Literal节点都是绿色或红色，且它的“非”与它的颜色刚好相反。</p><p>继续接上面：</p><ul><li>对每个Clause，假设<span class="math inline">\(C_i=x_1 \vee\overline{x_2} \vee x_3\)</span>,则对<span class="math inline">\(x_1 ,\overline{x_2} , x_3\)</span>添加6个节点以及13条边</li></ul><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-2.png" /></p><p>即<span class="math inline">\(x_1 , \overline{x_2} ,x_3\)</span>下方的两行一共6个节点，并将左下角的节点、第一行的节点与之前构造的<spanclass="math inline">\(T\)</span>节点相连，右下角的节点与之前的<spanclass="math inline">\(F\)</span>节点相连。</p><p>这样构造是为了保证当三个Literal节点全为红色的时候，是不满足三着色的，如下图所示：当三个Literal节点全为红色的时候，他们下面那行节点必须为蓝色，这样最后一行从左到右着色，最后一个节点冲突。</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-3.png" /></p><p><strong>3-SAT <span class="math inline">\(\le_p\)</span>3-Colorable</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>若图3-Colorable：</p><ul><li>将所有为绿色的Literal节点设为真</li><li>由上面可知，当图3-Colorable的时候三个Literal节点至少有一个是绿色的，那么该句子的输出为真</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><p>若3-SAT是可满足的：则 - 三个Literal节点至少有一个为真 -将为真的Literal节点染为绿色，然后将该节点下面的节点染为红色（否则会冲突），再继续将下面的节点染为蓝色-对中间一行没有染红的节点染为蓝色，然后它们下面一行没有染色的节点可唯一确定颜色</p><p><img src="/img/多项式规约/3-SAT23-COLOLABLE-4.png" /></p><p>上面没有染色的Literal节点绿色、红色皆可。</p><h3 id="color搜索问题-le_p-3-color判断问题自规约">3-COLOR搜索问题 <spanclass="math inline">\(\le_p\)</span> 3-COLOR判断问题（自规约）</h3><p><strong>方法1</strong>：</p><p>将3-COLOR图中不相邻的点合并，合并后的点表示之前所有合并过来点的集合，如下图所示：</p><p><img src="/img/多项式规约/3-color自规约.png" /></p><p>然后一直重复上述步骤，若图可以进行3着色，那么到最后图必然会合并为一个三角形。染色是对最后的三角形三个点所代表的点的集合染成不同的颜色，便为最后的3着色。</p><p><strong>方法2</strong>：</p><p>设判定算法为<span class="math inline">\(D\)</span></p><ol type="1"><li>调用算法<spanclass="math inline">\(D\)</span>判断原图是否有解，若无解，则返回NO。</li><li>任意选择一对边<span class="math inline">\((u,v)\)</span>，满足<spanclass="math inline">\((u,v) \notin E\)</span><ol type="1"><li>考虑图<span class="math inline">\(G&#39; = G +(u,v)\)</span>，调用<spanclass="math inline">\(D\)</span>判断是否有解。</li><li>若<span class="math inline">\(G&#39;\)</span>无解，标记点对<spanclass="math inline">\((u,v)\)</span>；若有解，添加边<spanclass="math inline">\((u,v)\)</span>到<spanclass="math inline">\(G\)</span>中。</li></ol></li><li>返回步骤2，继续选择一对未标记点对。</li><li>若图<spanclass="math inline">\(G\)</span>构成一个三部完全图，每一部选择一个颜色，输出颜色方案。### 点覆盖搜索问题 <span class="math inline">\(\le_p\)</span>点覆盖判断问题</li></ol><ul><li>从1开始，依次查找该图有没有<spanclass="math inline">\(k^*\)</span>个顶点的顶点覆盖(这样得到的第一次满足的<spanclass="math inline">\(k^*\)</span> 的值就是该图最小顶点覆盖的数目)</li><li>从图中选出一个点<span class="math inline">\(v\)</span>，若去除该点后图的顶点覆盖数目变为<span class="math inline">\(k^* −1\)</span>，则<spanclass="math inline">\(v\)</span>是原图顶点覆盖中的一员，反之则不是</li><li>在<span class="math inline">\(G −v\)</span>中递归执行上述两步。</li></ul><h3 id="ham-cycle搜索问题-le_p-ham-cycle判断问题">Ham-Cycle搜索问题<span class="math inline">\(\le_p\)</span> Ham-Cycle判断问题</h3><p>证明：若可以在多项式时间内给出判定一个图是否存在哈密尔顿圈，则可以在多项式时间内找到一个图的哈密尔顿圈（如果存在的话）</p><p>首先判断<spanclass="math inline">\(G\)</span>中是否存在Ham-Cycle,若不存在则算法结束，如果存在则继续寻找Ham-Cycle:<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">对G中的每条边e<br>&#123;<br>    若G-e不存在Ham-<span class="hljs-keyword">Cycle</span>，将e加入S中；<br>    否则令G=G-e<br>&#125;<br>最后所得的集合便是一个Ham-<span class="hljs-keyword">Cycle</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式规约</title>
    <link href="/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/"/>
    <url>/2022/12/02/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A7%84%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="多项式规约">多项式规约</h2><p>定义：若问题X 的任意实例可以由下面两条之和解决</p><ul><li>问题X可以通过多项式时间的基本运算步骤转换为问题Y；</li><li>问题X多项式次调用求解问题Y的算法，且问题Y可以在多项式时间内被求解。</li></ul><p>那么称问题X可以多项式规约到问题Y，记为 $ X _{p} Y$。需要注意的是，问题X转换为问题Y之后，问题Y的运行时间是建立在问题Y的输入上。</p><p>多项式规约的几个性质：</p><ul><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若Y能在多项式时间内求解，那么X也能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p}Y\)</span>，则若X不能在多项式时间内求解，那么Y也不能在多项式时间内求解。</li><li>若 <span class="math inline">\(X \le_{p} Y\)</span> 且 <spanclass="math inline">\(Y \le_{p} X\)</span>，那么X和Y是等价的。</li></ul><h3 id="基本的规约方法">基本的规约方法</h3><ul><li>简单的恒等归约：比如最大独立集和最小点覆盖。</li><li>从特殊例子到一般例子：比如 <span class="math inline">\(点覆盖\le_{p} 集合覆盖\)</span>。<br /></li><li>通过一些小技巧规约。比如 <span class="math inline">\(3-SAT \le_{p}独立集\)</span></li></ul><h3 id="简单的恒等规约">简单的恒等规约</h3><h4 id="独立集问题independent-set">独立集问题（Independent Set）</h4><p><strong>定义</strong>：给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k(V为顶点集，E为边集)，是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \gek\)</span>并且图中每条边至多有一个顶点在S中？</p><figure><img src="/img/多项式规约/独立集.png" alt="独立集" /><figcaption aria-hidden="true">独立集</figcaption></figure><h4 id="点覆盖问题vertex-cover">点覆盖问题（Vertex Cover）</h4><p><strong>定义</strong>:给定一个图 <spanclass="math inline">\(G=(V,E)\)</span>和一个整数k,是否有一个V的子集<span class="math inline">\(S \subseteq V\)</span>使得 <spanclass="math inline">\(|S| \lek\)</span>并且图中的每条边至少有一个顶点在<spanclass="math inline">\(S\)</span>中？</p><figure><img src="/img/多项式规约/点覆盖.png" alt="点覆盖" /><figcaption aria-hidden="true">点覆盖</figcaption></figure><h4 id="vertex-cover和independent-set的关系">Vertex Cover和IndependentSet的关系</h4><p><strong>定理： <span class="math inline">\(点覆盖 \equiv_p独立集\)</span></strong></p><p>证明如下：</p><p><span class="math inline">\(\Rightarrow\)</span></p><ul><li>令<span class="math inline">\(S\)</span>为任意独立集</li><li>对任意的边 <span class="math inline">\((u,v)\)</span></li><li><span class="math inline">\(S\)</span>是独立集 <spanclass="math inline">\(\Rightarrow\)</span> <span class="math inline">\(u\notin S\)</span> 或 <span class="math inline">\(v \notin S \Rightarrowu \in V - S\)</span> 或 <span class="math inline">\(v \in V -S\)</span></li><li>所以 <span class="math inline">\(V-S\)</span> 是一个点覆盖</li></ul><p><span class="math inline">\(\Leftarrow\)</span></p><ul><li>令 <span class="math inline">\(V-S\)</span>是一个点覆盖</li><li>对两个顶点 <span class="math inline">\(u \in S\)</span> 及 <spanclass="math inline">\(v \in S\)</span></li><li>若 <span class="math inline">\(V-S\)</span> 是一个点覆盖,那么 <spanclass="math inline">\((u, v) \notin E\)</span></li><li>因此，没有相邻的顶点在 <span class="math inline">\(S\)</span> 中<span class="math inline">\(\Rightarrow\)</span> <spanclass="math inline">\(S\)</span>是独立集</li></ul><h3 id="从特殊例子到一般例子">从特殊例子到一般例子</h3><h4 id="集合覆盖set-cover">集合覆盖（Set Cover）</h4><p><strong>定义</strong>：给定一个集合<spanclass="math inline">\(U\)</span>，以及<spanclass="math inline">\(U\)</span>的子集<spanclass="math inline">\(S_1,S_2,\dots,S_m\)</span>以及一个整数<spanclass="math inline">\(k\)</span>，是否存在小于或等于<spanclass="math inline">\(k\)</span>个子集<spanclass="math inline">\(S_i\)</span>的并等于<spanclass="math inline">\(U\)</span>?</p><p><strong>例子</strong>:</p><figure><img src="/img/多项式规约/集合覆盖例子.png" alt="几何覆盖例子" /><figcaption aria-hidden="true">几何覆盖例子</figcaption></figure><h4 id="vertex-cover归约到set-cover">Vertex Cover归约到Set Cover</h4><p><strong>证明：给定一个Vertex-Cover的实例<spanclass="math inline">\(G=(V,E),k\)</span>,可以构造一个与VertexCover大小相等的Set Cover的实例。（从特殊例子到一般例子）</strong></p><ul><li>创建一个Set Cover的实例<span class="math inline">\(k = k,U=E,S_v=\{e\in E: 与V相连的边\}\)</span></li><li>可以看到Set Cover的<span class="math inline">\(size \lek\)</span>当且仅当Vertex Cover的<span class="math inline">\(size \lek\)</span></li></ul><p><strong>例子</strong>：有如下点覆盖</p><p><img src="/img/多项式规约/VertexCover归约到SetCover例子.png" /></p><p>构造Set Cover的<span class="math inline">\(U\)</span>为VertexCover的边集，即<span class="math inline">\(U=(1,2,3,4,5,6)\)</span>，SetCover的每个子集<span class="math inline">\(S_i\)</span>为VertexCover中对应顶点所连的边,故有 <span class="math display">\[    S_a=\{3,7\}， \\    S_b=\{2,4\}， \\    S_c=\{3,4,5,6\}， \\    S_d=\{5\}，  \\    S_e=\{1\}， \\    S_f=\{1,2,6,7\}    \]</span></p><p>可以看到<span class="math inline">\(S_c\)</span>和<spanclass="math inline">\(S_f\)</span>构成一个SetCover的实例，而这两个子集对应的顶点恰好组成一个Vertex Cover的实例。</p><h3 id="通过小技巧规约">通过"小技巧"规约</h3><h4 id="sat问题">3-SAT问题</h4><p><strong>Literal（字）</strong>：一个布尔变量或者它的非<spanclass="math inline">\(x_i \quad or \quad \overline{x_i}\)</span></p><p><strong>Clause（句子）</strong>：Literal的析取 <spanclass="math inline">\(C_j = x_1 \vee \overline{x_2} \veex_3\)</span></p><p><strong>Formula（式子）</strong>：Clause的合取 <spanclass="math inline">\(\Phi=C_1 \wedge C_2 \wedge C_3 \wedgeC_4\)</span></p><p><strong>SAT</strong>:给定CNF式子<spanclass="math inline">\(\Phi\)</span>，是否存在一个满足结果是True的分配<spanclass="math inline">\(x_1,\dots,x_n\)</span>？若有则称式子<spanclass="math inline">\(\Phi\)</span>是<strong>可满足</strong>的。</p><p><strong>3-SAT</strong>:每个Clause只有三个Literals。</p><p><strong>例子</strong>：</p><p><img src="/img/多项式规约/3-SAT例子.png" /></p><h4id="satisfiability3-sat归约到independent-set">3-Satisfiability（3-SAT）归约到IndependentSet</h4><p><strong>证明：给定一个3-SAT的例子<spanclass="math inline">\(\Phi\)</span>,可以构造一个大小为<spanclass="math inline">\(k\)</span>的Independent Set当且仅当式子<spanclass="math inline">\(\Phi\)</span>是可满足的。</strong></p><p>构造: -3-SAT中的每个Clause包含独立集里的三个顶点，其中每个Literal对应一个顶点 -连接句子里的点连接形成三角形 -连接不同Clause里每个Literal和它对应的非</p><p>如下图所示：</p><p><img src="/img/多项式规约/3-SAT2IndependentSet.png" /></p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span></p><p>令S为一个大小为<spanclass="math inline">\(k\)</span>的独立集，每个三角形里一定只有一个顶点在<spanclass="math inline">\(S\)</span>里，设该顶点取1，其余顶点取0，则其肯定是一个满足3-SAT的赋值。</p><p><span class="math inline">\(\Leftarrow\)</span></p><p>给定3-SAT一个满足的赋值，在每个三角形中选取一个取值为1的顶点，这样便构成了一个大小为<spanclass="math inline">\(k\)</span>的独立集。</p><h2 id="自规约重要">自规约（重要）</h2><p><strong>决策问题（Decision Problem）</strong>：诸如"是否存在一个<spanclass="math inline">\(size \ge k\)</span>的点覆盖"</p><p><strong>求解问题（SearchProblem）</strong>：诸如"寻找一个最小的点覆盖"</p><p><strong>自规约（Self-Reducibility）</strong>：Search Problem <spanclass="math inline">\(\le_p\)</span> Decision Problem</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大流最小割</title>
    <link href="/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <url>/2022/12/02/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小割">最小割</h2><p>在图论中，去掉其中所有边能使一张网络流图不再连通（即分成两个子图）的边集称为图的割。一个$st-cut $即去掉的边把源点s和汇点t划分在两个不同的部分。</p><figure><img src="/img/最大流最小割/最小割定义.png" alt="最小割定义" /><figcaption aria-hidden="true">最小割定义</figcaption></figure><p>一般来说，一张图中有多个不同的<spanclass="math inline">\(st-cut\)</span>，如下图便为其中一个 <spanclass="math inline">\(st-cut\)</span> 。</p><figure><img src="/img/最大流最小割/一个割例子.png" alt="一个割例子" /><figcaption aria-hidden="true">一个割例子</figcaption></figure><p>但是在实际应用中，我们去掉每条边往往都是有代价的，以边的容量作为权值，一个割中去掉的边的权值之和为这个割的值，那么最小割就是这张图上最小的割。</p><h2 id="最大流">最大流</h2><p>为了求解最小割，需要引入最大流的概念。用边的权值表示边的最大流量，一个<span class="math inline">\(st-flow\)</span>是从源点s到汇点t的流量。通俗的讲，最大流就是从源点s到汇点t的最大流量。</p><figure><img src="/img/最大流最小割/最大流.png" alt="最大流" /><figcaption aria-hidden="true">最大流</figcaption></figure><h2 id="求解最大流">求解最大流</h2><h3 id="贪心算法">贪心算法</h3><ul><li>开始时对每条边e令<span class="math inline">\(f(e)=0\)</span></li><li>找到一条从源点s到汇点t的路径 <span class="math inline">\(s\rightarrow t\)</span> 使路径上的每条边e满足 <spanclass="math inline">\(f(e)&lt;c(e)\)</span> ,其中 <spanclass="math inline">\(c(e)\)</span> 为边e的权值</li><li><span class="math inline">\(flow = flow + 路径上的流量\)</span></li><li>重复上述步骤直至找不到新的路径</li></ul><h3 id="ford-fulkerson算法">Ford-Fulkerson算法</h3><h4 id="残留图residual-graph">残留图(Residual Graph)</h4><p>在另一个图中，额外构造一个反向边，权值是实际流过该边的流量 <spanclass="math inline">\(f(e)\)</span> 。</p><figure><img src="/img/最大流最小割/残余图.png" alt="残余图" /><figcaption aria-hidden="true">残余图</figcaption></figure><p>剩余图有以下性质： - <strong>增广路径(AugmentingPath)</strong>:一个增广路径P是从残余图中的一条简单路径 <spanclass="math inline">\(s \rightarrow t\)</span> -增广路径的容量是该条路径所有边中的最小权值</p><h4 id="算法说明">算法说明</h4><ul><li>每次找到一条从s到t的增广路径，并调整flow和残留图，不断调整直到没有增广路径</li><li>当残留图中不存在从s到t的增广路径时，该图已经达到最大流</li></ul><h4 id="例子">例子</h4><p>初始时没有反向边,此时残留图等于原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子1.png" /></p><p>从中选取一条增广路径,并更新残留图和原图</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子2.png" /></p><p>重复上面的步骤,注意<strong>增广路径一定要从残留图中找</strong>,且可以使用残留图中的反向边.</p><p><img src="/img/最大流最小割/Ford-Fulkerson例子3.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子4.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子5.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子6.png" /></p><p><img src="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>此时,没有新的增广路径,则最大流的值等于流进s的流量,即 <spanclass="math inline">\(flow = s_{in}\)</span></p><h2 id="最大流与最小割的关系">最大流与最小割的关系</h2><p><strong>最大流最小割定理：最大流=最小割。</strong>最大流-最小割定理用来证明Ford-Fulkson方法的确达到了最大流.</p><figure><img src="/img/最大流最小割/最大流最小割定理.png"alt="最大流最小割定理" /><figcaption aria-hidden="true">最大流最小割定理</figcaption></figure><p>证明:</p><ul><li><span class="math inline">\((i) \Rightarrow (ii)\)</span>:弱对偶性法则的推论</li><li><span class="math inline">\((ii) \Rightarrow (iii)\)</span>:反证法<br />若f是一个最大流,且仍存在增广路径,那么可以让f加上增广路径的流量,与f是一个最大流相悖.故<spanclass="math inline">\((ii) \Rightarrow (iii)\)</span>成立</li><li><span class="math inline">\((iii) \Rightarrow (i)\)</span></li></ul><p>设f是一个流,且没有增广路径,令A等于s的可达顶点集,则</p><p><img src="/img/最大流最小割/iii到i.png" /></p><h2 id="求出最大流之后如何求最小割">求出最大流之后如何求最小割</h2><p>求完最大流之后，在残留图中用BFS遍历，结束后可得到一个从<spanclass="math inline">\(s\)</span>出发可达的集合，将原图分为两个子集合，<spanclass="math inline">\(s\)</span>可达的集合<spanclass="math inline">\(X\)</span>以及<spanclass="math inline">\(s\)</span>不可达的集合<spanclass="math inline">\(Y\)</span>,其中<spanclass="math inline">\(Y\)</span>中必然包含汇点<spanclass="math inline">\(t\)</span>。</p><p>连接两个集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的边有两种情况</p><ul><li>已被占满的前向边</li><li>没有流量的反向边(即从<span class="math inline">\(Y\)</span>到<spanclass="math inline">\(X\)</span>的边)</li></ul><p>其中被占满的前向边集合就是所求的最小割</p><p>还是用上面的例子 <imgsrc="/img/最大流最小割/Ford-Fulkerson例子7.png" /></p><p>在<span class="math inline">\(G_f\)</span>中,用BFS遍历可得<spanclass="math inline">\(s\)</span>可达的顶点集合为<spanclass="math inline">\(\{s, 3\}\)</span>，在<spanclass="math inline">\(G\)</span>中查看<span class="math inline">\(\{s,3\}\)</span>与图中剩余顶点集合的关系。</p><ul><li>已被占满的前向边:<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span></li><li>没有流量的反向边:<span class="math inline">\(2 \rightarrow3\)</span></li></ul><p>所以图中的一个最小割为<span class="math inline">\(s \rightarrow 2, 3\rightarrow 5\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高级算法设计与分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/12/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git撤销commit命令">Git撤销commit命令</h2><p>当要撤销的提交不是最开始的提交时 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD~<br></code></pre></td></tr></table></figure>当要撤销的提交时最开始的提交时 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">update</span> <span class="hljs-operator">-</span><span class="hljs-keyword">ref</span> <span class="hljs-operator">-</span>d HEAD<br></code></pre></td></tr></table></figure> ## Git连接远程仓库<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>url<br></code></pre></td></tr></table></figure> 注：url为github仓库链接 ## Git删除已经add的文件1.要删除的文件少时 一种是 <code>git rm --cached</code>"文件路径"，不删除物理文件，仅将该文件从缓存中删除； 一种是<code>git rm --f</code>"文件路径"，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。</p><p>2.要删除的文件多时 <code>git rm -r --cached</code> . 清空缓存区然后将本地文件删除，再次<code>add</code></p><h2 id="git创建远程新分支">Git创建远程新分支</h2><p>git无法直接通过命令方式创建远程新分支，需要间接来创建,这里我创建的远程新分支名叫vedio</p><p>首先</p><p><code>git checkout --orphan 分支名</code> <imgsrc="https://img-blog.csdnimg.cn/20210403164118752.png" /> <strong>gitrm -rf .</strong> （这一步很关键）然后创建一个文件readme.md（其实任何文件都可以），add并commit，然后</p><p><code>git push origin 分支名</code></p><p>就可以啦~如下图红框圈注的命令 <imgsrc="https://img-blog.csdnimg.cn/20210403164816128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTQyMQ==,size_16,color_FFFFFF,t_70" /></p><h2id="git强制提交本地分支覆盖远程分支">git强制提交本地分支覆盖远程分支</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> localBranchName:remoteBranchName --force<br></code></pre></td></tr></table></figure><h2 id="git从远程仓库拉取">Git从远程仓库拉取</h2><p><code>git pull origin main</code></p><h2 id="git创建与切换分支">Git创建与切换分支</h2><p>创建分支 <code>git branch branch_name</code> 切换分支<code>git checkout branch_name</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Latex常用表示</title>
    <link href="/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/12/01/Latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th>小写字母</th><th>语法</th><th>大写字母</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(A\)</span></td><td><code>A</code></td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td><td><span class="math inline">\(B\)</span></td><td><code>B</code></td></tr><tr class="odd"><td><span class="math inline">\(\gamma\)</span></td><td><code>\gamma</code></td><td><span class="math inline">\(\Gamma\)</span></td><td><code>\Gamma</code></td></tr><tr class="even"><td><span class="math inline">\(\delta\)</span></td><td><code>\delta</code></td><td><span class="math inline">\(\Delta\)</span></td><td><code>\Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td><td><span class="math inline">\(E\)</span></td><td><code>E</code></td></tr><tr class="even"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(Z\)</span></td><td><code>Z</code></td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td><td><span class="math inline">\(H\)</span></td><td><code>H</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span></td><td><code>\theta</code></td><td><span class="math inline">\(\Theta\)</span></td><td><code>\Theta</code></td></tr><tr class="even"><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(I\)</span></td><td><code>I</code></td></tr><tr class="even"><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td><td><span class="math inline">\(K\)</span></td><td><code>K</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span></td><td><code>\lambda</code></td><td><span class="math inline">\(\Lambda\)</span></td><td><code>\Lambda</code></td></tr><tr class="even"><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td><td><span class="math inline">\(M\)</span></td><td><code>M</code></td></tr><tr class="odd"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(N\)</span></td><td><code>N</code></td></tr><tr class="even"><td><span class="math inline">\(\xi\)</span></td><td><code>\xi</code></td><td><span class="math inline">\(\Xi\)</span></td><td><code>\Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(O\)</span></td><td><code>O</code></td></tr><tr class="even"><td><span class="math inline">\(\pi\)</span></td><td><code>\pi</code></td><td><span class="math inline">\(\Pi\)</span></td><td><code>\Pi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td><td><span class="math inline">\(R\)</span></td><td><code>R</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\sigma\)</span></td><td><code>\sigma</code></td><td><span class="math inline">\(\Sigma\)</span></td><td><code>\Sigma</code></td></tr><tr class="odd"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td><td><span class="math inline">\(T\)</span></td><td><code>T</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td><code>\upsilon</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span></td><td><code>\phi</code></td><td><span class="math inline">\(\Phi\)</span></td><td><code>\Phi</code></td></tr><tr class="odd"><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td><td><span class="math inline">\(X\)</span></td><td><code>X</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span></td><td><code>\psi</code></td><td><span class="math inline">\(\Psi\)</span></td><td><code>\Psi</code></td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span></td><td><code>\omega</code></td><td><span class="math inline">\(\Omega\)</span></td><td><code>\Omega</code></td></tr></tbody></table><p>var开头的只有小写希腊字母，没有大写。</p><h2 id="运算符符号">运算符符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td></tr><tr class="even"><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="odd"><td><span class="math inline">\(\int\)</span></td><td><code>\int</code></td></tr><tr class="even"><td><span class="math inline">\(\oplus\)</span></td><td><code>\oplus</code></td></tr><tr class="odd"><td><span class="math inline">\(\otimes\)</span></td><td><code>\otimes</code></td></tr><tr class="even"><td><span class="math inline">\(\times\)</span></td><td><code>\times</code></td></tr><tr class="odd"><td><span class="math inline">\(\cdot\)</span></td><td><code>\codt</code></td></tr><tr class="even"><td><span class="math inline">\(\cap\)</span></td><td><code>\cap</code></td></tr><tr class="odd"><td><span class="math inline">\(\cup\)</span></td><td><code>\cup</code></td></tr></tbody></table><h2 id="关系符号">关系符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\le\)</span></td><td><code>\le</code></td></tr><tr class="even"><td><span class="math inline">\(\ge\)</span></td><td><code>\ge</code></td></tr><tr class="odd"><td><span class="math inline">\(\ll\)</span></td><td><code>\ll</code></td></tr><tr class="even"><td><span class="math inline">\(\gg\)</span></td><td><code>\gg</code></td></tr><tr class="odd"><td><span class="math inline">\(\equiv\)</span></td><td><code>\equiv</code></td></tr><tr class="even"><td><span class="math inline">\(\subseteq\)</span></td><td><code>\subseteq</code></td></tr><tr class="odd"><td><span class="math inline">\(\supseteq\)</span></td><td><code>\supseteq</code></td></tr><tr class="even"><td><span class="math inline">\(\subset\)</span></td><td><code>\subset</code></td></tr><tr class="odd"><td><span class="math inline">\(\supset\)</span></td><td><code>\supset</code></td></tr></tbody></table><h2 id="箭头符号">箭头符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Leftarrow\)</span></td><td><code>\Leftarrow</code></td></tr><tr class="even"><td><span class="math inline">\(\Rightarrow\)</span></td><td><code>\Rightarrow</code></td></tr><tr class="odd"><td><span class="math inline">\(\Longleftrightarrow\)</span></td><td><code>\Longleftrightarrow</code></td></tr></tbody></table><h2 id="其他符号">其他符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\infty\)</span></td><td><code>\infty</code></td><td>无穷</td></tr><tr class="even"><td><span class="math inline">\(\exists\)</span></td><td><code>\exists</code></td><td>存在</td></tr><tr class="odd"><td><span class="math inline">\(\forall\)</span></td><td><code>\forall</code></td><td>任取</td></tr><tr class="even"><td><span class="math inline">\(\ldots\)</span></td><td><code>\ldots</code></td><td>下三连点</td></tr><tr class="odd"><td><span class="math inline">\(\cdots\)</span></td><td><code>\cdots</code></td><td>中三连点</td></tr><tr class="even"><td><span class="math inline">\(\vdots\)</span></td><td><code>\vdots</code></td><td>竖三连点</td></tr><tr class="odd"><td><span class="math inline">\(\ddots\)</span></td><td><code>\ddots</code></td><td>斜三连点</td></tr><tr class="even"><td><span class="math inline">\(\overline{x}\)</span></td><td><code>\overline&#123;x&#125;</code></td><td>平均</td></tr><tr class="odd"><td><span class="math inline">\(\quad\)</span></td><td><code>\quad</code></td><td>空格</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/12/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>本文大部分转载自知乎<ahref="https://www.zhihu.com/people/ruan-xing-zhi"><span class="citation"data-cites="阮行止">@阮行止</span></a>，后添加了自己的一些思考。</p><h2 id="从一个生活问题谈起">1. 从一个生活问题谈起</h2><p>先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，<strong>需要用到尽量少的钞票</strong>。</p><p>依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。</p><p>这种策略称为“<strong>贪心</strong>”：假设我们面对的局面是“需要凑出w”，贪心策略会<strong>尽快</strong>让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。</p><p>但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：<br />　　15=1×11+4×1 （贪心策略使用了5张钞票）<br />　　15=3×5 （正确的策略，只用3张钞票）<br />　　为什么会这样呢？贪心策略错在了哪里？</p><p><strong>鼠目寸光</strong>。</p><p>刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。</p><p>在这里我们发现，贪心是一种<strong>只考虑眼前情况</strong>的策略。</p><p>那么，现在我们怎样才能避免鼠目寸光呢？</p><p>如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。</p><p>重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。</p><p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？</p><p>明显<strong>cost=f(4)+1=4+1=5</strong>，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。</p><p>依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1=2+1=3</strong>。</p><p>那么，现在w=15的时候，我们该取那种钞票呢？<strong>当然是各种方案中，cost值最低的那一个！</strong></p><ul><li>取11：cost=f(4)+1=4+1=5</li><li>取5:cost=f(10)+1=2+1=3</li><li>取1:cost=f(14)+1=4+1=5</li></ul><p>显而易见，cost值最低的是取5的方案。<strong>我们通过上面三个式子，做出了正确的决策！</strong></p><p>这给了我们一个<strong>至关重要</strong>的启示——f(n)只与f(n-1),f(n-5),f(n-11) 相关；更确切地说：</p><blockquote><p>f(n)=min{f(n-1),f(n-5),f(n-11)}+1</p></blockquote><p>这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。代码如下：</p><figure><img src="/img/动态规划/解决方案.jpg" alt="pic1" /><figcaption aria-hidden="true">pic1</figcaption></figure><p>我们以O(n)的复杂度解决了这个问题。现在回过头来，我们看看它的原理：</p><ul><li>f(n)只与f(n-1),f(n-5),f(n-11)的值有关。</li><li>我们只关心f(w)的值，不关心是怎么凑出w的。</li></ul><p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”！</p><p>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。<strong>其他信息并不需要</strong>。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).</p><p>我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。<strong>我们将求解f(c)称作求解f(n)的“子问题”</strong>。</p><p><strong>这就是DP（动态规划，dynamic programming）</strong>.</p><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</strong></p><h2 id="几个简单的概念">2. 几个简单的概念</h2><ul><li><strong>无后效性</strong><br />一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</li></ul><p>要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p><p>“<strong>未来与过去无关</strong>”，这就是<strong>无后效性</strong>。</p><p>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p><ul><li>最优子结构</li></ul><p>回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).</p><p>f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的最优解，我们即可算出w=15的最优解。</p><p>大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“最优子结构性质”。</p><p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p><p><strong>能将大问题拆成几个小问题，且满足无后效性、最优子结构性质</strong>。</p><h2 id="dp的典型应用dag最短路">3. DP的典型应用：DAG最短路</h2><p>问题很简单：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p><figure><img src="/img/动态规划/最短路径.png" alt="最短路径" /><figcaption aria-hidden="true">最短路径</figcaption></figure><p>这个问题能用DP解决吗？我们先试着记从S到P的最少费用为f(P).</p><p>想要到T，要么经过C，要么经过D。从而<spanclass="math inline">\(f(T)=min\{f(C)+20,f(D)+10\}\)</span>.</p><p>好像看起来可以DP。现在我们检验刚刚那两个性质：</p><ul><li>无后效性：对于点P，一旦f(P)确定，以后就只关心f(P)的值，不关心怎么去的。</li><li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是<spanclass="math inline">\(S \rightarrow P\rightarrow Q \rightarrowT\)</span>,那肯定S走到Q的最优路径是<span class="math inline">\(S\rightarrow P\rightarrowQ\)</span>。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li></ul><p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p><blockquote><p>f(P)=min{f(R)+W<sub><span class="math inline">\(R \rightarrowP\)</span></sub>}</p></blockquote><p>其中R为有路通到P的所有的点， [公式] 为R到P的过路费。</p><p>代码实现也很简单，拓扑排序即可。</p><h2 id="对dp原理的一点讨论">4. 对DP原理的一点讨论</h2><ul><li>DP的核心思想</li></ul><p>DP为什么会快？</p><p>无论是DP还是暴力，我们的算法都是在<strong>可能解空间</strong>内，寻找<strong>最优解</strong>。</p><p>来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。</p><p>DP是枚举<strong>有希望成为答案的解</strong>。这个空间比暴力的小得多。</p><p>也就是说：<strong>DP自带剪枝</strong>。</p><p>DP舍弃了一大堆不可能成为最优解的答案。譬如：<br />　　15 = 5+5+5 被考虑了。<br />　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。</p><p>在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。</p><p>一般来说，解空间越小，寻找解就越快。这样就完成了优化。</p><ul><li>DP的操作过程</li></ul><p>一言以蔽之：<strong>大事化小，小事化了</strong>。</p><p>将一个大问题转化成几个小问题；<br />　　求解小问题；<br />　　推出大问题的解。</p><ul><li>如何设计DP算法</li></ul><p>下面介绍比较通用的设计DP算法的步骤。</p><p>首先，把我们面对的局面表示为x。这一步称为设计状态。</p><p>对于状态x，记我们要求出的答案(e.g.最小费用)为f(x).我们的目标是求出f(T).<strong>找出f(x)与哪些局面有关（记为p）</strong>，写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p><ul><li>DP三连</li></ul><p>设计DP算法，往往可以遵循DP三连：</p><p>我是谁？ ——设计状态，表示局面</p><p>我从哪里来？</p><p>我要到哪里去？ ——设计转移</p><p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，<strong>更新能从x走到的一些解</strong>。这种DP也是不少的，我们以后会遇到。</p><p>总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。</p><blockquote><p>思考题：如何把钞票问题的代码改写成“我到哪里去”的形式？<br />提示：求出f(x)之后，更新f(x+1),f(x+5),f(x+11).</p></blockquote><h2 id="例题最长上升子序列">5. 例题：最长上升子序列</h2><p>扯了这么多形而上的内容，还是做一道例题吧。</p><p>最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。<br />　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p><p>如何设计状态（我是谁）？</p><p>我们记<spanclass="math inline">\(f(x)\)</span>为以a<sub>x</sub>结尾的LIS长度，那么答案就是<span class="math inline">\(max\{f(x)\}\)</span></p><p>状态x从哪里推过来（我从哪里来）？</p><p>考虑比x小的每一个p：如果 a<sub>x</sub> &gt; a<sub>p</sub>，那么<spanclass="math inline">\(f(x)\)</span>可以取<spanclass="math inline">\(f(p)+1\)</span>.</p><p>解释：我们把 a<sub>x</sub> 接在 a<sub>p</sub>的后面，肯定能构造一个以 a<sub>x</sub> 结尾的上升子序列，长度比以a<sub>p</sub> 结尾的LIS大1.那么，我们可以写出状态转移方程了：</p><figure><img src="/img/动态规划/状态转移方程.svg" alt="状态转移方程" /><figcaption aria-hidden="true">状态转移方程</figcaption></figure><p>至此解决问题。两层for循环，复杂度O(n<sup>2</sup>) 。</p><figure><img src="/img/动态规划/最长上升子序列代码.jpg"alt="最长上升子序列代码" /><figcaption aria-hidden="true">最长上升子序列代码</figcaption></figure><p>从这三个例题中可以看出，DP是一种思想，一种“大事化小，小事化了”的思想。带着这种思想，DP将会成为我们解决问题的利器。</p><h2 id="习题">6. 习题</h2><p>如果读者有兴趣，可以试着完成下面几个习题：</p><ol type="1"><li>请采取一些优化手段，以 O(n log<sub>2</sub> n)的复杂度解决LIS问题。</li></ol><p>提示：可以参考这篇博客 <ahref="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">JuniorDynamic Programming--动态规划初步·各种子序列问题</a></p><ol start="2" type="1"><li>“按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成<ahref="https://www.luogu.com.cn/problem/P1541">P1541 乌龟棋 - 洛谷</a>。</li><li>01背包问题是一种常见的DP模型。请完成<ahref="https://www.luogu.com.cn/problem/P1048">P1048 采药 -洛谷</a>。</li></ol><h2 id="读后思考动态规划和分治法的区别与共同点">7.读后思考：动态规划和分治法的区别与共同点？</h2><h3 id="分治法">1. 分治法</h3><p>分治法(Divide-and-Conquer) :将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治模式在每一层递归上都有三个步骤：</p><ul><li>分解(Divide)：将原问题分解成一系列子问题；</li><li>解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。</li><li>合并(Combine)：将子问题的结果合并成原问题的解。</li></ul><p>合并排序(MergeSort)是一个典型分治法的例子。其对应的直观的操作如下:</p><p>分解： 将n个元素分成各含n/2个元素的子序列；</p><p>解决：用合并排序法对两个子序列递归地排序；</p><p>合并：合并两个已排序的子序列以得到排序结果。</p><h3 id="动态规划法">2. 动态规划法</h3><p>动态规划算法的设计可以分为如下4个步骤：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><p><strong>分治法是指将问题划分成一些独立的子问题，递归的求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。</strong></p><p>适合采用动态规划方法的最优化问题中的两个要素：<strong>最优子结构</strong>和<strong>重叠子问题</strong>。</p><p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。</p><p>重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p><p>In a word, <strong>分治法 —— 各子问题独立；动态规划 ——各子问题重叠</strong>。</p><p>算法导论：<strong>动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>高级算法设计与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/12/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p><h2 id="红黑树的性质">红黑树的性质</h2><ol type="1"><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）</li></ol><p>由性质5我们可以推出：<br />性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</p><h2 id="红黑树和avl的区别">红黑树和AVL的区别</h2><ol type="1"><li><p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p></li><li><p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p></li><li><p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胜者树与败者树</title>
    <link href="/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    <url>/2022/12/01/%E8%83%9C%E8%80%85%E6%A0%91%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>胜者树与败者树是完全二叉树。就像是参加比赛一样，每个选手有不同的实力，两个选手PK,实力决定胜负，晋级下一轮，经过几轮之后，就能得到冠军。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树可以在log(n)的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。在k路归并排序中经常用到。</p><h2 id="胜者树">胜者树</h2><p>胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p><figure><img src="/img/胜者树败者树/fig1.jpg" alt="fig1" /><figcaption aria-hidden="true">fig1</figcaption></figure><p>上图是一个胜者树的示例。规定数值小者胜。 1. b3 PKb4，b3胜b4负，内部结点ls[4]的值为3； 2. b3 PKb0，b3胜b0负，内部结点ls[2]的值为3； 3. b1 PKb2，b1胜b2负，内部结点ls[3]的值为1； 4. b3 PKb1，b3胜b1负，内部结点ls[1]的值为3。</p><p>取出胜者b3之后，叶子结点b3的值变为11时，重构的胜者树如下:</p><figure><img src="/img/胜者树败者树/fig2.jpg" alt="fig2" /><figcaption aria-hidden="true">fig2</figcaption></figure><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li><li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li><li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。</li></ol><p>用胜者树对n个节点实现排序操作，构建胜者树和构建堆比较相似，区别在于胜者树只有叶子节点存放了数据，中间节点记录的是叶子节点间的关系。</p><p>胜者树在每次重构时只需与其兄弟结点比较，一直到根节点选出胜者为止。</p><h2 id="败者树">败者树</h2><p>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p><figure><img src="/img/胜者树败者树/fig3.jpg" alt="fig3" /><figcaption aria-hidden="true">fig3</figcaption></figure><p>上图是一棵败者树。规定数大者败。</p><ol type="1"><li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；</li><li>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；</li><li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；</li><li>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；</li></ol><p>败者树重构过程如下： -将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。-比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。</p><figure><img src="/img/胜者树败者树/fig4.jpg" alt="fig4" /><figcaption aria-hidden="true">fig4</figcaption></figure><h2 id="胜者树败者树堆比较">胜者树、败者树、堆比较</h2><h3 id="相同点">相同点</h3><p>这三者空间和时间复杂度都是一样的。调整一次的时间复杂度都是O(logN)的。</p><h3 id="不同点">不同点</h3><p>一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，<strong>调整堆的时候，每次都要选出父结点的两个孩子节点的最小值，然后再用孩子结点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了胜者树。这样<strong>每次比较只用跟自己的兄弟结点进行比较就好</strong>，所以用胜者树可以比堆少一半的比较次数。</p><p>而<strong>胜者树想要比较兄弟结点首先要获得其父结点，也就是说需要访存两次</strong>，这时人们又想能否再次减少比较次数，于是就有了败者树。败者树每个新元素上升时，<strong>只需要获得父节点并比较即可</strong>。</p><p>总的来说，败者树与胜者树相比减少了访存时间。<strong>现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了</strong>。</p><h2 id="参考">参考</h2><ol type="1"><li><ahref="https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html#:~:text=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91%E9%83%BD%E6%98%AF%E5%AE%8C%E5%85%A8,%E6%97%B6%E9%97%B4%E5%86%85%E6%89%BE%E5%88%B0%E6%9C%80%E5%80%BC%E3%80%82">胜者树和败者树</a></li><li><ahref="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
