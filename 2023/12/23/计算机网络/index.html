

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Starmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络 一些术语的缩写  MSL(Maximum Segment Lifetime):传输层的概念，表示TCP报文最大存活时间 TTL(Time to Live):网络层的概念，每次IP数据包在网络中被路由器传递时，TTL值减一。当TTL减为零时，数据包会被丢弃，并向源发送一个 ICMP 时间超过消息。TTL用来防止数据包在网络中无限循环 RTT(Round-Trip Time): 往返时延">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://gstarmin.github.io/2023/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
<meta property="og:site_name" content="私人杂货铺">
<meta property="og:description" content="计算机网络 一些术语的缩写  MSL(Maximum Segment Lifetime):传输层的概念，表示TCP报文最大存活时间 TTL(Time to Live):网络层的概念，每次IP数据包在网络中被路由器传递时，TTL值减一。当TTL减为零时，数据包会被丢弃，并向源发送一个 ICMP 时间超过消息。TTL用来防止数据包在网络中无限循环 RTT(Round-Trip Time): 往返时延">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/osi七层协议图.gif">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/网络协议.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/三次握手.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/四次挥手.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/TCP四大拥塞控制算法.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/拥塞控制图.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/快速恢复算法.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/TCP系统调用流程.png">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/计网/TCP系统调用流程-1.png">
<meta property="article:published_time" content="2023-12-23T06:47:10.000Z">
<meta property="article:modified_time" content="2023-12-23T06:47:10.000Z">
<meta property="article:author" content="Starmin">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gstarmin.github.io/img/C++八股文/计网/osi七层协议图.gif">
  
  
  
  <title>计算机网络 - 私人杂货铺</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gstarmin.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Starmin</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-23 14:47" pubdate>
          2023年12月23日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          260 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机网络</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络">计算机网络</h1>
<h3 id="一些术语的缩写">一些术语的缩写</h3>
<ul>
<li><p><code>MSL(Maximum Segment Lifetime)</code>:传输层的概念，表示TCP报文最大存活时间</p></li>
<li><p><code>TTL(Time to Live)</code>:网络层的概念，每次IP数据包在网络中被路由器传递时，TTL值减一。当TTL减为零时，数据包会被丢弃，并向源发送一个
ICMP 时间超过消息。TTL用来防止数据包在网络中无限循环</p></li>
<li><p><code>RTT(Round-Trip Time)</code>: 往返时延</p></li>
<li><p><code>RTO(Retransmission Time Out)</code>：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</p></li>
</ul>
<h2 id="osi-七层协议模型">OSI 七层协议模型</h2>
<p>OSI 模型（Open System Interconnection Model）是⼀个由 ISO
提出得到概念模型，试图提供⼀个使各种不同的的计算机和⽹络在世界范围内实现互联的标准框架。</p>
<p>虽然OSI参考模型在实际中的应⽤意义并不是很⼤，但是它对于理解⽹络协议内部的运作很有帮助，为我们学习⽹络协议提供了⼀个很好的参考。它将计算机⽹络体系结构划分为7层，每层都为上⼀层提供了良好的接⼝。以下将具体介绍各层结构及功能。</p>
<figure>
<img src="/img/C++八股文/计网/osi七层协议图.gif" srcset="/img/loading.gif" lazyload alt="OSI模型" />
<figcaption aria-hidden="true">OSI模型</figcaption>
</figure>
<p>主要分为以下七层（从下⾄上）：物理层、数据链路层、⽹络层、传输层、会话层、表示层、应⽤层。</p>
<p><strong>物理层</strong>：规定了一些<strong>机械特性，电⽓特性，功能特性</strong>，如网线、网卡标准，这⼀层传输的是
<strong>bit 流</strong>。</p>
<p><strong>数据链路层</strong>：定义数据的基本格式，如何传输，如何标识，在<strong>不可靠</strong>的物理介质上<strong>提供可靠的传输</strong>。该层的作⽤包括：<strong>物理地址寻址、封装成帧、流量控制、数据的检错、重发</strong>等。这⼀层中将
bit 流封装成 <strong>frame 帧</strong>。</p>
<p><strong>⽹络层</strong>：定义ip编址，对数据包进⾏<strong>路由选择</strong>。此外，⽹络层还可以实现<strong>拥塞控制</strong>、<strong>⽹际互连</strong>等功能。在这⼀层，数据的单位称为<strong>数据包（packet）</strong>。</p>
<p><strong>传输层</strong>：提供<strong>端到端的、可靠的或不可靠的传输</strong>。此外，传输层还要处理端到端的<strong>差错控制</strong>和<strong>流量控制</strong>问题。在这⼀层，数据的单位称为<strong>数据段（segment）</strong>。</p>
<p><strong>会话层</strong>：<strong>控制应用程序之间会话能力</strong>。如不同软件负责不同软件分发给不同软件。</p>
<p><strong>表示层</strong>：数据格式标识，基本压缩加密功能</p>
<p><strong>应⽤层</strong>：各种应用软件，包括 Web 应用。</p>
<p>网络七层模型是一个标准，而非实现。网络四层模型由七层模型简化而来，是一个实现的应用模型。</p>
<!-- 

## 各层传输协议、传输单元、主要功能性设备⽐较

|名称|传输协议|传输单元|主要功能设备/接口|
|-----|-----|-----|-----|
|物理层|IEEE 802.1A、IEEE 802.2| bit-flow 比特流|光纤，双绞线，中继器，集线器，网线接口|
|数据链路层|ARP、MAC、FDDI、Ethernet、Arpanet、PPP、PDN|frame帧|网桥、二层交换机|
|网络层|IP、ICMP、ARP、PPP、RARP|数据包packet|路由器、三层交换机|
|传输层|TCP、UDP|segment/datagram|四层交换机|
|会话层|SMTP、DNS|报文|QoS|
|表示层|Telnet、FTP、HTTP、SNMP|报文|-|
|应用层|FTP、HTTP、TFTP、Telnet、DNS|报文|-|

-->
<h2 id="tcp-三次握手和四次挥手的流程">TCP 三次握手和四次挥手的流程</h2>
<h3 id="三次握手">三次握手</h3>
<ul>
<li>第⼀次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt;
SYN_SEND）</li>
<li>第⼆次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM =
P的包到客户机。（服 -&gt; SYN_RECV）</li>
<li>第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt;
ESTABLISH，服 -&gt; ESTABLISH）</li>
</ul>
<h3 id="四次挥手">四次挥手</h3>
<ul>
<li>第⼀次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt;
FIN_WAIT_1）</li>
<li>第⼆次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt;
CLOSE_WAIT，客 -&gt; FIN_WAIT_2）</li>
<li>此处有等待</li>
<li>第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt;
LAST_ACK，客 -&gt; TIME_WAIT）</li>
<li>此处有等待</li>
<li>第四次：客户机发送最后⼀个含有ACK位且ACK_NUM = R +
1的包到客户机。（服 -&gt; CLOSED</li>
</ul>
<h2
id="为什么建立连接时候要三次握手不是两次也不是四次">为什么建立连接时候要三次握手？不是两次也不是四次？</h2>
<p>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。</p>
<p>例子：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p>
<p>所以说两次握手不能满足需求，而三次握手已经可以满足需求，那么四次握手就是浪费了。</p>
<p>从另一个角度看“TCP建立连接为什么是三次握手？”，这个问题的本质是,信道不可靠,
但是通信双发需要就某个问题达成一致. 而要解决这个问题,
无论你在消息中包含什么信息, 三次通信是理论上的最小值.
所以<strong>三次握手不是TCP本身的要求,
而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的</strong>.
请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了,
那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了.
因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到,
或者你不关心是否要保证对方收到你的消息,
那就能像UDP那样直接发送消息就可以了.”。</p>
<p>参考自<a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/24853633/answer/63668444">TCP
为什么是三次握手，而不是两次或四次？</a></p>
<h2
id="说一下一次完整的http请求过程包括哪些内容">说一下一次完整的HTTP请求过程包括哪些内容？</h2>
<p>域名解析 --&gt; 发起TCP的3次握手 --&gt; 建立TCP连接后发起http请求
--&gt; 服务器响应http请求，浏览器得到html代码 --&gt;
浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --&gt;
浏览器对页面进行渲染呈现给用户。</p>
<h2 id="你知道dns是什么">你知道DNS是什么？</h2>
<p><strong>官方解释</strong>：DNS（Domain Name
System，域名系统），因特网上作为<strong>域名和IP地址相互映射的一个分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p>通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。</p>
<h2
id="https是如何保证数据传输的安全整体的流程是什么ssl是怎么工作保证安全的">HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h2>
<ol type="1">
<li>客户端向服务器端发起SSL连接请求；</li>
<li>服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥</li>
<li>客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端</li>
<li>服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密</li>
<li>进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。</li>
</ol>
<p>以上是属于TLS 1.0版本的答案，使用RSA密钥交换算法。而TLS
1.2版本使用的是ECDHE_RSA密钥交换算法，其过程如下：</p>
<ol type="1">
<li>客户端和服务器各自选择一个
<strong>椭圆曲线私钥（随机数）</strong>，并使用椭圆曲线算法生成对应的
<strong>椭圆曲线公钥</strong>。</li>
<li>在握手阶段，客户端和服务器互相交换
<strong>椭圆曲线公钥</strong>。</li>
<li>客户端和服务器各自使用 <strong>对方的椭圆曲线公钥</strong> 和
<strong>自己的椭圆曲线私钥</strong>，通过椭圆曲线的点运算生成一个
<strong>共享密钥</strong>。由于椭圆曲线的数学性质，这个共享密钥在双方都知道，但是不能被第三方计算出来。(共享密钥并非通过传输手段获得，避免中间人截取。)</li>
<li>客户端和服务器使用这个共享密钥进行
<strong>对称加密通信</strong>。</li>
</ol>
<h2
id="在浏览器地址栏输入一个url后回车背后都发生了什么">在浏览器地址栏输入一个URL后回车，背后都发生了什么？</h2>
<p>查浏览器缓存，检查域名是否在缓存中，如果没有则调用 gethostbyname
(不同操作系统函数名也不同)进行查询。</p>
<p>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts
里找到，它将会向 DNS 服务器发送一条 DNS
查询请求。查询本地DNS服务器，如果DNS服务器和我们的主机在一个子网内采用ARP地址解析协议进行ARP查询;如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）</p>
<p>拿到服务器的ip以及端口号后，浏览器会建立一个TCP连接，连接建立成功之后如果使用的是http协议的话直接返回网页需要的数据；如果是https协议的话，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了（http默认端口是80，https默认端口是443）.然后四次挥手断开连接，再进行一边上述操作，但是端口从80变为443，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，然后浏览器会对页面进行需求渲染。</p>
<h2 id="谈谈dns解析过程具体一点">谈谈DNS解析过程，具体一点</h2>
<p>先在浏览器找之前有没有缓存过的域名所对应的ip地址，有的话，直接跳过dns解析了，若是没有，就会找硬盘的hosts文件，看看有没有，有的话，直接找到hosts文件里面的ip。</p>
<p>如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个dns请求到本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。</p>
<p>查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归查询</strong>。</p>
<p>如果没有，本地DNS服务器继续向域服务器发出请求，比如查询google.com，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>
<p>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<h2 id="dns负载均衡是什么策略">DNS负载均衡是什么策略？</h2>
<p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是<strong>在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的</strong>｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h2 id="https和http的区别">HTTPS和HTTP的区别</h2>
<ul>
<li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，
HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
</ul>
<h2 id="什么是ssltls">什么是SSL/TLS ？</h2>
<p>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。
身份验证 ，
加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<p>SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；</p>
<p>对称加密：优点在于加密、解密效率通常比较高 ，HTTPS
是基于非对称加密的， 公钥是公开的.</p>
<h2 id="cookie是什么">Cookie是什么？</h2>
<p>HTTP 协议是无状态的，主要是为了让 HTTP
协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie
来保存状态信息。</p>
<p>Cookie
是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带
Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie
曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie
渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用
Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h2 id="cookie有什么用途">Cookie有什么用途？</h2>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h2 id="session-的工作原理是什么">Session 的工作原理是什么？</h2>
<p>session 的工作原理是客户端登录完成之后，服务器会创建对应的
session，session 创建完之后，会把 session 的 id
发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着
sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session
这样就可以正常工作了。</p>
<h2 id="cookie与session的对比">Cookie与Session的对比</h2>
<h3 id="cookie">Cookie</h3>
<p>Cookie是<strong>客户端</strong>保持状态的方法。</p>
<p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p>
<p>除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p>
<h3 id="session">Session</h3>
<p>Session是<strong>服务器</strong>保持状态的方法。</p>
<p>首先需要明确的是，<strong>Session保存在服务器上</strong>，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为<strong>每个用户有一个独一无二的Session
ID作为Session文件的Hash键</strong>，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p>
<p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session
ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>
<h2 id="cookies和session区别是什么">Cookies和Session区别是什么？</h2>
<ol type="1">
<li>cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全</li>
<li>存储的数据类型不同
两者都是key-value的结构，但针对value的类型是有差异的
cookie：value只能是字符串类型，session：value是Object类型</li>
<li>存储的数据大小限制不同
cookie：大小受浏览器的限制，很多是是4K的大小，
session：理论上受当前内存的限制</li>
<li>生命周期的控制:cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束;session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁</li>
</ol>
<h2 id="sql注入攻击了解吗">SQL注入攻击了解吗？</h2>
<p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。
用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1
，如果此时使用参数构造的方式，就会出现 select * from user where name =
‘lianggzone’ and password = ‘’ or ‘1’=‘1’
不管用户名和密码是什么内容，使查询出来的用户列表不为空。</p>
<p>如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。</p>
<p><strong>Web端</strong></p>
<ol type="1">
<li>有效性检验。</li>
<li>限制字符串输入的长度。</li>
</ol>
<p><strong>服务端</strong></p>
<ol type="1">
<li>不用拼接SQL字符串。</li>
<li>使用预编译的PrepareStatement。</li>
<li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</li>
<li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li>
</ol>
<h2 id="什么是rarp工作原理">什么是RARP？工作原理</h2>
<p>概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。
RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p>
<p><strong>工作原理</strong>：</p>
<ol type="1">
<li>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的<strong>广播数据包</strong>，请求RARP服务器回复该主机的IP地址。</li>
<li>RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。</li>
<li>PC1收到RARP回应后，就使用得到的IP地址进行通讯。</li>
</ol>
<h2 id="端口有效范围是多少到多少">端口有效范围是多少到多少？</h2>
<p>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）</p>
<p>UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</p>
<h2 id="为何需要把-tcpip-协议栈分成-5-层或7层开放式回答">为何需要把
TCP/IP 协议栈分成 5 层（或7层）？开放式回答。</h2>
<p>为了更好的管理和维护，将协议分层，每一层都有自己的功能，每一层都可以独立的进行修改，而不会影响到其他层。</p>
<h2 id="dns查询方式有哪些">DNS查询方式有哪些</h2>
<h3 id="递归解析">递归解析</h3>
<p>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>
<h3 id="迭代解析">迭代解析</h3>
<p>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p>
<h2 id="使用-session-的过程是怎样的">使用 Session 的过程是怎样的？</h2>
<p>过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP
请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在
Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session
ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie
值，服务器收到之后提取出 Session ID，从 Redis
中取出用户信息，继续之前的业务操作。</li>
</ul>
<p><strong>注意</strong>：Session ID
的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的
Session ID 值。此外，还需要经常重新生成 Session
ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session
管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h2
id="session和cookie应该如何去选择适用场景">Session和cookie应该如何去选择（适用场景）？</h2>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session
则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在
Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session
中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session
中。</li>
</ul>
<h2 id="ddos-攻击了解吗">DDos 攻击了解吗？</h2>
<p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认.没有彻底根治的办法，除非不使用TCP</p>
<p><strong>DDos 预防</strong>:</p>
<ol type="1">
<li>限制同时打开SYN半链接的数目</li>
<li>缩短SYN半链接的Time out 时间</li>
<li>关闭不必要的服务</li>
</ol>
<h2 id="mtu和mss分别是什么">MTU和MSS分别是什么？</h2>
<p><strong>MTU</strong>：maximum transmission
unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。</p>
<p><strong>MSS</strong>：maximum segment
size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4
Header（20 Byte）和TCP header（20 Byte）得到。</p>
<h2
id="http中有个缓存机制但如何保证缓存是最新的呢缓存过期机制">HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）</h2>
<p>max-age
指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age
指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure>
<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Expires</span>: Wed, <span class="hljs-number">04</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05</span> GMT<br></code></pre></td></tr></table></figure>
<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h2 id="tcp头部中有哪些信息">TCP头部中有哪些信息？</h2>
<ul>
<li>源端口 目标端口</li>
<li>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值
= ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN =
1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 +
512。用于解决网络包乱序问题。</li>
<li>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 +
1。</li>
<li>首部长（4bit）：标识首部有多少个4字节 *
首部长，最大为15，即60字节。</li>
<li>标志位（6bit）：
<ul>
<li>URG：标志紧急指针是否有效。</li>
<li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li>
<li>PSH：提示接收端立即从缓冲读走数据。</li>
<li>RST：表示要求对方重新建立连接（复位报文段）。</li>
<li>SYN：表示请求建立一个连接（连接报文段）。</li>
<li>FIN：表示关闭连接（断开报文段）。</li>
</ul></li>
<li>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</li>
<li>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</li>
</ul>
<h2 id="常见tcp的连接状态有哪些">常见TCP的连接状态有哪些？</h2>
<ul>
<li>CLOSED：初始状态。</li>
<li>LISTEN：服务器处于监听状态。</li>
<li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li>
<li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li>
<li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li>
<li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li>
<li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li>
<li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li>
</ul>
<h2
id="网络的七层五层模型主要的协议有哪些">网络的七层/五层模型主要的协议有哪些？</h2>
<p><img src="/img/C++八股文/计网/网络协议.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="tcp是什么">TCP是什么？</h2>
<p>TCP（Transmission Control Protocol
传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h2
id="应用层常见协议知道多少了解几个">应用层常见协议知道多少？了解几个？</h2>
<table>

<thead>
<tr class="header">
<th>协议</th>
<th>名称</th>
<th>默认端口</th>
<th>底层协议</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HTTP</td>
<td>超文本传输协议</td>
<td>80</td>
<td>TCP</td>
</tr>
<tr class="even">
<td>HTTPS</td>
<td>安全超文本传输协议</td>
<td>443</td>
<td>TCP</td>
</tr>
<tr class="odd">
<td>Telnet</td>
<td>远程登录服务</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr class="even">
<td>FTP</td>
<td>文件传输协议</td>
<td>20传输/21连接</td>
<td>TCP</td>
</tr>
<tr class="odd">
<td>TFTP</td>
<td>简单文件传输协议</td>
<td>69</td>
<td>UDP</td>
</tr>
<tr class="even">
<td>SMTP</td>
<td>简单邮件传输协议</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr class="odd">
<td>POP3</td>
<td>邮局协议</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr class="even">
<td>DNS</td>
<td>域名系统</td>
<td>53</td>
<td>服务器间进行域传输的时候用TCP，客户端查询DNS服务器时用 UDP</td>
</tr>
</tbody>
</table>
<h2
id="浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开">浏览器在与服务器建立了一个
TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2>
<p>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP
链接。但是这样每次请求都会重新建立和断开 TCP
连接，代价过大。所以虽然<strong>标准中没有设定，某些服务器对 Connection:
keep-alive 的 Header 进行了支持</strong>。意思是说，完成这个 HTTP
请求之后，不要断开 HTTP 请求使用的 TCP
连接。这样的好处是连接可以被重新使用，之后发送 HTTP
请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL
的开销也可以避免。</p>
<p>HTTP/1.1 就把 Connection
头写进标准，并且默认开启持久连接，除非请求中写明 Connection:
close，那么浏览器和服务器之间是会维持一段时间的 TCP
连接，不会一个请求结束就断掉。</p>
<p>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection:
close 才会在请求完成后关闭连接。</p>
<h2 id="三次握手相关内容">三次握手相关内容</h2>
<p><img src="/img/C++八股文/计网/三次握手.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li><strong>初始状态</strong>：客户端处于 closed(关闭)状态，服务器处于
listen(监听) 状态。</li>
<li><strong>第一次握手</strong>：客户端发送请求报文将 SYN =
1同步序列号和初始化序列号seq =
x发送给服务端，发送完之后客户端处于SYN_Send状态。（验证了客户端的发送能力和服务端的接收能力）</li>
<li><strong>第二次握手</strong>：服务端受到 SYN
请求报文之后，如果同意连接，会以自己的同步序列号SYN(服务端) =
1、初始化序列号 seq = y和确认序列号（期望下次收到的数据包）ack = x+ 1
以及确认号ACK =
1报文作为应答，服务器为SYN_Receive状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li>
<li><strong>第三次握手</strong>： 客户端接收到服务端的 SYN +
ACK之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号
ack = y + 1和数据包的序列号 seq = x + 1以及确认号ACK =
1确认包作为应答，客户端转为established状态。（分别站在双方的角度上思考，各自ok）</li>
</ul>
<h2 id="什么是半连接队列">什么是半连接队列？</h2>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD
状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为
1s，2s，4s，8s......</p>
<h2 id="isninitial-sequence-number是固定的吗">ISN(Initial Sequence
Number)是固定的吗？</h2>
<p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN是一个有可以看作是一个32比特的计数器，但并不是简单的计数器，大概每4ms加1
。</p>
<div class="admonition info">
<p class="admonition-title">
info
</p>
<p>
ISN = M + F(localhost, localport, remotehost,
remoteport)(M为计数器)，ISN应该由这个公式确定，F为哈希算法，不是一个简单计数器。
</p>
</div>
<p>这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial
Sequence
Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果
ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN
是动态生成的。</strong></p>
<h2
id="三次握手过程中可以携带数据吗">三次握手过程中可以携带数据吗？</h2>
<p>第三次握手的时候，可以携带数据。但是，第一次、第二次握手不可以携带数据。</p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的
SYN
报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发
SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，<strong>第一二次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于
ESTABLISHED
状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p>
<h2 id="syn攻击是什么">SYN攻击是什么？</h2>
<p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<strong>SYN
攻击是一种典型的 DoS/DDoS 攻击。</strong></p>
<p>检测 SYN
攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在
Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -n -p TCP | grep SYN_RECV<br></code></pre></td></tr></table></figure>
<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="四次挥手相关内容">四次挥手相关内容</h2>
<p><img src="/img/C++八股文/计网/四次挥手.png" srcset="/img/loading.gif" lazyload /></p>
<p>刚开始双方都处于 ESTABLISHED
状态，<strong>假如是客户端先发起关闭请求</strong>。四次挥手的过程如下：</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN
报文，报文中会指定一个序列号。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，<strong>进入FIN_WAIT1</strong>（终止等待1）状态，等待服务端的确认。</li>
<li><strong>第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK
报文，且把客户端的序列号值 +1 作为 ACK
报文的序列号值，表明已经收到客户端的报文了。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），<strong>服务端进入CLOSE_WAIT</strong>（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。<strong>客户端</strong>收到服务端的确认后，<strong>进入FIN_WAIT2</strong>（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li><strong>第三次挥手</strong>：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给
FIN 报文，且指定一个序列号。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），<strong>服务端进入LAST_ACK（最后确认）状态</strong>，等待客户端的确认。</li>
<li><strong>第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK
报文作为应答，且把服务端的序列号值 +1 作为自己 ACK
报文的确认号值。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入
CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED
状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），<strong>客户端进入TIME_WAIT</strong>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<h2 id="挥手为什么需要四次">挥手为什么需要四次？</h2>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，<strong>当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。之后服务器端可能还有想要传输的数据，只有等到服务端所有的报文都发送完了，服务器端才发送FIN报文</strong>，因此不能一起发送。故需要四次挥手。</p>
<h2 id="msl等待状态">2MSL等待状态？</h2>
<p>TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum
Segment
Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<h2
id="四次挥手释放连接时等待2msl的意义">四次挥手释放连接时，等待2MSL的意义?</h2>
<ol type="1">
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。
这个ACK报文段有可能丢失，使得处于LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。
客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2
id="tcp粘包问题是什么你会如何去解决它">TCP粘包问题是什么？你会如何去解决它？</h2>
<p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p>造成TCP粘包的原因：</p>
<ul>
<li>TCP连接复用</li>
<li>TCP默认会使用Nagle算法，此算法会导致粘包问题</li>
<li>数据包过大</li>
<li>流量控制，拥塞控制也可能导致粘包</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
<p>解决方案：</p>
<ul>
<li>Nagle算法问题导致的，需要结合应用场景适当关闭该算法</li>
<li>尾部标记序列。通过特殊标识符表示数据包的边界，例如或者一些隐藏字符</li>
<li>头部标记分步接收。在TCP报文的头部加上表示数据长度</li>
<li>应用层发送数据时定长发送</li>
</ul>
<h2 id="对称密钥加密的优点缺点">对称密钥加密的优点缺点？</h2>
<p>对称密钥加密（Symmetric-Key
Encryption），加密和解密使用同一密钥。</p>
<p><strong>优点</strong>：运算速度快</p>
<p><strong>缺点</strong>：无法安全地将密钥传输给通信方</p>
<h2
id="非对称密钥加密你了解吗优缺点">非对称密钥加密你了解吗？优缺点？</h2>
<p>非对称密钥加密，又称公开密钥加密（Public-Key
Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<p><strong>优点</strong>：可以更安全地将公开密钥传输给通信发送方；</p>
<p><strong>缺点</strong>：运算速度慢。</p>
<h2 id="https是什么">HTTPS是什么？</h2>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets
Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS
使用了隧道进行通信。通过使用 SSL，HTTPS
具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<h2 id="http的缺点有哪些">HTTP的缺点有哪些？</h2>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<h2
id="https采用的加密方式有哪些是对称还是非对称">HTTPS采用的加密方式有哪些？是对称还是非对称？</h2>
<p>PS
采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p>
<h2
id="为什么有的时候刷新页面不需要重新建立-ssl-连接">为什么有的时候刷新页面不需要重新建立
SSL 连接？</h2>
<p>TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP
不需要重新建立，SSL 自然也会用之前的。</p>
<h2
id="ssl中的认证中的证书是什么了解过吗">SSL中的认证中的证书是什么？了解过吗？</h2>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate
Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA
在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS
通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<h2
id="http如何禁用缓存如何确认缓存">HTTP如何禁用缓存？如何确认缓存？</h2>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cache-Control: no-store<br></code></pre></td></tr></table></figure>
<p><strong>强制确认缓存</strong></p>
<p>no-cache
指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cache-Control: no-cache<br></code></pre></td></tr></table></figure>
<h2
id="get与post传递数据的最大长度能够达到多少呢">GET与POST传递数据的最大长度能够达到多少呢？</h2>
<p>get
是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。</p>
<p>很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。</p>
<p>这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。</p>
<p>post
理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</p>
<p>因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。</p>
<p>以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。这就很明白的说明了这个问题了。</p>
<h2 id="网络层常见协议可以说一下吗">网络层常见协议？可以说一下吗？</h2>
<table style="width:100%;">

<thead>
<tr class="header">
<th>协议</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IP</td>
<td>网际协议</td>
<td>IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</td>
</tr>
<tr class="even">
<td>ICMP</td>
<td>Internet控制报文协议</td>
<td>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</td>
</tr>
<tr class="odd">
<td>RIP</td>
<td>路由信息协议</td>
<td>使用“跳数”(即metric)来衡量到达目标地址的路由距离</td>
</tr>
<tr class="even">
<td>IGMP</td>
<td>Internet组管理协议</td>
<td>用于实现组播、广播等通信</td>
</tr>
</tbody>
</table>
<h2 id="tcp四大拥塞控制算法总结">TCP四大拥塞控制算法总结?*</h2>
<h3 id="四大算法">四大算法</h3>
<p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p>
<p><img src="/img/C++八股文/计网/TCP四大拥塞控制算法.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="慢启动算法-slow-start">慢启动算法 – Slow Start</h3>
<p>所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p>
<p>慢启动算法：</p>
<ol type="1">
<li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd大小加一，呈线性上升。</li>
<li>每当过了一个往返延迟时间RTT(Round-Trip
Time)，cwnd大小直接翻倍，乘以2，呈指数让升。</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;=
ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li>
</ol>
<h3 id="拥塞避免算法-congestion-avoidance">拥塞避免算法 – Congestion
Avoidance</h3>
<p>如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p>
<ol type="1">
<li>收到一个ACK，则cwnd = cwnd + 1 / cwnd</li>
<li>每当过了一个往返延迟时间RTT，cwnd大小加一。</li>
</ol>
<p>过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p>
<h3 id="拥塞发生状态时的算法">拥塞发生状态时的算法</h3>
<p>一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission
Timeout]超时，另一个是收到三个重复确认ACK。</p>
<p>超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p>
<p>但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做<strong>快速重传</strong>，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p>
<p>超时重传RTO[Retransmission
Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：</p>
<ul>
<li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh =
cwnd / 2.</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ul>
<p>最为早期的TCP
Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。</p>
<p>所以，TCP
Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast
Retransmit算法，而不用等到RTO超时再进行重传：</p>
<ul>
<li>cwnd大小缩小为当前的一半</li>
<li>ssthresh设置为缩小后的cwnd大小</li>
<li>然后进入快速恢复算法Fast Recovery</li>
</ul>
<p><img src="/img/C++八股文/计网/拥塞控制图.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="快速恢复算法-fast-recovery">快速恢复算法 – Fast Recovery</h3>
<p>TCP
Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在<strong>进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半</strong>。快速恢复算法的逻辑如下：</p>
<ul>
<li>cwnd = cwnd + 3 MSS，加3 MSS的原因是因为收到3个重复的ACK。</li>
<li>重传DACKs指定的数据包。</li>
<li>如果再收到DACKs，那么cwnd大小增加一。</li>
<li>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</li>
</ul>
<p><img src="/img/C++八股文/计网/快速恢复算法.png" srcset="/img/loading.gif" lazyload /></p>
<h2
id="为何快速重传是选择3次重复ack">为何快速重传是选择3次重复ACK？</h2>
<p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p>
<p>两次duplicated ACK时很可能是乱序造成的！三次duplicated
ACK时很可能是丢包造成的！四次duplicated
ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated
ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p>
<p>在没有fast retransmit / recovery 算法之前，重传依靠发送方的retransmit
timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因</p>
<ol type="1">
<li>包checksum 出错</li>
<li>网络拥塞</li>
<li>网络断，包括路由重收敛，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND
减为1/2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</li>
</ol>
<p>于是有了fast retransmit
算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout
时间内没有接收到&gt; 2 的duplicated
ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；</p>
<p>而如果接收到三个或三个以上的duplicated
ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。</p>
<p>而如果依然接收到duplicated
ACK，则认为是网络拥塞造成的，此时降速则比较合理。</p>
<h2
id="对于fin_wait_2close_wait状态和time_wait状态你知道多少">对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h2>
<p>FIN_WAIT_2：</p>
<ul>
<li>半关闭状态。</li>
<li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li>
</ul>
<p>CLOSE_WAIT状态：</p>
<ul>
<li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li>
<li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</li>
</ul>
<p>TIME_WAIT状态：</p>
<ul>
<li>又叫2MSL等待状态。</li>
<li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li>
<li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li>
</ul>
<h2 id="你了解流量控制原理吗">你了解流量控制原理吗？</h2>
<ul>
<li><strong>目的</strong>:接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li>
<li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
<ul>
<li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li>
<li>接收窗：用来标记可以接收的数据大小。</li>
</ul></li>
<li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分
| 已发送未被确认部分 | 未发送但可发送部分 |
不可发送部分，其中<strong>发送窗 = 已发送未确认部分 +
未发但可发送部分</strong>。接收到的数据流可分为：已接收 |
未接收但准备接收 | 未接收不准备接收。<strong>接收窗 =
未接收但准备接收部分</strong>。</li>
<li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li>
</ul>
<h2
id="建立tcp服务器的各个系统调用过程是怎样的">建立TCP服务器的各个系统调用过程是怎样的？</h2>
<figure>
<img src="/img/C++八股文/计网/TCP系统调用流程.png" srcset="/img/loading.gif" lazyload
alt="TCP的系统调用过程" />
<figcaption aria-hidden="true">TCP的系统调用过程</figcaption>
</figure>
<figure>
<img src="/img/C++八股文/计网/TCP系统调用流程-1.png" srcset="/img/loading.gif" lazyload
alt="TCP的系统调用过程" />
<figcaption aria-hidden="true">TCP的系统调用过程</figcaption>
</figure>
<h2 id="tcp-协议如何保证可靠传输">TCP 协议如何保证可靠传输？</h2>
<p>首部校验 这个校验机制能够确保数据传输不会出错吗？ 答案是不能。</p>
<p><strong>解决方案</strong>:</p>
<p>传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题</p>
<h2 id="udp是什么">UDP是什么？</h2>
<p>提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p>
<h2 id="tcp和udp的区别">TCP和UDP的区别</h2>
<ol type="1">
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li><strong>TCP提供可靠的服务</strong>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;<strong>UDP尽最大努力交付，即不保证可靠交付</strong></li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
<li><strong>UDP是面向报文的</strong>，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小;<strong>TCP是面向字节流的</strong>，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</li>
</ol>
<h2
id="封包和拆包你听说过吗它是基于tcp还是udp的">封包和拆包你听说过吗？它是基于TCP还是UDP的？</h2>
<p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<h2 id="tcp和upd的特点">TCP和UPD的特点</h2>
<h3 id="udp特点">UDP特点</h3>
<ul>
<li>UDP是无连接的；</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是面向报文的；</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
<h3 id="tcp特点">TCP特点</h3>
<ul>
<li>TCP是面向连接的。</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li>
<li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ul>
<h2 id="tcp对应的应用层协议有哪些">TCP对应的应用层协议有哪些？</h2>
<ul>
<li>FTP：定义了文件传输协议，使用21端口.</li>
<li>Telnet：它是一种用于远程登陆的端口,23端口</li>
<li>SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。</li>
<li>POP3：它是和SMTP对应，POP3用于接收邮件。</li>
</ul>
<h2 id="udp对应的应用层协议">UDP对应的应用层协议</h2>
<ul>
<li>DNS：用于域名解析服务，用的是53号端口</li>
<li>SNMP：简单网络管理协议，使用161号端口</li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，69</li>
</ul>
<h2
id="数据链路层常见协议可以说一下吗">数据链路层常见协议？可以说一下吗？</h2>
<table>
<thead>
<tr class="header">
<th>协议</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ARP</td>
<td>地址解析协议</td>
<td>根据IP地址获取物理地址</td>
</tr>
<tr class="even">
<td>RARP</td>
<td>逆地址解析协议</td>
<td>根据物理地址获取IP地址</td>
</tr>
<tr class="odd">
<td>PPP</td>
<td>点对点协议</td>
<td>在两点之间建立可靠的通信链路</td>
</tr>
</tbody>
</table>
<h2
id="ping命令基于什么协议原理是什么">Ping命令基于什么协议？原理是什么？</h2>
<p>ping是基于网络层的ICMP协议实现的。通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。</p>
<div class="admonition note">
<p class="admonition-title">
ICMP协议类型
</p>
<p>
ICMP报文分为两个种类:
</p>
<ul>
<li>
ICMP差错报告报文，常见的有
</li>
</ul>
<ol>
<li>
终点不可达
</li>
<li>
时间超过
</li>
<li>
参数问题
</li>
<li>
改变路由
</li>
</ol>
<ul>
<li>
ICMP询问报文
</li>
</ul>
<ol>
<li>
回送请求和回答：向特定主机发出回送请求报文，收到回送请求报文的主机响应<strong>回送回答报文</strong>。
</li>
<li>
时间戳请求和回答：询问对方当前的时间，返回的是一个32位的时间戳。
</li>
</ol>
</div>
<h2
id="在进行udp编程的时候一次发送多少bytes好">在进行UDP编程的时候，一次发送多少bytes好?</h2>
<p>当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的。</p>
<p>我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:首先,我们知道,TCP/IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.UDP属于运输层,</p>
<p>下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.</p>
<p>所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。</p>
<p>当我们发送的UDP数据大于1472的时候会怎样呢？
这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).
把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.
这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便
无法重组数据报.将导致丢弃整个UDP数据报。</p>
<p>因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.</p>
<p>进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.
如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机
制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.</p>
<p>鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.
最好将UDP的数据长度控件在576-8-20=548字节以内</p>
<h2 id="tcp实现流量控制的机制">TCP实现流量控制的机制？</h2>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。<strong>TCP
利用滑动窗口实现流量控制</strong>。</p>
<p>TCP
中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为
0
时，发送方一般不能再发送数据报，但有两种情况除外，<strong>一种情况</strong>是可以发送紧急数据。例如，允许用户终止在远端机上的运行进程。<strong>另一种情况</strong>是发送方可以发送一个
1
字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
<h2
id="可以解释一下rtortt和超时重传分别是什么吗">可以解释一下RTO，RTT和超时重传分别是什么吗？</h2>
<ul>
<li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。
<ul>
<li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......</li>
<li>重传次数到达上限之后停止重传。</li>
</ul></li>
<li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li>
<li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：
<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li>
<li>接收端拒绝或丢弃数据。</li>
</ul></li>
</ul>
<h2 id="xss攻击是什么低频">XSS攻击是什么？（低频）</h2>
<p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。</p>
<p>如何防范XSS攻击？</p>
<ol type="1">
<li>前端，服务端，同时需要字符串输入的长度限制。</li>
<li>前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。
防 XSS 的核心是必须对输入的数据做过滤处理。</li>
</ol>
<h2 id="csrf攻击">CSRF攻击？</h2>
<p>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。</p>
<p><strong>如何防范CSRF攻击？</strong></p>
<ul>
<li>安全框架，例如Spring Security。</li>
<li>token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。</li>
<li>验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。</li>
<li>referer识别。在HTTP
Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。
<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加 token 并验证。</li>
</ul></li>
</ul>
<h2
id="文件上传漏洞是如何发生的如何防范文件上传漏洞">文件上传漏洞是如何发生的？如何防范文件上传漏洞？</h2>
<p><strong>文件上传漏洞</strong>，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。
许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。</p>
<p><strong>如何防范文件上传漏洞?</strong></p>
<ol type="1">
<li>判断文件类型。在判断文件类型的时候，可以结合使用MIME
Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。</li>
<li>对上传的文件类型进行白名单校验，只允许上传可靠类型。</li>
<li>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。</li>
<li>限制上传文件的大小。</li>
<li>单独设置文件服务器的域名。</li>
</ol>
<!-- ## 拥塞控制原理？

- 拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。
- TCP拥塞控制算法：
  - **慢启动 & 拥塞避免**：先试探网络拥塞程度再逐渐增大拥塞窗口。假设窗口长度为d，收到一个确认就加1，正好收到了d个确认，所以一共加d，正好是翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行增加，这个过程为拥塞避免。
  - 快速重传 & 快速恢复：见[TCP四大拥塞控制算法总结](https://gstarmin.github.io/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/#tcp%E5%9B%9B%E5%A4%A7%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93)
  - 最终拥塞窗口会收敛于稳定值。 -->
<h2 id="如何区分流量控制和拥塞控制">如何区分流量控制和拥塞控制？</h2>
<p>流量控制和拥塞控制是网络通信中两个重要的概念，它们的主要区别在于目标和作用对象。</p>
<p><strong>流量控制</strong>：</p>
<ul>
<li>作用对象：主要针对发送者和接收者之间的数据流量进行控制。</li>
<li>目标：控制发送者的发送速度，使得接收者来得及接收，防止分组丢失。</li>
<li>实现原理：通过滑动窗口协议实现，接收方告知发送方自己的窗口大小，发送方立刻更改即可实现流量控制。</li>
</ul>
<p><strong>拥塞控制</strong>：</p>
<ul>
<li>作用对象：主要针对<strong>网络中的节点和链路进行控制</strong>。</li>
<li>目标：防止过多的数据注入到网络中，避免出现网络负载过大的情况。</li>
<li>实现原理：常用的方法有<strong>慢开始、拥塞避免、快重传、快速恢复</strong>。发送方会维持一个拥塞窗口（动态变化），拥塞窗口的大小代表着网络的拥塞程度。</li>
</ul>
<p>总的来说，<strong>流量控制是为了防止接收方被淹没，而拥塞控制是为了防止网络被淹没</strong>。这两种控制机制共同保证了网络通信的稳定和高效。</p>
<h2 id="常见的http状态码有哪些">常见的HTTP状态码有哪些？</h2>
<table>
<thead>
<tr class="header">
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1xx</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr class="even">
<td>2xx</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr class="odd">
<td>3xx</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr class="even">
<td>4xx</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr class="odd">
<td>5xx</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h3 id="xx-信息">1xx 信息</h3>
<p>100 Continue
：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<h3 id="xx-成功">2xx 成功</h3>
<ul>
<li>200 OK</li>
<li>204 No Content
：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由
Content-Range 指定范围的实体内容。</li>
</ul>
<h3 id="xx-重定向">3xx 重定向</h3>
<ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303
明确要求客户端应该采用 GET 方法获取资源。</li>
<li>304 Not Modified
：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回
304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307
要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h3 id="xx-客户端错误">4xx 客户端错误</h3>
<ul>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC
认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found</li>
</ul>
<h3 id="xx-服务器错误">5xx 服务器错误</h3>
<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable
：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h3
id="三次握手过程中bindlistenaccept哪个环节">三次握手过程中bind()、listen()、accept()哪个环节？</h3>
<ol type="1">
<li><code>bind()</code>:
该函数用于将一个本地地址绑定到套接字，指定套接字使用的IP地址和端口号。这对应于<strong>第一次握手中客户端发送</strong>SYN请求的时候，客户端选择一个本地端口并将其绑定到目标IP地址上。</li>
<li><code>listen()</code>:
该函数使套接字进入监听状态，等待客户端的连接请求。这对应于第一次握手中服务端收到客户端的SYN请求，服务端准备接受连接。</li>
<li><code>accept()</code>:
该函数用于接受客户端的连接请求，创建一个新的套接字用于与客户端通信。这对应于第二次握手中服务端发送SYN-ACK，表示接受连接。</li>
<li><code>connect()</code>:
该函数用于发起到远程套接字的连接请求。这对应于第三次握手中客户端接收到服务端的SYN-ACK后，发送ACK表示连接建立成功。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络</div>
      <div>https://gstarmin.github.io/2023/12/23/计算机网络/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Starmin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/23/Cpp-static%E5%88%9D%E5%A7%8B%E5%8C%96/" title="Cpp-static初始化">
                        <span class="hidden-mobile">Cpp-static初始化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
