

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Starmin">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++知识点 C++ 知识点 说一下你理解的 C++ 中的四种智能指针 面试官你好，⾸先，说一下为什么要使用智能指针：智能指针其作用是管理一个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。 然后使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动">
<meta property="og:type" content="article">
<meta property="og:title" content="C++知识点">
<meta property="og:url" content="https://gstarmin.github.io/2023/11/23/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/">
<meta property="og:site_name" content="私人杂货铺">
<meta property="og:description" content="C++知识点 C++ 知识点 说一下你理解的 C++ 中的四种智能指针 面试官你好，⾸先，说一下为什么要使用智能指针：智能指针其作用是管理一个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。 然后使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gstarmin.github.io/img/C++八股文/虚函数.jpg">
<meta property="article:published_time" content="2023-11-23T02:46:05.000Z">
<meta property="article:modified_time" content="2024-01-20T03:40:05.000Z">
<meta property="article:author" content="Starmin">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gstarmin.github.io/img/C++八股文/虚函数.jpg">
  
  
  
  <title>C++知识点 - 私人杂货铺</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gstarmin.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Starmin</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++知识点"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-23 10:46" pubdate>
          2023年11月23日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          105k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1052 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++知识点</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="c知识点">C++知识点</h1>
<h2 id="c-知识点">C++ 知识点</h2>
<h3 id="说一下你理解的-c-中的四种智能指针">说一下你理解的 C++
中的四种智能指针</h3>
<p>面试官你好，⾸先，说一下为什么要使用智能指针：智能指针其作用是管理一个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。</p>
<p>然后使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要⼿动释放内存空间。</p>
<p><strong>常用接口</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>T&amp; <span class="hljs-keyword">operator</span>*(); T* <span class="hljs-keyword">operator</span>-&gt;();<br>T&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> T&amp; val); <br><span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span> <span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>T 是模板参数, 也就是传入的类型；</li>
<li>get() 用来获取 auto_ptr 封装在内部的指针, 也就是获取原生指针；</li>
<li>operator() 重载 , operator-&gt;() 重载了-&gt;,
operator=()重载了=；</li>
<li>realease() 将 auto_ptr 封装在内部的指针置为 nullptr,
但并不会破坏指针所指向的内容, 函数返回的是内部指针置空之前的值；</li>
<li>直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值,
则将内部指针初始化为该值 (否则将其设置为 nullptr；</li>
</ul>
<p>下面分别说一下哪四种：</p>
<h4 id="auto_ptrc98-的方案c11-已抛弃采用所有权模式">1.
<strong>auto_ptr</strong>（C++98 的方案，C11 已抛弃）采用所有权模式</h4>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;std::string&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;hello&quot;</span>))</span></span>;<br>auto_ptr&lt;std::string&gt; p2;<br>p2 = p1; <span class="hljs-comment">//auto_ptr 不会报错.</span><br></code></pre></td></tr></table></figure></p>
<p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1
将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>
<h4 id="unique_ptr替换-auto_ptr">2. <strong>unique_ptr</strong>（替换
auto_ptr ）</h4>
<p>unique_ptr
实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-keyword">auto</span>))</span></span>;<span class="hljs-comment">//#4 </span><br>unique_ptr&lt;string&gt; p4；<span class="hljs-comment">//#5</span><br>p4 = p3;<span class="hljs-comment">//此时会报错</span><br></code></pre></td></tr></table></figure></p>
<p>编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。</p>
<p>因此，unique_ptr ⽐ auto_ptr 更安全。</p>
<h4 id="shared_ptr共享型强引用">3.
<strong>shared_ptr</strong>（共享型，强引用）</h4>
<p>shared_ptr
实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字
share
就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。</p>
<p>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new
来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用
release() 时，当前指针会释放资源所有权，计数减一。当计数等于
0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr
是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<h4 id="weak_ptr弱引用">4. <strong>weak_ptr</strong>（弱引用）</h4>
<p>weak_ptr
是一种<strong>不控制对象生命周期的智能指针</strong>，它指向一个
shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的
shared_ptr。</p>
<p>weak_ptr 只是提供了对管理对象的一个访问⼿段。weak_ptr
设计的目的是为配合 shared_ptr 而引入的一种智能指针，来协助 shared_ptr
工作，它只可以从一个 shared_ptr 或另一个 weak_ptr
对象构造,它的构造和析构不会引起引用记数的增加或减少。</p>
<p>weak_ptr 是用来<strong>解决 shared_ptr
相互引用时的死锁问题</strong>，如果说两个 shared_ptr
相互引用，那么这两个指针的引用计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和
shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用
lock 函数来获得 shared_ptr。</p>
<p>当两个智能指针都是 shared_ptr
类型的时候，析构时两个资源引用计数会减一，但是两者引用计数还是为
1，导致跳出函数时资源没有被释放（的析构函数没有被调用），解决办法：把其中一个改为weak_ptr就可以。</p>
<p>详细介绍智能指针见<a
href="https://gstarmin.github.io/2023/03/04/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">C++智能指针</a></p>
<h3
id="make_shared与直接创建shared_ptr的区别">make_shared与直接创建shared_ptr的区别</h3>
<h4 id="shared_ptr结构">shared_ptr结构</h4>
<p>shared_ptr源码如下（截取片段）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> : <span class="hljs-keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="hljs-comment">// class for reference counted resource management</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ptr_base</span> &#123; <span class="hljs-comment">// base class for shared_ptr and weak_ptr</span><br><span class="hljs-keyword">private</span>:<br>    element_type* _Ptr&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    _Ref_count_base* _Rep&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/v2-0f63ac10a770358bae0ec65a954fe457_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/v2-4dccfe27f585d77a81e74ca427731616_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4
id="直接创建shared_ptr是异常不安全的可能会发生内存泄漏而make_shared是异常安全的">（1）直接创建shared_ptr是异常不安全的，可能会发生内存泄漏；而make_shared是异常安全的。</h4>
<p>参考下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不好：可能会泄漏</span><br><span class="hljs-comment">//异常不安全的，编译器可能会把两个用以创建函数的两个参数的表达式重新排序。</span><br><span class="hljs-comment">//可能会首先为两个对象先进行内存分配，然后再试图调用二者的Widget构造函数。</span><br><span class="hljs-comment">//一旦其中一个构造函数调用抛出了异常，那么另一个对象的内存可能永远不会被释放了！</span><br><br><span class="hljs-comment">//异常不安全</span><br><span class="hljs-built_in">fun</span>(<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(a,b)),<br>    <span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(c,d)));<br><br><span class="hljs-comment">//异常不安全</span><br><span class="hljs-keyword">auto</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(a,b);<br><span class="hljs-keyword">auto</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>(c,d);<br><span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(p1);<br><span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(p2);<br><br><span class="hljs-comment">//异常安全，但写法不干净</span><br><span class="hljs-function">shared_ptr&lt;Widget&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget(a,b))</span></span>;<br><span class="hljs-function">shared_ptr&lt;Widget&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget(c,d))</span></span>;<br><span class="hljs-built_in">fun</span>(sp1,sp2);<br><br><span class="hljs-comment">//异常安全，性能最好，也很干净</span><br><span class="hljs-built_in">fun</span>(<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(a,b), <span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(c,d));<br></code></pre></td></tr></table></figure>
<h4
id="make_shared-只需要分配一次内存而直接创建-shared_ptr-需要分配两次内存">2）make_shared
只需要分配一次内存，而直接创建 shared_ptr 需要分配两次内存。</h4>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/v2-a26c103854275fabd9f854a186ff7c18_720w.webp" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>采用直接创建shared_ptr的方式，那么首先需要在堆上为原始对象分配内存，其次根据上面
shared_ptr 的构造函数可知，<code>new _Ref_count&lt;_Ux&gt;(_Px)</code>
时还需要为控制块分配一次内存。</p>
<p>然后我们再来看看 make_shared 源码，它采用placement
new的方式，动态分配了一个
<code>_Ref_count_obj2</code>，这也是<code>_Ref_count_base</code>的一个派生类，<code>union &#123;_Wrap&lt;_Ty&gt; _Storage;&#125;</code>为
<code>_Ty</code>
类型的对象分配了内存空间，所以对象和控制块都被放在了一块。</p>
<h4
id="make_shared也存在缺陷只有当-_weaks-为-0-时控制块才会调用-_delete_this-释放自己weak_ptr会拖延整块内存释放时间">（3）make_shared也存在缺陷，只有当
_Weaks 为 0 时，控制块才会调用 _Delete_this()
释放自己，weak_ptr会拖延整块内存释放时间。</h4>
<p>上面我们提到，在_Ref_count_base的实现中，只有当 _Weaks 为 0
时，控制块才会调用 _Delete_this()
释放自己，然而**由于现在对象也被放在了控制块中，所以即使 _Uses 为 0
时，对象空间也没有算被释放，只有当 _Weaks 为 0 时，
才算是真的被释放了**。</p>
<p>测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;MyClass()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~MyClass()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x, y, z;<br>&#125;;<br><br><span class="hljs-type">int</span> alloc_times = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dealloc_times = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> allocated = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-type">void</span>* p = std::<span class="hljs-built_in">malloc</span>(size);<br>    cout &lt;&lt; <span class="hljs-string">&quot;new &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot; byte(s)&quot;</span> &lt;&lt; endl;<br><br>    allocated += size;<br>    alloc_times++;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;deleted memory&quot;</span> &lt;&lt; endl;<br><br>    dealloc_times++;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;MyClass&gt; w;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配尺寸:&quot;</span> &lt;&lt; allocated &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配次数&quot;</span> &lt;&lt; alloc_times &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;释放次数&quot;</span> &lt;&lt; dealloc_times &lt;&lt; endl;<br>    &#123;<br>        <span class="hljs-comment">//shared_ptr&lt;MyClass&gt; s&#123;new MyClass()&#125;;</span><br>        shared_ptr s = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>        w = s;<br><br>    &#125;   <span class="hljs-comment">//1. s析构、释放原始对象、但不释放控制块</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;block end--------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配尺寸:&quot;</span> &lt;&lt; allocated &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配次数&quot;</span> &lt;&lt; alloc_times &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;释放次数&quot;</span> &lt;&lt; dealloc_times &lt;&lt; endl;<br><br>    w.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//2. w析构、释放控制块</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;分配尺寸:&quot;</span> &lt;&lt; allocated &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;分配次数&quot;</span> &lt;&lt; alloc_times &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;释放次数&quot;</span> &lt;&lt; dealloc_times &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当采用直接创建shared_ptr的方式时，输入如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">分配尺寸:0<br>分配次数0<br>释放次数0<br>new 24 byte(s)<br>MyClass()<br>new 24 byte(s)<br>~MyClass()<br>deleted memory<br>block end--------<br>分配尺寸:48<br>分配次数2<br>释放次数1<br>deleted memory<br>分配尺寸:48<br>分配次数2<br>释放次数2<br></code></pre></td></tr></table></figure>
<p>当采用make_shared的方式时，输入如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">分配尺寸:0<br>分配次数0<br>释放次数0<br>new 40 byte(s)<br>MyClass()<br>~MyClass()<br>block end--------<br>分配尺寸:40<br>分配次数1<br>释放次数0<br>deleted memory<br>分配尺寸:40<br>分配次数1<br>释放次数1<br></code></pre></td></tr></table></figure>
<h3
id="智能指针的引用计数是普通成员变量还是指针变量使用static可不可以">智能指针的引用计数是普通成员变量还是指针变量？使用static可不可以？</h3>
<p>指针变量；</p>
<p>不可以用static变量，在只有一个对象的时候，该方法是合适的。但是static变量是属于类的，如下图所示，当出现第二个对象，此时新增一个shared_ptr指针，此时内部的count就变成了4，既不满足指向对象1的指针数量，也不满足指向对象2的指针数量。</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/650eab4b416c41089f3219a7b6dea02f.png" srcset="/img/loading.gif" lazyload
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="c-中内存分配情况">C++ 中内存分配情况</h3>
<p>栈：由编译器管理分配和回收，存放局部变量和函数参数。</p>
<p>堆：由程序员管理，需要⼿动 new malloc delete free
进行分配和回收，空间较大，但可能会出现内存泄漏和空闲碎⽚的情况。</p>
<p>全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</p>
<p>常量存储区：存储常量，一般不允许修改。</p>
<p>代码区：存放程序的⼆进制代码。</p>
<h3
id="c中指针参数传递和引用参数传递">C++中指针参数传递和引用参数传递</h3>
<p><strong>指针参数传递本质上是值传递</strong>，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<p>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的<strong>实参变量的地址</strong>。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p><strong>引用传递和指针传递是不同的</strong>，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p>
<p><strong>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）</strong>。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<h3 id="c-中-const-和-static-关键字定义用途">C++ 中 const 和 static
关键字（定义，用途）</h3>
<h4 id="static-作用控制变量的存储方式和可性">static
作用：控制变量的存储方式和可⻅性</h4>
<p><strong>作用一,修饰局部变量</strong>：一般情况下，对于局部变量在程序中是存放在栈区的，并且局部的生命周期在包含语句块执行结束时便结束了。但是如果用
static
关键字修饰的话，该变量便会存放在静态数据区，其生命周期会一直延续到整个程序执行结束。但是要注意的是，虽然用
static
对局部变量进行修饰之后，其生命周期以及存储空间发生了变化，但其作用域并没有改变，作用域还是限制在其语句块。</p>
<p><strong>作用二,修饰全局变量</strong>：C++中全局变量是对整个项目都可见的，只要你在另一个文件中使用的时候加上<strong>extern关键字</strong>，如果你想让这个全局变量作用域改为仅当前文件可见，那么可以在定义的时候在前面加上static关键字。也就是说，C++中static关键字和extern关键字是冲突的。<strong>如果你在一个文件中声明了一个static全局变量，它将无法在其他文件中通过extern关键字访问。static全局变量的生命周期是整个程序的执行期间，但它的链接属性是内部的，意味着它只能在定义它的翻译单元（通常是一个源文件）中被访问</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// header.h</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVarGlobal = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// source1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header.h&quot;</span></span><br><span class="hljs-comment">// staticVarGlobal 可以在这里访问,因为有include</span><br><br><span class="hljs-comment">// source2.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> staticVarGlobal; <span class="hljs-comment">// 错误：staticVarGlobal 在这个文件中不可见</span><br></code></pre></td></tr></table></figure>
<p><strong>作用三,修饰函数</strong>：用 static
修饰函数，情况和修饰全局变量类似，也是改变了函数的作用域。</p>
<p><strong>作用四,修饰类的成员变量/成员函数</strong>：如果 C++
中对类中的某个函数用 static
修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行
static
修饰，则表示该变量以及所有的对象共有，存储空间中只存在一个副本，可以通过；类和对象去调用。</p>
<p>（补充：静态非常量数据成员，其只能在类外定义和初始化，在类内仅是声明而已。）</p>
<p><strong>作用五,函数体/类成员函数内声明 static</strong>:</p>
<ul>
<li>函数体内 static 变量的作用范围为该函数体，不同于 auto
变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</li>
<li>在模块内的 static
全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</li>
<li>在模块内的 static
函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；<br />
</li>
<li>在类中的 static
成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li>
<li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this
指针，因而只能访问类的 static 成员变量。</li>
<li>static 类对象必须要在类外进行初始化，static
修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化；</li>
<li>由于 static 修饰的类成员函数属于类，不属于对象，因此 <strong>static
类成员函数是没有 this 指针</strong>，this
指针是指向本对象的指针，正因为没有 this 指针，<strong>所以 static
类成员函数不能访问⾮ static 的类成员，只能访问
static修饰的类成员；</strong></li>
<li>static 成员函数不能被 virtual 修饰，static
成员不属于任何对象或实例，所以加上 virtual
没有任何实际意义；静态成员函数没有 this
指针，虚函数的实现是为每一个对象分配一个 vptr 指针，而 vptr 是通过 this
指针调用的，所以不能为
virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual
function。</li>
</ul>
<h4 id="const-关键字含义及实现机制">const 关键字：含义及实现机制</h4>
<p><strong>const 修饰基本类型数据类型</strong>：基本数据类型，修饰符
const
可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值即可。</p>
<p><strong>const 修饰指针变量和引用变量</strong>：如果 const
位于小星星的左侧,也叫<strong>顶层const</strong>，则 const
就是用来<strong>修饰指针所指向的变量，即指针指向为常量</strong>；如果
const 位于小星星的右侧，也叫<strong>底层const</strong>，则 <strong>const
就是修饰指针本身，即指针本身是常量</strong>。</p>
<p><strong>const 应用到函数中</strong>：作为参数的 const
修饰符：调用函数的时候，用相应的变量初始化 const
常量，则在函数体中，按照 const
所修饰的部分进行常量化，保护了原对象的属性。</p>
<div class="admonition attention">
<p class="admonition-title">
attention
</p>
<p>
参数 const 通常用于参数为指针或引用的情况; 作为函数返回值的 const
修饰符：声明了返回值后，const
按照"修饰原则"进行修饰，起到相应的保护作用。
</p>
</div>
<p><strong>const 在类中的用法</strong>：const
成员变量，只在某个对象生命周期内是常量，而对于整个类而⾔是可以改变的。因为类可以创建多个对象，不同的对象其
const 数据成员值可以不同。所以不能在类的声明中初始化 const
数据成员，因为类的对象在没有创建时候，编译器不知道 const
数据成员的值是什么。<strong>const
数据成员的初始化只能在类的构造函数的初始化列表中进行</strong>。const
成员函数：const
成员函数的主要目的是防⽌成员函数修改对象的内容。要注意，<strong>const
关键字和 static 关键字对于成员函数来说是不能同时使用的，因为 static
关键字修饰静态成员函数不含有 this 指针，即不能实例化，const
成员函数⼜必须具体到某一个函数</strong>。</p>
<p><strong>const
修饰类对象，定义常量对象</strong>：常量对象只能调用常量函数，别的成员函数都不能调用。</p>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
const 成员函数中如果实在想修改某个变量，可以使用 mutable
进行修饰。成员变量中如果想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现或者
static const。
</p>
</div>
<p><strong>C ++ 中的
const类成员函数（用法和意义）</strong>:常量对象可以调用类中的 const
成员函数，但不能调用非 const 成员函数； （原因：const
成员函数承诺不修改对象的状态。因此，即使在常量对象上调用，它们也不会违反对象的不可变性。因此，对于常量对象来说，只有
const 成员函数是安全的，并且可以被调用。而非 const
成员函数没有保证不修改对象的状态。因此，在常量对象上调用非 const
成员函数会导致潜在的对象状态修改，这与常量对象的本质相违背，因此编译器不允许这样的调用。）</p>
<div class="admonition info">
<p class="admonition-title">
info
</p>
<p>
const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。
因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。
</p>
</div>
<h3 id="c-和-c-区别-函数类structclass">C 和 C++ 区别
（函数/类/struct/class）</h3>
<p>C 和 C++ 在基本语句上没有过大的区别，但在语法和关键字上，C++
有许多新增的内容。以下是一些主要的区别：</p>
<p>首先，C++与C在<strong>语法和关键字</strong>上有显著区别。C++允许<strong>命名空间</strong>的概念，这使得我们能够定义自己的作用域，而在C中是不允许的。此外，在<strong>关键字</strong>方面，C++采用不同的内存管理方式，引入了<code>new</code>和<code>delete</code>来动态管理内存，同时也在指针的基础上增加了引用的概念。C++还引入了一些新的关键字，例如<code>auto</code>、<code>explicit</code>，以及<code>dynamic_cast</code>用于增强类型安全性。</p>
<p><strong>在函数方面</strong>，C++引入了<strong>函数重载</strong>和<strong>虚函数</strong>的概念。函数重载允许同名函数拥有不同的参数列表，以提供更多灵活性，而C不支持函数重载。另外，C++的虚函数概念用于实现多态性。</p>
<p><strong>在类方面</strong>，C语言的struct和C++中的class有着显著区别。在C++中，struct不仅可以包含成员变量，还可以包含成员函数，并且引入了成员访问权限的概念。在<strong>C++中，struct的默认成员访问权限和默认继承权限都是public，而class的默认成员访问权限和默认继承权限都是private</strong>。</p>
<p>C++还引入了模板的概念，允许代码的重用，并且提供了更强大的<strong>STL标准库</strong>。</p>
<p>总体来说，C语言更加侧重于算法和数据结构，强调通过代码和过程对输入进行运算处理并输出。而C++更加注重对象模型的构建，利用对象的状态信息来得到输出。因此，C的struct更适合看作是数据结构的实现体，而C++的class更适合看作是对象的实现体。</p>
<h3 id="c-和-java的区别">C++ 和 Java的区别</h3>
<ul>
<li><strong>指针</strong>：Java
语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的自动管理功能，从而有效的防⽌了
C++ 语⾔中的指针操作失误的影响。但并⾮ Java 中没有指针，Java
虚拟机内部中还是用了指针，保证了 Java 程序的安全。</li>
<li><strong>多重继承</strong>：C++ ⽀持多重继承但 Java
不⽀持，但⽀持一个类继承多个接口，实现了 C++ 中多重继承的功能，⼜避免了
C++ 的多重继承带来的不便。</li>
<li><strong>数据类型和类</strong>：Java
是完全面向对象的语⾔，所有的函数和变量必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可以实现自⼰的特点和行为。
Java 中取消了 C++ 中的 struct 和 union 。</li>
<li><strong>自动内存管理</strong>：Java 程序中所有对象都是用 new
操作符建立在内存堆栈上，<strong>Java
自动进行无用内存回收操作</strong>，不需要程序员进行⼿动删除。而 C++
中必须由程序员释放内存资源，增加了程序设计者的负担。Java
中当一个对象不再被用到时， 无用内存回收器将给他们加上标签。Java
⾥无用内存回收程序是以线程方式在后台运行的，利用空闲时间工作来删除。</li>
<li>Java 不⽀持操作符重载。<strong>操作符重载被认为是 C++
的突出特性。</strong></li>
<li>Java 不⽀持预处理功能。C++ 在编译过程中都有一个预编译阶段，Java
没有预处理器，但它提供了 import 与 C++预处理器具有类似功能。</li>
<li><strong>类型转换</strong>：C++ 中有数据类型隐含转换的机制，Java
中需要限时强制类型转换。</li>
<li><strong>字符串</strong>：C++中字符串是以 Null
终⽌符代表字符串的结束，而 Java 的字符串 是用类对象（string 和
stringBuffer）来实现的。</li>
<li>Java 中不提供 goto 语句，虽然指定 goto
作为关键字，但不⽀持它的使用，使程序简洁易读。</li>
<li>Java 的异常机制用于捕获例外事件，增强系统容错能⼒。</li>
</ul>
<h3 id="说一下-c-里是怎么定义常量的常量存放在内存的哪个位置">说一下 C++
里是怎么定义常量的？常量存放在内存的哪个位置？</h3>
<ul>
<li>对于局部常量，存放在栈区；</li>
<li>对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；</li>
<li>字面值常量，⽐如字符串，放在常量区。</li>
</ul>
<h3 id="c-中重载重写重定义的区别">C++ 中重载、重写、重定义的区别</h3>
<p><strong>重载</strong>：翻译自
overload，是指同一可访问区内被声明的几个具有不同参数列表的同名函数，依赖于
C++函数名字的修饰会将参数加在后面，<strong>可以是参数类型，个数，顺序的不同</strong>。根据参数列表决定调用哪个函数，重载不关⼼函数的返回类型。</p>
<p><strong>重写</strong>：翻译自
override，派生类中重新定义父类中除了函数体外完全相同的<strong>虚函数</strong>，注意被重写的函数不能是
static
的，一定要是虚函数，且其他一定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管
virtual 中是 private 的，派生类中重写可以改为 public。</p>
<p><strong>重定义（隐藏）</strong>：派生类重新定义父类中相同名字的<strong>非虚函数</strong>，参数列表
和返回类型都可以不同，即父类中除了定义成 virtual
且完全相同的同名函数才不会被派生类中的同名函数所隐藏（重定义）。</p>
<p><strong>重写和隐藏的区别在于基类函数是否是虚函数</strong>。</p>
<h3 id="介绍-c-所有的构造函数">介绍 C++ 所有的构造函数</h3>
<p>类的对象被创建时，编译系统为对象分配内存空间，并自动调用构造函数，由构造函数完成成员的初始化工作。即<strong>构造函数的作用：初始化对象的数据成员</strong>。</p>
<p><strong>无参数构造函数</strong>：即默认构造函数，如果没有明确写出无参数构造函数，编译器会自动生成默认的无参数构造函数，函数为空，什么也不做，如果不想使用自动生成的无参构造函数，必需要自⼰显示写出一个无参构造函数。</p>
<p><strong>一般构造函数</strong>：也称<strong>重载构造函数</strong>，一般构造函数可以有各种参数形式，一个类可以有多个一般构造函数，前提是参数的个数或者类型不同，创建对象时根据传入参数不同调用不同的构造函数。</p>
<p><strong>拷贝构造函数</strong>：拷贝构造函数的函数参数为对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在的对象的数据成员的值一一复制到新创建的对象中。如果没有显示的写拷贝构造函
数，则系统会默认创建一个拷贝构造函数，但当类中有指针成员时，最好不要使用编译器提供的默认的拷贝构造函数，最好自⼰定义并且在函数中执行深拷贝。</p>
<p><strong>类型转换构造函数</strong>：根据一个指定类型的对象创建一个本类的对象，也可以算是一般构造函数的一种，这⾥提出来，是想说有的时候不允许默认转换的话，要记得将其声明为
explict 的，来阻⽌一些隐式转换的发生。</p>
<p><strong>赋值运算符的重载</strong>：注意，这个类似拷贝构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会生成默认的赋值运算符，做一些基本的拷贝工作。</p>
<p>这里区分赋值构造函数和拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a1, A a2; a1 = a2;    <span class="hljs-comment">// 调用赋值运算符</span><br>A a3 = a1;              <span class="hljs-comment">// 调用拷贝构造函数</span><br></code></pre></td></tr></table></figure>
<h3 id="c-的四种强制转换">C++ 的四种强制转换</h3>
<p><strong>static_cast</strong>：明确指出类型转换，一般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上行转换（派生类-&gt;基类）安全，下行转换（基类-&gt;派生类）
不安全，所以<strong>主要执行⾮多态的转换操作</strong>；</p>
<p><strong>dynamic_cast</strong>：专门用于派生类之间的转换，type-id
必须是类指针，类引用或
void*，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而static_cast，当类型不一致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。</p>
<p><strong>const_cast</strong>：专门用于 const 属性的转换，去除 const
性质，或增加 const 性质，
是四个转换符中唯一一个可以操作常量的转换符。</p>
<p><strong>reinterpret_cast</strong>：<strong>不到万不得已，不要使用这个转换符，高危操作</strong>。使用特点：
从底层对数据进行重新解释，依赖具体的平台，可移植性差； 可以将整形转
换为指针，也可以把指针转换为数组；可以在指针和引用之间进行肆无忌惮的转换。</p>
<h3 id="指针和引用的区别">指针和引用的区别</h3>
<p>指针和引用都是一种内存地址的概念，区别呢，指针是一个实体，引用只是一个别名。在程序编译的时候，将指针和引用添加到符号表中。</p>
<p>指针它指向一块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有
const 和⾮ const 区别，甚⾄可以为空，sizeof
指针得到的是指针类型的大小。</p>
<p>而对于引用来说，它只是一块内存的别名，在添加到符号表的时候，是将"引用变量名-引用对象的地址"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑定到一块内存上，后续不能更改，也不能为空，也没有
const 和⾮ const 区别。</p>
<p>sizeof 引用得到代表对象的大小。而 sizeof
指针得到的是指针本身的大小。另外在参数传递中，指针需要被解引用后才可以对对象进行操作，而直接对引用进行的修改会直接作用到引用对象上。</p>
<p>作为参数时也不同，传指针的实质是传值，传递的值是指针指向内存的地址；传引用的实质是传地址，传递的是变量的地址。</p>
<h3
id="野wild指针与悬空dangling指针有什么区别如何避免">野(wild)指针与悬空(dangling)指针有什么区别？如何避免？</h3>
<p><strong>野指针(wild pointer)</strong>：就是没有被初始化过的指针。用
<code>gcc -Wall</code>编译, 会出现 used uninitialized 警告。</p>
<p><strong>悬空指针</strong>：是指针最初指向的内存已经被释放了的一种指针。</p>
<p>无论是野指针还是悬空指针，都是指向无效内存区域(这⾥的无效指的是"不安全不可控")的指针。
访问"不安全可控"(invalid)的内存区域将导致"Undefined Behavior"。</p>
<p><strong>如何避免使用野指针</strong>?在平时的编码中，养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。</p>
<h3 id="说一下-const-修饰指针如何区分">说一下 const
修饰指针如何区分？</h3>
<p>下面都是合法的声明，但是含义大不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p1;  <span class="hljs-comment">//指向整形常量 的指针，它指向的值不能修改</span><br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p2;  <span class="hljs-comment">//指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3; <span class="hljs-comment">//指向整形常量 的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。</span><br></code></pre></td></tr></table></figure>
<p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量
，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。</p>
<p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量
，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。</p>
<h3 id="简单说一下函数指针">简单说一下函数指针</h3>
<p>从定义和用途两方面来说一下自⼰的理解：</p>
<p>⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这⾥是指向函数。</p>
<p>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p>其次是用途：调用函数和做函数的参数，⽐如回调函数。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> * p)</span> </span>&#123;…&#125; <span class="hljs-comment">// 函数fun</span><br><span class="hljs-type">char</span> * (*pf)(<span class="hljs-type">char</span> * p); <span class="hljs-comment">// 函数指针pf</span><br>pf = fun;               <span class="hljs-comment">// 函数指针pf指向函数fun</span><br><span class="hljs-built_in">pf</span>(p);                  <span class="hljs-comment">// 通过函数指针pf调用函数fun</span><br></code></pre></td></tr></table></figure>
<h3 id="堆和栈区别">堆和栈区别</h3>
<p><strong>栈</strong>：由编译器进行管理，在需要时由编译器自动分配空间，在不需要时候自动回收空间，一般保存的是局部变量和函数参数等。</p>
<p>连续的内存空间，在函数调用的时候，⾸先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。</p>
<p>大多数编译器中，参数是从右向左入栈（原因在于采用这种顺序，是为了让程序员在使用C/C++的“函数参数⻓度可变”这个特性时更方便。如果是从左向右压栈，第一个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第一步就需要解析可变参数表的各参数类型，即第一步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产生碎⽚。</p>
<p>栈是<strong>高地址向低地址扩展</strong>，栈底高地址，空间较小。</p>
<p><strong>堆</strong>：由程序员管理，需要⼿动 new malloc delete free
进行分配和回收，如果不进行回收的话，会造成内存泄漏的问题。</p>
<p>不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个大于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写入内存大小，方便
delete
回收空间大小。当然如果有剩余的，也会将剩余的插入到空闲链表中，这也是产生内存碎⽚的原因。</p>
<p>堆是<strong>低地址向高地址扩展</strong>，空间较大，较为灵活。</p>
<h3 id="函数传递参数的几种方式">函数传递参数的几种方式</h3>
<p><strong>值传递</strong>：形参是实参的拷贝，函数内部对形参的操作并不会影响到外部的实参。</p>
<p><strong>指针传递</strong>：也是值传递的一种方式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。</p>
<p><strong>引用传递</strong>：实际上就是把引用对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上面。</p>
<h3 id="new-delete-malloc-free-区别">new / delete ，malloc / free
区别</h3>
<p>都可以用来在堆上分配和回收空间。new / delete
是<strong>操作符</strong>，malloc/free 是<strong>库函数</strong>。</p>
<p><strong>执行 new
实际上执行两个过程</strong>：1.分配未初始化的内存空间（malloc）；2.使用对象的构造函数对空间进行初始化；返回空间的⾸地址。如果在第一步分配空间中出现问题，则抛出
std::bad_alloc
异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则自动调用
delete 释放内存。</p>
<p><strong>执行 delete 实际上也有两个过程</strong>：1.
使用析构函数对对象进行析构；2.回收内存空间（free）。以上也可以看出 new
和 malloc 的区别，new 得到的是经过初始化的空间，而 malloc
得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc
一个字节⻓度的空间。delete 和 free 同理，delete
不仅释放空间还析构对象，delete 一个类型，而 free
是释放一个字节⻓度的空间。</p>
<p><strong>为什么有了 malloc／free 还需要
new／delete</strong>？因为对于⾮内部数据类型而⾔，光用 malloc／free
无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于
mallo／ free
是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于
malloc／free，所以有了 new／delete 操作符。</p>
<h3 id="volatile-和-extern-关键字">volatile 和 extern 关键字</h3>
<p><strong>volatile 三个特性</strong>:</p>
<ul>
<li>易变性：在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的
volatile 变量的寄存器内容，而是重新从内存中读取。</li>
<li>不可优化性：volatile
告诉编译器，不要对我这个变量进行各种激进的优化，甚⾄将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</li>
<li>顺序性：能够保证 volatile
变量之间的顺序性，编译器不会进行乱序优化。</li>
</ul>
<p><strong>extern</strong>:</p>
<p>在 C 语⾔中，修饰符 extern 用在变量或者函数的声明前，用来说明
“此变量/函数是在别处定义的，要在此处引用”。</p>
<p>注意 extern 声明的位置对其作用域也有关系，如果是在 main
函数中进行声明的，则只能在 main
函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用
#include 包含进来即可，为啥要用 extern？因为用 extern
会加速程序的编译过程，这样能节省时间。</p>
<p>在 C++ 中 extern 还有另外一种作用，用于指示 C 或者
C＋＋函数的调用规范。⽐如在 C＋＋ 中调用 C 库函数，就需要在 C＋＋
程序中用 extern “C”
声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C
函数规范来链接。主要原因是 C＋＋ 和 C
程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。不单单是C++可以调用C，在C中也可以用extern关键字调用C++函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++调用C函数</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//xx.c</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//xx.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xx.h&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C调用C++函数</span><br><br><span class="hljs-comment">//xx.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//xx.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;    <br>&#125;<br><span class="hljs-comment">//xx.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<h3 id="define-和-const-的区别编译阶段安全性内存占用等">define 和 const
的区别（编译阶段、安全性、内存占用等）</h3>
<p>对于 define
来说，<strong>宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查</strong>，仅仅做的是遇到宏定义进行字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为
define 宏定义仅仅是展开，因此运行时系统并不为宏定义分配内存，但是从汇编
的⻆度来讲， define 却以立即数的方式保留了多份数据的拷贝。</p>
<p>对于 const 来说，<strong>const 是在编译期间进行处理的，const
有类型，也有类型检查</strong>，程序运行时系统会为 const
常量分配内存，而且从汇编的⻆度讲，const
常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的
const 常量分配内存，而是直接将 const
常量添加到符号表中，省去了读取和写入内存的操作，效率更高。</p>
<p>此外C++ 11 中还引入了 constexpr 的关键字（并在C++
14中进行改进），它也用于定义常量，但它更强调在编译时期求值的常量。const
变量可以在编译时期或运行时期进行赋值，而 constexpr
只能在编译时期赋值。</p>
<p><strong>const 和 constexpr 的区别</strong>？见下条</p>
<h3 id="const-和-constexpr-的区别">const 和 constexpr 的区别</h3>
<p>在 C++ 中，const 和 constexpr
都用于创建常量，但它们在使用和编译时期的特性上有一些区别：</p>
<ul>
<li>const 可以修饰变量或者指针，表示其值不可以被修改，而 constexpr
更强调在编译时期求值的变量</li>
<li>const 变量可以在编译时期或运行时期进行赋值，而 constexpr
只能在编译时期赋值。</li>
<li>const
变量的值在编译时期不需要确定，可以是运行时期确定的值，只要在使用前初始化即可；而constexpr
变量的值必须在编译时期确定，其初始化必须是一个常量表达式。</li>
<li>在修饰函数时，const
只能用于非静态成员函数，它保证成员函数不修改任何非静态数据；而constexpr
函数是在使用需要它的代码时，可在编译时计算其返回值的函数，当其自变量为
constexpr 值时， constexpr 函数将生成编译时 constant（常数）。 使用非
constexpr
自变量调用时，或者编译时不需要其值时，它将与正则函数一样，在运行时生成一个值。
（此双重行为使你无需编写同一函数的 constexpr 和非 constexpr
版本。）</li>
</ul>
<h3
id="面向对象的三大特性并举例说明">面向对象的三大特性，并举例说明</h3>
<p>C++ 面向对象的三大特征是：封装、继承、多态。</p>
<p><strong>所谓封装</strong></p>
<p>就是把客观事物封装成抽象的类，并且类可以把自⼰的数据和方法只让信任的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防⽌程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p><strong>所谓继承</strong></p>
<p>是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它⽀持按级分类的概念。继承是指这样一种能⼒：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或者“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。</p>
<p>继承概念的实现方式有两类：</p>
<p>实现继承：实现继承是指直接使用基类的属性和方法而无需额外编码的能⼒。</p>
<p>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必需提供实现的能⼒。</p>
<p><strong>所谓多态</strong></p>
<p>指的是通过一个基类指针或引用调用一个虚函数时，会根据具体对象的类型来调用该虚函数的不同实现1。在多态中，相同的操作可以作用于不同的对象，而具体执行的操作则取决于对象的类型和特性1。</p>
<p>多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并产生代码，则是静态的，即地址早绑定。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定</p>
<h3 id="多态的实现">多态的实现</h3>
<p>多态其实一般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数生成符号表时的不同规则，重载只是一种语⾔特性，与多态无关，与面向对象也无关，但这⼜是
C++中增加的新规则，所以也算属于
C++，所以如果⾮要说重载算是多态的一种，那就可以说：多态可以分为<strong>静态多态</strong>和<strong>动态多态</strong>。</p>
<p><strong>静态多态其实就是重载</strong>，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定；</p>
<p><strong>动态多态是指通过子类重写父类的虚函数来实现的</strong>，因为是在运行期间决定调用的函数，所以称为动态多态，一般情况下我们不区分这两个时所说的多态就是指动态多态。动态多态的实现与虚函数表，虚函数指针相关。</p>
<p><strong>扩展</strong>：子类是否要重写父类的虚函数？子类继承父类时，父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<h3
id="虚函数相关虚函数表虚函数指针虚函数的实现原理">虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</h3>
<p>⾸先我们来说一下，C++中多态的表象，在基类的函数前加上 virtual
关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数，如果是基类，就调用基类的函数。</p>
<p>实际上，当一个类中包含虚函数时，编译器会为该类生成一个虚函数表，保存该类中虚函数的地址，同样，派生类继承基类，派生类中自然一定有虚函数，所以编译器也会为派生类生成自⼰的虚函数表。当我们定义一个派生类对象时，编译器检测该类型有虚函数，所以为这个派生类对象生成一个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。</p>
<p>后续如果有一个基类类型的指针，指向派生类，那么当调用虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调用派生类的虚函数表中的虚函数以此实现多态。</p>
<p><strong>补充</strong>：如果基类中没有定义成 virtual，那么进行 Base B;
Derived D; Base *p = D; p-&gt;function(); 这种情况下调用的则是 Base 中的
function()。因为基类和派生类中都没有虚函数的定义，那么编译器就会认为不用留给动态多态的机会，就事先进行函数地址的绑定（早绑定），详述过程就是，定义了一个派生类对象，⾸先要构造基类的空
间，然后构造派生类的自身内容，形成一个派生类对象，那么在进行类型转换时，直接截取基类的部分的内存，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另一个表］中）绑定的函数地址也就是基类中函数的地址，所以执行的是基类的函数。</p>
<h3
id="编译器处理虚函数表应该如何处理">编译器处理虚函数表应该如何处理</h3>
<p>对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤：</p>
<ol type="1">
<li>拷贝基类的虚函数表，如果是多继承，就拷贝每个有虚函数基类的虚函数表</li>
<li>当然还有一个基类的虚函数表和派生类自身的虚函数表共用了一个虚函数表，也称为某个基类为派生类的主基类</li>
<li>查看派生类中是否有重写基类中的虚函数，
如果有，就替换成已经重写的虚函数地址；查看派生类是否有自身的虚函数，如果有，就追加自身的虚函数到自身的虚函数表中。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Derived *pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">D</span>(); B *pb = pd; C *pc = pd;<br></code></pre></td></tr></table></figure>
<p>其中 pb，pd，pc
的指针位置是不同的，要注意的是派生类的自身的内容要追加在主基类的内存块后。</p>
<figure>
<img src="/img/C++八股文/虚函数.jpg" srcset="/img/loading.gif" lazyload alt="虚函数" />
<figcaption aria-hidden="true">虚函数</figcaption>
</figure>
<h3 id="析构函数一般写成虚函数的原因">析构函数一般写成虚函数的原因</h3>
<p>直观的讲：是为了<strong>降低内存泄漏的可能性</strong>。举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数,该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。</p>
<p>如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。</p>
<h3
id="构造函数为什么一般不定义为虚函数">构造函数为什么一般不定义为虚函数</h3>
<ul>
<li>虚函数调用只需要知道“部分的”信息，即只需要知道函数接口，而不需要知道对象的具体类型。但是，我们要创建一个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；</li>
<li>而且从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过实例化之后对象的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违反了先实例化后调用的准则。</li>
</ul>
<h3
id="构造函数或析构函数中调用虚函数会怎样">构造函数或析构函数中调用虚函数会怎样</h3>
<p>实际上是不应该在构造函数或析构函数中调用虚函数的，因为这样的调用其实并不会带来所想要的效果。</p>
<p>举例来说就是，有一个动物的基类，基类中定义了一个动物本身行为的虚函数
action_type()，在基类的构造函数中调用了这个虚函数。</p>
<p>派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自实现的虚函数，但实际上当我们创建一个派生类对象时，⾸先会创建派生类的基类部分，执行基类的构造函数，此时，派生类的自身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为一种安全的方法。</p>
<p>也就是说构造派生类的基类部分是，编译器会认为这就是一个基类类型的对象，然后调用基类类型中的虚函数实现，并没有按照我们想要的方式进行。即对象在派生类构造函数执行前并不会成为一个派生类对象。</p>
<p>在析构函数中也是同理，派生类执行了析构函数后，派生类的自身成员呈现未定义的状态，那么在执行基类的析构函数中是不可能调用到派生类重写的方法的。所以说，我们不应该在构在函数或析构函数中调用虚函数，就算调用一般也不会达到我们想要的结果。</p>
<h3 id="析构函数的作用如何起作用">析构函数的作用，如何起作用？</h3>
<p>构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数⾥面，这样就使其他的函数⾥面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就是你不写，编译器也自动调用一次。</p>
<p>析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</p>
<p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。</p>
<p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
<h3
id="构造函数的执行顺序析构函数的执行顺序">构造函数的执行顺序？析构函数的执行顺序？</h3>
<p><strong>构造函数顺序</strong></p>
<ul>
<li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li>
<li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</li>
<li>派生类构造函数。</li>
</ul>
<p><strong>析构函数顺序</strong></p>
<ul>
<li>调用派生类的析构函数；</li>
<li>调用成员类对象的析构函数；</li>
<li>调用基类的析构函数。</li>
</ul>
<h3 id="纯虚函数-应用于接口继承和实现继承">纯虚函数
（应用于接口继承和实现继承）</h3>
<p>实际上，纯虚函数的出现就是为了让继承可以出现多种情况：</p>
<ul>
<li>有时我们希望派生类只继承成员函数的接口</li>
<li>有时我们⼜希望派生类既继承成员函数的接口，⼜继承成员函数的实现，而且可以在派生类中可以重写成员函数以实现多态</li>
<li>有的时候我们⼜希望派生类在继承成员函数接口和实现的情况下，不能重写缺省的实现。</li>
</ul>
<p>其实，声明一个纯虚函数的目的就是为了让派生类只继承函数的接口，而且派生类中必需提供一个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进行实例化。</p>
<p>对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调用这个实现的唯一方式是在派生类对象中指出其
class 名称来调用。</p>
<h3 id="静态绑定和动态绑定的介绍">静态绑定和动态绑定的介绍</h3>
<p>说起静态绑定和动态绑定，我们⾸先要知道<strong>静态类型和动态类型</strong>，静态类型就是它在程序中被声明时所采用的类型，在编译期间确定。动态类型则是指“目前所指对象的实际类型”，在运行期间确定。</p>
<p><strong>静态绑定</strong>，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期间。</p>
<p><strong>动态绑定</strong>，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发生在运行期间。</p>
<p>⽐如说，virtual
函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意，我们<strong>不应该重新定义继承而来的缺省参数，因为即使我们重定义了，也不会起到效果</strong>。因为一个基类的指针指向一个派生类对象，在派生类的对象中针对虚函数的参数缺省值进行了重定义，
但是<strong>缺省参数值是静态绑定的</strong>，静态绑定绑定的是静态类型相关的内容，所以会出现一种派生类的虚函数实现方式结合了基类的缺省参数值的调用效果，这个与所期望的效果不同。</p>
<h3
id="深拷贝和浅拷贝的区别举例说明深拷贝的安全性">深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h3>
<p><strong>浅拷贝</strong>只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。<strong>深拷贝</strong>不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p>
<p>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，
系统会调用默认的拷贝函数－即浅拷贝，它能够完成成员的一一复制。<strong>当数据成员中没有指针时，浅拷贝是可行的。</strong></p>
<p>但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致指野指针的问题。</p>
<p>所以，这时必需采用深拷贝。深拷贝与浅拷贝之间的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决来野指针的问题。简而⾔之，当数据成员中有指针时，必需要用深拷贝更加安全。</p>
<h3
id="引用是否能实现动态绑定为什么可以实现">引用是否能实现动态绑定，为什么可以实现？</h3>
<p>可以。</p>
<p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>  <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>  <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Son s;<br>	Base&amp; b = s; <span class="hljs-comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span><br>	s.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">//son::fun()</span><br>	b.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">//son :: fun()</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>需要说明的是虚函数才具有动态绑定</strong>，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p>
<h3
id="什么情况下会调用拷贝构造函数三种情况">什么情况下会调用拷贝构造函数(三种情况)</h3>
<ul>
<li>一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间中。</li>
<li>一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值。<br />
</li>
<li>一个对象需要通过另外一个对象进行初始化。</li>
</ul>
<h3
id="为什么拷贝构造函数必需时引用传递不能是值传递">为什么拷贝构造函数必需时引用传递，不能是值传递？</h3>
<p>为了防⽌递归调用。当一个对象需要以值方式进行传递时，编译器会生成代码调用它的拷贝构造函数生成一个副本，如果类
A
的拷贝构造函数的参数不是引用传递，而是采用值传递，那么就⼜需要为了创建传递给拷贝构造函数的参数的临时对象，而⼜一次调用类
A 的拷贝构造函数，这就是一个无限递归。</p>
<h3
id="结构体内存对齐方式和为什么要进行内存对齐">结构体内存对齐方式和为什么要进行内存对齐？</h3>
<p>⾸先我们来说一下结构体中内存对齐的规则：</p>
<ul>
<li>对于结构体中的各个成员，第一个成员位于偏移为 0
的位置，以后的每个数据成员的偏移量必须是<code>min(#pragma pack()制定的数，数据成员本身⻓度)</code>
的倍数。</li>
<li>在所有的数据成员完成各自对齐之后，结构体或联合体本身也要进行对齐，整体⻓度是
<code>min(#pragma pack()制定的数，⻓度最⻓的数据成员的⻓度)</code>
的倍数。</li>
</ul>
<p>那么内存对齐的作用是什么呢？</p>
<ul>
<li>经过内存对齐之后，CPU 的内存访问速度大大提升。因为 CPU
把内存当成是一块一块的，块的大小可以是 2，4，8，16 个字节，因此 CPU
在读取内存的时候是一块一块进行读取的，块的大小称为内存读取粒度。⽐如说
CPU 要读取一个 4 个字节的数据到寄存器中（假设内存读取粒度是
4），如果数据是从 0 字节开始的，那么直接将 0-3
四个字节完全读取到寄存器中进行处理即可。</li>
<li>如果数据是从 1 字节开始的，就⾸先要将前 4
个字节读取到寄存器，并再次读取 4-7 个字节数据进入寄存 器，接着把 0
字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4
字节的数据进入寄存器，所以说，当内存没有对齐时，寄存器进行了很多额外的操作，大大降低了
CPU 的性能。</li>
<li>另外，还有一个就是，有的 CPU
遇到未进行内存对齐的处理直接拒绝处理，不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存对齐还有利于平台移植。</li>
</ul>
<h3
id="内存泄漏的定义如何检测与避免">内存泄漏的定义，如何检测与避免？</h3>
<p><strong>定义</strong>：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。
它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。</p>
<p><strong>如何检测内存泄漏</strong></p>
<ul>
<li>⾸先可以通过观察猜测是否可能发生内存泄漏，Linux 中使用 swap
命令观察还有多少可用的交换空间，在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。</li>
<li>还可以使用 其他一些 /usr/bin/stat 工具如 netstat、vmstat
等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。</li>
<li>当然也有用于内存调试，内存泄漏检测以及性能分析的软件开发工具
如linux的valgrind 、windows下CRT库这样的工具来进行内存泄漏的检测。</li>
</ul>
<h3
id="说一下平衡二叉树高度平衡二叉树avl">说一下平衡二叉树、高度平衡二叉树（AVL）</h3>
<p>⼆叉树：任何节点最多只允许有两个子节点，称为左子节点和右子节点，以递归的方式定义⼆叉树为，一个⼆叉树如果不为空，便是由一个根节点和左右两个子树构成，左右子树都可能为空。</p>
<p>⼆叉搜索树：⼆叉搜索树可以提供对数时间的元素插入和访问。节点的放置规则是：任何节点的键值一定大于其左子树的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此一直向左⾛可以取得最小值，一直向右⾛可以得到最大值。插入：从根节点开始，遇键值较大则向左，遇键值较小则向右，直到尾端，即插入点。删除：如果删除点只有一个子节点，则直接将其子节点连⾄父节点。如果删除点有两个子节点，以右子树中的最小值代替要删除的位置。</p>
<p>平衡⼆叉树：其实对于树的平衡与否没有一个绝对的标准，“平衡”的大致意思是：没有任何一个节点过深，不同的平衡条件会造就出不同的效率表现。以及不同的实现复杂度。有数种特殊结构例如
AVL-tree, RB-tree, AA-tree，均可以实现平衡⼆叉树。</p>
<p>AVL-tree ：高度平衡的平衡⼆叉树（严格的平衡⼆叉树）AVL-tree
是要求任何节点的左右子树高度相差最多为 1 的平衡⼆叉树。
当插入新的节点破坏平衡性的时候，从下往上找到第一个不平衡点，需要进行单旋转，或者双旋转进行调整。</p>
<h3 id="说一下红黑树rb-tree">说一下红黑树（RB-tree）</h3>
<p>红黑树的定义：</p>
<p>性质1：每个节点要么是黑色，要么是红色。</p>
<p>性质2：根节点是黑色。</p>
<p>性质3：每个叶子节点（NIL）是黑色。</p>
<p>性质4：每个红色结点的两个子结点一定都是黑色</p>
<p><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点</strong></p>
<h3 id="说一下-defineconsttypedefinline-使用方法">说一下
define、const、typedef、inline 使用方法？</h3>
<ol type="1">
<li>const 与 #define 的区别</li>
</ol>
<p><strong>类型检查</strong>：const 定义的常量是带类型的变量，而 #define
定义的只是一个不带类型的常数。这意味着 const
在编译时会进行类型检查，可以避免一些低级错误，而 #define
只是简单的字符串替换，没有类型检查。</p>
<p><strong>预处理和编译</strong>：#define
只在预处理阶段起作用，进行简单的文本替换，而 const
在编译、链接过程中起作用。</p>
<p><strong>内存占用</strong>：#define 预处理后，占用代码段空间，而 const
占用数据段空间。</p>
<p><strong>重定义</strong>：const 不能重定义，而 #define 可以通过 #undef
取消某个符号的定义，进行重定义。</p>
<p><strong>文件重复引用</strong>：#define
有独特的功能，比如可以用来防止文件重复引用。</p>
<p>总的来说，const 和 #define
都可以用来定义常量，但它们的工作方式和用途有所不同。</p>
<ol start="2" type="1">
<li>#define 和别名 typedef 的区别</li>
</ol>
<p><strong>执行时间不同</strong>，typedef 在编译阶段有效，typedef
有类型检查的功能；#define
是宏定义，发生在预处理阶段，不进行类型检查；</p>
<p><strong>功能差异</strong>：typedef
用来定义类型的别名，定义与平台无关的数据类型，与 struct
的结合使用等。#define
不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
<p><strong>作用域不同</strong>：#define
没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而
typedef 有自⼰的作用域。</p>
<ol start="3" type="1">
<li>define 与 inline 的区别</li>
</ol>
<p><strong>#define是关键字，inline是函数</strong>;</p>
<p>宏定义在预处理阶段进行文本替换，inline 函数在编译阶段进行替换；inline
函数有类型检查，相⽐宏定义⽐较安全；</p>
<h3
id="预处理编译汇编链接程序的区别">预处理，编译，汇编，链接程序的区别</h3>
<p>一段高级语⾔代码经过四个阶段的处理形成可执行的目标⼆进制代码:预处理器→编译器→汇编器→链接器</p>
<p>这⾥采用《深入理解计算机系统》的说法。</p>
<p><strong>预处理阶段</strong>：写好的高级语⾔的程序文本⽐如
hello.c，预处理器根据
#开头的命令，修改原始的程序，如#include&lt;stdio.h&gt;
将把系统中的头文件插入到程序文本中，通常是以 .i 结尾的文件。</p>
<p><strong>编译阶段</strong>：编译器将 hello.i 文件翻译成文本文件
hello.s，这个是汇编语⾔程序。高级语⾔是源程序。所以注意概念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的文本格式确切描述一条低级机器语⾔指令。不同的高级语⾔翻译的汇编语⾔相同。</p>
<p><strong>汇编阶段</strong>：汇编器将 hello.s
翻译成机器语⾔指令。把这些指令打包成可重定位目标程序，即
.o文件。hello.o是一个⼆进制文件，它的字节码是机器语⾔指令，不再是字符。前面两个阶段都还有字符。</p>
<p><strong>链接阶段</strong>：⽐如 hello 程序调用 printf 程序，它是每个
C 编译器都会提供的标准库 C 的函数。这个函数存在于一个名叫 printf.o
的单独编译好的目标文件中，这个文件将以某种方式合并到 hello.o
中。链接器就负责这种合并。得到的是可执行目标文件</p>
<p>fork</p>
<h3 id="说一下-forkwaitexec-函数">说一下 fork，wait，exec 函数</h3>
<p>父进程产生子进程使用 fork
拷贝出来一个父进程的副本，此时只拷贝了父进程的⻚表，两个进程都读同一块内存。</p>
<p>当有进程写的时候使用写实拷贝机制分配内存，exec 函数可以加载一个 elf
文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</p>
<p>fork 从父进程返回子进程的 pid，从子进程返回 0，调用了 wait
的父进程将会发生阻塞，直到有子进程状态改变，执行成功返回 0，错误返回
-1。exec 执行成功则子进程从新的程序开始运行，无返回值，执行失败返回
-1。</p>
<h3 id="动态编译与静态编译">动态编译与静态编译</h3>
<p><strong>静态编译</strong>，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p>
<p><strong>动态编译</strong>，可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；⼆是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行</p>
<h3 id="动态链接和静态链接区别">动态链接和静态链接区别</h3>
<p>静态连接库就是把 (lib)
文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从
DLL 中寻找相应函数代码，因此需要相应 DLL 文件的⽀持。</p>
<p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib
中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该
DLL 不必被包含在最终 EXE 文件中，EXE
文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。</p>
<p>静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p>
<p>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但如果有多处对
lib
文件中同一个函数的调用，那么执行时该函数将在当前程序的执行空间⾥留下多份拷贝，而且是一处调用就产生一份拷贝。</p>
<h3 id="动态联编与静态联编">动态联编与静态联编</h3>
<p>在 C++
中，联编是指一个计算机程序的不同部分彼此关联的过程。按照联编所进行的阶段不同，可以分为<strong>静态联编</strong>和<strong>动态联编</strong>；</p>
<p><strong>静态联编</strong>是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。</p>
<p><strong>动态联编</strong>是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。</p>
<p>C++中一般情况下的联编是<strong>静态联编</strong>，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p>
<p><strong>实现动态联编三个条件</strong>：</p>
<ol type="1">
<li>必须把动态联编的行为定义为类的虚函数；</li>
<li>类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来</li>
<li>必须先使用基类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数</li>
</ol>
<h3
id="怎么用c代码判断16位32位还是64位系统">怎么用C++代码判断16位、32位还是64位系统</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) == <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is a 16-bit system.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) == <span class="hljs-number">4</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is a 32-bit system.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) == <span class="hljs-number">8</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is a 64-bit system.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown architecture.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="admonition info">
<p class="admonition-title">
info
</p>
<p>
16位是2字节是因为16位下地址空间有2^16,一个地址要用16位表示，所以就是2字节。32位和64位同理。
</p>
</div>
<h2 id="类和数据抽象">类和数据抽象</h2>
<h3 id="类之间的关系">类之间的关系</h3>
<p>has-A 包含关系:⽤以描述⼀个类由多个部件类构成，实现 has-A
关系⽤类的成员属性表示，即⼀个类的成员属性是另⼀个已经定义好的类;</p>
<p>use-A，⼀个类使⽤另⼀个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p>
<p>is-A，继承关系，关系具有传递性.</p>
<h3 id="什么是类的继承">什么是类的继承？</h3>
<p>所谓的继承就是⼀个类继承了另⼀个类的属性和方法，这个新的类包含了上⼀个类的属性和方法，被称为子类或者派⽣类，被继承的类称为父类或者基类。</p>
<p><strong>继承的特点</strong>：子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使⽤；</p>
<p><strong>继承的兼容性原则</strong>：继承的兼容性原则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来代替。具体来说，继承的兼容性原则包括以下几点：</p>
<ul>
<li>子类对象可以当做父类对象使用。</li>
<li>子类对象可以直接赋值给父类对象。</li>
<li>子类对象可以直接初始化父类对象。</li>
<li>父类指针可以直接指向子类对象。</li>
<li>父类引用可以直接引用子类对象。</li>
</ul>
<h3 id="什么是组合">什么是组合</h3>
<p>⼀个类⾥面的数据成员是另⼀个类的对象，即内嵌其他类的对象作为⾃⼰的成员；创建组合类的对象：⾸先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进⾏初始化，⼜要对内嵌对象进⾏初始化。</p>
<p>创建组合类对象，构造函数的执⾏顺序：先调⽤内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表
顺序⽆关。然后执⾏组合类构造函数的函数体，析构函数调⽤顺序相反</p>
<h3 id="c中的虚函数表存储在哪里">C++中的虚函数表存储在哪里？</h3>
<p>存储在常量区，参考<a target="_blank" rel="noopener" href="https://qr.ae/pKx6bW"><strong>Where are
virtual tables stored in C++?</strong></a></p>
<h3
id="在main执行之前和之后执行的代码可能是什么">在main执行之前和之后执行的代码可能是什么？</h3>
<p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li>
<li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>
<li><code>__attribute__((constructor))</code></li>
</ul>
<p><strong>main函数执行之后</strong>：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main
之后执行;</li>
<li><code>__attribute__((destructor))</code></li>
</ul>
<h3 id="结构体内存对齐问题">结构体内存对齐问题？</h3>
<ul>
<li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li>
<li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li>
</ul>
<p>c++11以后引入两个关键字 <a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/alignas">alignas (opens
new window)</a>与 <a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/alignof">alignof (opens
new
window)</a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// alignas 生效的情况</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint16_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 6  2 + 2 + 2</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) Info2 &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint16_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 8  4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>
<div class="admonition note">
<p class="admonition-title">
为什么<code>sizeof(info2)</code>是8？
</p>
<p>
<code>alignas(4)</code> 指定了整个结构体的对齐方式为 4
字节。这意味着结构体的起始地址和大小都必须是 4
的倍数。由于结构体中的成员也需要按照特定的对齐方式排列，因此编译器会在成员之间添加填充字节。
</p>
</div>
<ul>
<li><code>uint8_t a;</code> 占用 1 字节。</li>
<li>在 <code>a</code> 和 <code>b</code> 之间添加 1 字节的填充，以确保
<code>b</code> 在 2 字节边界上对齐。</li>
<li><code>uint16_t b;</code> 占用 2 字节。</li>
<li><code>uint8_t c;</code> 占用 1 字节。</li>
<li>在 <code>c</code> 之后添加 3 字节的填充，以确保整个结构体的大小是 4
字节的倍数。</li>
</ul>
<pre><code class="hljs">这里声明了`alignas`之后每个成员变量之间仍然要考虑自然对齐，`uint16_t` 类型的变量自然对齐是 2 字节，这意味着它应该从一个 2 字节边界开始。所以`a`声明之后要有1字节的对齐而不是3字节的对齐。</code></pre>
<p>但是<code>alignas</code>在某些情况下是不能使用的，具体见下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// alignas 失效的情况</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 12  4 + 4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">2</span>) Info2 &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125;;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 12  4 + 4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>
<p>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</p>
<div class="admonition info">
<p class="admonition-title">
info
</p>
<p>
如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma
pack(push,1)</code>或者使用<code><strong>attribute</strong>((packed))</code>。
</p>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>&#125; ONEBYTE_ALIGN;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 6 1 + 4 + 1</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p>确定结构体中每个元素大小可以通过下面这种方法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 0 1   3     6   8 9            15</span><br><span class="hljs-comment">* +-+---+-----+---+-+-------------+</span><br><span class="hljs-comment">* | |   |     |   | |             |</span><br><span class="hljs-comment">* |a| b |  c  | d |e|     pad     |</span><br><span class="hljs-comment">* | |   |     |   | |             |</span><br><span class="hljs-comment">* +-+---+-----+---+-+-------------+</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">uint16_t</span> a : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">uint16_t</span> b : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint16_t</span> c : <span class="hljs-number">3</span>;<br>  <span class="hljs-type">uint16_t</span> d : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint16_t</span> e : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">uint16_t</span> pad : <span class="hljs-number">7</span>;<br>&#125; ONEBYTE_ALIGN;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 2</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p>这种处理方式是<code>alignas</code>处理不了的。</p>
<h3
id="在传递函数参数时什么时候该使用指针什么时候该使用引用呢">在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢
？</h3>
<ul>
<li>需要返回函数内局部变量的内存的时候用指针(注意该<strong>局部变量一定要是动态分配内存</strong>的，否则函数结束后该局部变量就会被销毁)。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h3 id="宏定义和typedef区别">宏定义和typedef区别？</h3>
<ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li>
<li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li>
<li>宏不检查类型；typedef会检查数据类型。</li>
<li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li>
<li>注意对<strong>指针的操作</strong>，typedef char * p_char和#define
p_char char *区别巨大。</li>
</ul>
<div class="admonition info">
<p class="admonition-title">
info
</p>
<p>
在使用 <code>typedef</code>
时，如果你声明了多个变量，它们都会被视为指针类型。例如：
</p>
<p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* p_char;<br>p_char a, b, c; <span class="hljs-comment">// a, b, c 都是 char 类型的指针</span><br></code></pre></td></tr></table></figure>
</p>
<p>
而使用 <code>#define</code>
时，只有第一个变量会被视为指针类型，其余的将被视为普通变量。例如：
</p>
<p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">define</span> p_char char*</span><br>p_char x, y, z; <span class="hljs-comment">// x 是 char 类型的指针，y 和 z 是 char 类型的变量</span><br></code></pre></td></tr></table></figure>
</p>
<p>
因此，typedef 更适合用于定义新类型，而 #define
可以用于定义值的别名，但在定义指针类型时可能会导致混淆。<strong>在现代C++中，建议尽可能避免使用宏（#define），而是使用
typedef 或 using 语句来定义类型别名。</strong>
</p>
</div>
<h3 id="strlen和sizeof区别">strlen和sizeof区别</h3>
<ul>
<li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li>
<li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。</li>
<li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;name&quot;</span>;<br><br>    <span class="hljs-built_in">sizeof</span>(str); <span class="hljs-comment">// 取的是指针str的长度，是8</span><br>    <span class="hljs-built_in">strlen</span>(str); <span class="hljs-comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="一个指针占多少字节">一个指针占多少字节？</h3>
<p>上面有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；</p>
<p>而在32位环境下，指针占用大小为4字节。</p>
<p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p>
<h3 id="a和a有什么区别">a和&amp;a有什么区别？</h3>
<p>假设数组<code>int a[10]; int (*p)[10] = &amp;a</code>;其中：</p>
<ul>
<li><code>a</code>是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果<code>a</code>的值是0x00000001，加1操作后变为0x00000005。<code>*(a + 1) = a[1]</code>。</li>
<li>&amp;a是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li>
<li>若<code>(int *)p</code> ，此时输出
<code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照<code>int</code>类型大小来读取。</li>
</ul>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
注意&amp;a的类型为<code>int (<em>)[10]</code>,<code>int
(</em>)[10]</code>和<code>int <em>[10]</code>是不一样的，<code>int
(</em>)[10]</code>表示一个指向<code>int</code>数组的指针，这个数组的长度为10，而<code>int
<em>[10]</code>表示一个<code>int </em></code>类型的数组，数组的长度是10.
</p>
</div>
<h3 id="c和python的区别">C++和Python的区别</h3>
<p>包括但不限于：</p>
<ul>
<li>Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>Python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>Python的库函数比C++的多，调用起来很方便</li>
</ul>
<h3
id="数组名和指针这里为指向数组首元素的指针区别">数组名和指针（这里为指向数组首元素的指针）区别？</h3>
<ul>
<li>二者均可通过增减偏移量来访问数组中的元素。</li>
<li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li>
<li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了</strong></li>
</ul>
<h3 id="拷贝初始化和直接初始化">拷贝初始化和直接初始化</h3>
<ul>
<li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;I am a string&quot;</span>)</span></span>;<span class="hljs-comment">//语句1 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(str1)</span></span>;<span class="hljs-comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br>string str3 = <span class="hljs-string">&quot;I am a string&quot;</span>;<span class="hljs-comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span><br>string str4 = str1;<span class="hljs-comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了</p>
<p>（语句1和语句3等价），但是需要辨别两种情况。</p>
<ul>
<li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul></li>
</ul>
<h3 id="初始化和赋值的区别">初始化和赋值的区别</h3>
<ul>
<li>对于简单类型来说，初始化和赋值没什么区别</li>
<li>对于类和复杂数据类型来说，这两者的区别就大了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">num1</span>(a),<span class="hljs-built_in">num2</span>(b)&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;;<br>    <span class="hljs-comment">//重载 = 号操作符函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        num1 = a.num1 + <span class="hljs-number">1</span>;<br>        num2 = a.num2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    A a1 = a; <span class="hljs-comment">//拷贝初始化操作，调用拷贝构造函数</span><br>    A b;<br>    b = a;<span class="hljs-comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="内联函数和宏定义的区别">内联函数和宏定义的区别</h3>
<ul>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行<strong>参数类型检查</strong>（编译时），且具有返回值。</li>
<li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数有<strong>类型检测、语法判断</strong>等功能，而宏没有</li>
</ul>
<p><strong>内联函数适用场景:</strong></p>
<ul>
<li>使用宏定义的地方都可以使用 inline 函数。</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。</li>
</ul>
<h3
id="publicprotected和private访问和继承权限publicprotectedprivate的区别">public，protected和private访问和继承权限/public/protected/private的区别？</h3>
<h4 id="访问权限">访问权限</h4>
<ul>
<li>public的变量和函数在类的内部外部都可以访问。</li>
<li>protected的变量和函数只能在类的内部和其派生类中访问。</li>
<li>private修饰的元素只能在类内访问。</li>
</ul>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212341241.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="继承权限">继承权限</h4>
<p>派生类继承自基类的成员权限有四种状态：public、protected、private、不可见，排序为
public &gt; protected &gt; private。</p>
<p>派生类对基类成员的访问权限取决于两点：</p>
<ul>
<li>继承方式；</li>
<li>基类成员在基类中的访问权限</li>
</ul>
<p>基类成员在派生类中的访问权限不得高于继承方式中指定的权限，高于继承方式中指定的权限则下降为继承权限，低于继承权限则不调整，<strong>基类
private 成员在任何继承方式下都是不可见的</strong>。例如：</p>
<ul>
<li>public 继承 + private 成员 =&gt; 不可见</li>
<li>public 继承 + protected 成员 =&gt; protected</li>
<li>protected 继承 + public 成员 =&gt; protected</li>
<li>private 继承 + protected 成员 =&gt; private</li>
<li>private 继承 + public 成员 =&gt; private</li>
</ul>
<h3 id="如何用代码判断大小端存储">如何用代码判断大小端存储？</h3>
<p><strong>大端存储</strong>：字数据的高字节存储在低地址中</p>
<p><strong>小端存储</strong>：字数据的低字节存储在低地址中</p>
<p>例如：32bit的数字0x12345678</p>
<p>小端模式中的存储方式为：</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071832785.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>大端模式中的存储方式为：</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071832707.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</p>
<h4
id="方法一使用强制类型转换">方法一：<strong>使用强制类型转换</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)(a);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;big endian&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;little endian&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4
id="方法二巧用union联合体">方法二：巧用<strong>union联合体</strong></h4>
<p><strong>什么是联合体</strong>？</p>
<p>C++中的联合体（<code>union</code>）是一种特殊的数据结构，允许在同一内存位置存储不同的数据类型。在联合体中，<strong>所有成员共享同一块内存空间，占用的大小取决于联合体中最大的成员。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义联合体</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> &#123;<br>    <span class="hljs-type">int</span> intValue;<br>    <span class="hljs-type">double</span> doubleValue;<br>    <span class="hljs-type">char</span> charValue;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在上述示例中，<code>MyUnion</code>联合体有三个成员：<code>intValue</code>（整数）、<code>doubleValue</code>（双精度浮点数）和<code>charValue</code>（字符）。这三个成员共享相同的内存空间，因此对一个成员的修改会影响到其他成员。</p>
<p>需要注意的是，联合体在某一时刻只能存储其中的一个成员的值。在上面的示例中，赋值给<code>intValue</code>后，<code>doubleValue</code>和<code>charValue</code>的值将变得不确定，因为它们共享相同的内存位置。</p>
<p>联合体常用于需要在不同数据类型之间进行快速切换的情况，但在使用时需要格外小心，确保正确地理解和处理数据的类型。</p>
<p><strong>使用union联合体判断大小端</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">endian</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> ch;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    endian value;<br>    value.a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//a和ch共用4字节的内存空间</span><br>    <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;big endian&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;little endian&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3
id="volatilemutable和explicit关键字的用法">volatile、mutable和explicit关键字的用法</h3>
<h4 id="volatile">volatile</h4>
<p>volatile
关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>volatile 指针和 const 修饰词类似，const
有常量指针和指针常量的说法，volatile
也有相应的概念,修饰由指针指向的对象、数据是 const 或 volatile 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpch;<span class="hljs-keyword">volatile</span> <span class="hljs-type">char</span>* vpch;<br></code></pre></td></tr></table></figure>
<p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* <span class="hljs-type">const</span> pchc;<span class="hljs-type">char</span>* <span class="hljs-keyword">volatile</span> pchv;<br></code></pre></td></tr></table></figure>
<p>!!! attention - 可以把一个非volatile int赋给volatile
int，但是不能把非volatile对象赋给一个volatile对象。 -
除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。 -
C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集,只能调用那些被类的实现者明确允许在<code>volatile</code>对象上调用的成员函数。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</p>
<p><strong>多线程下的volatile</strong>：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</strong></p>
<h4 id="mutable">mutable</h4>
<p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// example1.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量 在常函数里值也可以被修改</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-comment">//在函数里不可修改this指针指向的值 常量指针</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_A = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误  不可修改值，this已经被修饰为常量指针</span><br>        m_B = <span class="hljs-number">20</span>;<span class="hljs-comment">//正确</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// example2.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量 在常函数里值也可以被修改</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> person p = <span class="hljs-built_in">person</span>();<span class="hljs-comment">//修饰常对象 不可修改类成员的值</span><br>    p.m_A = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误，被修饰了指针常量</span><br>    p.m_B = <span class="hljs-number">200</span>;<span class="hljs-comment">//正确，特殊变量，修饰了mutable</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="explicit"><strong>explicit</strong></h4>
<p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显式的方式进行类型转换</strong>，注意以下几点：</p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上</li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
<h3 id="什么情况下会调用拷贝构造函数">什么情况下会调用拷贝构造函数</h3>
<ul>
<li>用类的一个实例化对象去初始化另一个对象的时候（注意初始化和赋值的区别）</li>
<li>函数的参数是类的对象时（非引用传递）</li>
<li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named
return
Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li>
</ul>
<p><strong>第三种情况在Linux g++
下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p>
<p><strong>总结就是：即使发生NRV优化的情况下，Linux+
g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows
+
VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>() &#123;&#125;;<br>	<span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;copy constructor is called&quot;</span> &lt;&lt; endl;<br>	&#125;;<br>	~<span class="hljs-built_in">A</span>() &#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useClassA</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function">A <span class="hljs-title">getClassA</span><span class="hljs-params">()</span><span class="hljs-comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span><br><span class="hljs-function"></span>&#123;<br>	A a;<br>	<span class="hljs-keyword">return</span> a;<br>&#125;<br><br><br><span class="hljs-comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//	A a;</span><br><span class="hljs-comment">//	return a;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	A a1,a3,a4;<br>	A a2 = a1;  <span class="hljs-comment">//调用拷贝构造函数,对应情况1</span><br>	<span class="hljs-built_in">useClassA</span>(a1);<span class="hljs-comment">//调用拷贝构造函数，对应情况2</span><br>	a3 = <span class="hljs-built_in">getClassA</span>();<span class="hljs-comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span><br>	a4 = <span class="hljs-built_in">getClassA2</span>(a1);<span class="hljs-comment">//发生NRV优化，且引用返回自身，不会调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="c中有几种类型的new">C++中有几种类型的new</h3>
<p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement
new.</p>
<h4 id="plain-new"><strong>plain new</strong></h4>
<p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>因此<strong>plain
new</strong>在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">try</span><br>	&#123;<br>		<span class="hljs-type">char</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10e11</span>];<br>		<span class="hljs-keyword">delete</span> p;<br>	&#125;<br>	<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc &amp;ex)<br>	&#123;<br>		cout &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//执行结果：bad allocation</span><br></code></pre></td></tr></table></figure>
<h4 id="nothrow-new"><strong>nothrow new</strong></h4>
<p>nothrow
new在<strong>空间分配失败的情况下是不抛出异常，而是返回NULL</strong>，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> *p = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">char</span>[<span class="hljs-number">10e11</span>];<br>	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;alloc failed&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">delete</span> p;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：alloc failed</span><br></code></pre></td></tr></table></figure>
<h4 id="placement-new"><strong>placement new</strong></h4>
<p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement
new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">void</span>*)</span></span>;<br></code></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ADT</span>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">int</span> j;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">ADT</span>()&#123;<br>		i = <span class="hljs-number">10</span>;<br>		j = <span class="hljs-number">100</span>;<br>		cout &lt;&lt; <span class="hljs-string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j &lt;&lt;endl;<br>	&#125;<br>	~<span class="hljs-built_in">ADT</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;ADT destruct&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> *p = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">char</span>[<span class="hljs-keyword">sizeof</span> ADT + <span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;alloc failed&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	ADT *q = <span class="hljs-built_in">new</span>(p) ADT;  <span class="hljs-comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span><br>	<span class="hljs-comment">//delete q;//错误!不能在此处调用delete q;</span><br>	q-&gt;ADT::~<span class="hljs-built_in">ADT</span>();<span class="hljs-comment">//显示调用析构函数</span><br>	<span class="hljs-keyword">delete</span>[] p;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//ADT construct i=10j=100</span><br><span class="hljs-comment">//ADT destruct</span><br></code></pre></td></tr></table></figure>
<h3 id="c的异常处理的方法">C++的异常处理的方法</h3>
<p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<ul>
<li>数组下标越界</li>
<li>除法计算时除数为0</li>
<li>动态分配空间时空间不足</li>
<li>···</li>
</ul>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<h4
id="trythrow和catch关键字"><strong>try、throw和catch关键字</strong></h4>
<p>C++中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，其在程序中的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> m = <span class="hljs-number">1</span>, n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;before dividing.&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">//抛出int型异常</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> - <span class="hljs-number">1.0</span>;  <span class="hljs-comment">//拋出 double 型异常</span><br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; m / n &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;after dividing.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">double</span> d) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;catch (...)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;finished&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-comment">//before dividing.</span><br><span class="hljs-comment">//catch (...)</span><br><span class="hljs-comment">//finished</span><br></code></pre></td></tr></table></figure>
<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。</strong>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<h4 id="函数的异常声明列表"><strong>函数的异常声明列表</strong></h4>
<p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,A,B,C)</span></span>&#123;...&#125;;<br></code></pre></td></tr></table></figure>
<p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<h4 id="c标准异常类-exception"><strong>C++标准异常类
exception</strong></h4>
<p>C++ 标准库中有一些类代表异常，这些类都是从 exception
类派生而来的，如下图所示</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205212342667.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为
NULL，则会拋出此异常，</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>();<br>&#125;;<br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	A* a = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">try</span> &#123;<br>  		cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*a).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">// Error condition</span><br>  	&#125;<br>	<span class="hljs-built_in">catch</span> (bad_typeid)&#123;<br>  		cout &lt;&lt; <span class="hljs-string">&quot;Object is NULL&quot;</span> &lt;&lt; endl;<br>  	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：bject is NULL</span><br></code></pre></td></tr></table></figure></p></li>
<li><p>bad_cast：在用 dynamic_cast
进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</p></li>
<li><p>bad_alloc：在用 new
运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</p></li>
<li><p>out_of_range:用 vector 或 string的at
成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</p></li>
</ul>
<h3 id="delete-pdelete-pallocator都有什么作用">delete p、delete []
p、allocator都有什么作用？</h3>
<ol type="1">
<li><p>动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p></li>
<li><p>new动态数组返回的并不是数组类型，而是一个元素类型的指针；</p></li>
<li><p>delete[]时，数组中的元素按逆序的顺序进行销毁；</p></li>
<li><p>new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p></li>
</ol>
<h3
id="new和delete的实现原理-delete是如何知道释放内存的大小的">new和delete的实现原理，
delete是如何知道释放内存的大小的？</h3>
<p>在分配内存的时候，编译器已经在内存块的前面存储了这些信息。</p>
<h3
id="malloc申请的存储空间能用delete释放吗">malloc申请的存储空间能用delete释放吗?</h3>
<p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc
/free的。</p>
<p>malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。</p>
<p>new
和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。</p>
<p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p>
<h3 id="malloc与free的实现原理">malloc与free的实现原理？</h3>
<ol type="1">
<li><p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由<strong>brk、mmap、，munmap</strong>这些<strong>系统调用</strong>实现的;</p></li>
<li><p>brk是将「堆顶」指针向高地址移动，获得新的内存空间,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p></li>
<li><p>malloc<strong>小于128k的内存，使用brk分配内存</strong>，将「堆顶」指针往高地址推；malloc<strong>大于128k的内存，使用mmap分配内存</strong>，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p></li>
<li><p>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p></li>
</ol>
<h3 id="mallocrealloccalloc的区别">malloc、realloc、calloc的区别</h3>
<ol type="1">
<li><p>malloc函数</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_size)</span></span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));申请<span class="hljs-number">20</span>个<span class="hljs-type">int</span>类型的空间；<br></code></pre></td></tr></table></figure></p></li>
<li><p>calloc函数</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n,<span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure></p>
<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p></li>
<li><p>realloc函数</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">size_t</span> new_size)</span></span>;<br></code></pre></td></tr></table></figure></p>
<p>给动态分配的空间分配额外的空间，用于扩充容量。</p></li>
</ol>
<h3
id="类成员初始化方式构造函数的执行顺序-为什么用成员初始化列表会快一些">类成员初始化方式？构造函数的执行顺序
？为什么用成员初始化列表会快一些？</h3>
<ol type="1">
<li>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。</li>
</ol>
<p>这两种方式的主要区别在于：</p>
<p>函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p>
<p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p>
<ol start="2" type="1">
<li>一个派生类构造函数的执行顺序如下：</li>
</ol>
<p>①
虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p>
<p>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p>
<p>③ 类类型的成员对象的构造函数（按照成员对象在类中的定义顺序）</p>
<p>④ 派生类自己的构造函数。</p>
<ol start="3" type="1">
<li>方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</li>
</ol>
<h3
id="有哪些情况必须用到成员列表初始化作用是什么">有哪些情况必须用到成员列表初始化？作用是什么？</h3>
<p>必须使用成员初始化的四种情况:</p>
<ol type="1">
<li><p>当初始化一个引用成员时；</p></li>
<li><p>当初始化一个常量成员时；</p></li>
<li><p>当调用一个基类的构造函数，而它拥有一组参数时；</p></li>
<li><p>当调用一个成员类的构造函数，而它拥有一组参数时；</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
成员初始化列表做了什么?编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；<strong>初始化列表中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的</strong>；
</p>
</div>
<h3
id="c中新增了string它与c语言中的-char-有什么区别吗它是如何实现的">C++中新增了string，它与C语言中的
char *有什么区别吗？它是如何实现的？</h3>
<p>string继承自basic_string,其实是对char<em>进行了封装，封装的string包含了char</em>数组，容量，长度等等属性。</p>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h3 id="对象复用的了解零拷贝的了解">对象复用的了解，零拷贝的了解</h3>
<h4 id="对象复用"><strong>对象复用</strong></h4>
<p>对象复用其本质是一种设计模式：Flyweight享元模式。</p>
<p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
<h4 id="零拷贝"><strong>零拷贝</strong></h4>
<p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数<strong>emplace_back()</strong>很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：<strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造（原地构造指的是直接在容器的末尾添加一个元素，不用创建临时元素），不需要触发拷贝构造和转移构造</strong>，效率更高。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//初始构造函数</span><br>    <span class="hljs-built_in">Person</span>(string p_name, <span class="hljs-type">int</span> p_age): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(p_name)), <span class="hljs-built_in">age</span>(p_age)<br>    &#123;<br>         cout &lt;&lt; <span class="hljs-string">&quot;I have been constructed&quot;</span> &lt;&lt;endl;<br>    &#125;<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    &#123;<br>         cout &lt;&lt; <span class="hljs-string">&quot;I have been copy constructed&quot;</span> &lt;&lt;endl;<br>    &#125;<br>     <span class="hljs-comment">//转移构造函数</span><br>     <span class="hljs-built_in">Person</span>(Person&amp;&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    &#123;<br>         cout &lt;&lt; <span class="hljs-string">&quot;I have been moved&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Person&gt; e;<br>    cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:&quot;</span> &lt;&lt;endl;<br>    e.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">//不用构造类对象</span><br><br>    vector&lt;Person&gt; p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;push_back:&quot;</span>&lt;&lt;endl;<br>    p.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Mike&quot;</span>,<span class="hljs-number">36</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//emplace_back:</span><br><span class="hljs-comment">//I have been constructed</span><br><span class="hljs-comment">//push_back:</span><br><span class="hljs-comment">//I have been constructed</span><br><span class="hljs-comment">//I am being moved.</span><br></code></pre></td></tr></table></figure>
<h3
id="成员初始化列表的概念为什么用它会快一些">成员初始化列表的概念，为什么用它会快一些？</h3>
<h4 id="成员初始化列表的概念">成员初始化列表的概念</h4>
<p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值</p>
<h4 id="效率">效率</h4>
<p>用初始化列表会快一些的原因是，<strong>对于自定义类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。</strong>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造函数A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)<br>    &#123;<br>        value = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span>&lt;&lt;value&lt;&lt;<span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>    &#123;<br>        value = a.value;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数A(A&amp; a):  &quot;</span>&lt;&lt;value &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        b = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    A a;<br>    A b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>&#125;<br><br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//默认构造函数A()</span><br><span class="hljs-comment">//A(int 2)</span><br><span class="hljs-comment">//拷贝构造函数A(A&amp; a): 2</span><br><br><br><span class="hljs-comment">// 注：</span><br><span class="hljs-comment">// 在B的构造函数中，先初始化了B类的成员变量a（使用A类的默认构造函数），然后初始化了成员变量b，通过调用A类的带有int参数的构造函数（A(2)）。</span><br><span class="hljs-comment">// A类的带有int参数的构造函数被调用，输出&quot;A(int 2)&quot;。</span><br><span class="hljs-comment">// 接着，A类的拷贝构造函数被调用，因为在B类的构造函数中，要将A类对象b初始化为A类对象（A(2)），这会触发拷贝构造函数。拷贝构造函数输出&quot;拷贝构造函数A(A&amp; a): 2&quot;。</span><br></code></pre></td></tr></table></figure>
<p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p>
<h3 id="c函数调用的压栈过程">C++函数调用的压栈过程</h3>
<ol type="1">
<li>当前函数运行状态压栈</li>
<li>被调用函数的返回地址压栈</li>
<li>被调用函数的参数（从右到左压栈）</li>
<li>被调用函数的变量压栈</li>
</ol>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return
的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; n &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> param1, <span class="hljs-type">int</span> param2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> var1 = param1;<br>	<span class="hljs-type">int</span> var2 = param2;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var1=%d,var2=%d&quot;</span>, <span class="hljs-built_in">f</span>(var1), <span class="hljs-built_in">f</span>(var2));<span class="hljs-comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//var1=1,var2=2</span><br></code></pre></td></tr></table></figure>
<p>当函数从入口函数main函数开始执行时，编译器会将我们<strong>操作系统的运行状态</strong>，<strong>main函数的返回地址</strong>、<strong>main的参数</strong>、<strong>mian函数中的变量、进行依次压栈</strong>；</p>
<p>当main函数开始调用func()函数时，编译器此时会将<strong>main函数的运行状态进行压栈</strong>，<strong>再将func()函数的返回地址</strong>、<strong>func()函数的参数从右到左</strong>、<strong>func()定义变量依次压栈</strong>；</p>
<p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p>
<h3
id="写c代码时有一类错误是-coredump-很常见你遇到过吗怎么调试这个错误">写C++代码时有一类错误是
coredump ，很常见，你遇到过吗？怎么调试这个错误？</h3>
<p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<h4 id="调试">调试</h4>
<p><strong>使用gdb命令对core文件进行调试</strong>：</p>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir coredumpTest<br>vim coredumpTest.cpp<br></code></pre></td></tr></table></figure>
<p>在编辑器内键入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<span class="hljs-comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ coredumpTest.cpp -g -o coredumpTest<br></code></pre></td></tr></table></figure>
<p>运行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./coredumpTest<br></code></pre></td></tr></table></figure>
<p>使用gdb调试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gdb [可执行文件名] [core文件名]<br></code></pre></td></tr></table></figure>
<h3 id="gdb怎么调试怎么打断点">gdb怎么调试怎么打断点</h3>
<p>gdb调试见上一条</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ Test.cpp -g -o Test # 注意编译的时候要加上-g选项<br><br>gdb ./Test<br><br>break main:10 # 在main的第10行添加断点，也可以用缩写b<br><br>run<br></code></pre></td></tr></table></figure>
<h3
id="gdb怎么查看一个很多元素数组的后部分内容">gdb怎么查看一个很多元素数组的后部分内容？</h3>
<p>假设有一个数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>编译并调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ Test.cpp -g -o Test # 注意编译的时候要加上-g选项<br><br>gdb ./Test<br><br>break main:10 # 在合适的地方打上断点<br><br>run # 运行到合适的位置之后可以开始查看数组的元素了<br><br>x/5dw &amp;arr[5] # <br></code></pre></td></tr></table></figure>
<p><code>x/5dw</code> 命令的含义是查看从
<code>&amp;arr[5]</code>（数组的第6个元素）开始的5个整数（<code>d</code>
表示以十进制显示，<code>w</code>
表示以4字节为单位显示，可以根据实际情况调整）。</p>
<p>注意：<code>&amp;arr[5]</code>
是数组的第6个元素的地址，可以根据实际情况选择数组中的任何一个元素。</p>
<h3 id="说说移动构造函数">说说移动构造函数</h3>
<ol type="1">
<li><p>如果我们用对象a初始化对象b，构造出对象b之后对象a我们就不再使用了，但是对象a的空间在析构之前还在，既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p></li>
<li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p>
<p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p></li>
<li><p>移动构造函数的参数和拷贝构造函数不同，<strong>拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</strong>意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p></li>
</ol>
<h3
id="c中将临时变量局部变量作为返回值时的处理过程">C++中将临时变量（局部变量）作为返回值时的处理过程</h3>
<p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p>C语言里规定：<strong>16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</strong></p>
<p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p>
<p>如果我们需要返回值，一般使用赋值语句就可以了。</p>
<h3
id="如何获得结构成员相对于结构开头的字节偏移量">如何获得结构成员相对于结构开头的字节偏移量</h3>
<p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">S</span><br>&#123;<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">char</span> y;<br>	<span class="hljs-type">int</span> z;<br>	<span class="hljs-type">double</span> a;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Visual Studio 2019 + Win10 下的输出情况如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span><br></code></pre></td></tr></table></figure>
<p>当然了，如果加上 #pragma pack(4) 指定4字节对齐方式就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">S</span><br>&#123;<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">char</span> y;<br>	<span class="hljs-type">int</span> z;<br>	<span class="hljs-type">double</span> a;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>S结构体中各个数据成员的内存空间划分如下所示，需要注意内存对齐</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035079.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3
id="全局变量和局部变量有什么区别">全局变量和局部变量有什么区别？</h3>
<p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面
。</p>
<h3 id="指针加减计算要注意什么">指针加减计算要注意什么？</h3>
<p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> *a, *b, c;<br>	a = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x500</span>;<br>	b = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x520</span>;<br>	c = b - a;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c); <span class="hljs-comment">// 8</span><br>	a += <span class="hljs-number">0x020</span>;<br>	c = b - a;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c); <span class="hljs-comment">// -24</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16^2=1280）和1312（5</em>16^2+2*16=1312)，
那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 =
1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280
= -96，所以c的值就变成了-96/4 = -24</p>
<p>遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</strong></p>
<h3 id="怎样判断两个浮点数是否相等">怎样判断两个浮点数是否相等？</h3>
<p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p>
<h3
id="类如何实现只能静态分配和只能动态分配">类如何实现只能静态分配和只能动态分配</h3>
<p><strong>只能静态分配</strong>：把<code>new</code>、<code>delete</code>运算符重载为private属性</p>
<p><strong>只能动态分配</strong>：把构造函数、析构函数设为protect属性，再用子类动态创建</p>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
建立类的对象有两种方式：<strong>静态建立</strong>，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；<strong>动态建立</strong>，<code>A
*p = new
A()</code>;动态建立一个类对象，就是使用<code>new</code>运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行<code>operator
new()</code>函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象。只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。
</p>
</div>
<p>### 如果想将某个类用作基类，为什么该类必须定义而非声明？</p>
<p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。所以必须定义而非声明。</p>
<h3
id="继承机制中对象之间如何转换指针和引用之间如何转换">继承机制中对象之间如何转换？指针和引用之间如何转换？</h3>
<p><strong>向上类型转换</strong>：将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是<strong>安全</strong>的。</p>
<p><strong>向下类型转换</strong>：将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用<strong>dynamic_cast</strong>进行向下类型转换。</p>
<h3
id="知道c中的组合吗它与继承相比有什么优缺点吗">知道C++中的组合吗？它与继承相比有什么优缺点吗？</h3>
<h4 id="继承">继承</h4>
<p>继承是Is a 的关系，比如说Student继承Person,则说明Student is a
Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p>
<p>继承的缺点有以下几点：</p>
<p>①：父类的内部细节对子类是可见的。</p>
<p>②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p>
<p>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</p>
<h4 id="组合">组合</h4>
<p>组合是一种对象关系，它表示<strong>一个对象包含另一个对象作为其部分</strong>。</p>
<p>组合的<strong>优点</strong>：</p>
<ol type="1">
<li><p>当前对象只能通过所包含的那个对象去调用其方法，所以被包含的对象的内部细节对当前对象时不可见的。</p></li>
<li><p>当前对象与包含的对象是一个低耦合关系，如果修改被包含对象的类中代码不需要修改当前对象类的代码。</p></li>
<li><p>当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</p></li>
</ol>
<p>组合的<strong>缺点</strong>：</p>
<ol type="1">
<li>容易产生过多的对象.</li>
<li>为了能组合多个对象，必须仔细对接口进行定义。</li>
</ol>
<h3 id="函数指针">函数指针</h3>
<h4 id="什么是函数指针"><strong>什么是函数指针?</strong></h4>
<p>函数指针指向的是特殊类型的指针，用于存储函数的地址，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<h4 id="函数指针的声明方法"><strong>函数指针的声明方法</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*pf)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;);<br></code></pre></td></tr></table></figure>
<p>上面的pf就是一个函数指针，指向函数的返回类型为int，并带有两个const
int&amp;参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<br></code></pre></td></tr></table></figure>
<p>声明了一个函数，函数的返回值是<code>int *</code>,参数是<code>const int&amp;</code>和<code>const int&amp;</code>。</p>
<h4 id="为什么有函数指针"><strong>为什么有函数指针</strong></h4>
<ol type="1">
<li><strong>抽象和封装</strong>：函数指针可以使得函数的具体实现被抽象和封装，使得代码更加模块化。通过函数指针，我们可以将函数作为参数传递给其他函数，或者将函数作为结构体或类的成员。</li>
<li><strong>回调函数</strong>：函数指针是实现回调函数的一种常见方式。回调函数是在某个特定事件或条件发生时被调用的函数。通过函数指针，我们可以动态地指定需要在特定事件发生时执行的函数，增加了程序的灵活性和可扩展性。</li>
<li><strong>动态函数调用</strong>：<strong>函数指针的值可以在运行时进行更改，从而实现动态函数调用。</strong>这可以用于实现多态和类似接口的概念，使得程序可以根据运行时的上下文，选择合适的函数进行调用。</li>
<li><strong>运行时多态</strong>：函数指针可以实现运行时多态。这种数据成为专门的数据类型时就是函数指针。</li>
</ol>
<h4
id="一个函数名就是一个指针它指向函数的代码"><strong>一个函数名就是一个指针，它指向函数的代码</strong></h4>
<p>一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p>
<h4 id="两种方法赋值"><strong>两种方法赋值</strong></h4>
<p>指针名 = 函数名； 指针名 = &amp;函数名</p>
<h3
id="说一说你理解的内存对齐以及原因">说一说你理解的内存对齐以及原因</h3>
<p>在C++中，内存对齐是<strong>将变量的起始地址调整为其自身大小或者某个值的倍数</strong>，这个值称为“对齐系数”。</p>
<p>内存对齐的原因主要有以下几点：</p>
<ol type="1">
<li><strong>提高程序性能</strong>：大部分处理器并不是按字节块来存取内存的，而是以双字节、四字节、8字节、16字节甚至32字节为单位来存取内存。如果没有内存对齐机制，数据可以任意存放，处理器在取数据时可能需要做很多额外的操作，而有了内存对齐的机制后，处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，从而提高了效率。</li>
<li><strong>平台移植</strong>：不同的硬件平台对内存对齐的要求可能不同，内存对齐可以帮助代码在不同的平台上运行。</li>
<li><strong>SIMD优化</strong>：SIMD（Single Instruction Multiple
Data）技术要求数据在内存中是对齐的，内存对齐可以帮助实现这种优化。</li>
</ol>
<h3
id="你知道printf函数的实现原理是什么吗">你知道printf函数的实现原理是什么吗？</h3>
<p>在C/C++中，对函数参数的扫描是<strong>从右向左</strong>的。</p>
<p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码</p>
<h3
id="为什么模板类一般都是放在一个h文件中">为什么模板类一般都是放在一个h文件中</h3>
<p>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于链接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</p>
<p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待链接器能够将符号的地址决议出来。</p>
<p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是链接器也黔驴技穷了。</p>
<h3 id="cout和printf有什么区别">cout和printf有什么区别？</h3>
<p>很多人认为cout&lt;&lt;是一个函数，其实不是的，它是类<code>std::ostream</code>的<strong>全局对象</strong>。</p>
<p>cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p>
<p>输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout是<strong>有缓冲输出</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt; &lt; <span class="hljs-string">&quot;abc &quot;</span> &lt; &lt;endl;  	<span class="hljs-comment">// 这行代码会输出字符串 &quot;abc &quot;，然后输出一个换行符，并且立即刷新输出缓冲区。这意味着，一旦执行这行代码，字符串 &quot;abc &quot; 就会立即显示在屏幕上。</span><br><br><span class="hljs-comment">// 等价于</span><br>cout &lt; &lt; <span class="hljs-string">&quot;abc\n &quot;</span>; 	<span class="hljs-comment">// 也会输出字符串 &quot;abc &quot;，然后输出一个换行符，但是它不会立即刷新输出缓冲区。这意味着，如果输出缓冲区没有满，字符串 &quot;abc &quot; 可能不会立即显示在屏幕上,所以加上fulsh才和上面等价</span><br>cout &lt; &lt;flush; 	<br><br></code></pre></td></tr></table></figure>
<p>flush立即强迫缓冲输出。</p>
<p>printf是行缓冲输出，不是无缓冲输出</p>
<h3 id="你知道重载运算符吗">你知道重载运算符吗？</h3>
<ol type="1">
<li>只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li>
<li>两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数，因为成员成员运算符有一个隐藏的参数就是对象本身；</li>
<li>引入运算符重载，是为了实现类的多态性；</li>
<li>当重载的运算符是成员函数时，this绑定到左侧运算符对象；</li>
<li>当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）时，从参数的个数推断到底定义的是哪种运算符；</li>
<li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li>
<li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li>
</ol>
<h3
id="当程序中有函数重载时函数的匹配原则和顺序是什么">当程序中有函数重载时，函数的匹配原则和顺序是什么？</h3>
<ol type="1">
<li>名字查找</li>
<li>确定候选函数</li>
<li>寻找最佳匹配</li>
</ol>
<h3 id="如何消除隐式转换">如何消除隐式转换？</h3>
<p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<h3 id="c如何处理多个异常">C++如何处理多个异常</h3>
<p>在C++中，你可以使用try-catch语句块来处理多个异常。当你的代码可能会抛出多种类型的异常时，你可以在try-catch语句块中列出多个catch语句，每个catch语句用于捕获一种特定类型的异常。</p>
<h3 id="定义和声明的区别">定义和声明的区别</h3>
<p>从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
<h3
id="如何在不使用额外空间的情况下交换两个数你有几种方法">如何在不使用额外空间的情况下，交换两个数？你有几种方法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span>)  算术<br><br>x = x + y;<br>y = x - y;<br>x = x - y; <br><br><span class="hljs-number">2</span>)  异或<br>x = x^y;<span class="hljs-comment">// 只能对int,char..</span><br>y = x^y;<br>x = x^y;<br></code></pre></td></tr></table></figure>
<h3 id="strcpy和memcpy的区别">strcpy和memcpy的区别</h3>
<ol type="1">
<li>strcpy只能复制字符串，而memcpy可以复制任意内容</li>
<li>strcpy不需要指定长度，它复制到‘\0’自动结束，而memcpy需要指定第三个参数来确定复制的长度</li>
</ol>
<h3
id="程序在执行int-mainint-argc-char-argv时的内存结构你了解吗">程序在执行int
main(int argc, char *argv[])时的内存结构，你了解吗？</h3>
<p>参数的含义是程序在命令行下运行的时候，需要<strong>输入argc
个参数</strong>，<strong>每个参数是以char
类型输入的，依次存在数组里面，数组是
argv[]</strong>，所有的参数在指针</p>
<p>char * 指向的内存中，数组的中元素的个数为 argc
个，<strong>第一个参数为程序的名称</strong>。</p>
<h3
id="strcpy函数和strncpy函数的区别哪个函数更安全">strcpy函数和strncpy函数的区别？哪个函数更安全？</h3>
<p>他们都是C语言中的字符串复制函数，但是他们之间存在一些重要的区别。</p>
<ol type="1">
<li>strcpy函数：
<ul>
<li><strong>作用：</strong> 用于将一个字符串复制到另一个字符串。</li>
<li><strong>参数：</strong>
<code>strcpy(destination, source)</code>，其中<code>destination</code>是目标字符串，<code>source</code>是要复制的源字符串。</li>
<li><strong>特点：</strong>
复制源字符串的所有字符直到遇到空字符('\0')。</li>
<li><strong>安全性：</strong>
如果源字符串比目标字符串长，可能会导致缓冲区溢出，因此需要确保目标字符串足够大。</li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> destination[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> source[] = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">strcpy</span>(destination, source);<br></code></pre></td></tr></table></figure>
<ol type="1">
<li>strncpy函数：
<ul>
<li><strong>作用：</strong>
用于将一个字符串的指定数量的字符复制到另一个字符串。</li>
<li><strong>参数：</strong>
<code>strncpy(destination, source, n)</code>，其中<code>destination</code>是目标字符串，<code>source</code>是要复制的源字符串，<code>n</code>是要复制的字符数。</li>
<li><strong>特点：</strong>
复制源字符串的前<code>n</code>个字符，如果源字符串长度小于<code>n</code>，则用空字符填充剩余的空间。</li>
<li><strong>安全性：</strong>
相对于<code>strcpy</code>更安全，因为可以限制复制的字符数，防止缓冲区溢出。</li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> destination[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> source[] = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">strncpy</span>(destination, source, <span class="hljs-built_in">sizeof</span>(destination) - <span class="hljs-number">1</span>);<br>destination[<span class="hljs-built_in">sizeof</span>(destination) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 确保目标字符串以空字符结尾</span><br></code></pre></td></tr></table></figure>
<p><strong>安全性比较：</strong></p>
<ul>
<li>在处理已知长度的字符串时，<code>strncpy</code>
更安全，因为它允许明确指定要复制的字符数，避免了缓冲区溢出。</li>
<li>但需要注意，<code>strncpy</code>
有一个缺点，即当源字符串长度大于或等于<code>n</code>时，目标字符串可能不以空字符结尾，因此需要手动添加空字符。</li>
</ul>
<h3
id="static_cast比c语言中的转换强在哪里">static_cast比C语言中的转换强在哪里？</h3>
<ol type="1">
<li>更加安全；</li>
<li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图</li>
</ol>
<h3
id="成员函数里memsetthis0sizeofthis会发生什么">成员函数里memset(this,0,sizeof(*this))会发生什么</h3>
<ol type="1">
<li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this,
0, sizeof
*this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</li>
<li>类含有虚函数表：这么做会<strong>破坏虚函数表</strong>，后续对虚函数的调用都将出现异常；</li>
<li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存</li>
</ol>
<h3 id="你知道回调函数吗它的作用">你知道回调函数吗？它的作用？</h3>
<ol type="1">
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1<strong>，声明；2，定义；3，设置触发条件</strong>，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ol>
<h3
id="为什么友元函数必须在类内部声明">为什么友元函数必须在类内部声明？</h3>
<p>友元函数必须要在类内部声明，表明这是在类内的的授权，但是在正式使用友元函数之前，还需要在类外部或者其他头文件中进行一次正式的函数定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">double</span> x, y; <span class="hljs-comment">//点的坐标</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y) &#123; <span class="hljs-comment">//构造函数</span><br>            <span class="hljs-keyword">this</span>-&gt;x = x;<br>            <span class="hljs-keyword">this</span>-&gt;y = y;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(Point &amp;p1, Point &amp;p2)</span></span>; <span class="hljs-comment">//友元函数声明</span><br>&#125;;<br><br><span class="hljs-comment">//友元函数类外声明，可以省略</span><br><span class="hljs-comment">//double distance(Point &amp;p1, Point &amp;p2);</span><br><br><span class="hljs-comment">//友元函数定义</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(Point &amp;p1, Point &amp;p2)</span> </span>&#123;<br>    <span class="hljs-type">double</span> dx = p1.x - p2.x; <span class="hljs-comment">//可以直接访问Point类的私有成员</span><br>    <span class="hljs-type">double</span> dy = p1.y - p2.y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(dx * dx + dy * dy);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//创建两个点对象</span><br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The distance between p1 and p2 is &quot;</span> &lt;&lt; <span class="hljs-built_in">distance</span>(p1, p2) &lt;&lt; endl; <span class="hljs-comment">//调用友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="用c语言实现c的继承">用C语言实现C++的继承</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//C++中的继承与多态</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>  <span class="hljs-comment">//C++中的多态:通过虚函数实现</span></span><br><span class="hljs-function">  </span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;A:fun()&quot;</span>&lt;&lt;endl;<br>  &#125;<br><br>  <span class="hljs-type">int</span> a;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A     <span class="hljs-comment">//C++中的继承:B类公有继承A类</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>  <span class="hljs-comment">//C++中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span></span><br><span class="hljs-function">  </span>&#123;<br>   cout&lt;&lt;<span class="hljs-string">&quot;B:fun()&quot;</span>&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-type">int</span> b;<br><br>&#125;;<br><br><span class="hljs-comment">//C语言模拟C++的继承与多态</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*FUN)</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//定义一个函数指针来实现对成员函数的继承</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_A</span>    <span class="hljs-comment">//父类</span><br>&#123;<br>  FUN _fun;  <span class="hljs-comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span><br>  <span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_B</span>     <span class="hljs-comment">//子类</span><br>&#123;<br>  _A _a_;   <span class="hljs-comment">//在子类中定义一个基类的对象即可实现对父类的继承</span><br>  <span class="hljs-type">int</span> _b;<br>&#125;;<br><br><span class="hljs-type">void</span> _fA()    <span class="hljs-comment">//父类的同名函数</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;_A:_fun()\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> _fB()    <span class="hljs-comment">//子类的同名函数</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;_B:_fun()\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//测试C++中的继承与多态</span><br>  A a;  <span class="hljs-comment">//定义一个父类对象a</span><br>  B b;  <span class="hljs-comment">//定义一个子类对象b</span><br>    <br>  A* p1 = &amp;a;  <span class="hljs-comment">//定义一个父类指针指向父类的对象</span><br>  p1-&gt;<span class="hljs-built_in">fun</span>();  <span class="hljs-comment">//调用父类的同名函数</span><br>  p1 = &amp;b;   <span class="hljs-comment">//让父类指针指向子类的对象</span><br>  p1-&gt;<span class="hljs-built_in">fun</span>();  <span class="hljs-comment">//调用子类的同名函数</span><br><br>  <span class="hljs-comment">//C语言模拟继承与多态的测试</span><br><br>  _A _a;  <span class="hljs-comment">//定义一个父类对象_a</span><br>  _B _b;  <span class="hljs-comment">//定义一个子类对象_b</span><br>  _a._fun = _fA;    <span class="hljs-comment">//父类的对象调用父类的同名函数</span><br>  _b._a_._fun = _fB;  <span class="hljs-comment">//子类的对象调用子类的同名函数</span><br><br>  _A* p2 = &amp;_a;  <span class="hljs-comment">//定义一个父类指针指向父类的对象</span><br>  p2-&gt;_fun();   <span class="hljs-comment">//调用父类的同名函数</span><br>  p2 = (_A*)&amp;_b; <span class="hljs-comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br>  p2-&gt;_fun();   <span class="hljs-comment">//调用子类的同名函数</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3
id="为什么不能把所有的函数写成内联函数">为什么不能把所有的函数写成内联函数?</h3>
<p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
<ul>
<li>函数体内的代码比较长，将导致内存消耗代价</li>
<li>函数体内有递归调用的话，函数执行时间要比函数调用开销大</li>
</ul>
<h3
id="为什么c没有垃圾回收机制这点跟java不太一样">为什么C++没有垃圾回收机制？这点跟Java不太一样</h3>
<ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h3 id="c的多态是如何实现的">C++的多态是如何实现的</h3>
<p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p>
<p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022619.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022551.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</strong></p>
<ol type="1">
<li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li>
<li>*<strong>*编译器会在每个对象的前四个字节中保存一个虚表指针，即<code>*vptr</code></strong>，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li>
<li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li>
<li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li>
</ol>
<h3 id="为什么析构函数一般写成虚函数">为什么析构函数一般写成虚函数</h3>
<p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p>
<p>所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test1.cpp 不将析构函数声明为虚函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Parent</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;<br>	&#125;;<br>	~<span class="hljs-built_in">Parent</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Parent&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Son</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;<br>	&#125;;<br>	~<span class="hljs-built_in">Son</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();<br>	<span class="hljs-keyword">delete</span> p;<br>	p = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//Parent construct function</span><br><span class="hljs-comment">//Son construct function</span><br><span class="hljs-comment">//Parent destructor function</span><br><br><br><br><span class="hljs-comment">// test2.cpp 将析构函数声明为虚函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Parent</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;<br>	&#125;;<br>	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Parent</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Parent&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Son</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;<br>	&#125;;<br>	~<span class="hljs-built_in">Son</span>()&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();<br>	<span class="hljs-keyword">delete</span> p;<br>	p = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//Parent construct function</span><br><span class="hljs-comment">//Son construct function</span><br><span class="hljs-comment">//Son destructor function</span><br><span class="hljs-comment">//Parent destructor function</span><br></code></pre></td></tr></table></figure>
<p>但存在一种特例，在<code>CRTP</code>模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应
该声明为虚函数，因为这种继承方式，不需要虚函数表。</p>
<h3
id="构造函数能否声明为虚函数或者纯虚函数析构函数呢">构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h3>
<p>析构函数：</p>
<ul>
<li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li>
<li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li>
<li><strong>析构函数可以是纯虚函数</strong>，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li>
</ul>
<p>构造函数：</p>
<ul>
<li>根据《effective
C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li>
<li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li>
</ul>
<h3
id="基类的虚函数表存放在内存的什么区虚表指针vptr的初始化时间">基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3>
<p>虚函数表的特征：</p>
<ul>
<li>一个类的虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li>
<li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li>
<li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li>
</ul>
<p>根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。测试结果显示：</p>
<p>虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别。</p>
<p>C++中
<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong></p>
<h3 id="模板函数和模板类的特例化">模板函数和模板类的特例化</h3>
<p><strong>引入原因</strong>：编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
<p><strong>定义</strong>：对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<h4 id="模板函数特例化"><strong>模板函数特例化</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;v1,<span class="hljs-type">const</span> T &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(v1 &gt; v2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(v2 &gt; v1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;v1,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1,p2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>本质</strong>:特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用<strong>特例化版本</strong>（因为这个cosnt
char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p><strong>注意</strong>:模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
<h4 id="类模板特例化"><strong>类模板特例化</strong></h4>
<p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hash</span>&lt;sales_data&gt;<br>&#123;<br>	<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(sales_data&amp; s)</span></span>;<br>	<span class="hljs-comment">//里面所有T都换成特例化类型版本sales_data</span><br>	<span class="hljs-comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>类模板的部分特例化</strong>:不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<h5 id="特例化类中的部分成员"><strong>特例化类中的部分成员</strong></h5>
<p><strong>可以特例化类中的部分成员函数而不是整个类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bar</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Barst</span><span class="hljs-params">(T a)</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">void</span> Foo&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">Bar</span>()<br>&#123;<br>    <span class="hljs-comment">//进行int类型的特例化处理</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;我是int型特例化&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Foo&lt;string&gt; fs;<br>Foo&lt;<span class="hljs-type">int</span>&gt; fi;<span class="hljs-comment">//使用特例化</span><br>fs.<span class="hljs-built_in">Bar</span>();<span class="hljs-comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span><br>fi.<span class="hljs-built_in">Bar</span>();<span class="hljs-comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span><br><span class="hljs-comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span><br></code></pre></td></tr></table></figure>
<h3
id="c模板是什么你知道底层怎么实现的">C++模板是什么，你知道底层怎么实现的？</h3>
<ol type="1">
<li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行<strong>两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</strong>。</li>
<li>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</li>
</ol>
<h3
id="构造函数和析构函数可以调用虚函数吗为什么">构造函数和析构函数可以调用虚函数吗，为什么</h3>
<ol type="1">
<li>在C++中，提倡不在构造函数和析构函数中调用虚函数；</li>
<li><strong>构造函数和析构函数调用虚函数时都不使用动态联编</strong>，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</li>
<li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</li>
<li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义</li>
</ol>
<h3
id="构造函数析构函数的执行顺序构造函数和拷贝构造的内部都干了啥">构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h3>
<p><strong>1) 构造函数顺序</strong></p>
<ol type="1">
<li><p>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</p></li>
<li><p>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</p></li>
<li><p>派生类构造函数。</p></li>
</ol>
<p><strong>2) 析构函数顺序</strong></p>
<ol type="1">
<li><p>调用派生类的析构函数；</p></li>
<li><p>调用成员类对象的析构函数；</p></li>
<li><p>调用基类的析构函数。</p></li>
</ol>
<h3 id="构造函数析构函数可否抛出异常">构造函数析构函数可否抛出异常</h3>
<ol type="1">
<li>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。因此在构造函数中抛出异常要考虑释放已经申请的资源。比如<strong>用auto_ptr对象来取代指针类成员</strong>，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</li>
<li>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</li>
<li>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情.</li>
</ol>
<div class="admonition note">
<p class="admonition-title">
总结
</p>
<p>
在构造函数和析构函数中抛出异常时都要注意释放已经申请的资源.
</p>
</div>
<h3 id="类什么时候会析构">类什么时候会析构？</h3>
<ol type="1">
<li>对象生命周期结束，被销毁时；</li>
<li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</li>
<li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</li>
</ol>
<h3 id="构造函数的几种关键字">构造函数的几种关键字</h3>
<h4 id="default"><strong>default</strong></h4>
<p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CString</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">//语句1</span><br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">CString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr) : _str(pstr)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//这样不允许使用new关键字</span><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">CString</span>()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>     string _str;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">auto</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CString</span>(); <span class="hljs-comment">//语句2</span><br>   cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-comment">//Hello World</span><br></code></pre></td></tr></table></figure>
<h4 id="delete"><strong>delete</strong></h4>
<p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//这样不允许使用new关键字</span><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">CString</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">auto</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CString</span>(); <span class="hljs-comment">//语句1</span><br>   cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p>
<h4 id="section">0</h4>
<p>将虚函数定义为纯虚函数（纯虚函数无需定义，=
0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。</p>
<h3
id="构造函数拷贝构造函数和赋值操作符的区别">构造函数、拷贝构造函数和赋值操作符的区别</h3>
<p><strong>构造函数</strong></p>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<p><strong>拷贝构造函数</strong></p>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<p><strong>赋值运算符</strong></p>
<p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p>
<h3
id="拷贝构造函数和赋值运算符重载的区别">拷贝构造函数和赋值运算符重载的区别？</h3>
<ul>
<li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p></li>
<li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p></li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p></li>
<li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Student s;<br>Student s1 = s;    <span class="hljs-comment">// 调用拷贝构造函数</span><br>Student s2;<br>s2 = s;    <span class="hljs-comment">// 赋值运算符操作</span><br></code></pre></td></tr></table></figure></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。
</p>
</div>
<h3 id="什么是虚拟继承">什么是虚拟继承</h3>
<p>虚拟继承是面向对象编程中的一个概念，主要出现在支持多重继承的语言中，如
C++。虚拟继承解决了由多重继承引入的菱形继承问题（Diamond Problem）。</p>
<p>菱形继承问题是指一个类同时继承了两个不同路径上的同一个基类，而这两个路径最终汇聚到一个共同的派生类。这样在继承体系中，<strong>基类的成员在派生类中出现了多次，可能导致二义性和冗余</strong>。</p>
<p>虚拟继承通过在派生类对共同基类的继承前添加 <code>virtual</code>
关键字，告诉编译器在继承体系中使用虚拟继承。这样，只会有一个共同基类的实例被派生类继承，从而解决了菱形继承问题。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal is eating&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">breathe</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Mammal is breathing&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bird is flying&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span> : <span class="hljs-keyword">public</span> Mammal, <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">navigate</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bat is navigating&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Bat bat;<br>    bat.<span class="hljs-built_in">eat</span>();      <span class="hljs-comment">// Accessing eat from Animal</span><br>    bat.<span class="hljs-built_in">breathe</span>();  <span class="hljs-comment">// Accessing breathe from Mammal</span><br>    bat.<span class="hljs-built_in">fly</span>();      <span class="hljs-comment">// Accessing fly from Bird</span><br>    bat.<span class="hljs-built_in">navigate</span>(); <span class="hljs-comment">// Accessing navigate from Bat</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="什么情况会合成默认构造函数">什么情况会合成默认构造函数？</h3>
<ol type="1">
<li><p>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正被需要的时候才会发生；</p>
<p>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</p></li>
<li><p>带有默认构造函数的基类，如果一个没有任何构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</p></li>
<li><p>带有一个虚函数的类</p></li>
<li><p>带有一个虚基类的类</p></li>
<li><p>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</p></li>
</ol>
<h3
id="什么时候需要合成拷贝构造函数呢">什么时候需要合成拷贝构造函数呢？</h3>
<p>有三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ol type="1">
<li>对一个对象做显示的初始化操作，X xx = x;</li>
<li>当对象被当做参数交给某个函数时；</li>
<li>当函数传回一个类对象时；</li>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li>
</ol>
<h3 id="抽象基类为什么不能创建对象">抽象基类为什么不能创建对象？</h3>
<p>抽象基类（Abstract Base Class，简称
ABC）是一种在面向对象编程中用于定义接口和规范的机制。抽象基类本身不能被实例化，主要有以下原因：</p>
<ol type="1">
<li><strong>纯虚函数：</strong> 抽象基类通常包含至少一个纯虚函数（Pure
Virtual
Function），这是一种在基类中声明但没有提供实现的函数。这样的函数使得基类成为抽象，因为它没有完整的实现，必须由派生类提供具体实现。由于抽象基类中存在纯虚函数，无法实例化该类。</li>
<li><strong>接口规范：</strong>
抽象基类用于定义一组接口规范，它为派生类提供了一种契约，告诉派生类应该实现哪些方法。这些规范用于确保派生类的一致性，但抽象基类本身并不提供完整的实现，因此不能创建对象。</li>
<li><strong>设计目的：</strong>
抽象基类的设计目的是为了促使子类提供特定的功能，而不是为了直接创建实例。通过强制派生类实现抽象基类中的虚函数，可以确保派生类符合特定的接口规范。</li>
</ol>
<h3
id="模板类和模板函数的区别是什么">模板类和模板函数的区别是什么？</h3>
<p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必.</p>
<h3
id="多继承的优缺点作为一个开发者怎么看待多继承">多继承的优缺点，作为一个开发者怎么看待多继承</h3>
<h4 id="优点">优点</h4>
<ol type="1">
<li><strong>灵活性：</strong>
多继承允许一个类从多个基类派生，从而获得不同类的功能。这提供了更灵活的设计选择。</li>
<li><strong>代码重用：</strong>
可以通过继承多个类来重用现有代码，避免重复实现相似的功能。</li>
<li><strong>分层设计：</strong>
多继承使得可以通过多个层次结构来建模复杂的关系，更容易表达真实世界的问题。</li>
</ol>
<h4 id="缺点">缺点</h4>
<p>多继承是C++中一项强大而灵活的特性，但也容易引入复杂性和潜在的问题。以下是多继承的一些优缺点，以及开发者在使用多继承时应该注意的一些方面：</p>
<h3 id="优点-1">优点：</h3>
<ol type="1">
<li><strong>灵活性：</strong>
多继承允许一个类从多个基类派生，从而获得不同类的功能。这提供了更灵活的设计选择。</li>
<li><strong>代码重用：</strong>
可以通过继承多个类来重用现有代码，避免重复实现相似的功能。</li>
<li><strong>分层设计：</strong>
多继承使得可以通过多个层次结构来建模复杂的关系，更容易表达真实世界的问题。</li>
</ol>
<h3 id="缺点-1">缺点：</h3>
<ol type="1">
<li><strong>菱形继承问题（Diamond Problem）：</strong>
当一个类从两个不同的类继承，而这两个类又共同继承自同一个类时，可能导致二义性和代码冗余。</li>
<li><strong>复杂性：</strong>
多继承引入了更多的复杂性，增加了理解和维护代码的难度。代码结构可能会变得混乱，难以追踪。</li>
<li><strong>潜在的命名冲突：</strong>
如果多个基类中有相同的成员名，可能会引发命名冲突，需要显式解决。</li>
<li><strong>维护困难：</strong>
随着继承层次的增加，维护和修改代码可能变得更加困难。</li>
</ol>
<h4 id="开发者应该注意的方面">开发者应该注意的方面</h4>
<ol type="1">
<li><strong>设计良好的继承层次结构：</strong>
在使用多继承时，设计一个良好的继承层次结构非常重要。避免过于复杂的层次结构和过度深度的继承链。</li>
<li><strong>使用虚拟继承：</strong> 使用虚拟继承（virtual
inheritance）来解决菱形继承问题，确保共同的基类只有一个实例。</li>
<li><strong>避免深度继承链：</strong>
尽量避免深度继承链，过多的层次可能导致代码难以理解和维护。</li>
<li><strong>使用接口和抽象类：</strong>
尽量使用接口和抽象类，将接口与实现分离，降低耦合度。</li>
<li><strong>考虑其他设计模式：</strong>
在某些情况下，其他设计模式如组合、委托等可能更合适，可以减轻多继承可能带来的复杂性</li>
</ol>
<h3
id="模板和实现可不可以不写在一个文件里面为什么">模板和实现可不可以不写在一个文件里面？为什么？</h3>
<p><strong>不能</strong>,因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。
《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p>
<p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以<strong>为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</strong></p>
<h3
id="为什么拷贝构造函数必须传引用不能传值">为什么拷贝构造函数必须传引用不能传值？</h3>
<p>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化该类一个新的实例。如果传值的方式是非引用,那么构造形参需要调用拷贝构造函数,调用拷贝构造函数的过程又需要调用拷贝构造函数,会造成无限递归.</p>
<h3
id="静态函数能定义为虚函数吗常函数呢">静态函数能定义为虚函数吗？常函数呢？</h3>
<ol type="1">
<li><p>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p></li>
<li><p>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p></li>
</ol>
<p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且<strong>只能用this指针来访问它</strong>，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</p>
<p>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr
-&gt; vtable -&gt;virtual function</p>
<h3 id="虚函数的代价是什么">虚函数的代价是什么？</h3>
<ol type="1">
<li>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，<strong>增大类存储空间</strong>；</li>
<li>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会<strong>增加对象的空间</strong>大小；</li>
<li><strong>不能再是内联的函数</strong>，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数</li>
</ol>
<h3
id="说一说你了解到的移动构造函数">说一说你了解到的移动构造函数？</h3>
<ol type="1">
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的资源还要有一个释放的过程，既然a不再使用了，那么为什么我们不能直接让b使用a的空间？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li><strong>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制</strong>；</li>
</ol>
<h3 id="构造函数的执行顺序">构造函数的执行顺序</h3>
<ol type="1">
<li>在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</li>
<li>如果有成员初始化列表；</li>
<li>构造函数体；</li>
<li>构造函数完毕之后,对象的vptr被初始化；</li>
</ol>
<h3
id="哪些函数不能是虚函数把你知道的都说一说">哪些函数不能是虚函数？把你知道的都说一说</h3>
<ol type="1">
<li>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</li>
<li>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</li>
<li>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</li>
<li>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</li>
<li>普通函数，普通函数<strong>不属于类的成员函数</strong>，不具有继承特性，因此普通函数没有虚函数。</li>
</ol>
<h3
id="unique_ptr实际场景中有哪些应用">unique_ptr实际场景中有哪些应用？</h3>
<p>互斥锁、socket会用到unique_ptr。</p>
<h2 id="c-11-新特性">C++ 11 新特性</h2>
<h3 id="c-11有哪些新特性">C++ 11有哪些新特性？</h3>
<ul>
<li>nullptr替代 NULL</li>
<li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li>
<li>基于范围的 for 循环for(auto&amp; i : res){}</li>
<li>类和结构体的中初始化列表</li>
<li>Lambda 表达式（匿名函数）</li>
<li>std::forward_list（单向链表）</li>
<li>右值引用和move语义</li>
</ul>
<h3 id="空指针-nullptr">空指针 nullptr</h3>
<p>nullptr 出现的⽬的是为了替代 NULL。</p>
<p>在某种意义上来说，传统 C语言会把 NULL、 0
视为同⼀种东⻄，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定 义为
((void<em>)0)，有些则会直接将其定义为 0。C++ 不允许直接将 void </em>
隐式转 换到其他类型，但如果 NULL 被定义为 ((void<em>)0)，那么当编译 char
</em>ch = NULL; 时，NULL 只好被定义为 0。⽽这依然会产⽣问题，将导致了
C++ 中重载特性 会发⽣混乱，考虑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span></span>;<br></code></pre></td></tr></table></figure>
<p>对于这两个函数来说，如果 NULL ⼜被定义为了 0 那么 func(NULL)
这个语句将 会去调⽤ func(int)，从⽽导致代码违反直观。</p>
<p>为了解决这个问题，C++11 引入了 nullptr
关键字，专门⽤来区分空指针、0。nullptr
的类型为nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进⾏相等或者不等的⽐较。</p>
<p>当需要使⽤ NULL 时候，养成直接使⽤ nullptr 的习惯。</p>
<h3 id="lambda-表达式">Lambda 表达式</h3>
<p>详见<a
href="https://gstarmin.github.io/2023/02/24/Cpp-lambda%E7%94%A8%E6%B3%95/">Lambda表达式用法</a>。</p>
<h3 id="右值引用">右值引用</h3>
<p>详见<a
href="https://gstarmin.github.io/2023/03/30/Cpp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">C++右值引用</a></p>
<h3 id="泛化的常量表达式-constexpr">泛化的常量表达式 constexpr</h3>
<p>constexpr
告诉编译器这是⼀个编译期常量，甚⾄可以把⼀个函数声明为编译期常量表达式。</p>
<p>constexpr 和 const 的区别见 C++ 部分 <a
href="https://gstarmin.github.io/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/#const-%E5%92%8C-constexpr-%E7%9A%84%E5%8C%BA%E5%88%AB">const
和 constexpr 的区别</a></p>
<h3 id="初始化列表">初始化列表</h3>
<p>接下来几个特性属于原有语⾔特性的使⽤性增强。这意味着这些操作原来也是可以实现的，
不过现在语法上更加简洁。⽐如⾸先要介绍的初始化列表。</p>
<p>⽽ C++11 提供了 initializer_list 来接受变⻓的对象初始化列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-built_in">A</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; list);<br>&#125;;<br><br>A a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意初始化列表特性只是现有语法增强，并不是提供了动态的可变参数。该列表只能静态地构造。</p>
<h3 id="统的初始化语法">统⼀的初始化语法</h3>
<p>不同的数据类型具有不同的初始化语法。如何初始化字符串？如何初始化数组？如何初始化多维数组？如何初始化对象？</p>
<p>C++11给出了统⼀的初始化语法：均可使⽤“{}-初始化变量列表”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X x1 = X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>X x2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;     <span class="hljs-comment">// 此处的&#x27;=&#x27;可有可⽆</span><br>X x3&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>X* p = <span class="hljs-keyword">new</span> X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : X &#123;    <br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) :X&#123;x,y&#125; &#123; <span class="hljs-comment">/* … */</span> &#125;;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;    <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];    <span class="hljs-comment">// 对于旧有问题的解决方案    </span><br>    <span class="hljs-built_in">S</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z) :a&#123;x,y,z&#125; &#123; <span class="hljs-comment">/* … */</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="auto和decltype类型推导">auto和decltype类型推导</h2>
<p>C++ 提供了 auto 和 decltype
来静态推导类型，在我们知道类型没有问题但⼜不想完整地写出类型的时候，
便可以使⽤静态类型推导。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it);<br><span class="hljs-comment">// 可以改写为</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it);<br></code></pre></td></tr></table></figure>
<div class="admonition attention">
<p class="admonition-title">
attention
</p>
<p>
虽然写起来和动态语⾔（如JavaScript的 var
）很像，但C++仍然是强类型的，会执⾏静态类型检查的语⾔。
这只是语法上的简化，并未改变C++的静态类型检查
</p>
</div>
<p>decltype ⽤于获取⼀个表达式的类型，⽽不对表达式进⾏求值（类似于sizeof
）。 decltype(e) 规则如下：</p>
<ul>
<li>若 e
为⼀个⽆括号的变量、函数参数、类成员，则返回类型为该变量/参数/类成员在源程序中的声明类型;</li>
<li>否则的话，根据表达式的值分类（value categories），设设 T 为 e
的类型:
<ul>
<li>若 e 是⼀个左值（lvalue，即“可寻址值”），返回 T&amp; ；</li>
<li>若 e 是⼀个临终值（xvalue），则返回值为 T&amp;&amp; ；</li>
<li>若 e 是⼀个纯右值（prvalue），则返回值为 T 。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回临终值：⽣命周期已结束但内存还未拿⾛</span><br><br><span class="hljs-keyword">auto</span> a = v[<span class="hljs-number">0</span>];          <span class="hljs-comment">// a 为 int</span><br><span class="hljs-keyword">decltype</span>(v[<span class="hljs-number">0</span>]) b = <span class="hljs-number">0</span>;  <span class="hljs-comment">// b 为 const int&amp;</span><br>                       <span class="hljs-comment">// 即 vector&lt;int&gt;::operator[](size_type) const 的返回值类型</span><br><span class="hljs-keyword">auto</span> c = <span class="hljs-number">0</span>;             <span class="hljs-comment">// c, d 均为 int</span><br><span class="hljs-keyword">auto</span> d = c;<br><span class="hljs-keyword">decltype</span>(c) e;          <span class="hljs-comment">// e 为 int，即 c 的类型</span><br><span class="hljs-keyword">decltype</span>((c)) f = e;    <span class="hljs-comment">// f 为 int&amp;，因为 c 是左值</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">0</span>) g;          <span class="hljs-comment">// g 为 int，因为 0 是右值</span><br></code></pre></td></tr></table></figure>
<h3 id="基于范围的for循环">基于范围的for循环</h3>
<p>Boost
中定义了很多"范围"，很多标准库函数都使⽤了范围⻛格的实现。这⼀概念被C++11提了出来:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; x: arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: v);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x: v);<br></code></pre></td></tr></table></figure>
<h3 id="构造函数委托">构造函数委托</h3>
<p>在 C# 和 Java 中，⼀个构造函数可以调⽤另⼀个来实现代码复⽤，但
C++⼀直不允许这样做.</p>
<p>现在可以了，这使得构造函数可以在同⼀个类中⼀个构造函数调⽤另⼀个构造函数，从⽽达到简化代码的⽬的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myBase</span>&#123;<br>    <span class="hljs-type">int</span> number;<br>    string name;<br>    <span class="hljs-built_in">myBase</span>(<span class="hljs-type">int</span> number, string&amp; s) : <span class="hljs-built_in">number</span>(number), <span class="hljs-built_in">name</span>(s)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myBase</span>() : <span class="hljs-built_in">myBase</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;invalid&quot;</span>)&#123;&#125;<br>    <span class="hljs-built_in">myBase</span>(<span class="hljs-type">int</span> number) : <span class="hljs-built_in">myBase</span>(number, <span class="hljs-string">&quot;guest&quot;</span>)&#123;&#125;<br>    <span class="hljs-built_in">myBase</span>(string&amp; s) : <span class="hljs-built_in">myBase</span>(<span class="hljs-number">1</span>, s)&#123;<span class="hljs-built_in">PostInit</span>();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="final-和-override">final 和 override</h3>
<p>C++ 借由虚函数实现运⾏时多态，但 C++ 的虚函数⼜很多脆弱的地方：</p>
<ul>
<li>⽆法禁⽌子类重写它。可能到某⼀层级时，我们不希望子类继续来重写当前虚函数了。</li>
<li>容易不小⼼隐藏父类的虚函数。⽐如在重写时，不小⼼声明了⼀个签名不⼀致但有同样名称的新函数。</li>
</ul>
<p>C++11 提供了 final 来禁⽌虚函数被重写/禁⽌类被继承， override
来显示地重写虚函数。如果不使用override，当你手一抖，将<strong>foo()</strong>写成了<strong>f00()</strong>会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base1</span> <span class="hljs-keyword">final</span> &#123; &#125;;     <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived1</span> : Base1 &#123;&#125;;         <span class="hljs-comment">// 编译错：Base1不允许被继承 </span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base2</span> &#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived2</span> : Base2 &#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 编译错：f1不允许重写    </span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// 编译错：父类中没有 void f2(int)</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="static_assert">static_assert</h3>
<p>C++ 提供了两种方式来 assert ：⼀种是 assert 宏，另⼀种是预处理指令
#error 。
前者在运⾏期起作⽤，⽽后者是预处理期起作⽤。它们对模板都不好使，因为模板是编译期的概念。</p>
<p>static_assert 关键字的使⽤方式如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Check</span> &#123;  <br>    <span class="hljs-built_in">static_assert</span>( <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;= <span class="hljs-built_in">sizeof</span>(T), <span class="hljs-string">&quot;T is not big enough!&quot;</span> ) ;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="智能指针">智能指针</h3>
<p>接下来介绍 C++11 对于 C++ 标准库的变更。C++11 把 TR1
并入了进来，废弃了 C++98 中的 auto_ptr ， 同时将 shared_ptr 和 uniq_ptr
并入 std 命名空间。</p>
<p>智能指针在 [Effective C++: Item 13]
中已经有不少讨论了。这⾥给⼀个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">p_first</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">double</span>)</span></span>;     <br>    &#123;        <br>        std::shared_ptr&lt;<span class="hljs-type">double</span>&gt; p_copy = p_first;        <br>        *p_copy = <span class="hljs-number">21.2</span>;    <br>    &#125;  <span class="hljs-comment">// p_copy 被销毁，⾥面的 double 还有⼀个引⽤因此仍然保持    </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// p_first 及其⾥面的 double 销毁</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="正则表达式">正则表达式</h3>
<p>这个任何⼀门现代的编程语⾔都会提供的特性终于进标准：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *reg_esp = <span class="hljs-string">&quot;[ ,.\\t\\n;:]&quot;</span>;<span class="hljs-function">std::regex <span class="hljs-title">rgx</span><span class="hljs-params">(reg_esp)</span> </span>;std::cmatch match ;  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *target = <span class="hljs-string">&quot;Polytechnic University of Turin &quot;</span> ; <span class="hljs-keyword">if</span>( <span class="hljs-built_in">regex_search</span>( target, match, rgx ) ) &#123;  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> n = match.<span class="hljs-built_in">size</span>();  <span class="hljs-keyword">for</span>( <span class="hljs-type">size_t</span> a = <span class="hljs-number">0</span> ; a &lt; n ; a++ ) &#123;    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">( match[a].first, match[a].second )</span> </span>;    cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> ;  &#125;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="增强的元组">增强的元组</h3>
<p>在 C++ 中本已有⼀个 pair 模板可以定义⼆元组，C++11
更进⼀步地提供了边⻓参数的tuple 模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::tuple&lt; <span class="hljs-type">int</span> , <span class="hljs-type">double</span>, string&gt; tuple_1 t1;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> std::tuple&lt; <span class="hljs-type">char</span>, <span class="hljs-type">short</span> , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * &gt; tuple_2 <span class="hljs-title">t2</span> <span class="hljs-params">(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Hola!&quot;</span>)</span></span>;<br>t1 = t2 ;       <span class="hljs-comment">// 隐式类型转换</span><br></code></pre></td></tr></table></figure>
<h3 id="哈希表">哈希表</h3>
<p>C++ 的 map , multimap , set , multiset 使⽤红⿊树实现，
插入和查询都是 O(lgn) 的复杂度</p>
<p>但 C++11 为这四种模板类提供了（底层哈希实现）以达到 O(1)
的复杂度：</p>
<table>
<thead>
<tr class="header">
<th>散列表类型</th>
<th>有无关系值</th>
<th>接受相同键值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>std::unordered_map</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>std::unordered_multimap</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="odd">
<td>std::unordered_set</td>
<td>否</td>
<td>否</td>
</tr>
<tr class="even">
<td>std::unordered_multiset</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="c内存管理">C++内存管理</h2>
<h3 id="类的对象存储空间大小">类的对象存储空间大小？</h3>
<ul>
<li>非静态成员的数据类型大小之和。</li>
<li>编译器加入的额外成员变量（如指向虚函数表的指针）。</li>
<li>为了边缘对齐优化加入的padding。</li>
</ul>
<p>空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0</p>
<h3 id="简要说明c的内存分区">简要说明C++的内存分区</h3>
<p>C++中的内存分区，分别是<strong>堆、栈、全局/静态存储区、常量存储区和代码区</strong>（CS
225写的是4个区域）。如下图所示</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021689.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p><strong>堆</strong>：就是那些由
<code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个
<code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p><strong>代码区</strong>：存放函数体的二进制代码</p>
<h3 id="什么是内存池如何实现">什么是内存池，如何实现</h3>
<p>内存池（Memory Pool）
是一种<strong>内存分配</strong>方式。通常我们习惯直接使用new、malloc
等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，
若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p>
<h4 id="实现">实现</h4>
<p>这里<strong>简单描述一下《STL源码剖析》中的内存池实现机制</strong>：</p>
<p><strong>allocate 包装
malloc，deallocate包装free</strong>，一般是一次20*2个的申请，先用一半，留着一半，C++委员会成员认为20是个比较好的数字，既不大也不小。</p>
<ol type="1">
<li>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20
* 32byte）</li>
<li>客户端之后有有内存需求，想申请（20 *
64bytes）的空间，这时内存池只有（20 * 32bytes），就先将（10 *
64bytes)个区块返回，1个区块交出，另外19个处于维护状态，此时内存池空空如也.</li>
<li>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</li>
<li>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</li>
</ol>
<p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。</p>
<p>内部实现，目前的所有编译器都是直接调用的::operator new()和::operator
delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
new和 operator new
的区别：new是一个关键字，用于为对象动态分配内存，而operate new
是一个分配原始内存的函数。程序员在使用new的时候会调用operate
new分配内存，然后它调用正确类型的对象的构造函数，因此结果是在该内存中创建的真实活动对象。
</p>
</div>
<h3
id="c中类的数据成员和成员函数内存分布情况">C++中类的数据成员和成员函数内存分布情况</h3>
<p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。
类分为成员变量和成员函数，我们先来讨论成员变量。</p>
<p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">23</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;对象地址：&quot;</span>&lt;&lt; &amp;p &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age地址：&quot;</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;对象大小：&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age大小：&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(p.age) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//对象地址：0x7fffec0f15a8</span><br><span class="hljs-comment">//age地址：0x7fffec0f15a8</span><br><span class="hljs-comment">//对象大小：4</span><br><span class="hljs-comment">//age大小：4</span><br></code></pre></td></tr></table></figure>
<p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p>
<p>要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。</p>
<p>我们再来补充一下静态成员函数的存放问题：<strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员。</p>
<p>就像前面提到的，<strong>所有函数都存放在代码区，静态函数也不例外。所有有人一看到
static 这个单词就主观的认为是存放在全局数据区，那是不对的。</strong></p>
<h3
id="关于this指针你知道什么全说出来">关于this指针你知道什么？全说出来</h3>
<ul>
<li>this指针是类的指针，<strong>指向对象的首地址</strong>。</li>
<li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li>
<li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</li>
</ul>
<h4 id="this指针的用处"><strong>this指针的用处</strong></h4>
<p>一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象)
的结果。this作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p>
<h4 id="this指针的使用"><strong>this指针的使用</strong></h4>
<p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用
return *this；</p>
<p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n
（不能写成n = n）</p>
<h4
id="类的this指针有以下特点"><strong>类的this指针有以下特点</strong></h4>
<p><strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>传入参数为当前对象地址，成员函数第一个参数为</strong>为<strong>T
* const this</strong></p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<span class="hljs-keyword">public</span>:	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;&#125;&#125;;<br></code></pre></td></tr></table></figure>
<p>其中，<strong>func</strong>的原型在编译器看来应该是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(A * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>,<span class="hljs-type">int</span> p)</span></span>;<br></code></pre></td></tr></table></figure>
<p>由此可见，<strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;a.<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);	<span class="hljs-comment">//此处，编译器将会编译成：A::func(&amp;a,10);</span><br></code></pre></td></tr></table></figure>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
<h3 id="几个this指针的易混问题">几个this指针的易混问题</h3>
<h4 id="this指针是什么时候创建的">this指针是什么时候创建的？</h4>
<p><strong>this在成员函数的开始执行前构造，在成员的执行结束后清除。</strong></p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE
xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p>
<h4
id="this指针存放在何处堆栈全局变量还是其他">this指针存放在何处？堆、栈、全局变量，还是其他？</h4>
<p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p>
<h4
id="this指针是如何传递类中的函数的绑定还是在函数参数的首参数就是this指针那么this指针又是如何找到类实例后函数的">this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h4>
<p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</p>
<h4
id="this指针是如何访问类中的变量的">this指针是如何访问类中的变量的？</h4>
<p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p>
<h4
id="我们只有获得一个对象后才能通过对象使用this指针如果我们知道一个对象this指针的位置可以直接使用吗">我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h4>
<p><strong>this指针只有在成员函数中才有定义</strong>。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<h4
id="每个类编译后是否创建一个类中函数表保存函数指针以便用来调用函数">每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h4>
<p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p>
<h3
id="成员函数中调用delete-this会出现什么问题对象还可以使用吗">成员函数中调用delete
this会出现什么问题？对象还可以使用吗？</h3>
<p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete
this时，类对象的内存空间被释放。在delete
this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<h4 id="为什么是不可预期的问题">为什么是不可预期的问题？</h4>
<p>delete
this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete
this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<h3
id="如果在类的析构函数中调用delete-this会发生什么">如果在类的析构函数中调用delete
this，会发生什么？</h3>
<p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete
this会去调用本对象的析构函数，而析构函数中又调用delete
this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h3 id="你知道空类的大小是多少吗">你知道空类的大小是多少吗？</h3>
<ol type="1">
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li><strong>C++标准指出，不允许一个对象（当然包括类对象）的大小为0</strong>，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ol>
<h3
id="请说一下以下几种情况下下面几个类的大小各是多少">请说一下以下几种情况下，下面几个类的大小各是多少？</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++中空类会占一个字节，这是为了让对象的实例能够相互区别</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>空类的大小是1，
在<strong>C++中空类会占一个字节，这是为了让对象的实例能够相互区别</strong>。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;&#125; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 4(32位机器)/8(64位机器);</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 4(32位机器)/8(64位机器);</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为有**虚函数的类对象中都有一个虚函数表指针
__vptr，其大小是4字节**</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> a; <span class="hljs-type">int</span> b; &#125;;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <span class="hljs-type">int</span> c; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(A)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>  A a; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(a)&lt;&lt;endl;<span class="hljs-comment">// 输出 1;</span><br>    <br>  <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(B)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>  B b; <br>  cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(b)&lt;&lt;endl;<span class="hljs-comment">// 输出 4;</span><br>    <br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(C) &lt;&lt; endl; <span class="hljs-comment">// 输出4</span><br>  C c;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(c) &lt;&lt; endl; <span class="hljs-comment">// 输出4</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>静态成员存放在静态存储区，不占用类的大小,
普通函数也不占用类大小。</p>
<h3
id="this指针调用成员变量时堆栈会发生什么变化">this指针调用成员变量时，堆栈会发生什么变化？</h3>
<p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h3 id="类对象的大小受哪些因素影响">类对象的大小受哪些因素影响？</h3>
<ol type="1">
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展</li>
</ol>
<h3 id="菱形继承和虚继承">菱形继承和虚继承</h3>
<p>详细见<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365223471">菱形继承和虚继承</a>,这里只贴出几个重要结论：</p>
<ol type="1">
<li>对于虚基类的初始化是由最后的派生类中负责初始化。在最后的派生类中不仅要对直接基类进行初始化，还要负责对虚基类初始化；</li>
<li>程序运行时，只有最后的派生类执行对基类的构造函数调用，而忽略其他派生类对虚基类的构造函数调用。从而避免对基类数据成员重复初始化。因此，虚基类只会构造一次。</li>
</ol>
<h2 id="stl模板库">STL模板库</h2>
<h3 id="说一下c左值引用和右值引用">说一下C++左值引用和右值引用</h3>
<ol type="1">
<li>在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</li>
<li><strong>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型</strong>，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</li>
<li><strong>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</strong></li>
</ol>
<h3 id="stl中hashtable的实现">STL中hashtable的实现？</h3>
<p>STL中的hashtable使用的是<strong>拉链法</strong>解决hash冲突问题，如下图所示。</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035271.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p>
<p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97,
193,...,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets
vector，重新计算元素在新hashtable的位置。</p>
<h3 id="stl的两级空间配置器">STL的两级空间配置器</h3>
<p>动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p>
<p>于是就设置了二级空间配置器，<strong>当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p>
<p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。
如果<strong>大于128字节再转去一级配置器器。</strong></p>
<h4 id="一级配置器">一级配置器</h4>
<p><strong>一级空间配置器</strong>中重要的函数就是allocate、deallocate、reallocate
。
一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置
。大致过程是：</p>
<p>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</p>
<p>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</p>
<p>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035143.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="二级配置器">二级配置器</h4>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220035104.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li><p>维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p></li>
<li><p>对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：
（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) *
20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。
（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。
（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。</p></li>
<li><p>内存池为空，申请内存
此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2
* 所需节点内存大小（提升后）* 20 +
一段额外空间），申请40块，一半拿来用，一半放内存池中。</p></li>
<li><p>malloc没有成功
在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</p></li>
</ol>
<p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p>
<h4 id="二级空间配置器的优缺点">二级空间配置器的优缺点</h4>
<p>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多<strong>内部碎片</strong>；</p>
<p>2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p>
<h3 id="vector如何释放空间">Vector如何释放空间?</h3>
<p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p>
<p>如果需要空间动态缩小，可以考虑使用deque。</p>
<p>如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>(Vec).<span class="hljs-built_in">swap</span>(Vec); <span class="hljs-comment">//将Vec中多余内存清除； </span><br><span class="hljs-built_in">vector</span>().<span class="hljs-built_in">swap</span>(Vec); <span class="hljs-comment">//清空Vec的全部内存；</span><br></code></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span> <span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)</span></span>;   <span class="hljs-comment">// three ints with a value of 100</span><br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(vec).<span class="hljs-built_in">swap</span>(vec); <span class="hljs-comment">//清空vec中多余的空间，相当于vec.shrink_to_fit();</span><br><br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">swap</span>(vec); <span class="hljs-comment">//清空vec的全部空间</span><br><br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    运行结果：</span><br><span class="hljs-comment">    vec.size(): 102</span><br><span class="hljs-comment">    vec.capasity(): 200</span><br><span class="hljs-comment">    vec.size(): 102</span><br><span class="hljs-comment">    vec.capasity(): 102</span><br><span class="hljs-comment">    vec.size(): 0</span><br><span class="hljs-comment">    vec.capasity(): 0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="stl迭代器如何实现">STL迭代器如何实现</h3>
<p>1、
迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p>
<p>2、
迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p>
<p>3、最常用的迭代器的相应型别有五种：value type、difference
type、pointer、reference、iterator catagoly;</p>
<h3
id="mapset是怎么实现的红黑树是怎么能够同时实现这两种容器-为什么使用红黑树">map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？
为什么使用红黑树？</h3>
<ol type="1">
<li>他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效的插入删除；</li>
<li>红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</li>
<li>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</li>
</ol>
<h3 id="map插入方式有哪几种">map插入方式有哪几种？</h3>
<ol type="1">
<li>用insert函数插入pair数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;student_one&quot;</span>));  <br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>用insert函数插入value_type数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;student_one&quot;</span>)); <br></code></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>在insert函数中使用make_pair()函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;student_one&quot;</span>)); <br></code></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>用数组方式插入数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mapStudent[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;student_one&quot;</span>; <br></code></pre></td></tr></table></figure>
<h3
id="stl中unordered_maphash_map和map的区别hash_map如何解决冲突以及扩容">STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</h3>
<ol type="1">
<li>unordered_map内部元素是无序的，而map会根据key的大小进行排序，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</li>
</ol>
<h3 id="stl中vector的实现">STL中vector的实现</h3>
<p>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，vector使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。扩容规则：以原大小的两倍(或1.5倍)配置另外一块较大的空间</p>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2
倍
</p>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> size_type len  = old_size + <span class="hljs-built_in">max</span>(old_size, n);<br></code></pre></td></tr></table></figure>
<h3 id="stl中slist的实现">STL中slist的实现</h3>
<p>list是双向链表，而slist（single linked
list）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectional
iterator，后者的迭代器属于单向的Forward
iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p>
<p><strong>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后</strong>，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的</p>
<p>slist的单向迭代器如下图所示：</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071953335.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allco</span> = alloc&gt;<br><span class="hljs-keyword">class</span> slist<br>&#123;<br>	...<br><span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-type">static</span> list_node* <span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> value_type&amp; x)&#123;&#125;<span class="hljs-comment">//配置空间、构造元素</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-built_in">destroy_node</span>(list_node* node)&#123;&#125;<span class="hljs-comment">//析构函数、释放空间</span><br><span class="hljs-keyword">private</span>:<br>    list_node_base head; <span class="hljs-comment">//头部</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(slist&amp; L)</span></span>&#123;&#125;<span class="hljs-comment">//交换两个slist，只需要换head即可</span><br>    <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//取头部元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">const</span> value&amp; x)</span></span>&#123;&#125;<span class="hljs-comment">//头部插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//从头部取走元素</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="admonition note">
<p class="admonition-title">
note
</p>
<p>
需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++
11中出现，它与slist的区别是没有size()方法。
</p>
</div>
<p>slist的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	forward_list&lt;<span class="hljs-type">int</span>&gt; fl;<br>	fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>	fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);<br>	fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<br>	fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">6</span>);<br>	fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">5</span>);<br><br>	forward_list&lt;<span class="hljs-type">int</span>&gt;::iterator ite1 = fl.<span class="hljs-built_in">begin</span>();<br>	forward_list&lt;<span class="hljs-type">int</span>&gt;::iterator ite2 = fl.<span class="hljs-built_in">end</span>();<br>	<span class="hljs-keyword">for</span>(;ite1 != ite2; ++ite1)<br>	&#123;<br>		cout &lt;&lt; *ite1 &lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 5 6 2 3 1</span><br>	&#125;<br>	cout &lt;&lt; endl;<br><br>	ite1 = <span class="hljs-built_in">find</span>(fl.<span class="hljs-built_in">begin</span>(), fl.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>); <span class="hljs-comment">//寻找2的位置</span><br><br>	<span class="hljs-keyword">if</span> (ite1 != ite2)<br>		fl.<span class="hljs-built_in">insert_after</span>(ite1, <span class="hljs-number">99</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : fl)<br>	&#123;<br>		cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//5 6 2 99 3 1</span><br>	&#125;<br>	cout &lt;&lt; endl;<br><br>	ite1 = <span class="hljs-built_in">find</span>(fl.<span class="hljs-built_in">begin</span>(), fl.<span class="hljs-built_in">end</span>(), <span class="hljs-number">6</span>); <span class="hljs-comment">//寻找6的位置</span><br>	<span class="hljs-keyword">if</span> (ite1 != ite2)<br>		fl.<span class="hljs-built_in">erase_after</span>(ite1);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : fl)<br>	&#123;<br>		cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//5 6 99 3 1</span><br>	&#125;<br>	cout &lt;&lt; endl;	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="stl中list的实现">STL中list的实现</h3>
<p>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是<strong>双向迭代器</strong>：Bidirectional
iterators。</p>
<p>list节点的结构见如下源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__list_node</span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* void_pointer;<br>    void_pointer prev;<br>    void_pointer next;<br>    T data;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="stl中的deque的实现">STL中的deque的实现</h3>
<p>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头部进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205071953980.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>deque和vector的最大差异一个是deque运行在<strong>常数时间内对头端进行元素操作</strong>，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来</p>
<p>d<strong>eque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。</strong>如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque。</p>
<p>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性。</p>
<p>deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如下图所示。</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021322.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>deque的迭代器数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__deque_iterator</span><br>&#123;<br>    ...<br>    T* cur;<span class="hljs-comment">//迭代器所指缓冲区当前的元素</span><br>    T* first;<span class="hljs-comment">//迭代器所指缓冲区第一个元素</span><br>    T* last;<span class="hljs-comment">//迭代器所指缓冲区最后一个元素</span><br>    map_pointer node;<span class="hljs-comment">//指向map中的node</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素:</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021453.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p>
<h3 id="stl中stack和queue的实现">STL中stack和queue的实现</h3>
<h4 id="stack">Stack</h4>
<p>stack（栈）是一种先进后出（First In Last
Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021348.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack<br>&#123;<br>	...<br><span class="hljs-keyword">protected</span>:<br>    Sequence c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();&#125;<br>    <span class="hljs-function">reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();&#125;<br>    <span class="hljs-function">const_reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="hljs-built_in">push_back</span>(x);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;c.<span class="hljs-built_in">pop_back</span>();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而<strong>Sequence默认是deque数据结构</strong>。stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container
adapter而非container</p>
<p>stack<strong>除了默认使用deque作为其底层容器之外，也可以使用双向开口的list</strong>，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</p>
<h4 id="queue">Queue</h4>
<p>queue（队列）是一种先进先出（First In First
Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> queue<br>&#123;<br>	...<br><span class="hljs-keyword">protected</span>:<br>    Sequence c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();&#125;<br>    <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>();&#125;<br>    <span class="hljs-function">const_reference <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="hljs-built_in">push_back</span>(x);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;c.<span class="hljs-built_in">pop_front</span>();&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成</strong>，Sequence默认也是deque数据结构。queue也是一类container
adapter。</p>
<p>同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</p>
<h3 id="stl中的heap的实现">STL中的heap的实现</h3>
<p>heap（堆）并不是STL的容器组件，是priority
queue（优先队列）的底层实现机制，因为binary max
heap（大根堆）总是最大值位于堆的根部，优先级最高。</p>
<p>binary heap本质是一种complete binary tree（完全二叉树），整棵binary
tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220021792.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于<span
class="math inline">\(i\)</span>处，其左节点必定位于<span
class="math inline">\(2i\)</span>处，右节点位于<span
class="math inline">\(2i+1\)</span>处，父节点位于<span
class="math inline">\(i/2\)</span>（向下取整）处。这种以array表示tree的方式称为隐式表述法。</p>
<p>因此我们可以使用一个array和一组heap算法来实现max
heap（每个节点的值大于等于其子节点的值）和min
heap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，可以用vector代替array。</p>
<h3 id="stl中的priority_queue的实现">STL中的priority_queue的实现</h3>
<p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022333-17059267793603.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。</p>
<p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> ia[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span> &#125;;<br>	<span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(ia, ia + <span class="hljs-number">9</span>)</span></span>;<br>	cout &lt;&lt; pq.<span class="hljs-built_in">size</span>() &lt;&lt;endl;  <span class="hljs-comment">// 9</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pq.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 8 8 8 8 8 8 8 8 8</span><br>	&#125;<br>	cout &lt;&lt; endl;<br>	<span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">// 8 7 6 5 4 3 2 1 0</span><br>		pq.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="stl中set的实现">STL中set的实现？</h3>
<p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</p>
<p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p>
<p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p>
<p>标准的STL
set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：</p>
<ul>
<li>每个节点不是红色就是黑色</li>
<li>根结点为黑色</li>
<li>如果节点为红色，其子节点必为黑</li>
<li>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</li>
</ul>
<p>关于红黑树的具体操作过程，比较复杂读者可以翻阅《算法导论》详细了解。</p>
<h3 id="stl中map的实现">STL中map的实现</h3>
<p>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</p>
<p>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant
iterator，也不是mutable iterator</p>
<p>标准STL map的底层机制是RB-tree（红黑树），另一种以hash
table为底层机制实现的称为hash_map。map的架构如下图所示</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/202205220022980.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p>
<h3
id="set和map的区别multimap和multiset的区别">set和map的区别，multimap和multiset的区别</h3>
<p>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是
identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素。</p>
<p>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</p>
<p>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入。</p>
<p>multiset和multimap的区别也是一样的，只不过multiset和multimap使用insert_equal()。</p>
<p>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p>
<h3 id="红黑树"><strong>红黑树</strong></h3>
<p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p>
<ol type="1">
<li>它是二叉排序树（继承二叉排序树特显）：</li>
</ol>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
<ul>
<li>左、右子树也分别为二叉排序树。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>它满足如下几点要求：</li>
</ol>
<ul>
<li>树中所有节点非红即黑。</li>
<li>根节点必为黑节点。</li>
<li>红节点的子节点必为黑（黑节点子节点可为黑）。</li>
<li>从根到NULL的任何路径上黑结点数相同。</li>
</ul>
<ol start="3" type="1">
<li>查找时间一定可以控制在O(logn)。</li>
</ol>
<h3
id="stl中unordered_map和map的区别和应用场景">STL中unordered_map和map的区别和应用场景</h3>
<ul>
<li><p>map底层实现是红黑树，查询和维护时间复杂度均为<code>O(log n)</code>,而unordered_map的底层实现是哈希表，其查询时间复杂度为<code>O(1)</code>,维护时间与bucket桶锁维护的list长度有关，到那时建立hash表耗时比较大。</p></li>
<li><p>map支持键值自动排序，而unordered_map是无序容器</p></li>
</ul>
<p>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</p>
<h3
id="hashtable中解决冲突有哪些方法">hashtable中解决冲突有哪些方法？</h3>
<ul>
<li><strong>线性探测法</strong>：使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</li>
<li><strong>拉链法</strong>：每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</li>
<li><strong>再散列</strong>：发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</li>
<li><strong>二次探测</strong>：使用hash函数计算出的位置如果已经有元素占用了，按照<span
class="math inline">\(1^2\)</span>、<span
class="math inline">\(2^2\)</span>、<span
class="math inline">\(3^2\)</span>...的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</li>
</ul>
<h3 id="stl的六大组件">STL的六大组件</h3>
<ol type="1">
<li>容器Containers：各种数据结构，如 vector、list、deque、set、map
等。分为两大类，序列式容器和关联式容器。序列式容器（sequential
container）为程序员提供了控制元素存储和访问顺序的能力。和序列式容器对应的是关联式容器（associative-container），关联容器中的元素是按关键字来保存和访问的。关联容器支持高效的关键字查找和访问，STL
有两个主要的关联容器：map 和 set。</li>
<li>算法Algorithms：各种常用算法，提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作，比如
sort、search、copy、erase。从实现的角度来看，STL 算法是一种 function
template。</li>
<li>迭代器Iterator：迭代器（Iterators）：迭代器用于遍历对象集合的元素，扮演容器与算法之间的胶合剂，是所谓的“<strong>泛型指针</strong>”。</li>
<li>仿函数Functors：也称为函数对象（Function
object），行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()
的 class 或者 class template。</li>
<li>适配器Adapters：一种用来修饰容器或者仿函数或迭代器接口的东西。例如
STL 提供的 queue 和 stack，就是一种空间配接器，因为它们的底部完全借助于
deque。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。</li>
<li>分配器allocator：也称为空间配置器，负责空间的配置与管理。从实现的角度来看，配置器是一个实现了动态配置空间、空间管理、空间释放的
class template。</li>
</ol>
<h3 id="红黑树-1">红黑树</h3>
<p>红黑树是一种自平衡的二叉搜索树，它在每个节点上增加了一个额外的属性表示节点的颜色（红色或黑色），并通过一组规则来保持树的平衡。这些规则确保了红黑树的高度保持在对数级别，从而保证了各种基本操作的高效性。</p>
<p>红黑树的特性包括：</p>
<ol type="1">
<li><strong>节点颜色：</strong>
<ul>
<li>每个节点都被标记为红色或黑色。</li>
</ul></li>
<li><strong>根节点：</strong>
<ul>
<li>根节点是黑色的。</li>
</ul></li>
<li><strong>叶子节点（NIL节点）：</strong>
<ul>
<li>所有叶子节点（NIL节点，也称为哨兵节点）都是黑色的。</li>
</ul></li>
<li><strong>红色节点规则：</strong>
<ul>
<li>父子节点之间不能同时为红色，也就是说，红色节点不能有红色的子节点。</li>
</ul></li>
<li><strong>路径黑高度相等：</strong>
<ul>
<li>从任意节点到其每个叶子节点的路径都包含相同数目的黑色节点，这被称为黑高度相等。</li>
</ul></li>
</ol>
<p>这些特性确保了红黑树的平衡，使得在最坏情况下，红黑树的高度是对数级别的。这样做的目的是保证插入、删除和查找等基本操作的时间复杂度始终是对数级别的，保证了红黑树的高效性。</p>
<p>红黑树的自平衡性质使其在动态插入和删除操作时能够有效地维持平衡，而不会退化为一棵高度不平衡的树。这使得红黑树在实际应用中被广泛使用，例如在STL中的<code>std::map</code>和<code>std::set</code>的实现中。</p>
<h3
id="stl的vector的内存扩容为什么是2倍3倍可以吗">STL的vector的内存扩容为什么是2倍？3倍可以吗</h3>
<p>VS用的是两倍，GCC扩容是1.5倍。为什么不用3倍？（可能3倍太浪费）</p>
<p>标准库并没有提供直接设置容器扩容倍数的接口。所以想要用3倍需要自己实现一个新的容器。</p>
<h3 id="vector的初始容量是多少">vector的初始容量是多少？</h3>
<p>初始容量是0。</p>
<p><strong>初始为0怎么按照1.5或2倍的扩容规则扩容？</strong></p>
<p>初始为0的话第一次扩容是例外，会扩容到1，然后再按照1.5或2倍的规则扩容。</p>
<h2 id="项目">项目</h2>
<h3 id="epoll底层实现细节">epoll底层实现细节</h3>
<p>epoll 在 Linux 内核中申请了一个简易的文件系统，把原先的一个 select 或
poll 调用分成了 3 部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events,<span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>; <br></code></pre></td></tr></table></figure>
<ol type="1">
<li>调用 epoll_create 建立一个 epoll 对象(在 epoll
文件系统中给这个句柄分配资源)；</li>
<li>调用 epoll_ctl 向 epoll 对象中添加这 100 万个连接的套接字；</li>
<li>调用 epoll_wait 收集发生事件的连接。</li>
</ol>
<p>这样只需要在进程启动时建立 1 个 epoll
对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait
的效率就会非常高，因为调用 epoll_wait 时并没有向它传递这 100
万个连接，内核也不需要去遍历全部的连接。</p>
<p>当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll
结构体，这个结构体中有两个成员与 epoll
的使用方式密切相关，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> &#123;<br>　　...<br>　　<span class="hljs-comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，</span><br><span class="hljs-comment">　　也就是这个epoll监控的事件*/</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_root</span> rbr;<br>　　<span class="hljs-comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdllist;<br>　　...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我们在调用 epoll_create 时，<strong>内核除了帮我们在 epoll
文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后
epoll_ctl 传来的 socket 外，还会再建立一个 rdllist
双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个
rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到
timeout 时间到后即使链表没数据也返回。</strong>所以，epoll_wait
非常高效。</p>
<p>所有添加到 epoll
中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做
ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p>
<p>在 epoll 中对于每一个事件都会建立一个 epitem 结构体，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epitem</span> &#123;<br>　　...<br>　　<span class="hljs-comment">//红黑树节点</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> rbn;<br>　　<span class="hljs-comment">//双向链表节点</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdllink;<br>　　<span class="hljs-comment">//事件句柄等信息</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_filefd</span> ffd;<br>　　<span class="hljs-comment">//指向其所属的eventepoll对象</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> *ep;<br>　　<span class="hljs-comment">//期待的事件类型</span><br>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br>　　...<br>&#125;; <span class="hljs-comment">// 这里包含每一个事件对应着的信息。</span><br></code></pre></td></tr></table></figure>
<p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查 eventpoll
对象中的 rdllist 双向链表是否有 epitem 元素而已，如果 rdllist
链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此
epoll_waitx 效率非常高。epoll_ctl 在向 epoll
对象中添加、修改、删除事件时，从 rbr 红黑树中查找事件也非常快，也就是说
epoll 是非常高效的，它可以轻易地处理百万级别的并发连接。</p>
<p><strong>总结</strong>：执行
<strong>epoll_create()</strong>时，创建了红黑树和就绪链表；执行
<strong>epoll_ctl()</strong>时，如果增加 socket
句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表（是一个双向链表）中插入数据；执行
<strong>epoll_wait()</strong>时,如果 rdllist
链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。</p>
<h3
id="lt模式和et模式分别适合哪种场景">LT模式和ET模式分别适合哪种场景？</h3>
<p>ET 模式（边缘触发）：</p>
<p>在 ET 模式下，当 I/O
状态发生变化时，系统只通知一次，直到下次状态变化才会再次通知。也就是说，ET
模式只在状态从未就绪变为就绪时通知一次。</p>
<p>适用场景：</p>
<p>对于 ET
模式，通常需要使用<strong>非阻塞（non-blocking）I/O</strong>。因为 ET
模式只在状态变化的瞬间通知一次，如果使用阻塞
I/O，可能在数据未完全处理时就被阻塞。</p>
<p>ET
模式适用于需要及时响应状态变化的场景，例如网络套接字的事件处理，可以在一次通知中处理多个事件。ET
模式更容易实现高性能，因为事件只在状态变化时通知，减少了不必要的上下文切换。</p>
<p>LT 模式（水平触发）：</p>
<p>在 LT 模式下，当 I/O
状态处于就绪时，系统会一直通知直到状态变为不可用。也就是说，LT
模式会持续通知应用程序，直到应用程序处理完所有就绪的数据或事件。</p>
<p>适用场景：</p>
<p><strong>LT 模式更适合于使用阻塞 I/O 的场景</strong>，因为在 LT
模式下，系统会持续通知应用程序，直到应用程序处理完成，避免了在数据未完全处理时被阻塞。</p>
<p>LT 模式适用于对于状态变化需要持续处理的场景，比如文件
I/O。应用程序可以在每次通知中处理少量的数据，然后等待下一次通知。</p>
<h3 id="线程池怎么实现">线程池怎么实现</h3>
<p>先创建并启动一组线程，称为线程池threads_
，由用户指定其大小maxQueueSize_。每个线程函数都是一样的，在其中会运行一个loop循环：从<strong>双端队列</strong>取出一个任务对象task，如果非空，就执行之，如此往复。</p>
<p>当有一个用户线程想要通过线程池运行一个用户任务时，就可以将用户任务函数及参数封装成一个可调用对象Task
f，然后通过线程池接口，将f加入双端队列末尾。当线程池有线程空闲时（未执行用户任务），就会从双端队列头部取出一个Task对象task，然后执行之。</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/741401-20220308114232593-1404677717-17093836488295.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>线程池主要由以下几个部分组成：</p>
<ol type="1">
<li>工作队列queue_，用双端队列实现，能从尾部加入用户任务对应的可调用对象；</li>
<li>用户任务Task f，封装了用户任务，包含任务函数和参数；</li>
<li>线程组threads_，用于管理工作的线程数组；</li>
<li>工作线程，执行回调函数。</li>
</ol>
<h3 id="reactor实现">Reactor实现</h3>
<p>Reactor 模式主要有 Reactor 和 Event Handler 两个核心模块组成，其中
Reactor
负责监听事件，当事件发生时通过<strong>事件分发</strong>机制（Acceptor类）将其发给
Event Handler
进行处理。muduo有单reactor单线程和多reactor多线程，这里使用的是多reactor多线程，基于one
loop per thread的思想。</p>
<p>事件循环主要由EventLoop, Channel 和 Poller类实现，其中EventLoop
是事件循环的“驱动者”：</p>
<ul>
<li>EventLoop 是整个事件循环的核心。核心功能是驱动 Poller
将事件循环跑起来，并通过其提供的 <code>poll</code>
方法进行事件循环(也就是上面的 IO 多路复用调用)</li>
<li>Poller 类是对 <strong>IO
多路复用系统调用</strong>的一个封装类，可以向其中注册感兴趣的
Channel，阻塞等待事件发生，事件发生之后返回发生的事件(通过 Channel
类)。</li>
<li>Channel 类对某个文件描述符、相关事件、处理事件的方法进行了封装。更新
Channel 中的感兴趣事件实际需要通过 EventLoop 进行，EventLoop
通过其持有的 Poller 来实际执行，Channel 和 Poller
并没有直接的联系。</li>
</ul>
<h3 id="设计个持最并发数的线程池">设计⼀个⽀持最⼤并发数的线程池</h3>
<p>仿照muduo的线程池，先创建并启动一组线程，称为线程池threads_
，由用户指定其大小maxQueueSize_。每个线程会运行一个loop循环：从双端队列取出一个任务对象task，如果非空，就执行之，如此往复。</p>
<h4
id="如果有个优先级的事件怎么处理">如果有个⾼优先级的事件怎么处理</h4>
<p>将高优先级队列插入到双端队列头</p>
<h4
id="如果任务队列的任务之间有依赖关系要怎么处理呢">如果任务队列的任务之间有依赖关系要怎么处理呢？</h4>
<p>将前置任务先插入双端队列，后置任务后插入双端队列。</p>
<h3
id="webserver中buffer是怎么设计的怎么实现自动增长">webserver中buffer是怎么设计的？怎么实现自动增长</h3>
<p>注：这里因为muduo的buffer是自适应的，可以实现自动增长。比如它一开始的初始值是
1k，如果程序里边经常收发 10k 的数据，那么用几次之后它的 size()
会自动增长到 10k，然后就保持不变。</p>
<p><strong>回答</strong>：</p>
<p>Buffer 的内部是一个 vector of char，它是一块连续的内存。此外，Buffer
有两个 data members分别为read_index和write_imdex，指向该 vector
中的元素。这两个 indices 的类型是 int，不是
char*，目的是应对迭代器失效。这两个索引把vector分为三部分，prependable、readable、writable。</p>
<p>其中prependable可以让程序能以很低的代价在数据<strong>前面</strong>添加几个字节；全部数据读完了，readIndex
和 writeIndex 返回原位以备新一轮使用。</p>
<p>因为使用的是vector所以可以自动增长。</p>
<h3 id="线程池的重要参数有哪些">线程池的重要参数有哪些</h3>
<p>工作队列的容量，线程池的容量</p>
<h3 id="内存泄漏如何检测和防">内存泄漏如何检测和防⽌？</h3>
<h4 id="检测">检测</h4>
<ol type="1">
<li>检查代码：仔细检查代码中的内存分配和释放，确保每次分配内存后都有相应的释放操作。比如
malloc和free、new和delete是否配对使用了。</li>
<li>使用调试器和工具：有一些工具可以帮助检测内存泄露。例如：
<ol type="1">
<li>Valgrind（仅限于Linux和macOS）：Valgrind是一个功能强大的内存管理分析工具，可以检测内存泄露、未初始化的内存访问、数组越界等问题。使用Valgrind分析程序时，只需在命令行中输入valgrind
--leak-check=yes your_program即可。</li>
<li>Visual Studio中的CRT（C Runtime）调试功能：Visual
Studio提供了一些用于检测内存泄露的C
Runtime库调试功能。例如，_CrtDumpMemoryLeaks函数可以在程序结束时报告内存泄露。</li>
<li>AddressSanitizer：AddressSanitizer是一个用于检测内存错误的编译器插件，适用于GCC和Clang。要启用AddressSanitizer，只需在编译时添加-fsanitize=address选项。</li>
</ol></li>
</ol>
<h4 id="防止">防止</h4>
<ol type="1">
<li>使用智能指针（C++）：在C++中，可以使用智能指针（如std::unique_ptr和std::shared_ptr）来自动管理内存。这些智能指针在作用域结束时会自动释放所指向的内存，从而降低忘记释放内存或者程序异常导致内存泄露的风险。</li>
<li>异常安全：在C++中，如果程序抛出异常，需要确保在异常处理过程中正确释放已分配的内存。使用try-catch块来捕获异常并在适当的位置释放内存。
或者使用RAII（Resource Acquisition Is
Initialization）技术，将资源（如内存）的管理与对象的生命周期绑定。</li>
</ol>
<h3 id="手写线程池">手写线程池</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// 构造函数，初始化线程池</span><br>    ThreadPool(<span class="hljs-type">size_t</span> numThreads) : stop(<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-comment">// 创建指定数量的工作线程，并将它们添加到线程池中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) &#123;<br>            workers.emplace_back([this] &#123;<br>                <span class="hljs-comment">// 线程主循环</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>()&gt; task;<br><br>                    &#123;<br>                        <span class="hljs-comment">// 使用互斥锁保护任务队列</span><br>                        <span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; lock(queueMutex);<br><br>                        <span class="hljs-comment">// 使用条件变量等待任务队列不为空或停止信号</span><br>                        <span class="hljs-comment">// 该wait函数内部会自动调用lock.unlock()对互斥锁解锁，使得其他被阻塞在互斥锁上的线程恢复执行</span><br>                        condition.wait(lock, [this] &#123; <span class="hljs-keyword">return</span> stop || !tasks.empty(); &#125;);<br><br>                        <span class="hljs-comment">// 如果收到停止信号且任务队列为空，线程退出</span><br>                        <span class="hljs-keyword">if</span> (stop &amp;&amp; tasks.empty()) &#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br><br>                        <span class="hljs-comment">// 取出队列头部的任务</span><br>                        task = <span class="hljs-built_in">std</span>::move(tasks.front());<br>                        tasks.pop();	<br>                    &#125;<br><br>                    <span class="hljs-comment">// 执行取出的任务</span><br>                    task();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将任务加入到任务队列</span><br>    template&lt;class F&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(F&amp;&amp; func)</span> &#123;<br>        &#123;<br>            <span class="hljs-comment">// 使用互斥锁保护任务队列</span><br>            <span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">lock</span><span class="hljs-params">(queueMutex)</span>;<br>            <br>            <span class="hljs-comment">// 将任务移动到队列中</span><br>            tasks.emplace(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(func));<br>        &#125;<br><br>        <span class="hljs-comment">// 通知一个等待中的线程有新任务可以执行</span><br>        condition.notify_one();<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数，停止线程池，并等待所有线程结束</span><br>    ~ThreadPool() &#123;<br>        &#123;<br>            <span class="hljs-comment">// 使用互斥锁保护停止信号</span><br>            <span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">lock</span><span class="hljs-params">(queueMutex)</span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 唤醒所有等待中的线程</span><br>        condition.notify_all();<br><br>        <span class="hljs-comment">// 等待所有线程结束</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::thread &amp;worker : workers) &#123;<br>            worker.join();<br>        &#125;<br>    &#125;<br><br>private:<br>    <span class="hljs-comment">// 工作线程</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; workers;<br>    <br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br>    <br>    <span class="hljs-comment">// 互斥锁用于保护对任务队列的访问</span><br>    <span class="hljs-built_in">std</span>::mutex queueMutex;<br>    <br>    <span class="hljs-comment">// 条件变量用于通知工作线程有新任务</span><br>    <span class="hljs-built_in">std</span>::condition_variable condition;<br>    <br>    <span class="hljs-comment">// 停止信号，用于通知工作线程停止</span><br>    <span class="hljs-type">bool</span> stop;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建包含4个工作线程的线程池</span><br>    ThreadPool <span class="hljs-title function_">threadPool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>;<br><br>    <span class="hljs-comment">// 向线程池中提交8个任务</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>        threadPool.enqueue([i] &#123;<br>            <span class="hljs-comment">// 打印任务信息和执行线程的ID</span><br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; processed by thread &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 给予一些时间让任务被处理</span><br>    <span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-built_in">std</span>::chrono::seconds(<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="算法">算法</h2>
<h3 id="海量数据找中位数">海量数据找中位数</h3>
<h4 id="方法一桶排序">方法一：桶排序</h4>
<ol type="1">
<li><p>创建多个小文件桶，设定每个桶的取值范围，然后把海量数据元素根据数值分配到对应的桶中，并记录桶中元素的个数</p></li>
<li><p>根据桶中元素的个数，计算出中位数所在的桶（比如 100 亿个数据，第 1
个桶到第 18 个桶一共有 49 亿个数据，第 19 个桶有 2
亿数据，那么中位数一定在第 19
个桶中），然后针对该桶进行排序，就可以求出海量数据中位数的值（如果内存还是不够，可以继续对这个桶进行拆分；或者直接用
BitMap 来排序）</p></li>
</ol>
<p>简单用 100 个数据画个图直观理解下：</p>
<figure>
<img
src="/img/Cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/18dde9e7760129344e00545e74b348cb.png" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="方法二分治法-基于二进制比较">方法二：分治法 +
基于二进制比较</h4>
<p>假设这 100 亿数据都是 int 类型，4 字节（32
位）的有符号整数，存在一个超大文件中。</p>
<p>将每个数字用二进制表示，比较二进制的【<strong>最高位</strong>】 (第
32 位)，如果数字的最高位为 0，则将这个数字写入 <code>file_0</code>
文件中；如果最高位为 1，则将该数字写入 <code>file_1</code> 文件中。</p>
<blockquote>
<p>最高位为符号位，也就是说 file_1 中的数都是负数，而 file_0
中的数都是正数。</p>
</blockquote>
<p>通过这样的操作，这 100 亿个数字分成了两个文件，假设 file_0 文件中有
60 亿个数字，而 file_1 文件中有 40 亿个数字。</p>
<p>这样划分后，思考一下：所求的中位数在哪个文件中？</p>
<p>100 亿个数字的中位数是 100 亿个数排序之后的第 50 亿个数，现在 file_0
有 60 亿个正数，file_1 有 40 亿个负数，file_0 中的数都比 file_1
中的数要大，排序之后的第 50 亿个数是中位数，那么这个中位数一定位于
file_0 中，并且是 file_0 文件中所有数字排序之后的第 <strong>10</strong>
亿个数字。</p>
<p>现在，我们只需要处理 file_0 文件了（不需要再考虑 file_1 文件）。</p>
<p>而对于 file_0 文件，可以同样的采取上面的措施处理：将 file_0
文件依次读一部分到内存，将每个数字用二进制表示，比较二进制的【<strong>次高位</strong>】（第
31 位），如果数字的次高位为 0，写入 <code>file_0_0</code>
文件中；如果次高位为 1 ，写入 <code>file_0_1</code> 文件中。</p>
<p>现假设 file_0_0 文件中有 30 亿个数字，file_0_1 中也有 30
亿个数字，则中位数就是：file_0_0 文件中的数字从小到大排序之后的第 10
亿个数字。</p>
<p>抛弃 file_0_1 文件，继续对 file_0_0 文件
根据【<strong>次次高位</strong>】(第 30 位)
划分，如此反复下去，便可以得到中位数。</p>
<h4 id="方法三堆排序">方法三：堆排序</h4>
<p>要用堆排序直接找到中位数，可以把问题转换为找到第K大的数（K是全部数据量的一半），但是由于数据量过大，所以内存不能设置一个大小为K的堆，所以可以考虑分为多步。首先用小根堆堆找到第k大的数（k
&lt;
K）,然后再找到第2k大的数（有了kth大的数之后，再次遍历数据，大于kth的数直接丢掉，小于的放到小根堆中，最后可以得到2kth大的数），如此循环往复即可。</p>
<h4 id="方法四外排序">方法四：外排序</h4>
<p>使用外部归并排序</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++知识点</div>
      <div>https://gstarmin.github.io/2023/11/23/Cpp面试知识点/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Starmin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月23日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年1月20日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/23/Cpp-static%E5%88%9D%E5%A7%8B%E5%8C%96/" title="Cpp-static初始化">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Cpp-static初始化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/02/ubuntu%E9%85%8D%E7%BD%AEClash/" title="Ubuntu配置Clash">
                        <span class="hidden-mobile">Ubuntu配置Clash</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
